(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



If[Length[Names["FLAGS`ECHOLOAD"]]>0,
CelleratorML`Private`msgflag=ToExpression["FLAGS`ECHOLOAD"],
CelleratorML`Private`msgflag=True;
];
FLAGS`ECHOLOAD=False; 

BeginPackage["CelleratorML`"]; 
FLAGS`ECHOLOAD=CelleratorML`Private`msgflag; 

Needs["XML`"]; 

$CelleratorMLVersion="1.0.5 (19 June 2009)";
$CelleratorMLVersion::usage=$CelleratorMLVersion;



ModelToSXML::usage="ModelToSXML[model, options]\nReturns the symbolic XML corresponding to the specified Cellerator Model; see SaveModel."; 
ModelToXML::usage="ModelToXML[model,options]\nReturns the text XML corresponding to the specified options; see SaveModel. "; 
Options[ModelToXML]={"Parameters"-> {}, "InitialConditions"-> {}, "Name"-> "", "Frozen"-> {}}; 

CellzillaICToList::usage="CellzillaICToList[{a[1]\[Rule]val, a[2]\[Rule]val,.., b[1]\[Rule]val, b[2]\[Rule]val, ..}]\nreturns a list {a\[Rule]{val,val,..}, b\[Rule]{val, val,..}, ..}"; 
ListICToCellzillaIC::usage="ListICToCellzillaIC[{a\[Rule]{val1,val2,..}, b\[Rule]{val1,val2,..},..}]\n returns a list {a[1]\[Rule]val, a[2]\[Rule]val,.., b[1]\[Rule]val, b[2]\[Rule]val, ..}"; 

CellzillaModelToXML::usage="ModelToXML[model,options]\nReturns the text XML corresponding to the specified options; see SaveCellzillaModel. "; 
CellzillaModelToSXML::usage="CellzillaModelToSXML[model, options]\nReturns the symbolic XML corresponding to the specified Cellzilla Model; see SaveCellzillaModel."; ; 
Options[CellzillaModelToXML]:= {"Parameters"-> {}, "InitialConditions"-> {}, 
"Name"-> "CellzillaModel", "Centers"-> {},"Tissue"-> {},  "Models"-> {}, "DiffusingSpecies"-> {}, "Quiet"->False};
SaveCellzillaModel::usage="SaveCellzillaModel[filename,"<>
"\n\t\"Models\"\[Rule]{file1,file2,URL3,...}"<>
"\n\t\"Centers\"\[Rule]{{x1,y1},{x2,y2},..}"<>
"\n\t\"Tissue\"\[Rule]Tissue[..] object"<>
"\n\t\"Parameters\"\[Rule]{sym\[Rule]value,sym\[Rule]value,..}"<>
"\n\t\"InitialConditions\"{A[1]\[Rule]value,A[2]\[Rule]value,..., Z[n]\[Rule]value}"<>
"\n\t\"DiffusingSpecies\"\[Rule]{{species,rate}, {species, rate}, ..}"<>
"\n\t\"Quiet\"\[Rule]False"<>
"\n\t]\n\nIf filename is omitted, the model is written to the current notebook."; 
GetCellzillaModel::usage="GetCellzillaModel[filename, options]\n\n"<>
"Imports a CellzillaML file and returns the following data structure as a list of options (may be in any order):\n\n{\"Circuit\"\[Rule]list of celleratoar reactions\n\"Parameters\"\[Rule]{name\[Rule]value, name\[Rule]value,..}\n\"IC\"\[Rule]{name\[Rule]{val,val,val,..}, name\[Rule]{val, val, val,..}, ..}\n\"DiffusingSpecies\"\[Rule]{{species,rate}, {species, rate}, ..}\n\"Centers\"\[Rule]{{x1,y1}, {x2, y2},..}}\n\"Tissue\"\[Rule]Tissue[...]\n\nNote:\n\nNote: A file should have at least one of <Centers ..> or <Tissue ..>. If only Centers are included they are assumed to be Voronoi centers of the cells; if Tissue is provided the Centers may represent something else such as nuclear centroids.\n\n"<>
"Options:\n\"Quiet\"\[Rule]False; If True, printing of messages during import will be suppressed;"; 

SaveModel::usage="SaveModel[model, options] writes a Cellerator model into xml text to screen\n"<>"SaveModel[filename, model, options] writes xml to specified file; If the file already exists it is not overwritten, but a new file with a unique file name is created.\n\nOptions (note that all options are quoted strings, not symbols):\n\n"<>
"\t\"Name\"\[Rule]Optional model name\n"<>"\t\"Parameters\"\[Rule]Optional list of parameters  (equivalent to SME reactionRates or run option rates)\n"<>"\t\"InitialConditions\"\[Rule]Optional list of initail conditions (equivalent to SME initialCondi or run option initialConditions)\n"<>
"\t\"Frozen\"\[Rule]{}, List of Cellerator frozen varibles\n"<>
"\t\"Creator\"\[Rule]Optional textual annotation for creator's name; defaults to $UserName\n"<>"\t\"email\"\[Rule]Optional creator's email\n"<>"\t\"WebPage\"\[Rule]Optional creator's web page\n"<>
"\t\"SoftwareTool\"\[Rule]optional software tool name annotation.\n"<>
"\t\"Description\"\[Rule]Optional text or html description of model\n\n"<>"Example:\n\nSaveModel[{{A\[Rule]B, k1}, {B\[Rule]Q, k2}}, \"Parameters\"\[Rule]{k1\[Rule]1, k2\[Rule]2}, \"InitialConditions\"\[Rule]{A\[Rule]5, B\[Rule]7, Q\[Rule]0}]"; 
Options[SaveModel]={
"Creator"-> $UserName, "email"-> "", "WebPage"-> "", 
"SoftwareTool"-> "",
"Description"-> XMLElement["html", {}, {"This is a CelleratorML (XML) file."}]};

GetModel::usage="GetModel[filename, options] returns {model, list-of-reation-rates, list-of-initial-conditions, list-of-options}\n\nlist-of-options={\"Name\"\[Rule]modelname, \"Frozen\"\[Rule]list-of-frozen-variables}\n\n(Changed in 1.0.2 to include list-of-options)\n\nOptions are: \n\"Quiet\"\[Rule]False, if True, will reduce the amount of printed output."; 

LatexForm::usage="LatexForm[model, rules, ic, outputfile.tex] generates a latex file describing the model.\nLatexForm[model, rules, ic] autogenerates an output file name.\nIn each of these forms, model is a list of cellerator reactions; rules is a list of cellerator rate rules; and ic is a list of cellerator initial condition rules.\n\nLatexForm[inputfile.xml, outputfile.tex] converts the CelleratorML file to latex.\n
LatexForm[inputfile.xml] autogenerates an output file name.\n\nIn any case if the specified output file already exists, a unique new file name is generated\n\nThe return value of LatexForm is always the name of the file created.";


Begin["`Private`"]; 
Quiet[Needs["xlr8r`"]]; 
Quiet[Needs["Cellzilla2D`"]]; 
If[Length[Names["$xlr8r$Version"]]<1, 
Print[Style["Warning: ", Bold, Read], Style["CelleratorML: xlr8r.m not found in path. It should be loaded manually before any xlr8r simulations can be run.", Bold]];
];
If[Length[Names["Cellzilla2D`$Cellzilla2DVersion"]]<1,
Print[Style["Warning: ", Bold, Red], Style["Cellzilla2D.m not found in path. It should be loaded manually before any Cellzilla simulations can be run. Some functionality of CelleratorML.m in manipulating CellzillaML models may not work properly unless Cellzilla2D.m is loaded.", Bold]];
]; 


now[]:=DateString[{"Day"," ","MonthName", " ", "Year", " at ", "Hour24",":", "Minute", " ", "TimeZone"}];


UniqueFileName[]:= UniqueFileName[""]; 
UniqueFileName[filename_, echo_:False]:= Module[{f, m, dot, ftype, fname, ff},

f=ToString[filename];
If[StringLength[f]==0, 
f="CelleratorModel.xml"; m=True;, 
m=False]; 
 
If[Length[FileNames[f]]>0  \[Or] m, 

(* if file already exists, create a new file name *)

dot=StringPosition[f, "."]; 
If[Length[dot]>0, 
dot=dot[[1,1]]; 
ftype="."<>StringDrop[f, dot]; 
fname=StringTake[f, dot-1]; 
, 
fname=f; 
ftype=".xml";
]; 

ff=fname<>"-"<>DateString[{"Year","Month","Day","-", "Hour24","Minute", "Second" }]<>ftype; 
f=ff; 
If[echo \[And] Not[m],
Print["The requested file name: ", filename, " already exists. The file will be named: ", f]; 
]
];
Return[f]; 
]


MyFilterOptions[f_, opt___?OptionQ]:= 
If[$VersionNumber<6,
Utilities`FilterOptions`FilterOptions[f, opt]
,
Sequence@@FilterRules[Flatten[{opt}],Options[f]]
];


decontextify[x_?StringQ]:= Module[{p,q},
p = StringPosition[x,"`"];
If[Length[p]<1, Return[x]];
p=Map[First,p];
p = Last[p];
q= StringDrop[x,p];
Return[q];
];
decontextify[x_?ListQ]:= Map[decontextify,x];
decontextify[x_]:= Module[{s},
decontextify[ToString[InputForm[x]]]//ToExpression//Return;
];

decontextify[x_?StringQ, context_?StringQ]:= StringReplace[x, {context-> ""}]; 
decontextify[x_?ListQ, context_?StringQ]:= Map[decontextify[#,context]&,x]; 
decontextify[x_, context_?StringQ]:= Module[{},
decontextify[ToString[InputForm[x]],context]//ToExpression//Return;
]; 


Which[
$VersionNumber<6, 
ToSymbolicMathML[x_]:= XML`MathML`ExpressionToSymbolicMathML[x,"Formats"-> {"ContentMathML"}],

$VersionNumber ==6 \[And] $ReleaseNumber<2,
ToSymbolicMathML[x_]:= XML`MathML`ExpressionToSymbolicMathML[x, "Semantics"-> True, "Presentation"-> False], 

$VersionNumber ==6 \[And] $ReleaseNumber>1, 
ToSymbolicMathML[x_]:= XML`MathML`ExpressionToSymbolicMathML[x,"Formats"-> {"ContentMathML"}],

$VersionNumber==7, 
ToSymbolicMathML[x_]:= XML`MathML`ExpressionToSymbolicMathML[x,"Formats"-> {"ContentMathML"}],

$VersionNumber>7,
ToSymbolicMathML[x_]:= XML`MathML`ExpressionToSymbolicMathML[x,"Formats"-> {"ContentMathML"}]
];


FromSymbolicMathML[x_]:= XML`MathML`SymbolicMathMLToExpression[x]


ReactionToSXML[{reaction_, parameters___}]:= Module[{r},
r=ToSymbolicMathML[{reaction, parameters}]; 
r=XMLElement["CelleratorReaction", {}, 
{r}]
]; 
ReactionToSXML[x___]:= Module[{},
Print["ReactionToSXML: Expecting a list: {arrowform, parameters}"];
Print["Unexpected input: ", x]; 
Return[$Failed]
];
ReactionToXML[expression_]:= Module[{xml}, 
xml = ReactionToSXML[expression]; 
If[SameQ[xml, $Failed], Return[$Failed]]; 
ExportString[xml, "XML"]
];



ReactionsToSXML[{r__?ListQ}]:= Module[{reactions, xml}, 
reactions=ReactionToSXML/@{r}; 
If[MemberQ[reactions, $Failed], Return[$Failed]]; 

xml = XMLElement["ListOfCelleratorReactions", {}, reactions]; 
Return[xml]; 
]; 

ReactionsToSXML[x___]:= Module[{},
Print["ReactionsToSXML: Expecting a list of Cellerator Reactions."]; 
Return[$Failed];
]; 


ReactionsToXML[expression_]:= Module[{xml}, 
xml = ReactionsToSXML[expression]; 
If[SameQ[xml, $Failed], Return[$Failed]]; 
xml=ExportString[xml, "XML"]; 
Return[xml];
];




ParameterRuleToSXML[Rule[lhs_, rhs_]]:= Module[{xml},
xml = XMLElement["Parameter", {"Identifier"-> ToString[InputForm[lhs]], "Value"-> ToString[rhs]},{}]; 
Return[xml]; 
];
ParameterRuleToSXML[x___]:= Module[{}, 
Print["ParameterRuleToSXML: Expecting a rule, not: ", x]; 
Return[$Failed]; 
]; 

ParameterRuleToXML[expression_]:= Module[{xml}, 
xml = ParameterRuleToSXML[expression]; 
If[SameQ[xml, $Failed], Return[$Failed]]; 
ExportString[xml, "XML"]
];

ParametersToSXML[{x___Rule}]:= Module[{xml},
xml = ParameterRuleToSXML/@{x}; 
xml = XMLElement["ListOfCelleratorParameters", {}, xml]; 
Return[xml]; 
];
ParametersToSXML[x___]:= Module[{},
Print["ParametersToSXML: Expecting a list of Mathematica replacement rules of the form {A\[Rule]B,...}"]; 
Return[$Failed];
]; 
ParametersToXML[par_]:= Module[{xml}, 
xml = ParametersToSXML[par]; 
If[SameQ[xml, $Failed], Return[$Failed]]; 
xml = ExportString[xml, "XML"]; 
Return[xml];
]




SingleICToSXML[Rule[lhs_, rhs_], opt___?OptionQ]:= Module[{xml, frozen, tags},
tags = {"Identifier"-> ToString[InputForm[lhs]], "Value"-> ToString[rhs]}; 
frozen = "Frozen"/.{opt}/.{"Frozen"-> False}; 
If[frozen, AppendTo[tags, "Frozen"-> "True"]]; 
xml = XMLElement["InitialValue", tags,{}]; 
Return[xml]; 
];
SingleICToSXML[x___]:= Module[{}, 
Print["Expecting SingleICToSXML[rule, options],  not: ", x]; 
Return[$Failed]; 
]; 


ICToSXML[{x___Rule}, opt___?OptionQ]:= Module[{xml, vars, values, frozen, frozenvariables},

frozenvariables = "Frozen"/.{opt}/.{"Frozen"-> {}}; 
frozenvariables = Flatten[{frozenvariables}]; 

vars = First/@{x}; 
values = Last/@{x}; 
frozen=MemberQ[frozenvariables, #]&/@vars; 
xml=MapThread[SingleICToSXML[Rule[#1, #2], "Frozen"-> #3]&, {vars, values, frozen}]; 

(* xml = SingleICToSXML/@{x}; *)
xml = XMLElement["ListOfCelleratorIC", {}, xml]; 
Return[xml]; 
];
ICToSXML[x___]:= Module[{},
Print["Expecting ICToSXML[{var\[Rule]val, var\[Rule]val, ...}, options]"]; 
Return[$Failed];
]; 
ICToXML[u___]:= Module[{xml}, 
xml = ICToSXML[u]; 
If[SameQ[xml, $Failed], Return[$Failed]]; 
xml = ExportString[xml, "XML"]; 
Return[xml];
]




ModelAnnotation[opt___?OptionQ]:= Module[{now, mathver, relver, sys, user, email, web, xmlelements, xml, description, version, enc, softwaretool}, 
now=DateString[{"Year", "-", "Month","-","Day", "T", "Hour", ":", "Minute", ":", "Second"}]; 
now = XMLElement["CreationTime", {}, { now}]; 

mathver = XMLElement["MathematicaVersionNumber", {}, {ToString[$VersionNumber]}]; ; 
relver=XMLElement["MathematicaReleaseNumber", {}, {ToString[$ReleaseNumber]}]; 
version=XMLElement["MathematicaVersion", {}, {$Version}]; 
sys = XMLElement["OperatingSystem", {} ,{$System}]; 
enc = XMLElement["CharacterEncoding", {}, {$CharacterEncoding}]; 

xmlelements = {now, version, mathver, relver, sys, enc}; 

user=ToString["Creator"/.{opt}/.Options[SaveModel]]; 
If[user!= "", 
user=XMLElement["Creator", {}, {user}]; AppendTo[xmlelements, user]
]; 

email=ToString["email"/.{opt}/.Options[SaveModel]]; 
If[email != "", 
email = XMLElement["Email", {}, {email}];
AppendTo[xmlelements, email]
]; 

web=ToString["WebPage"/.{opt}/.Options[SaveModel]]; 
If[web != "", 
web = XMLElement["WebPage", {}, {web}];
AppendTo[xmlelements, web];
]; 

softwaretool="SoftwareTool"/.{opt}/.Options[SaveModel]; 

If[softwaretool== "", 
softwaretool="CelleratorML "<>$CelleratorMLVersion,
 softwaretool = softwaretool <> "+CelleratorML "<>$CelleratorMLVersion]; 
softwaretool=XMLElement["SoftwareTool", {}, {softwaretool}];
AppendTo[xmlelements, softwaretool]; 



description = "Description"/.{opt}/.Options[SaveModel]; 
If[SameQ[Head[description], XMLElement], 
description=XMLElement["Description", {}, {description}], 


description=StringReplace[ToString[description], {"<"-> "&lt;", ">"-> "&gt"}]; 
description=XMLElement["Text",{}, {description}]; 
description=XMLElement["Description", {}, {description}]; 

];
AppendTo[xmlelements, description];  
 
xml = XMLElement["ModelAnnotation", {}, xmlelements]; 
Return[xml];

]; 




ModelToSXML[model_, options___?OptionQ]:= Module[{m, p,n, ic, ann},
m=ReactionsToSXML[model]; 
If[SameQ[m, $Failed], 
Print["ModelToXML: Invalid Model."]; 
Return[$Failed]
]; 

p="Parameters"/.{options}/.Options[ModelToXML]; 
p=ParametersToSXML[p];
If[SameQ[p, $Failed], 
Print["ModelToSXML: Invalid List of Parameters."]; 
p=ParametersToSXML[{}]; 
];

ic="InitialConditions"/.{options}/.Options[ModelToXML]; 
ic=ICToSXML[ic, options]; 
If[SameQ[ic, $Failed], 
Print["ModelToSXML: Invalid List of Initial Conditions."]; 
ic = ICToSXML[{}]; 
]; 

n="Name"/.{options}/.Options[ModelToXML]; 
If[n=="", n=Unique["Model"]]; 
n=ToString[n]; 



m = XMLElement["CelleratorModel", {"Name"-> n}, {m, p, ic}]; 

Return[m];
];

ModelToXML[x___]:= Module[{xml},
xml = ModelToSXML[x]; 
If[SameQ[xml, $Failed], Return[$Failed]]; 
xml = ExportString[xml, "XML"]; 
Return[xml]; 
]


SaveModel[file_?StringQ, model_, options___?OptionQ]:= Module[{f, s,  preface}, 
f=UniqueFileName[file]; 
s = SaveModel[model, options]; 
Export[f, s, "Text"]; 
Return[f];
];

SaveModel[model_, options___?OptionQ]:= Module[
{s,m, preface,  ann}, 

With[{opt={MyFilterOptions[ModelToXML, options]}}, 
m=ModelToSXML[model, Sequence@@opt]
];


With[{opt={MyFilterOptions[SaveModel, options]}},
ann=ModelAnnotation[Sequence@@opt]
]; 

m=XMLElement["CelleratorML", {"Version"-> "1.0"}, {ann, m}]; 


preface = {
XMLObject["Declaration"]["Version"->"1.0","Encoding"->"ASCII"],
XMLObject["Comment"][" Generated "<>now[]<>" "],
XMLObject["Comment"][" Generated by CelleratorML "<>$CelleratorMLVersion<>" "],
XMLObject["Comment"][" Generated using Mathematica Version "<>$Version<>" (Release "<>ToString[$ReleaseNumber]<>")" ]
};

m= XMLObject["Document"][preface, m, {}]; 

s=ExportString[m, "XML", "CharacterEncoding"-> "ASCII"]; 
Return[s]; 
]


ListICToSXML[symbol_, values_]:= Module[{math, xml, id}, 
If[!ListQ[values], Print["Error:ListICToXML: values must be a list."];
Print["values=", values]; 
 Return[$Failed]]; 
math=ToSymbolicMathML[values]; 
id = If[StringQ[symbol], symbol, ToString[symbol]]; 
xml = XMLElement["CellzillaIC", {"Identifier"-> id}, {math}]; 
Return[xml]
]; 
ListICToXML[u___]:= Module[{xml}, 
xml = ListICToSXML[u]; 
If[SameQ[xml, $Failed], Return[$Failed]]; 
xml = ExportString[xml, "XML"]; 
Return[xml];
];

ListICsToSXML[x__Rule]:= Module[{symbols, values, xml, y},
y={x}/.{Rule-> List}; 
symbols = First/@y; 
values = Last/@y; 
xml = MapThread[ListICToSXML, {symbols, values}];
If[MemberQ[xml, $Failed], Return[$Failed]];  
xml = XMLElement["ListOfCellzillaIC", {}, xml]; 
Return[xml];
];

ListICsToXML[u___]:= Module[{xml}, 
xml = ListICsToSXML[u]; 
If[SameQ[xml, $Failed], Return[$Failed]]; 
xml = ExportString[xml, "XML"]; 
Return[xml];
];


CellzillaICToSXML[ic_]:= Module[{vars, icvar,ics, xml},
icvar[sym_]:= Last/@Sort[Cases[ic/.{Rule-> List}, {sym[___], _}]]; 
vars = Union[Head/@First/@ic];
ics = icvar/@vars; 

xml=MapThread[ListICToSXML, {vars, ics}]; 
xml = XMLElement["ListOfCellzillaIC", {}, xml]; 
Return[xml]; 
];

CellzillaICToXML[u___]:= Module[{xml}, 
xml = CellzillaICToSXML[u]; 
If[SameQ[xml, $Failed], Return[$Failed]]; 
xml = ExportString[xml, "XML"]; 
Return[xml];
];

CellzillaICToList[ic_]:= Module[{vars, icvar,ics, xml},
icvar[sym_]:= Last/@Sort[Cases[ic/.{Rule-> List}, {sym[___], _}]]; 
vars = Union[Head/@First/@ic];
ics = icvar/@vars; 
Return[MapThread[Rule,{vars, ics}]]
];
ListICToCellzillaIC[ic_]:= Module[{out, in, next, var, vals, n},
If[!ListQ[ic], Print["Expecting ListICToCellzillaIC[{var\[Rule]{val,val,..}, var\[Rule]{val,val,..},..}]"]; 
Return[$Failed]
]; 
If[!(Union[Head/@ic]=={Rule}), 
Print["Expecting ListICToCellzillaIC[{var\[Rule]{val,val,..}, var\[Rule]{val,val,..},..}]"]; Return[$Failed]; 
]; 

in = ic;
out={}; 
While[Length[in]>0, 
next = First[in]; 
in = Rest[in]; 
var = First[next]; 
vals=Last[next]; 
n=Length[vals]; 
next= MapThread[Rule, {var/@Range[n], vals}]; 
AppendTo[out, next]; 
]; 
out=Flatten[out];

Return[out];
]


ListListToSXML[label_?StringQ, {x__}]:= Module[{dim, xml, math}, 
If[!And@@(ListQ/@{x}), Print["Error:ListListToSXML]: all of the lists must be lists."]; 
Print[{x}]; 
Return[$Failed]]; 
math = ToSymbolicMathML[{x}]; 
xml =  XMLElement[label, {}, {math}]; 
Return[xml]; 
]; 
ListListToSXML[x___]:= (Print["Expecting ListListToSXML[label, {{x1,y1,..}, {x2, y2, ..},..}]"]; $Failed); 

ListListToXML[u___]:= Module[{xml}, 
xml = ListListToSXML[u]; 
If[SameQ[xml, $Failed], Return[$Failed]]; 
xml = ExportString[xml, "XML"]; 
Return[xml];
];



PointListToSXML[label_?StringQ, {x__}]:= Module[{dim, xml, math}, 
If[!And@@(ListQ/@{x}), Print["Error:PointListToSXML]: all of the coordinates must be lists."]; 
Print[{x}]; 
Return[$Failed]]; 
dim = Union[Length/@{x}]; 
If[Length[dim]>1, 
Block[{lengths,  pos, positions},
lengths=Length/@{x};  
pos[len_]:= First/@Position[lengths, len];  
positions = pos/@dim; 
Print["Error: PointListToSXML: all coordinates must have the same dimension. "]; 
MapThread[Print["Dimension ", #1, " found at positions ", #2]&, {dim, positions}]; 
]; 
Return[$Failed]; 
]; 
dim = First[dim]; 
math = ToSymbolicMathML[{x}]; 
xml =  XMLElement[label, {"Dimension"-> ToString[dim]}, {math}]; 
Return[xml]; 
]; 
PointListToSXML[x___]:= (Print["Expecting PointListToSXML[label, {{x1,y1,..}, {x2, y2, ..},..}]"]; $Failed); 

PointListToXML[u___]:= Module[{xml}, 
xml = PointListToSXML[u]; 
If[SameQ[xml, $Failed], Return[$Failed]]; 
xml = ExportString[xml, "XML"]; 
Return[xml];
];



CentersToSXML[{x__}]:= PointListToSXML["Centers", {x}]; 

CentersToSXML[x___]:= (Print["Expecting CentersToSXML[{{x1,y1,..}, {x2, y2, ..},..}]"]; $Failed); 

CentersToXML[u___]:= Module[{xml}, 
xml = CentersToSXML[u]; 
If[SameQ[xml, $Failed], Return[$Failed]]; 
xml = ExportString[xml, "XML"]; 
Return[xml];
];



TissueToSXML[tissue_?Cellzilla2D`TissueQ, opt___?OptionQ]:= Module[{c,v,e,f, nc,nv, ne, nf, dim, quiet, vPrint}, 

quiet = "Quiet"/.{opt}/.Options[CellzillaModelToXML]; 
vPrint[x___]:= If[!quiet, Print[x]]; 

v=Cellzilla2D`TissueVertices[tissue]; 
nv=Length[v]; 
v=PointListToSXML["Vertices", v]; 
dim =Cases[v, {"Dimension"-> _}]; 
If[Length[dim]<1 \[Or] Length[dim]>1, Print["Program Bug: Wrong dim: ", dim]; Return[$Failed]; 
];  
dim = "Dimension"/.Flatten[dim];

e=Cellzilla2D`TissueEdges[tissue];
ne=Length[e]; 
e=ListListToSXML["Edges", e]; 

Switch[dim,
"2", 
c=Cellzilla2D`TissueCells[tissue]; 
nc=Length[c]; 
c=ListListToSXML["Cells", c]; 
xml = XMLElement["Tissue", {"Dimension"-> dim}, {v,e,c}];
vPrint[dim, "-D tissue: ", nv, " vertices; ", ne, " edges; ", nc," cells."]; 
,

"3",
f=Cellzilla2D`TissueFaces[tissue]; 
f=ListListToSXML["Faces", f]; 
nf=Length[f]; 
c=Cellzilla2D`TissueCells[tissue]; 
c=ListListToSXML["Cells", c]; 
nc=Length[c]; 
xml = XMLElement["Tissue", {"Dimension"-> dim}, {v,e,f,c}];
vPrint[dim, "-D tissue: ", nv, " vertices; ",ne, " edges; ", nf, " faces; ",nc," cells."]; 
,
_,
Print["Error: TissueToSXML: dim = ", dim];
Return[$Failed]; 
]; 

Return[xml]; 

]; 
TissueToSXML[x___]:= (Print["Not a tissue."]; $Failed); 

TissueToXML[tissue_, opt___?OptionQ]:= Module[{xml},
xml = TissueToSXML[tissue, opt]; 
If[SameQ[xml, $Failed], Return[$Failed]]; 
xml = ExportString[xml, "XML"]; 
Return[xml];]; 


CellzillaDiffusionToSXML[{}]:= XMLElement["ListOfDiffusingSpecies", {}, {}]; 
CellzillaDiffusionToSXML[{sp__}]:= Module[{lens, xml, species, diff},
If[!And@@(ListQ/@{sp}), Print["Error: Expecting CellzillaDiffusionToSXML[{{species, D}, {species, D}, ..}]."]; Return[$Failed];];
lens=Union[Length/@{sp}];
If[Length[lens]>1, Print["Error: CellzillaDiffusionToSXML: invalid format (error 1): multiple length lists."]; 
Return[$Failed]]; 
lens=First[lens]; 
If[lens!=2, Print["Error: CellzillaDiffusionToSXML: invalid format (error 2): lists are not length 2."]; 
Return[$Failed]]; 

{species, diff}=Transpose[{sp}]; 
species = If[StringQ[#], #, ToString[#]]&/@species;
diff = If[StringQ[#], #, ToString[#]]&/@diff; 

xml = MapThread[XMLElement["DiffusingSpecies", {"Identifier"-> #1, "Rate"-> #2}, {}]&, {species, diff}];
xml = XMLElement["ListOfDiffusingSpecies", {}, xml];
Return[xml]; 
];

CellzillaDiffusionToXML[u___]:= Module[{xml}, 
xml = CellzillaDiffusionToSXML[u]; 
If[SameQ[xml, $Failed], Return[$Failed]]; 
xml = ExportString[xml, "XML"]; 
Return[xml];
];


CellzillaModelToSXML[opt___?OptionQ]:= Module[{name,parms,  models, centers, diff, IC, xml, tissue, subxml, quiet, vPrint, hascenters, hastissue},
quiet = "Quiet"/.{opt}/.Options[CellzillaModelToXML]; 
vPrint[x___]:= If[!quiet, Print[x]]; 

name="Name"/.{opt}/.Options[CellzillaModelToXML]; 
vPrint["Model name: ", name];
 
models ="Models"/.{opt}/.Options[CellzillaModelToXML]; 
models = Flatten[{models}]; 
If[Length[models]<1, Print["Error: CellzillaModelToSXML: At least one Cellerator Model must be specified."]; 
Return[$Failed];
]; 

models = If[StringQ[#], #, ToString[#]]&/@models; 
vPrint["Model file name(s) or URL(s): "]; 
vPrint["\t"<>#]&/@ models; 

models = XMLElement["CelleratorModel", {}, {#}]&/@models;
models = XMLElement["ListOfCelleratorModels", {}, models]; 

diff = "DiffusingSpecies"/.{opt}/.Options[CellzillaModelToXML]; 
vPrint[Length[diff], " Diffusing Species"]; 
diff=CellzillaDiffusionToSXML[diff]; 

parms="Parameters"/.{opt}/.Options[CellzillaModelToXML]; 
vPrint[Length[parms], " Parameters"]; 
parms =ParametersToSXML[parms]; 
parms = parms/.{"ListOfCelleratorParameters"-> "ListOfCellzillaParameters"}; 

IC ="InitialConditions"/.{opt}/.Options[CellzillaModelToXML]; 
vPrint[Length[IC], " Initial Conditions"]; 
IC = CellzillaICToSXML[IC]; 
subxml ={models, diff,parms, IC};

hascenters=False; 
centers = "Centers"/.{opt}/.Options[CellzillaModelToXML]; 
If[ListQ[centers],
hascenters = (Length[centers]>0),
hascenters = False; 
Print["Error: CellzillaModelToSXML: \"Centers\" should be a list."];
]; 
tissue = "Tissue"/.{opt}/.Options[CellzillaModelToXML]; 
hastissue=Cellzilla2D`TissueQ[tissue]; 
If[tissue!= {}, 
If[!hastissue,
Print["Error: \"Tissue\" does not appear to be a Tissue object: running TissueCheck\n."];
Cellzilla2D`TissueCheck[tissue];  
]; 
]; 
If[!(hastissue \[Or] hascenters),
Print["Either a list of Cell Centers (option \"Centers\") or a Tissue object (option \"Tissue\") must be specified."]; 
Return[$Failed]; 
]; 
If[hascenters, 
vPrint[Length[centers], " cell centers."]; 
centers = CentersToSXML[centers]; 
AppendTo[subxml, centers]; 
]; 
If[hastissue, 
tissue=TissueToSXML[tissue, opt];
AppendTo[subxml, tissue]; 
]; 

xml = XMLElement["CellzillaModel", {"Name"-> name}, subxml]; 
Return[xml];
];


CellzillaModelToXML[u___]:= Module[{xml}, 
xml = CellzillaModelToSXML[u]; 
If[SameQ[xml, $Failed], Return[$Failed]]; 
xml = ExportString[xml, "XML"]; 
Return[xml];
];


SaveCellzillaModel[file_?StringQ,  options___?OptionQ]:= Module[{f, s,  preface}, 
f=UniqueFileName[file]; 
s = SaveCellzillaModel[options]; 
Export[f, s, "Text"]; 
Return[f];
];

SaveCellzillaModel[options___?OptionQ]:= Module[
{s,m, preface,  ann}, 

m=CellzillaModelToSXML[options]; 
If[SameQ[m, $Failed], Return[$Failed]]; 

ann = "Description"/.{options}/.{
"Description"-> "This is a CellzillaML (XML) file."};
ann = ModelAnnotation["Description"-> ann]; 

m=XMLElement["CellzillaML", {"Version"-> "1.0"}, {ann, m}]; 


preface = {
XMLObject["Declaration"]["Version"->"1.0","Encoding"->"ASCII"],
XMLObject["Comment"][" Generated "<>now[]<>" "],
XMLObject["Comment"][" Generated by CelleratorML "<>$CelleratorMLVersion<>" "],
XMLObject["Comment"][" Generated using Mathematica Version "<>$Version<>" (Release "<>ToString[$ReleaseNumber]<>")" ]
};

m= XMLObject["Document"][preface, m, {}]; 

s=ExportString[m, "XML", "CharacterEncoding"-> "ASCII"]; 
Return[s]; 
]


GetTissue[model_]:= Module[{tissue, c, v, e, dim, dimv, tis},
tissue=GetXMLElement[model, "Tissue"]; 
If[SameQ[tissue, $Failed], Return[$Failed]];
dim = GetXMLAttribute [tissue, "Dimension"]; 

v=GetXMLElement[tissue, "Vertices"]; 
If[SameQ[v, $Failed], Print["Error: GetTissue: No <Vertices ...>"]]; 
dimv=GetXMLAttribute[v, "Dimensions"]; 
If[dim!= dimv, Print["Warning: Inconsistent dimension tag: tissue is tagged as ", dim," and vertices are tagged as ", dimv]]; 

v = GetXMLElement[v, "math"]; 
If[SameQ[v, $Failed], Print["Error: GetTissue: No Vertex <math ...>."]]; 

v= FromSymbolicMathML[v]; 

e=GetXMLElement[tissue, "Edges"]; 
If[SameQ[e, $Failed], Print["Error: GetTissue: No <Edges ...>"]]; 
e = GetXMLElement[e, "math"]; 
If[SameQ[e, $Failed], Print["Error: GetTissue: No Edge <math ...> ."]];   e= FromSymbolicMathML[e]; 

c=GetXMLElement[tissue, "Cells"]; 
If[SameQ[c, $Failed], Print["Error: GetTissue: No <Cells ...>."]]; 
c = GetXMLElement[c, "math"]; 
If[SameQ[c, $Failed], Print["Error: GetTissue: No Cell <math ...>."]]; 
c= FromSymbolicMathML[c]; 

tis = Cellzilla2D`Tissue[v,e,c];

If[!Cellzilla2D`TissueQ[tis],
Print["Warning: GetTissue: Problem Discovered in Tissue Data.\nRunning TIssueCheck."]; 
Cellzilla2D`TissueCheck[tis];
]; 

Return[tis]; 
 ]


GetCellzillaModel[file_?StringQ, opt___?OptionQ]:= Module[{m, annotation, model, vprint, version, name, verbose=True, subelements,
missingelements, unexpectedelements, allowedelements, centers, modelFileNames, ic, diff, parameters, models, circuits, parameterValues,  frozenVariables, globalParameters,localParameters,  getNameValuePair, vars, val, dim,  okdim, baddim, tissue, return},

verbose =Not[ "Quiet"/.{opt}/.{"Quiet"-> False}]; 

vprint[x___]:= If[verbose, Print[x]];  

(* verify that the file exists and contains CellzillaML *)

m=FileNames[file];
If[Length[m]<1, Print["GetCellzillaModel: File not found: ", file]; Return[$Failed]]; 
m=Import[file, "XML"];
vprint["File: ", file]; 
m=Cases[m, XMLElement["CellzillaML", ___]];
If[Length[m]<1, Print["GetCellzillaModel: No CellzillaML found in file ", file]; 
Return[$Failed]]; 

If[Length[m]>1, Print["GetCellzillaModel: Multiple instances of CellzillaML found. Only the first will be used."]; ]; 
m = First[m];

(* examine the ML version and file annotations if any *)

version = GetXMLAttribute[m, "Version"];
vprint["CellzillaML version: ", version]; 

annotation = GetXMLElement[m, "ModelAnnotation"];
CheckCellzillaAnnotation[annotation, verbose]; 

model = GetXMLElement[m, "CellzillaModel"];
If[SameQ[model, $Failed], Print["No CellzillaModel found."]; Return[$Failed]]; 

name = GetXMLAttribute[model, "Name"]; 
If[SameQ[name, $Failed], name="\[WarningSign]UnnamedModel\[WarningSign]"]; 
vprint["Model Name: ", name]; 

(* check to make sure only the allowed items are in the file *)

allowedelements={"ListOfCelleratorModels","ListOfDiffusingSpecies","ListOfCellzillaParameters","Centers","Tissue", "ListOfCellzillaIC"} ; 
subelements=GetXMLSubElementNames[model];

missingelements = Complement[allowedelements, subelements]; 
unexpectedelements=Complement[subelements, allowedelements]; 

Print["Warning: Expected ", #, " not found."]&/@Complement[missingelements, {"Centers", "Tissue"}];
Print["Warning: Unexpected XML tag ", #, " will be ignored."]&/@unexpectedelements; 

If[Length[Intersection[subelements, {"Centers", "Tissue"}]]<1, 
Print["Warning: Either \"Centers\" or \"Tissue\" should be specified."];
];

(* import all the model files that are references *)

circuits = ImportAllCelleratorModels[model, verbose]; 
If[SameQ[circuits, $Failed], Return[$Failed]]; 
{circuits, localParameters, frozenVariables}=circuits; 

vprint["Circuits: ", circuits]; 
vprint["local parameters (may be superceded): ", localParameters]; 
(* vprint["icvalues from models (ignored): ", icvalues];  *)
vprint["frozenVariables from models: ", frozenVariables]; 

(* get parameters and make sure the global assignments supercede the local assignments *)

getNameValuePair[x_, value_:"Value"]:= Rule[
ToExpression[GetXMLAttribute[x, "Identifier"]],
ToExpression[ GetXMLAttribute[x, value]]];

globalParameters=GetXMLElement[model, "ListOfCellzillaParameters"];
globalParameters=GetXMLElements[globalParameters]; 
globalParameters=checkTagNames[globalParameters, "Parameter"]; 

globalParameters=getNameValuePair/@globalParameters;
vprint["Global parameters: ", globalParameters]; 

parameters=Union[Join[First/@globalParameters, First/@localParameters]]; 
parameterValues=parameters/.globalParameters/.localParameters; 
parameters = MapThread[Rule, {parameters, parameterValues}]; 
vprint["Joined parameters: ", parameters]; 

(* input the initial conditions *)

ic = GetXMLElement[model, "ListOfCellzillaIC"];
ic = GetXMLElements[ic];
ic = checkTagNames[ic, "CellzillaIC"]; 

vars = GetXMLAttribute[#, "Identifier"]&/@ic;
vars = ToExpression/@vars;
vals = GetXMLElement[#, "math"]&/@ic;
vals=FromSymbolicMathML/@vals;
ic = MapThread[Rule, {vars, vals}];
vprint["ic: ", ic];  

(* get the list of diffusing species *)

diff = GetXMLElement[model, "ListOfDiffusingSpecies"];
diff = GetXMLElements[diff]; 
diff=checkTagNames[diff, "DiffusingSpecies"];
diff=getNameValuePair[#, "Rate"]&/@diff; 
diff = diff/.{Rule-> List}; 
vprint["Diffusing Species: ", diff]; 


return ={
"Circuit"-> circuits, 
"Parameters"-> parameters,
"IC"-> ic, 
"DiffusingSpecies"-> diff
};

(* get the list of centers or the tissue *)

centers = GetXMLElement[model, "Centers"];

If[!SameQ[centers, $Failed], 
dim = GetXMLAttribute[centers, "Dimension"]; 
dim  = ToExpression[dim]; 
vprint["Dimension: ", dim]; 
centers=GetXMLElement[centers, "math"];
centers=FromSymbolicMathML[centers];
okdim = (Length[#]==dim)&/@centers; 
baddim = Pick[centers, okdim, False]; 

Print["Error: The center at ", #, " has unexpected dimension of ", Length[#], " and will be omitted; the expected dimension is ", dim]&/@baddim;
centers = Pick[centers, okdim];
vprint["Centers: ", centers]; 
vprint["Number of cells: ", Length[centers]]; 
AppendTo[return, "Centers"-> centers]; 
];

(* get the tissue *)

tissue = GetXMLElement[model, "Tissue"];
If[!SameQ[tissue, $Failed],
tissue = GetTissue[model];
AppendTo[return, "Tissue"->tissue]; 
];

Return[return];
];



GetCellzillaModel[x___]:= (Print["Expecting GetCellzillaModel[filename (string)]"]; $Failed); 


checkTagNames[xmlelements_, tag_]:= Module[{check, ok, notok}, 
check =(#==tag)&/@(GetXMLElementName/@xmlelements);
ok = Pick[xmlelements, check]; 
notok = Complement[xmlelements, ok]; 
Print["Warning: Unexpected xml tag ", GetXMLElementName[#], " found where ", tag, " was expected."]&/@notok; 
 
Return[ok]
]


CheckCellzillaAnnotation[xmlannotation_, verbose_]:= Module[{created, mathver, mathrel, os, checkfail}, 
checkfail[$Failed]:= "Unspecified"; 
checkfail[x_]:= x; 
created=GetXMLSubElement[xmlannotation, "CreationTime"]//checkfail; 
mathver=GetXMLSubElement[xmlannotation, "MathematicaVersionNumber"]//checkfail;mathrel=GetXMLSubElement[xmlannotation, "MathematicaReleaseNumber"]//checkfail;os =GetXMLSubElement[xmlannotation, "OperatingSystem"]//checkfail; 
 If[verbose, 
Print["Creation Date: ", created]; 
Print["Mathematica: Version ", mathver, " release ", mathrel, " on ", os]; 
]; 
];


ImportModel[f_, verbose_]:= Module[{m}, 
If[verbose,Print["\[LongRightArrow] Importing CelleratorML file: ", f]]; 
m=GetModel[f, "Quiet"-> !verbose]; 
If[m==$Failed, Print["File not found."]; ]; 
Return[m];
];


ImportAllCelleratorModels[model_, verbose_]:= Module[{modelFileNames, models, circuits, parameterValues, icvalues, options,frozenVariables , vprint},

vprint[x___]:= If[verbose, Print[x]]; 
 
modelFileNames=GetXMLElement[model, "ListOfCelleratorModels"];
If[SameQ[modelFileNames, $Failed], Print["A ListOfCelleratorModels is required."]; Return[$Failed]]; 

 modelFileNames=GetXMLElements[modelFileNames, "CelleratorModel"];
If[Length[modelFileNames]<1, Print["No CellertatorModel's found. At least one model file must be specified."]; 
Return[$Failed];
]; 
modelFileNames = Flatten[GetXMLElements/@modelFileNames]; 

models = ImportModel[#, verbose]&/@modelFileNames;
If[MemberQ[models, $Failed], Print["Error: at least one model file was not found."]; Return[$Failed]]; 
models = Transpose[models];
{circuits, parameterValues, icvalues, options}= models;
circuits = Join@@circuits; 
parameterValues=Join@@parameterValues; 
frozenVariables=Flatten[("Frozen"/.#)&/@options]; 
 
(* 
vprint["Circuits: ", circuits]; 
vprint["parameterValues (may be superceded): ", parameterValues]; 
vprint["frozenVariables from models: ", frozenVariables];
*) 

Return[{circuits, parameterValues, frozenVariables}]; 
]; 



(* Get all atributes *)

GetXMLAttributes[XMLElement[tag_, attributes_, elements_]]:= attributes;
GetXMLAttributes[x___]:= (Print["Expecting GetXMLAttributes[XMLElement[...]]"]; $Failed); 

(* Get the attribute with a specified name *)

GetXMLAttribute[XMLElement[tag_, attributes_, elements_], attribute_?StringQ]:= attribute/.attributes/.{attribute-> $Failed}; 
GetXMLAttribute[x___]:= (Print["Expecting GetXMLAttribute[XMLElement[..], Tag(string)"]; $Failed); 

(* Get all Elements *)

GetXMLElements[XMLElement[tag_, attributes_, elements_]]:= elements;

(* Get all Elements with a specified name *)

GetXMLElements[XMLElement[tag_, attributes_, elements_], element_]:= 
 Cases[elements, XMLElement[element,__]]; 

GetXMLElements[x___]:= (Print["Expecting GetXMLElements[XMLElement[..]]"]; $Failed);

(* Get the nth element with a specified tag *)

GetXMLElement[XMLElement[tag_, attributes_, elements_], element_, num_:1]:= Module[{e},
e = Cases[elements, XMLElement[element,__]]; 
If[Length[e]<1, Return[$Failed]]; 
If[num<1 \[Or] num>Length[e], Return[$Failed]]; 
Return[e[[num]]]; 
];

GetXMLElementName[XMLElement[tag_, attributes_, elements_]]:= tag;


GetXMLSubElementNames[XMLElement[tag_, attributes_, elements_]]:= GetXMLElementName/@GetXMLElements[XMLElement[tag, attributes, elements]]; 


GetXMLSubElement[XMLElement[tag_, attributes_, elements_], sub_]:= Module[{e},
e=GetXMLElement[XMLElement[tag, attributes, elements], sub]; 
If[e==$Failed, Return[$Failed]]; 
e= GetXMLElements[e]; 
If[Length[e]<1, Return[$Failed]]; 
e=e[[1]]; 
Return[e];
]; 



GetModel[filename_?StringQ, opt___?OptionQ]:= Module[{sxml, version, modelname, model, ann, debug, quiet, DPrint, reactions, parameters,nr,  ic, getNameValuePair, vars, frozen, m,  options},

debug = "Debug"/.{opt}/.{"Debug"-> False}; 
quiet= "Quiet"/.{opt}/.{"Quiet"-> False}; 

getNameValuePair[x_]:= Rule[
ToExpression[GetXMLAttribute[x, "Identifier"]],
ToExpression[ GetXMLAttribute[x, "Value"]]];


DPrint[x___]:= If[debug, Print["GetModel: ", x]]; 

sxml=Quiet[Import[filename, "XML"]];
If[SameQ[sxml, $Failed], Print["GetModel: File '"<>filename<>"' not found."]; Return[$Failed]]; 

sxml = Cases[sxml, XMLElement["CelleratorML",__]];
If[Length[sxml]<1, Print["GetModel: No CelleratorML found in file."]; Return[$Failed]];
If[Length[sxml]>1, Print["GetModel: ", Length[sxml], " models found. All but the first will be ignored."]]; 
sxml =First[sxml];
version = GetXMLAttribute[sxml, "Version"]; 

DPrint[version];

ann=GetXMLElement[sxml, "ModelAnnotation"]; 
DPrint["annotation: ", ann]; 

model = GetXMLElement[sxml, "CelleratorModel"]; 
DPrint["model: ", model]; 

modelname=GetXMLAttribute[model, "Name"]; 

reactions=GetXMLElement[model, "ListOfCelleratorReactions"]; 
If[SameQ[reactions, $Failed], Print["GetModel: No ListOfCelleratorReactions!"]; Return[$Failed]]; 
reactions=GetXMLElements[reactions, "CelleratorReaction"]; 
nr=Length[reactions]; 

If[nr<1, Print["GetModel: No CelleratorReaction's"]; Return[$Failed]]; 
reactions = GetXMLElement[#, "math"]&/@reactions; 
reactions = FromSymbolicMathML/@reactions;

parameters=GetXMLElement[model, "ListOfCelleratorParameters"]; 
If[!SameQ[parameters, $Failed],
parameters = GetXMLElements[parameters, "Parameter"];
If[Length[parameters]>0,parameters = getNameValuePair/@parameters]
]; 

ic = GetXMLElement[model, "ListOfCelleratorIC"]; 
frozen={}; 
If[!SameQ[ic, $Failed],
ic = GetXMLElements[ic, "InitialValue"];
If[Length[ic]>0,
(* determine which species are marked as Frozen *)
frozen=GetXMLAttribute[#, "Frozen"]&/@ic;
frozen = (frozen/.{$Failed-> False, "True"-> True}); 
DPrint["frozen:", frozen]; 

(* convert the ic into var->value rules as expressions, not strings *)
ic = getNameValuePair/@ic;
DPrint["ic: ", ic]; 
vars = First/@ic; 

(* Frozen is a list of True/False values, so pick the trues *)
frozen =Pick[vars, frozen]; 

];

]; 

DPrint["Reactions: ", reactions];
DPrint["parameters: ", parameters]; 
DPrint["ic ", ic]; 

If[!quiet,
Print[ "Model: ", modelname]; 
Print["CelleratorML Version: ", version];
Print[nr," reactions"]; 
Print[Length[parameters], " parameters"]; 
Print[Length[ic], " initial values"]; 
];

options={"Name"-> modelname, "Frozen"-> frozen};
m = {reactions, parameters, ic,options}; 

Return[m]; 

];

GetModel[x___]:= Module[{}, Print["Expecting GetModel[Filename]"]; $Failed];


LatexForm[inet_, irules_, iic_, outputfile_?StringQ]:= Module[{m, Eqn, align, latex, itemize, preamble, ofile, ic, rules, net},
Eqn[expression_]:="$"<>ToString[TeXForm[expression]]<>"$";
align[list_]:=StringJoin@@((#<>"\\\\\n")&/@list); 
itemize[list_, label_]:= "\\item[]"<>label<>"\\\\\n"<>align[list]; 

rules = irules; 
net=inet; 
ic=iic; 

rules =itemize[ Eqn/@rules, "Parameters:"];
ic = itemize[Eqn/@ic, "Initial Conditions:"];
net = itemize[Eqn/@net, "Model:"];

latex ="\\begin{description}\n"<> net<>ic<>rules<>"\n\\end{description}\n"; 
latex = latex<>"\\end{document}"; 

preamble="\\documentclass[12pt,letterpaper]{article}\n"<>
"\\usepackage[latin1]{inputenc}\n"<>
"\\usepackage{amsmath}\n"<>
"\\usepackage{amsfonts}\n"<>
"\\usepackage{amssymb}\n"<>
"\\begin{document}\n"<>
"\\begin{center}CelleratorModel\n\\\\\\today\n\\end{center}";

latex = preamble<>latex; 

ofile=UniqueFileName[outputfile]; 
Export[ofile, latex, "Text"]
];

LatexForm[net_, rules_, ic_]:= LatexForm[net, rules, ic, "Cellerator-Model-Description.tex"]; 

LatexForm[filename_?StringQ, outputfile_?StringQ]:= Module[{m, net, rules, ic, Eqn, align, latex, itemize, preamble, ofile,opts},
Eqn[expression_]:="$"<>ToString[TeXForm[expression]]<>"$";
align[list_]:=StringJoin@@((#<>"\\\\\n")&/@list); 
itemize[list_, label_]:= "\\item[]"<>label<>"\\\\\n"<>align[list]; 

m=GetModel[filename, "Quiet"-> True]; 
If[SameQ[m, $Failed], Return[$Failed]]; 

{net, rules, ic}=Take[m,3]; 
 
Return[LatexForm[net, rules, ic, outputfile]]; 

];
LatexForm[filename_?StringQ]:= LatexForm[filename, "Cellerator-Model-Description.tex"]; 
LatexForm[x___]:= (Print["Expecting LatexForm[inputfile, outputfile]"]; Return[$Failed]); 


CelleratorMLhelp[]:= Module[{names, usagestrings, print}, 
names=decontextify/@Names["CelleratorML`*"];
usagestrings = ToExpression/@((ToString[#]<>"::usage")&/@names); 
print[a_, b_]:= Module[{}, 
If[StringLength[ToString[b]]>0, 
StylePrint[a, "Subsection"]; 
Print[b]; 
];
]; 
StylePrint["CelleratorML Help", "Section"]; 
Print["This is the CelleratorML Help file. It provides some reference information about each of the externally visible CelleratorML functions. It is not a users guide and does not provide any introduction to using CelleratorML. It also does not include plugin reference information. \nPlease note that CelleratorML is experimental software and as such many of the functions may only contain partial implementations. And like a lot of software documentation in the cybersphere it does not always keep up with the latest implementation. Please check with the developer if you have any questions."];
Print["This file was generated by CelleratorML version "<>$CelleratorMLVersion<>" on "<>DateString[{"Day", " ", "MonthNameShort", " ", "Year", " at ", "Hour", ":", "Minute", ":", "Second", " (", "TimeZone",")"}]<>" using Mathematica "<>$Version<>" (Version "<>ToString[ $VersionNumber]<>", Release "<>ToString[ $ReleaseNumber]<> ")"];  
MapThread[print, {names, usagestrings}]; 
];


dropVersionDate[version_]:= Module[{v,p}, 
v=version;
p=StringPosition[v, " "]; 
If[p=={}, Return[v]]; 
p = p[[1,1]]; 
v=StringTake[v, p-1];
Return[v]; 
];



If[CelleratorML`Private`msgflag, Print[Style["CelleratorML "<>$CelleratorMLVersion<>" loaded "<>now[]<>" using Mathematica Version "<>$Version<>" Release "<>ToString[$ReleaseNumber],
Bold]]
]; 
Remove[CelleratorML`Private`msgflag]; 

End[];
EndPackage[]; 
