(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



BeginPackage["Cellzilla2D`"];
$Cellzilla2DVersion="2.1.\[Alpha].22 3-Dec-2010"


If[$VersionNumber<6, Print["This package requires Mathematica Version 6.0.3 or higher."]; Abort[]
]; 
If[$VersionNumber==6 \[And] $ReleaseNumber<3, 
Print["This package requires Mathematica Version 6.0.3 or higher; You have version 6.0."<>ToString[$ReleaseNumber]];
Abort[]; 
];

Needs["XML`"]; 


DelaunayMean::usage="DelaunayMean[{{\!\(\*SubscriptBox[\"x\", \"1\"]\),\!\(\*SubscriptBox[\"y\", \"1\"]\)},{\!\(\*SubscriptBox[\"x\", \"2\"]\),\!\(\*SubscriptBox[\"y\", \"2\"]\)},...}]\nReturns the average length of all the links in the Delaunay Triangulation"; 
DelaunayEdges::usage="DelaunayEdges[{{\!\(\*SubscriptBox[\"x\", \"1\"]\),\!\(\*SubscriptBox[\"y\", \"1\"]\)},{\!\(\*SubscriptBox[\"x\", \"2\"]\),\!\(\*SubscriptBox[\"y\", \"2\"]\)},...}]\nReturns a the coordinates of the end points of all the links in the Delaunay Triangulation, {\!\(\*SubscriptBox[\"link\", \"1\"]\), \!\(\*SubscriptBox[\"link\", \"2\"]\),..} where each \!\(\*SubscriptBox[\"link\", \"i\"]\) has the form {{\!\(\*SubscriptBox[\"x\", \"1\"]\),\!\(\*SubscriptBox[\"y\", \"1\"]\)}, {\!\(\*SubscriptBox[\"x\", \"2\"]\),\!\(\*SubscriptBox[\"y\", \"2\"]\)}}."; 
ConvexHullVertices::usage="ConvexHullVertices[{{\!\(\*SubscriptBox[\"x\", \"1\"]\),\!\(\*SubscriptBox[\"y\", \"1\"]\)},{\!\(\*SubscriptBox[\"x\", \"2\"]\),\!\(\*SubscriptBox[\"y\", \"2\"]\)}, ...}]\nReturns the convex hull as a list of vertex coordinates."; 
GenerateBoundaryLayer::usage="GenerateBoundaryLayer[{{\!\(\*SubscriptBox[\"x\", \"1\"]\),\!\(\*SubscriptBox[\"y\", \"1\"]\)},{\!\(\*SubscriptBox[\"x\", \"2\"]\),\!\(\*SubscriptBox[\"y\", \"2\"]\)}, ...}]\nReturns an artificial boundary layer of points obtained by extending the convex hull out by a diameter equal to the average length of the delaunay triangulation (before extension)."; 
BoundedCellVoronoi::usage="BoundedCellVoronoi[{{\!\(\*SubscriptBox[\"x\", \"1\"]\),\!\(\*SubscriptBox[\"y\", \"1\"]\)}, {\!\(\*SubscriptBox[\"x\", \"2\"]\),\!\(\*SubscriptBox[\"y\", \"2\"]\)}, ...}]\nreturns a Tissue[..] object that represente the Bounded-Cell Voronoi Diagram, obtained as the Voronoi Diagram of the original cells after adding artificial cells around the convex hull."; 
PrunedDelaunayEdges::usage="PrunedDelaunayEdges[poitns] gives coordinates of endpoints of links in Pruned Delaunay Triangulation. The Delaunay Triangulation is is pruned by removing links that are not between cells that are touching in the Bounded Cell Voronoi.";
PrunedDelaunayPairs::usage="PrunedDelaunayPairs[points] returns a list of the {i,j} pairs in the pruned Delaunay Triangulation. The indices {i,j} refer to positions in the list of points. Only links between cells that are connected according to the BoundedCellVoronoi are included; other links in the Delaunay Triangulation are excluded. To get the actual coordinates of the links, use PrunedDelaunayEdges.";  
DelaunayPairs::usage="DelaunayPairs[{{\!\(\*SubscriptBox[\"x\", \"1\"]\),\!\(\*SubscriptBox[\"y\", \"1\"]\)},{\!\(\*SubscriptBox[\"x\", \"2\"]\),\!\(\*SubscriptBox[\"y\", \"2\"]\)},...}]\nReturns a the indices of the endpoints of the unique edges in the Delaunay Triangulation, as {i,j} pairs in the list of vertices."


RunSim::usage=""; 
SimPlot::usage="SimPlot[sim, variable, {tstart, tend}, options] (any option for Plot)\nSimPlot[sim, {tstart, tend}, options] - plots all variables\nSimPlot[sim, {variables}, {tstart, tend}, options}] - plot specific variables\nSimPlot[sim, options] - autodetect time span\nOptions:\n\"Grid\"\[Rule]False\n\"Columns\"\[Rule]3 (if Grid=True)";
MultiSimPlot::usage=""; 
SimShow::usage="SimShow[solution,variable, time, tissue, {rgbfrom, rgbto}, {vmin, vmax}]\nTo display a legend use SimShowAt instead.";  
SimShowFinal::usage="SimShowFinal[solution, variable, template, {colormin, colormax}, options]"; 
SimShowThreshold::usage=""; 
SimShowAt::usage="SimShowAt[solution,variable,time, template,{colormin, colormax}, options] or \nSimShowAt[solution,variable,time,template,{colormin,colormax}, {vmin,vmax}, optoins]\nLike SimShow but with a legend."; 
SimAnimate::usage="SimAnimate[solution, Variable, Template, {tstart, tend, deltat}, {colormin, colormax}, {valmin, valmax}, options]"; 
SaveFrames::usage="SaveFrames[pictures_?ListQ,type_, size_, movieType_:\".avi\",  label_:\"MovieData\", framerate_:8]";
ToAVI::usage="ToAvi[pics_,title_:\"MovieData\",  size_:400, rate_:16]";
ToMOV::usage="ToMOV[pics_,title_:\"MovieData\",  size_:400, rate_:16]"; 
SimRange::usage="SimRange[solution, Variable,time] gives {min, max} of variable over the tissute."; 
SimInterpolate::usage="SimInterpolate[solution, variable, time] returns list of values of variable in each cell."; 
CommonTimeDomain::usage="CommonTimeDomain[solution] returns the time range represented by all variables in the solution."; 


CelleratorNetwork::usage="CelleratorNetwork[network,beta]\nnetwork is any xCellerator reaction network, e.g., as stored in Sigmoid (NOT indexed by cell; the cell indices will be added\nbeta={{x,\!\(\*SubscriptBox[\"\[Beta]\", \"x\"]\)}, {y, \!\(\*SubscriptBox[\"\[Beta]\", \"y\"]\)}, ...}, list of species and penetrability coefficients constants.\n\nImplementation Note: Each diffusion reaction is implemented as\n\t{x[i]\[RightArrowLeftArrow] \[EmptySet], \[Beta]*\!\(\*SubscriptBox[\"\[ScriptL]\", \"ij\"]\)/\!\(\*SubscriptBox[\"A\", \"i\"]\),\[Beta]*\!\(\*SubscriptBox[\"\[ScriptL]\", \"ij\"]\)*x[j]/\!\(\*SubscriptBox[\"A\", \"i\"]\)}\nfor all neigbors j of cell i, for all cell i, where \!\(\*SubscriptBox[\"\[ScriptL]\", \"ij\"]\) is the length of cell cell wall between i and j and \!\(\*SubscriptBox[\"A\", \"i\"]\) is the area of cell i. The net result is the differential equation\n\!\(\*FractionBox[SubscriptBox[\"dx\", \"i\"], \"dt\"]\)=\!\(\*FractionBox[SubscriptBox[\"\[Beta]\", \"i\"], SubscriptBox[\"A\", \"i\"]]\)\!\(\*UnderscriptBox[\"\[Sum]\", 
RowBox[{\" \", 
RowBox[{\"j\", \" \", \"\[Element]\", \" \", 
RowBox[{\"nbrs\", 
RowBox[{\"(\", \"i\", \")\"}]}]}]}]]\)\!\(\*SubscriptBox[\"\[ScriptL]\", \"ij\"]\)(\!\(\*SubscriptBox[\"x\", \"j\"]\)-\!\(\*SubscriptBox[\"x\", \"i\"]\)).\n\nOptions:\n\n\"Verbose\"\[Rule]True, set to false to suppress printing summary message.\n\"Area\"\[Rule]None, specify a symbol to replace \!\(\*SubscriptBox[\"A\", \"i\"]\) with var[i][t] \n\"Edge\"\[Rule]None, specify a symbol to replace  \!\(\*SubscriptBox[\"\[ScriptL]\", \"ij\"]\) with edge[p][t] where p is the edge number between nodes i and j.\n\nIf cell sizes will change during the simulation the options \"Area\" and \"Edge\" must be specified. If one is specified but the other is not a unique variable name will be generated." ; 

SSANetwork::usage=""; 
X2SSANetwork::usage="";


TemplateHoneycombCover::usage="TemplateHoneycombCover[xmax,ymax]";
TemplateRectangular::usage="TemplateRectangular[nx,ny]\nTemplateRectangular[{xmin,xmax,dx}, {ymin,ymax,dy}]"; 
TemplateRectangularCover::usage="TemplateRectangularCover[xmax, ymax, dx, dy, offset:.5]";
TemplateCircularHoneycombCover::usage="TemplateCircularHoneycombCover[radius, mode]\nmode=-1: circle\nmode=0: semiscircle\nmode=n>0: semicircle atop base of n rows."; 
RandomizeTemplate::usage="RandomizeTemplate[tissue, rand:.1]";
TemplateRandom::usage="TemplateRandom[npoints, {{x1,y1}, {x2,y2},..} (boundary)] generates a template of totally random cells that fall within the specified boundary (uses a Voronoi based model).";
TemplatePolygon::usage="TemplatePolygon[...] returns a single-cell tissue in the shape of a polygon. Arguments are idential to RegularPolygon.";
TemplateRandomCircularGrid::usage="TemplateRandomCircularGrid[numberOfCells, radius]"; 
TemplateRandomSemicircularGrid::usage="TemplateRandomSemicircularGrid[n, radius, nbottom]"; 
TemplateRandomSquareGrid::usage="TemplateRandom[npoints, {xmin, ymin}, {xmax, ymax}]\n generates a random template in the specified box with the cell centers on a randomized hexagonal grid (uses a Voronoi based model)."; 
VoronoiToTissue::usage="VoronoiToTissue[points, boundary]"; 
CellVerticesToTissue::usage="CellVerticesToTissue[{cell1, cell2, ...}] where celli={{x,y}, {x,y},...}"; 


(* MultiPlot::usage="MultiPlot[solution, {variables, ...}, {t, tstart, tend}, options]"; 
RowPlot::usage="RowPlot[solution, {variables, ...}, {t, tstart, tend}, options]"; *)
SolutionVariables::usage="SolutionVariables[sim]";
SolutionVars::usage="SoltionVars[sim]";
GeometricSnapShot::usage=""; 


SmootheCell::usage="SmootheCell[tissue, cellNumber]"; 
SmootheCells::usage="SmootheCells[tissue, {cellNum, cellNum, ...}]\nSmoothCells[tissue] for all cells on boundary";


Tissue::usage="Tissue[vertices, edges, faces]"; 
TissueQ::usage="TissueQ[Tissue[...]]"; 
TissueCheck::usage="TissueCheck"; 
MidPoint::usage="MidPoint[p1,p2]\nMidPoint[{p1,p2}]\nMidPoint[{p1,p2,...}, i] - find midpoints of edge i (0 means all)\nMidPoint[{p1,p2,...}] - find midpoints of all edges\nMidPoint[Tissue[..]] - find midpoints of all edges in all cells\nMidPoint[Tissue,cellNumber] - find midpoints of all edges in given cell\nMidPoint[Tissue,cellNumber, edgeNumber] - midpoint of given edge in given cell."; 
AdjacentVertices::usage="AdjacentVertices[g,i] returns a list of the vertices that are adjacent to vertex i in g";
AdjacentBoundaryVertices::usage="AdjacentBoundaryVertices[g,i] returns a list of vertices that are adjacent to vertex i in g and lie on the boundary. If no vertices lie on the boundary then a null list is returned.";  
VerticesOnBottom::usage="";
VerticesOnTop::usage=""; 
VerticesOnRight::usage=""; 
VerticesOnLeft::usage=""; 

ConnectionList::usage="ConnectionList[tissue]\nOptions:\n\"UpperTriangular\"\[Rule]False, include both {i,j} and {j,i}; if True, only the one with i<j will be included";
ConnectionMatrix::usage="ConnectionMatrix[tissue] returns a SparseArray[..] object\nOptions are the same as ConnectionList";  
EdgeLengths::usage="EdgeLengths[tissue] returns a list of the lengths of all the edges in the tissue"; 
CellEdgeLengths::usage="CellEdgeLengths[tissue, cellNumber]";
EdgeLength::usage="EdgeLength[tissue, Edge Number]"; 
EdgeVertices::usage="EdgeVertices[edge, list-of-vertices] - where edge = {i,j} is pair of vertex indices and list-of-vertices is a list of coordinate pairs.  Returns {{x1,y1}, {x2,y2}} for the two endpoints of the edge. \nEdgeVertices[list-of-edges, list-of-vertices] - where list-of-vertices is a list of {i,j} pairs. Returns a list of vertex pairs.\nEdgeVertices[tissue] - returns {{x1,y1}, {x2, y2}} for all edges in tissue. "; 
CellVertexNumbers::usage="CellVertexNumbers[cell, list-of-cells]\nCellVertexNumbers[list-of-cells, list-of-vertices]\nCellVertexNumbers[Tissue]\nCellVertexNumbers[Tissue, cellNumber]"; 
SortCellsCounterClockwise::usage="SortCellClockwise[tissue] returns a list {s1,s2,...} where each si is a rule list {\"Edges\"-> {e1,e2, ...}, \"Vertices\"->{v1,v2,...}} where e1,e2,... are edge numbers of si, and v1,v2,... are the vertex numbers of cell i, arranged counter-clockwise.";
SortCellEdges::usage="SortCellEdges[cell, edges] returns a rule list {\"Edges\"-> {e1,e2, ...}, \"Vertices\"->{v1,v2,...}} where e1,e2,... are edge numbers of cell, and v1,v2,... are the vertex numbers of cell. Here cell is the list of edges numbers, and edges is the list of edge vertex pairs, as given in the tissue object."; 
CellVertexCoordinates::usage=""; 
CellsOnBoundary::usage="CellsOnBoundary[tissue]"; 
InteriorCells::usage="InteriorCells[tissue]"; 
VerticesOnBoundary::usage="VerticesOnBoundary[tissue]  returns a list of the indices of the vertices that are on the outer edge of the tissue."; 
VerticesNotOnBoundary::usage="VerticesNotOnBoundary[tissue] returns a list of the indices of the vertices that are not on the out edge of the tissuue."; 
EdgesOnBoundary::usage="EdgesOnBoundary[tissue] returns a list of the indices of the edges that are on the outer edges of the tissue."; 
EdgesNotOnBoundary::usage="EdgesNotOnBoundary[tissue] returns a list of the indices of the edges that are not on the outer boundary of the tissue.";
DivideEdge::usage="DivideEdge[tissue, edgeNumber, number of segments, randomness]"; 
DivideEdges::usage="DivideEdge[tissue, number of segments, randomness] or \nDivideEdge[tissue, {n1,n2,...}, number of segments, randomness]"; 
MergeEdges::usage="MergeEdges[tissue, edge1, edge2] returns a new tissue object with the specified edges merged together; the two edges must share a common vertex. \nOptions:\n\"Undangle\"\[Rule]True - if True, dangling edges and vertices will be removed after the merge; if False, they will not be removed."; 
MergeVertices::usage="MergeVertices[tissue, {v1,v2}] returns a tissue with the edge between {v1,v2} removed; or an error if there is no such edge.\nMergeVertices[tissue, n] returns a tissue with the nth redge removed. \nOptions:\n\"Changes\"->False; if True, a list {changes, newtissue} is returned. the list changes indicates edge number changes, oldNumber -> newNumber, with {} for a removed number."; 
DivideCell::usage="DivideCell[tissue, cellNumber, {{x1,y1}, {x2,y2}}] returns a tissue with the specified cells replaced by two daughter cells; the cell is divided along a single line segment determined by that part of the line through {x1,y1} and {x2,y2} that is not exterior to the cell.\nIf the option \"Changes\"\[Rule]True is used, instead of returning a tissue object, a list {changes, tissue} is returned, where changes is a list of rules giving the edge number changes, e.g., 3->{3,17} means edge 3 becomes edges 3 and 17 and {}-> 42 means the new edge is number 42."; 

DanglingEdges::usage="DanglingEdges[tissue]"; 
DanglingVertices::usage="DanglingVertices[tissue]"; 
UndangleEdge::usage="UndangleEdge[tissue, edgeNumber]"; 
RemoveEdge::usage="RemoveEdge[tissue, edgeNumber]"; 
UndangleEdges::usage="UndangleEdges[tissue]"; 
UndangleVertex::usage="UndangleVertex[tissue, vertexNumber]"; 
RemoveVertex::usage="RemoveVertex[tissue, vertexNumber]"; 
UndangleVertices::usage="UndangleVertices[tissue]"; 
RemoveShortEdges::usage="RemoveShortEdges[tissue, threshold], threshold is fraction of length of average edge."; 

InLineVertices::usage="InLineVertices[tissue] returns a list of the vertices that fall are shared by precisely two edges which are co-linear and fall between those two vertices (and hence the middle vertex could presumably be removed). The return value is a list of the form {{v, {e1,e2}}, {v, {e1,e2}}, ...} where v is the vertex number and e1, e2 are the numbers of the two shared edges. \n\nOptions\n\"Vertices\"\[Rule]{n1,n2,...} subset of list of vertex numbers to check (rather than checking all vertices)."; 

TissueCells::usage="TissueCells[tissue] returns a list of the cells in a tissue object. Each cell is a list of edge numbers.";
TissueEdges::usage="TissueEdges[tissue] returns a list of the edges in a tissue object; each edge is a pair of vertex numbers."; 
TissueVertices::usage="TissueVertices[tissue] returns a list of the vertices in a tissue. Each vertex is a coordinate pair {x,y}."; 
NTissueCells::usage="NTissueCells[tissue] returns the number of cells in a tissue.";
NTissueEdges::usage="NTissueEdges[tissue] returns the number of edges in a tissue."; 
NTissueVertices::usage="NTissueVertices[tissue] returns the number of vertices in a tissue."; 

(* DynamicalEquations::usage=""; *)
(* SpringEquations::usage=""; 
PressureEquations::usage="";*)

RemoveCell::usage="RemoveCell[tissue, cellNumber]\nremoveCell[tissue,{cell1,cell2,...}]\nremoves a specififed cell (or list of cells) and removes any remaining dangling edges and vertices";
AddVertex::usage="AddVertex[tissue, {x,y}]"; 
AddEdge::usage="AddEdge[tissue, {i,j}]"; 
AddCell::usage="AddCell[tissue, {i1,i2,i3,...}]"; 

CellNeighbors::usage="CellNeighbors[tissue, n] returns a list of neighbors of cell n in tissue\ncellNeighbors[tissue] returns a list of list of all neighbors of all cells."; 
VertexNeighbors::usage="VertexNeighbors[tissue,n]"; 
TissueOrTorusQ::usage="True if either a tissue or torus; otherwise, False."; 
EdgeBetween::usage="EdgeBetween[tissue, i, j] returns the integer number of the edge between cell i and cell j, or {} if they are not neighbors.";
EdgesBetween::usage="EdgesBetween[tissue] returns a sparse array that gives the number of edge between two cells, if they are neighbors, and a zero otherwise.";  


Rectangularize::usage="Rectangularize[tissue, options]";
Options[Rectangularize]={"Corners"-> "Automatic", "Method"-> "Perpendicular", "Quiet"-> False,  "Debug"-> False, "Randomness"-> 0.25};
ToTorus::usage="ToTorus[Tissue[..],..]";
Options[ToTorus]={"Tolerance"-> 1.0 10^-5, "Debug"-> False};
TorusQ::usage=""; 
TorusCheck::usage=""; 
Torus::usage="Torus[.. TBD ..] is an uninstantiated function indicating a Tissue[..] object with Toroidal connectivity.";
TorusTissue::usage="";
TorusRules::usage=""; 


Help::usage=""; 
$XLR8RLOAD::usage=""; 
$XSSALOAD::usage=""; 
(* QuadraticFit::usage="QuadraticFit[P0, P1, V0, V1, t]"; 
QuadraticFitCoefficients::usage="QuadraticFitCoefficients[P0, P1, PC]"; *)

Boundary::usage="Boundary[points, directives, options]"; 
(* DrawSpokes::usage="DrawSpokes[outputOfDropSpokes]"; *)

RegularPolygon::usage="RegularPolygons[NumberOfSides, StartAngle:0, aspect:1, Randomness:-1, RotationAngle:0]"; 
RegularStar::usage="RegularStar[NumberOfSides, Rbig/Rlittle:0, StartAngle:0, AspectRatio:1, Random:-1, RotationAngle:0] ";
Centroid::usage="Centroid[{v1,v2, ...}]\nCentroid[tissue, n]\nCentroid[tissue, {n1,n2,...}]\nCentroid[tissue] - list of all centrois."; 
Area::usage="Area[{v1, v2, ...}] - area of polygon with specified vertices\nArea[tissue,i] - area of cell i in tissue\nArea[tissue] - list of all areas"; 
Perimeter::usage="Perimeter[{v1, v2, ...}]"; 
InertiaMatrix::usage="InertiaMatrix[{v1, v2, ...}]";  
distance::usage="distance[p1, p2]"; 
unitVector::usage="unitVector[pointFrom, pointTo]"; 
Vector::usage="Vector[from,to]"; 
PointQ::usage="True if {x, y}; otherwise False"; 
NumericPointQ::usage="True if {x,y} are numeric; else False"; 

Inside::usage="Inside[{v1, v2, ...}, point]"; 
NormalVector::usage="NormalVector[{v1,v2,...}, index]"; 
OutwardNormalVector::usage="OutwardNormalVector[{v1,v2,..}, index]\nindex=0 means return all outward normals in the cell\nOutwardNormalVector[{v1,v2,..}] is equivalent to setting index=0\nOutwardNormalVector[tissue] - all cells and all edges\nOutwardNormalVector[tissue, cellnumber] all edges in given cel \nOutwardNormalVector[tissue, cellnumber, edgenumber]"; 
VertexOutwardNormal::usage="VertexOutwardNormal[tissue,i,mean:T/F] Return an outward pointing mean-normal vector to a boundary vertex or a null vector if the vertex is not on the boundary. The mean is the average of the outward normals of the edges on either side of the vertex (when Mean=True). If Mean is False (the default) then a list of vectors is returned for each edge. "; 
PrimaryAxes::usage="PrimaryAxes[{v1, v2, ...}] or \nPrimaryAxes[tissue,i] or \nPrimaryAxes[tissue, {i1,i2,...}] or \nPrimaryAxes[tissue]"; 
PrimaryAxesVectors::usage=""; 
FitEllipse::usage="FitEllipse[{v1, v2, ...}]"; 
LineEdgeIntersection::usage="LineEdgeIntersection[Edge, Point, Direction] where\nEdge={point1, point2}\nPoint={x,y}\nDirection={vx, vy}"; 
DropPerpendicular::usage="DropPerpendicular[Point, Edge, Slide:False]\nIf Slide is True, and the perp. misses the edges, the result will be allowed to slide to the nearest endpoint; if Slide is false, the value $Failed is returned when the perpindiclar line misses the edge."; 

PolygonIntersection::usage="PolygonIntersection[{vx,vy}, {v1, v2, ...}] where {vx,vy} are the coordinates of a direction vector; and the line is assumed to pass through the centroid;  or \nPolygonIntersection[{p1,p2}, {v1,v2,...}], where p1,p2 are two points that determine the line (p1\[NotEqual]p2)";
ShowCell::usage= "ShowCell[{p1,p2,...}, options]\n\"BoundaryStyle\"\[Rule]{Black, Thin}\n\"CellStyle\"\[Rule]{LightGreen}\n\"CellNumber\"\[Rule]-1\n\"CellNumberStyle\"\[Rule]{Black,12,FontFamily\[Rule]\"Times\"}";
ShowTissueCells::usage="ShowTissueCells[Tissue[..], {n1,n2,...}, color,opt] highlights specific cells.\nShowTissueCells[Tissue[..],{n1,n2,..}] uses a default color."; 
ShowTissue::usage="ShowTisue[Tissue[..], options]\n\"CellStyle\" \[Rule] List of cell colors or Automatic or \"None\"\n\"BoundaryStyle\" \[Rule] Color, thickness of walls (automatic)\n\"CellNumbers\" \[Rule] List of numbers to label cells with\n\"NumberStyle\" \[Rule] Text style directives for cell numbers\n\"Vertices\ \[Rule] {} or style parameters for vertices, e.g., color, PointSize\n\"VertexNumbers\" \[Rule] {} or style parameeters to print numbers\n\"EdgeNumbers\" \[Rule] {} or style parameters to print numbers\n\"DangingEdges\"\[Rule]False, if True, will print any dangling edges that are not part of cells. Normally Dangling edges are not printed."; 
ShowTissueFunction::usage="ShowTissueFunction[tissue, f, {fmin, fmax}, {colormin, colormax}, options]\nf[x,y] gives a function that depends on cell centroid location."; 
ShowEdgeNormal::usage="ShowEdgeNormal[{p1,p2}, style:{}, edge:False]"; 
ShowOutwardNormals::usage="ShowOutwardNormals[{p1,p2,...}, style:{}, edge:False]";
PointOnLineSegment::usage="PointOnLineSegment[{{x1,y1}, {x2,y2}}, {x,y}, Tolerance]\nReturns True if {x,y} falls on the line segment from {x1,y1} to {x2, y2} and False otherwise, to within a specified tolerance. If not specified the default tolerance is \!\(\*SuperscriptBox[\"10\", 
RowBox[{\"-\", \"10\"}]]\)."; 

EntangledVertices::usage="EntangledVertices[tissue] returns a list of lists of vertex numbers that fall on each edge that are not endpoints .. and hence should be resolved because this is a poorly defined tissue.";
DisentangleVertices::usage="DisentangleVertices[tissue] returns a tissue with all the entangled vertices fixed."; 

RGBInterpolate::usage="RGBInterpolate[value, {vmin, vmax}, {rgbfrom, rgbto}]"; 
ColorBlendRectangle::usage=""; 


LambertPlaneToDome::usage="";
LambertDomeToPlane::usage="";
ShowTissueOnDome::usage=""; 
Options[ShowTissueOnDome]={"CellStyle"-> Automatic, "EdgeStyle"-> Black, "Radius"-> -1}; 



TissueCentroid::usage=""; 


Begin["`Private`"];
Needs["ComputationalGeometry`"]; 
Needs["DifferentialEquations`InterpolatingFunctionAnatomy`"];
If[Length[Names["FLAGS`ECHOLOAD"]]>0,
msgflag=ToExpression["FLAGS`ECHOLOAD"],
msgflag=True;];
saveEcho=msgflag;
FLAGS`ECHOLOAD=False; 
Quiet[Needs["xlr8r`"]];
$XLR8RLOAD=True; 
If[Length[Names["$xlr8r$Version"]]<1, 
$XLR8RLOAD=False; 
Print[Style["Warning: ", Bold, Read], Style["Cellzilla2D: xlr8r.m not found in path. It should be loaded manually before any xlr8r simulations can be run.", Bold]];
];
$XLR8RLOAD = If[$XLR8RLOAD, ToExpression["$xlr8r$Version"], "** Not Found **"]; 
FLAGS`ECHOLOAD=False;  (* may get reset in xlr8r load *)
Quiet[Needs["xSSA`"]];
$XSSALOAD=True;
If[Length[Names["$xSSA$Version"]]<1, 
$XSSALOAD=False; 
Print[Style["Warning: ", Bold, Red], Style["Cellzilla2D: xSSA.m not found in path. Some stochastic conversion functions may not work as expected. It should be loaded manually before any xSSA (stochastic) simulations can be run.", Bold]];
];
$XSSALOAD=If[$XSSALOAD, ToExpression["$xSSA$Version"], "** Not Found **"]; 
FLAGS`ECHOLOAD=saveEcho; 


MyFilterOptions[f_,opt___?OptionQ]:=Sequence@@FilterRules[Flatten[{opt}],Options[f]];


DifferentQ[x_,y_]:= Not[SameQ[x,y]]; 


numPairQ[{x_?NumericQ, y_?NumericQ}]:= True;
numPairQ[x___]:= False; 

intPairQ[{i_Integer, j_Integer}]:= True;
intPairQ[x___]:= False

intListQ[{i__Integer}]:= True;
intListQ[x___]:= False; 


argument[f_[x___]]:= {x}; 


stringify[x_?StringQ]:= x;
stringify[x_]:= ToString[x];
stringify[x__]:= (Print["Error: Multiple arguments to stringify: ",x]; Abort[]);


hasvalue[x_]:= ToString[ToExpression[x]]!= x;


default$context="sim";
current$context=default$context; 

contextify[item_, context_:current$context]:= Module[{res, thecontext, theitem, badcontext},
badcontext[u_]:=  If[hasvalue[ToExpression[u]], Print["Warning: contextify: the symbol: ",u," already has a value assigned to it. This could lead to unexpected results: ", ToExpression[u]];
]; 

badcontext[item];
badcontext[context];
theitem=stringify[item];
thecontext=stringify[context];
While[StringLength[thecontext]>1 \[And]StringTake[thecontext,-1]=="`",thecontext=StringDrop[thecontext,-1] ];
If[thecontext=="" \[Or] ToUpperCase[thecontext]=="NONE", thecontext="Global"]; 
res=thecontext<>"`"<>theitem; 
badcontext[res];
Return[ToExpression[res]]
]


decontextify[x_?StringQ]:= Module[{p,q},
p = StringPosition[x,"`"];
If[Length[p]<1, Return[x]];
p=Map[First,p];
p = Last[p];
q= StringDrop[x,p];
Return[q];
];
decontextify[x_?ListQ]:= Map[decontextify,x];
decontextify[x_]:= Module[{s},
decontextify[ToString[InputForm[x]]]//ToExpression//Return;
];

decontextify[x_?StringQ, context_?StringQ]:= StringReplace[x, {context-> ""}]; 
decontextify[x_?ListQ, context_?StringQ]:= Map[decontextify[#,context]&,x]; 
decontextify[x_, context_?StringQ]:= Module[{},
decontextify[ToString[InputForm[x]],context]//ToExpression//Return;
]; 


SymbolAppend[name_?AtomQ, appendix_?StringQ]:=Symbol[stringify[name]<>appendix];

SymbolAppend[x___]:= (Print["Expecting SymbolAppend[Atom, Sring], not SymbolAppend[",x,"]"]; $Failed);


RuleQ[x_?ListQ]:= And@@RuleQ/@x; 
RuleQ[x_]:= SameQ[Head[x], Rule];
RuleQ[x_, y__]:= False;


Symbols[expression_]:= Module[{xml, XML, contexts, nonSystem},

XML[_, _, {u___}]:= {u}; 

xml=XML`MathML`ExpressionToSymbolicMathML[expression, "Formats"-> "ContentMathML"];
xml=Cases[xml,XMLElement["ci",__], Infinity];
xml = xml/.{XMLElement-> XML};
xml=Flatten[xml];
xml=Union[xml];
xml = Symbol/@xml;

contexts = Context/@xml;
nonSystem = Not[Equal[#,"System`"]]&/@contexts;
xml = Pick[xml, nonSystem];

Return[xml]; 
]


distance[v1_?ListQ,v2_?ListQ]:=Module[{v},v=v1-v2;
Return[Sqrt[v.v]];];


Vector[from_?PointQ, to_?PointQ]:= to-from; 
Vector[{from_?PointQ, to_?PointQ}]:= to-from;


unitVector[v1_?ListQ,v2_?ListQ]:=Module[{v,d},If[v1==v2,Return[{0,0}]];
v=v1-v2;
d=distance[v1,v2];
v=v/d;
Return[v];];


PointQ[{x_Symbol,y_Symbol}]:=True;
PointQ[{x_[t_], y_[t_]}]:= True;
PointQ[{x_[i_][t_], y_[i_][t_]}]:= True;
PointQ[{x_?NumericQ, y_?NumericQ}]:= True; 
PointQ[x___]:=False;

NumericPointQ[u___]:= numPairQ[u]; 

PointListQ[{p__?PointQ}]:= True;
PointListQ[x___]:= False; 

EdgeQ[{p1_?PointQ, p2_?PointQ}]:= True;
EdgeQ[x___]:= False; 


Points2Edges[{points__?PointQ}]:= Partition[{points}, 2, 1,1]


PointOnLineSegment[{{x1_, y1_}, {x2_, y2_}}, {p_, q_}, tol_:0.00001]:= Module[
{tolerance,x,y, xmin, xmax, ymin, ymax, tx, ty, segLen},
segLen = distance[{x1,y1}, {x2,y2}]; 
tolerance=Max[tol, 0]*segLen; 
xmin=Min[x1,x2]; xmax=Max[x1,x2];
ymin = Min[y1,y2]; ymax=Max[y1, y2];   
If[y1==y2,
y=y1;
Return[(Abs[q-y]<= tolerance)\[And] (xmin-tolerance<= p) \[And] (p<= xmax+tolerance)]; 
]; 
If[x1==x2,
(* Print["x1=x2"]; *)
x=x1;

(* Print[{tolerance, (Abs[p-x]<= tolerance) ,p,x,(ymin-tolerance<= q) ,ymin, q,ymax, (q<= ymax+tolerance)}]; *)

Return[(Abs[p-x]<= tolerance) \[And](ymin-tolerance<= q) \[And] (q<= ymax+tolerance)]; 
]; 
 
tx=(p-x1)/(x2-x1); 
ty=(q-y1)/(y2-y1); 
Return[Abs[tx-ty]<= tolerance]; 
]; 
PointOnLineSegment[x___]:= (Print["Expecting PointOnLineSegment[{{x1,y1}, {x2,y2}}, {xp,yp}, tolerance]"]; $Failed); 


Boundary[{points__?PointQ}]:= Boundary[{points}, {}]; 

Boundary[{points__?PointQ}, {dir___}, opt___?OptionQ]:= Module[{g}, 

g=Line[Append[{points}, First[{points}]]]; 
If[Length[{dir}]>0, 
g={Directive@@{dir}, g},
g={g}
];

g=Graphics[g, opt];

Return[g];
]


DrawSpokes[SpokeData_, opt___?OptionQ]:= Module[{g, ep, angles, vectors, pointstyle, spokestyle, points, number, numbers , np, origin, textcolor, textstyle, offset},

ep="Endpoints"/.SpokeData;
vectors="Spokes"/.SpokeData;
angles="Angles"/.SpokeData;
origin="Origin"/.SpokeData;

spokestyle="SpokeStyle"/.{opt}/.{"SpokeStyle"-> {Thin, Blue, Dotted}}; 
pointstyle="PointStyle"/.{opt}/.{"PointStyle"-> {PointSize[.015], Red}}; 
number="Numbers"/.{opt}/.{"Number"-> False}; 
offset = "Offset"/.{opt}/.{"Offset"-> .1}; 
textcolor="TextColor"/.{opt}/.{"TextColor"-> Black}; 
textstyle="TextStyle"/.{opt}/.{"TextStyle"-> {FontFamily-> "Times", FontSize-> 16}};


g = Line/@vectors;

spokestyle=Directive@@Flatten[{spokestyle}]; 
g=Flatten[{spokestyle, g}];

points = Point/@ep;
pointstyle= Directive@@Flatten[{pointstyle}]; 
g=Flatten[{g, pointstyle, points}];

If[number, 
numbers=ToString/@Range[Length[ep]];

vectors = Vector/@vectors;
np = (# (1+offset/Norm[#])+origin)&/@vectors; 

numbers = MapThread[Text, {numbers, np}];
g= Flatten[{g,textcolor,  numbers}];
];

g=Flatten[{g, BaseStyle-> textstyle}]; 
 Return[g]; 
]


ShowCell[{vertex__?NumericPointQ},  
opt___?OptionQ]:=Module[
{b, inside,c, number,numberStyle, cellStyle, boundaryStyle},

boundaryStyle="BoundaryStyle"/.{opt}/.{"BoundaryStyle"->Automatic }/.{Automatic-> {Black, Thin}}; 
cellStyle="CellStyle"/.{opt}/.{"CellStyle"-> Automatic}/.{Automatic-> {LightGreen}};

b=Boundary[{vertex},Flatten[{boundaryStyle}]]; 

inside=Graphics[{}]; 
If[ToString[cellStyle]!="None",  
inside =
Graphics[Flatten[{ Flatten[{cellStyle}], Polygon[{vertex}]}]]; 
]; 

number="CellNumber"/.{opt}/.{"CellNumber"-> -1}; 
If[number>0,
numberStyle=Flatten[{
{Black, 12, FontFamily-> "Times"}, 
"CellNumberStyle"/.{opt}/.{"CellNumberStyle"->Automatic}/.{Automatic->  {}}
}
];

number = Style[number, Sequence@@numberStyle];
number=Text[number, Centroid[{vertex}]];
number=Graphics[number]; 
,
number=Graphics[{}]; 
]; 

c=Show[inside,b, number];
Return[c]; 
];
ShowCell[x___]:= (Print["Error: Expecting ShowCell[vertices, options]; some data will not be displayed."]; Return[Graphics[{}]]); 


ShowTissue[tissue_?TissueQ, opt___?OptionQ]:= Module[
{cellstyles, n, nv, ne,cells, boundarystyle, cellnumbers,vertexnumbers,vnstyle,vertexstyle,numberstyle, gvertex, gedgenums,edgenumbers, edgenumberstyle, danglingEdges, deg, gdir},
cells=CellVertexCoordinates[tissue]; 

If[MemberQ[cells, $Failed], Print["Warning: ShowTissue: unable to plot some cells becasue of inconsistent data."]; ]; 

n=Length[cells]; 

(** cell colors **)

cellstyles="CellStyle"/.{opt}/.{"CellStyle"-> Table[Automatic, {n}]};
If[!ListQ[cellstyles], 
cellstyles={cellstyles}];  
If[Length[cellstyles]!=  n, 
(* Print["Warning: ShowTissue: Number of CellStyles is fewer than number of cells."];*)
cellstyles=PadRight[cellstyles,n,  "None"]
]; 


(** cell boundary and labels **)

boundarystyle="BoundaryStyle"/.{opt}/.{"BoundaryStyle"-> Automatic}; 
cellnumbers="CellNumbers"/.{opt}/.{"CellNumbers"-> False}; 
If[cellnumbers,
cellnumbers=Range[n];
numberstyle="CellNumberStyle"/.{opt}/.{"CellNumberStyle"-> Automatic}
,
cellnumbers=Table[-1, {n}];
numberstyle=Automatic; 
]; 



(** display the vertices if requested *)

vertexstyle="Vertices"/.{opt}/.{False-> {}}/.{"Vertices"-> {}}; 
If[vertexstyle==True, vertexstyle= {Black}]; 
gvertex=Graphics[{}]; 
If[Length[{vertexstyle}//Flatten]>0, 
vertexstyle=Directive[Flatten[{vertexstyle}]]; 
gvertex = Point/@TissueVertices[tissue]; 
gvertex=Graphics[Flatten[{vertexstyle, gvertex}]]; 
];

(** label the vertices if requested **)

vertexnumbers=(("VertexNumbers"/.{opt})/.{False-> {}})/.{"VertexNumbers"-> {}}; 
If[vertexnumbers==True, vertexnumbers={Darker[Red]}]; 
nv=NTissueVertices[tissue];
If[Length[{vertexnumbers}//Flatten]>0,
vnstyle=Directive[Flatten[{vertexnumbers}]]; 

vertexnumbers=Range[nv];
vertexnumbers = MapThread[Text, {vertexnumbers, TissueVertices[tissue]}]; 
vertexnumbers=Graphics[Flatten[{vnstyle, vertexnumbers}]]; 

,
vertexnumbers=Graphics[{}]; 
]; 

(** label the edges if requested *)
edgenumbers =(( "EdgeNumbers"/.{opt})/.{False-> {}})/.{"EdgeNumbers"-> {}}; 
If[edgenumbers==True, edgenumbers={Darker[Blue],FontSize-> 14}]; 
ne = NTissueEdges[tissue]; 
If[Length[{edgenumbers}//Flatten]>0,
edgenumberstyle=Directive[Flatten[{edgenumbers}]]; 
edgenumbers=Range[ne]; 
edgenumbers=MapThread[Text,{edgenumbers, MidPoint/@EdgeVertices[tissue]}]; 
edgenumbers=Graphics[Flatten[{edgenumberstyle, edgenumbers}]]; 
,
edgenumbers=Graphics[{}]; 

]; 

(* are there any dangling edges that are not displayed because they are not part of cells ? *)
danglingEdges=Graphics[]; 
If["DanglingEdges"/.{opt}/.{"DanglingEdges"-> False}, 
deg=DanglingEdges[tissue]; 
If[Length[deg]>0,
gdir = Complement[Flatten[{boundarystyle}], {Automatic}]; 
danglingEdges = Graphics[{Directive@@gdir, #}]&/@Line/@EdgeVertices[tissue][[deg]]; 
]; 
]; 


With[{ShowOptions=MyFilterOptions[Graphics,opt]},  
Show[
MapThread[ShowCell[#1,"CellStyle"-> #2, "BoundaryStyle"-> boundarystyle, "CellNumber"-> #3, "CellNumberStyle"-> numberstyle]&, {cells, cellstyles, cellnumbers}],
danglingEdges,
gvertex, 
vertexnumbers,
edgenumbers,
ShowOptions
]
]
]


ShowTissue[tissue_?TorusQ, opt___?OptionQ]:= ShowTissue[TorusTissue[tissue], opt];


ShowEdgeNormal[{p1_?PointQ, p2_?PointQ}, style_:{}, edge_:False]:= Module[{nv, origin, g, l},
nv=NormalVector[{p1,p2}]; 
origin = (p1+p2)/2; 
nv={style, Arrow[{origin, origin+nv}]};  
g=Graphics[Flatten[nv]]; 
If[edge,
l=Graphics[Line[{p1, p2}]],  
l=Graphics[] ];
Return[Show[g, l]]
]


ShowOutwardNormals[{p__?PointQ}, style_:{}, edge_:False]:=Module[
{e, vecs, midpoints, arrows, l},
vecs = OutwardNormalVector[{p}, 0]; 
e=Append[{p}, First[{p}]]; 
midpoints = Mean/@Partition[e,2,1];
arrows = MapThread[Arrow[{#1, #2}]&, {midpoints, midpoints+vecs}]; 
arrows={style, arrows}//Flatten; 
arrows=Graphics[arrows]; 
If[edge,
l=Graphics[Line[e]],  
l=Graphics[] ];
Show[arrows, l]
]


ShowTissueCells[tissue_?TissueQ, {cells__?IntegerQ}, color_, opt___?OptionQ]:= Module[{colors,p,n, dc},
n=NTissueCells[tissue]; 
dc = "CellStyle"/.{opt}/.{"CellStyle"-> LightGreen}; 
colors = If[MemberQ[{cells}, #], color, dc]&/@Range[n]; 
p=ShowTissue[tissue, "CellStyle"-> colors, opt];
Return[p]; 
];
ShowTissueCells[tissue_?TissueQ, {cells__?IntegerQ}]:= ShowTissueCells[tissue, {cells}, LightPink];
ShowTissueCells[x___]:= (Print["Error: Expecting ShowTissueCells[tissue, {i1,i2,...}] or \nShowTissueCells[tissue, {i1, i2, ..}, color, options]"]; $Failed);


ShowTissueFunction[tissue_?TissueQ, 
f_, {fmin_, fmax_}, {cmin_, cmax_},
opt___?OptionQ]:=Module[
{n, centroids, values,colors,pic}, 

n=NTissueCells[tissue]; 

centroids = Centroid[tissue]; 
values = (f@@#)&/@centroids;
colors = RGBInterpolate[#, {fmin, fmax}, {cmin, cmax}]&/@values; 
pic = ShowTissue[tissue, "CellStyle"-> colors, opt]; 
Return[pic]
];


SolutionVars[system_]:= Union[Head/@SolutionVariables[system]]; 


SolutionVariables[system_]:= SolutionVariables[system, {}]; 
SolutionVariables[system_, {var___}]:= Module[{s,v, p},
s=Flatten[{system}]; 
v=First/@s;
If[Length[{var}]==0, Return[v]];
v=Join[Cases[ v,#, Infinity], Cases[v, #[_], Infinity], Cases[v, #[_][_], Infinity]]&/@{var}; 
v=Flatten[v]
];
SolutionVariables[x___]:= "??";


MultiPlot[solution_, {var__},  {time_, tstart_, tend_}, opt___?OptionQ]:= Module[
{variables, points, data, sol1, times, singleLine, singleCurve, dir, n},
points="PlotPoints"/.{opt}/.{"PlotPoints"-> 50};
variables=SolutionVariables[solution, {var}];
sol1=variables/.solution;
times = Range[tstart, tend,1.0* (tend-tstart)/points];
data[oneSolution_]:= (oneSolution/.{time-> #})&/@times;
singleLine[oneSolution_]:= Line[Transpose[{times, data[oneSolution]}]]; 
singleCurve[oneSolution_, graphicsDirectives_]:=Graphics[{graphicsDirectives, singleLine[oneSolution]}]; 

dir="GraphicsDirectives"/.{opt}/.{"GraphicsDirectives"-> Automatic};
n=Length[sol1]; 
If[ToString[dir]=="Automatic",
dir=Hue/@((1.0/n)*Range[0,n-1])
]; 
If[!ListQ[dir], dir = Table[dir, {n}]]; 
dir = PadRight[dir, n, Indeterminate]/.{Indeterminate-> {}}; 


With[{ShowOptions=MyFilterOptions[Graphics,opt]}, 
Show[MapThread[singleCurve, {sol1, dir}], ShowOptions, 
Frame-> True, FrameTicks-> {Automatic,Automatic, None, None}, AspectRatio-> 1]
]

];
MultiPlot[x___]:= Print["??"]; 


RowPlot[solution_, {var__}, {t_, tstart_, tend_}, opt___?OptionQ]:= With[{gropt=MyFilterOptions[GraphicsRow, opt]}, 
GraphicsRow[
MultiPlot[solution, {#}, {t, tstart, tend}, opt, PlotLabel-> ToString[#]]&/@{var}, gropt]
];


GeometricSnapShot[tissue_?TissueQ, solution_, {x_, y_}, {timeVariable_, time_}, opt___?OptionQ]:= Module[{c,e, n, v, p},
c=TissueCells[tissue];
e=TissueEdges[tissue];
n=NTissueVertices[tissue]; 
 v=({x[#][timeVariable], y[#][timeVariable]}&/@Range[n])/.solution/.{timeVariable-> time} ;
p=Tissue[v,e,c];
p=ShowTissue[p, opt]; 
Return[p]; 
];


RegularPolygon[n_,start_: 0,aspect_: 1.0,rnd_:-1,rotationAngle_: 0]:=Module[{v,angles,rv,RM},(*generate the precise vertex coordinates*)angles=Table[j,{j,0.0+start,0.0+start+2.0*((n-1)/n) Pi,2.0*Pi/n}];
v={Cos[#],aspect*Sin[#]}&/@angles;
(*add randomness if desired*)If[rnd>0,rv:=RandomReal[{-rnd,rnd}];
v=Map[{rv,rv}+#&,v];];
(*rotation through an angle rotationAngle*)RM=RotationMatrix[rotationAngle];
v=v.RM;
Return[v];]


RegularStar[npoints_,ROverr_: 0,start_: 0,aspect_: 1.0,rand_:-1,rotationAngle_: 0]:=Module[{v,n,angles,rv,RM,Rr,mults,rnd},(*generate the precise vertex coordinates*)n=npoints*2;
rnd=If[rand>0,rand,0];
Rr=Abs[ROverr];
If[Rr==0,Rr=1];
If[Rr<1,Rr=1/Rr];
angles=Table[j,{j,0.0+start,0.0+start+2.0*((n-1)/n) Pi,2.0*Pi/n}];
mults=Table[If[EvenQ[j],Rr,1]*(1+RandomReal[{-rnd,rnd}]),{j,0,n-1}];
v={Cos[#],aspect*Sin[#]}&/@angles;
v=mults*v;
(*rotation through an angle rotationAngle*)RM=RotationMatrix[rotationAngle];
v=v.RM;
Return[v];]


InertiaMatrix[{xydata__?PointQ}]:=InertiaMatrix[xydata]
InertiaMatrix[xydata__?PointQ]:=Module[{v,n,Ixx,Ixy,Iyy,x,y,Inertia},v={xydata};
n=Length[v];
AppendTo[v,v[[1]]];
x[i_]:=v[[i,1]];
y[i_]:=v[[i,2]];
Ixx=0;Ixy=0;Iyy=0;
For[i=2,i<=n+1,i++,Ixx=Ixx+(x[i]^3+x[i]^2 x[i-1]+x[i] x[i-1]^2+x[i-1]^3) (y[i]-y[i-1]);
Iyy=Iyy+(y[i]^3+y[i]^2 y[i-1]+y[i] y[i-1]^2+y[i-1]^3) (x[i]-x[i-1]);
Ixy=Ixy+(y[i] (3 x[i]^2+2 x[i] x[i-1]+x[i-1]^2)+y[i-1] (x[i]^2+2 x[i] x[i-1]+3 x[i-1]^2)) (y[i]-y[i-1])];
Ixx=Abs[Ixx]/12;
Iyy=Abs[Iyy]/12;
Ixy=Abs[Ixy]/24;
Inertia={{Ixx,Ixy},{Ixy,Iyy}};
Return[Inertia];];

InertiaMatrix[tis_?TissueQ,n_?IntegerQ]:= Module[{},
If[n<1 \[Or] n>NTissueCells[tis], 
Print["Error: InertiaMatrix[tissue,",n,"]; tissue only has ", NTissueCells[tis]," cells."];
Return[$Failed]]; 
Return[InertiaMatrix[CellVertexCoordinates[tis,n]]];
];
InertiaMatrix[tis_?TissueQ]:= InertiaMatrix/@CellVertexCoordinates[tis]; 

InertiaMatrix[x___]:=(Print["Error: Expecting InertiaMatrix[point1, point2, ...] or \nInertiaMatrix[tissue,n] or \nInertiaMatrix[tissue]"]; $Failed);


Mass[{xydata__?PointQ}]:= Mass[xydata]; 
Mass[xydata__?PointQ]:=Module[{v,j,n,x,y,mass},(*will be negative if cells are clockwise,positive otherwise*)
v={xydata};
n=Length[v];
mass=0;
x[i_]:=If[i==0,v[[n,1]],v[[i,1]]];
y[i_]:=If[i==0,v[[n,2]],v[[i,2]]];
For[j=0,j<n,j++,mass=mass+x[j]*y[j+1]-x[j+1] y[j];];
mass=mass/2;
Return[mass];];
MassSign[xydata__?PointQ]:=Module[{m},m=Mass[xydata];If[m!=0,m=m/Abs[m]];
Return[m]];
MassSign[{x__?PointQ}]:=MassSign[x];


Area[xydata__?PointQ]:=Abs[Mass[xydata]]; 
Area[{xydata__?PointQ}]:=Area[xydata];

Area[tis_?TissueQ, i_?IntegerQ]:= Area[CellVertexCoordinates[tis,i]];

Area[tis_?TissueQ, {i__?IntegerQ}]:= Module[{cvc},
cvc = CellVertexCoordinates[tis]; 
cvc = cvc[[{i}]]; 
Return[Area/@cvc]; 
]

Area[tis_?TissueQ]:= Area/@CellVertexCoordinates[tis]; 

Area[x___]:=(Print["Expecting Area[P1, P2, ...] or Area[tissue, i] or Area[tissue]"]; $Failed);


Centroid[{xydata__?PointQ}]:= Centroid[xydata]; 
Centroid[xydata__?PointQ]:=Module[{v,j,n,x,y,cx,cy,area,sign,centroid},v={xydata};
n=Length[v];
cx=cy=0;
sign=MassSign[xydata];
area=Area[xydata];
x[i_]:=If[i==0,v[[n,1]],v[[i,1]]];
y[i_]:=If[i==0,v[[n,2]],v[[i,2]]];
For[j=0,j<n,j++,cx=cx+(x[j]+x[j+1]) (x[j] y[j+1]-x[j+1] y[j]);
cy=cy+(y[j]+y[j+1]) (x[j] y[j+1]-x[j+1] y[j]);];
If[SameQ[area,0],centroid=sign*{cx,cy};
Return[centroid];];
If[Equal[area,0],centroid=sign*{cx,cy};
Return[centroid];];
centroid=sign*{cx,cy}/(6*area);
Return[centroid];
];
Centroid[tiss_?TissueQ]:= Centroid/@CellVertexCoordinates[tiss]; 
Centroid[tiss_?TissueQ, cellNumber_?IntegerQ]:= Centroid[tiss, {cellNumber}][[1]]; 
Centroid[tiss_?TissueQ, {cells__?IntegerQ}]:= Module[{cvc, centroids,n},
cvc = CellVertexCoordinates[tiss]; 
n=NTissueCells[tiss]; 
If[(#>n)\[Or](#<1), Print["Error: Centroid: Cell ", #, " does not exist."]]&/@{cells}; 
cvc = cvc[[{cells}]]; 
centroids = Centroid/@cvc;
Return[centroids]; 
];

Centroid[x___]:= (Print["Error: Expecting Centroid[{v1,v2, ...}]"]; $Failed);


TissueCentroid[g_Tissue]:= Module[{e,v,c, G},
(* create a tissue with a single cell that has only the boundary edges *)
e=TissueEdges[g]; 
v=TissueVertices[g]; 
c={EdgesOnBoundary[g]};
G=Tissue[v,e,c];
(* need to sort the edges to make the algorithm work properly *)
c={"Edges"/.SortCellsCounterClockwise[G][[1]]};
G=Tissue[v,e,c];
Centroid[G,1]
]


Perimeter[{points__?PointQ}]:=Module[{pts,c},pts=Partition[{points},2,1,1];
c=distance@@#&/@pts;
Return[Plus@@c]];
Perimeter[points__?PointQ]:= Perimeter[{points}]; 
Perimeter[tissue_?TissueQ, i_]:= Perimeter[CellVertexCoordinates[tissue,i]]; 
Perimeter[tissue_?TissueQ]:= Perimeter/@CellVertexCoordinates[tissue]; 
Perimeter[x___]:= (Print["Error: Expecting Perimeter[Point1, Point2, ...] or \nPerimeter[tissue] or \nPerimeter[tissue, i]"]; $Failed); 


Inside[{vertices__?PointQ},point_?PointQ]:=Module[{i,j,c,n,xp,yp,x, y,  points},

points={vertices}; 

{x,y}=point; (*from http://local.wasp.uwa.edu.au/~pbourke/geometry/insidepoly/*)xp[k_]:=points[[k,1]];
yp[k_]:=points[[k,2]];
c=False;
n=Length[points];
For[i=1;j=n;,i<=n,j=i++,If[(((yp[i]<=y)&&(y<yp[j]))||((yp[j]<=y)&&(y<yp[i])))&&(x<(xp[j]-xp[i])*(y-yp[i])/(yp[j]-yp[i])+xp[i]),c=\[Not]c]];
Return[c];];
Inside[x___]:= (Print["Error: Expecting Inside[{v1, v2, ...}, point]"]; $Failed;);


OutsideBox[{objectVertices__?numPairQ}, {boxVertices__?numPairQ}]:= Module[{vertexOutside, outside},
vertexOutside[{x_, y_}]:= !Inside[{boxVertices}, {x,y}]; 
outside = vertexOutside/@{objectVertices};
outside=And@@outside;
Return[outside];
]


PrimaryAxes[{vertices__?PointQ}, opt___?OptionQ]:=Module[{M,evalues,relativeEigenvalues,evectors,norms,centroid,arrows,g,angles,V, dbg, dPrint, listOfVertices, eigenvalues},

dbg= "Debug"/.{opt}/.{"Debug"-> False}; 
dPrint[x___]:= If[dbg, Print["PrimaryAxes: ", x]]; 

listOfVertices={vertices}; 
dPrint["list of vertices: ", listOfVertices]; 

centroid=Centroid[listOfVertices];
dPrint["centroid: ", centroid]; 

V=(#-centroid)&/@listOfVertices;
M=Transpose[V].V;
eigenvalues=Eigenvalues[M];
evalues=Sqrt/@eigenvalues;
(*find "relative" eigenvalues*)relativeEigenvalues=evalues/Norm[evalues];
(*find eigenvectors and normalize relative to the magnitudes of the eigenvalaues*)evectors=Eigenvectors[M];
norms=Norm/@evectors;
evectors=evectors/norms;
evectors=evectors*relativeEigenvalues;
angles=ArcTan@@#&/@evectors;
(*convert eigenvectors to graphical arrows& vectors from the centroid*)evectors={centroid,centroid+#}&/@evectors;
arrows=Arrow/@evectors;
g=Graphics[{Line[Append[listOfVertices,listOfVertices[[1]]]],

PointSize["PointSize"/.{opt}/.{"PointSize"-> .02}], 
"PointColor"/.{opt}/.{"PointColor"-> Red}, 
Point[centroid],
"Color"/.{opt}/.{"Color"-> Blue},arrows}];
Return[{"Vectors"->evectors,"Graphics"->g,"Eigenvalues"->relativeEigenvalues,"Angles"->angles}]
];
PrimaryAxes[tiss_?TissueQ, {i__?IntegerQ}, opt___?OptionQ]:= Module[{cvc, pa},
cvc=CellVertexCoordinates[tiss][[{i}]]; 
pa=PrimaryAxes[#, opt]&/@cvc; 
Return[pa]; 
];
PrimaryAxes[tiss_?TissueQ, i_?IntegerQ, opt___?OptionQ]:= PrimaryAxes[tiss, {i}, opt][[1]]; 
PrimaryAxes[tiss_?TissueQ, opt___?OptionQ]:= PrimaryAxes[tiss, Range[NTissueCells[tiss]], opt];


PrimaryAxesVectors[{vertices__?NumericPointQ}, opt___?OptionQ]:= Module[{pa, evectors, evalues},
pa=PrimaryAxes[{vertices}]; 
evectors = "Vectors"/.pa;
evalues = "Eigenvalues"/.pa;
pa = Transpose[{evalues, evectors}]; 
pa = Sort[pa];
pa = Last/@pa; 
Return[pa];
];
PrimaryAxesVectors[tiss_?TissueQ, {i__?IntegerQ}, opt___?OptionQ]:= Module[{cvc, pa},
cvc = CellVertexCoordinates[tiss][[{i}]]; 
pa = PrimaryAxesVectors[#,opt]&/@cvc; 
Return[pa]; 
];
PrimaryAxesVectors[tiss_?TissueQ, i_?IntegerQ, opt___?OptionQ]:= PrimaryAxesVectors[tiss, {i}, opt][[1]]; 
PrimaryAxesVectors[tiss_?TissueQ, opt___?OptionQ]:= PrimaryAxesVectors[tiss, Range[NTissueCells[tiss]], opt]; 


FitEllipse[V_]:=Module[{axes,V1,V2,\[Lambda]1,\[Lambda]2,K,axis1,axis2,A,Centroid,\[Theta]1,\[Theta]2,g},
axes=PrimaryAxes[V];
{V1,V2}="Vectors"/.axes;
{\[Lambda]1,\[Lambda]2}="Eigenvalues"/.axes;
K=\[Lambda]1/\[Lambda]2;
A=Area[V];
axis2=Sqrt[A/(\[Pi]*K)];
axis1=K*axis2;
Centroid=V1[[1]];
{\[Theta]1,\[Theta]2}="Angles"/.axes;
g="Graphics"/.axes;
g=Show[g,Graphics[{Purple,Rotate[Circle[Centroid,{axis1,axis2}],\[Theta]1]}]];
Return[{"Angle"->\[Theta]1,"Axes"->{axis1,axis2},"Graphics"->g}];]


LineEdgeIntersection[edge_?EdgeQ,point_?PointQ,direction_?PointQ]:=Module[{vedge,\[CapitalDelta]y,\[CapitalDelta]x,A,Ainv,b,x,y, p1, p2, xc, yc, v1, v2, x1, y1, x2, y2},


{p1, p2}=edge; 
{x1, y1} =p1; 
{x2, y2}=p2;

{xc, yc} = point;  
{v1, v2}=direction; 

\[CapitalDelta]x=x2-x1;
\[CapitalDelta]y=y2-y1;
vedge={\[CapitalDelta]x,\[CapitalDelta]y};

(*both parallel*)
If[\[CapitalDelta]y v1==\[CapitalDelta]x v2,Return[$Failed]];
A={{v2,-v1},{\[CapitalDelta]y,-\[CapitalDelta]x}};
Ainv=Inverse[A];
b={v2 xc-v1 yc,x1 \[CapitalDelta]y-y1 \[CapitalDelta]x};
{x,y}=Ainv.b;
(*we could use the worked-
out formula but its not as pretty:*)

(*{(v2 (-x1+x2) xc+v1 (x2 (y1-yc)+x1 (-y2+yc)))/(v2 (-x1+x2)+v1 (y1-y2)),(v2 (x2 y1-xc y1-x1 y2+xc y2)+v1 (y1-y2) yc)/(v2 (-x1+x2)+v1 (y1-y2))}*)

(*check to make sure the intersection is within the edge*)

If[x<Min[x1,x2],Return[$Failed]];
If[x>Max[x1,x2],Return[$Failed]];
If[y<Min[y1,y2],Return[$Failed]];
If[y>Max[y1,y2],Return[$Failed]];
Return[{x,y}]];
LineEdgeIntersection[x___]:=(Print["Error: Expecting LineEdgeIntersection[edge, point, direction]: ", {x}]; $Failed);


DropPerpendicular[point_?PointQ, edge_?EdgeQ, slide_:False]:= Module[{perp, intersection, d1, d2},

If[distance@@edge==0, Print["Error: DropPerpendicular: Edge ", edge, " has zero length."]; Return[$Failed]]; 
perp=edge[[2]]-edge[[1]]; 
perp = {-perp[[2]], perp[[1]]}; 
perp =perp/Norm[perp]; 
intersection=LineEdgeIntersection[edge, point, perp]; 

If[DifferentQ[intersection ,$Failed], Return[intersection]]; 

(* The perpendicular missed the edge. Should we slide it to the endpoint? *)
If[!slide, Return[$Failed]]; 

d1 = distance[point, edge[[1]]]; 
d2 = distance[point, edge[[2]]]; 

If[d1 <= d2, 
Return[edge[[1]]], 
Return[edge[[2]]]
];  

];
DropPerpendicular[x___]:= (Print["Error: Expecing DropPerpendicular[point, edge, slide]"]; $Failed);


DropLineToNearestPointOnEdge[point_?PointQ, edge_?EdgeQ]:= DropPerpendicular[point, edge, True];


PolygonIntersection[vector_?PointQ,{vertex__?PointQ}]:=Module[{nv,centroid,edges,debug=False,int,range,v, ok},nv=Length[{vertex}];
If[nv<3,Print["eh? polygonIntersect: expecting more than ",nv," vertices. Vector: ",vector," vertices: ",{vertex}];
Return[$Failed];];
centroid=Centroid[{vertex}];
Return[
PolygonIntersection[{centroid, centroid+vector}, {vertex}]
];
 
]


PolygonIntersection[{p1_?PointQ, p2_?PointQ},{vertex__?PointQ}]:=Module[{nv,edges,vector, debug=False,int,range,v,ok, toomany, dPrint},
dPrint[x___]:= If[debug, Print["PolygonIntersection: ", x]]; 
nv=Length[{vertex}];
If[nv<3,Print["eh? polygonIntersect: expecting more than ",nv," vertices. Vector: ",vector," vertices: ",{vertex}];
Return[$Failed];];
edges=Partition[{vertex},2,1,1];
vector=Subtract@@{p1,p2};
int=LineEdgeIntersection[#,p1,vector]&/@edges;

dPrint["polygonIntersect[",vector,{vertex},"]"];
dPrint["p1,p2,vector: ",{p1,p2,vector}];
dPrint["edges: ",edges];
dPrint["intersectons: ",int];

range=Range[nv];
ok=(ToString[#]!="$Failed")&/@int;
int=Pick[Transpose[{range,int}],ok];
nv=Length[int];
dPrint["Edge ",#[[1]]," intersection at ",#[[2]]]&/@int;
(* 2 intersections is normal; 3 or 4 means it occurs at existing vertices *)


toomany=False; 
Which[
nv==0,
Print["Warning: PolygonIntersect: no intersections."],

nv==1,
Print["Warning: PolygonIntersect: only 1 intersection: ",int],

nv>2,
dPrint["Warning: PolygonIntersect: too many intersections = ",int];
toomany=True; 

];

If[toomany,
Block[{pts, pos, i, j, points}, 
dPrint["Handling too many intersections."]; 
pts = Last/@int;

(* Fix in the case of non-convex cell *)
(* Also works if the intersections fall on a vertex! *)

If[pts[[1,1]]==pts[[1,2]],
(* vertical line *)
pts = Reverse/@Sort[Reverse/@Append[pts, p1]],
(* not a vertical line - can sort by x coordinate *)
pts = Sort[Append[pts,p1]];
]; 
pos = Position[pts, p1][[1,1]]; 
If[pos==1 \[Or] pos==Length[pts], 
Print["Error: Point p1 ", p1," is not an interior point. "];
If[pos==1,
i = pos+1; j = pos + 2,
i = pos-2; j = pos -1; 
], 
i = pos-1; j = pos + 1;
];
dPrint["p1: ", p1, " pos: ", pos, " i, j: ", i,",", j]; 
dPrint["pts: ", pts]; 
(* Extract Proper Points *)
i=pts[[i]]; j = pts[[j]]; 
i=int[[Position[int, i][[1,1]]]]; 
j = int[[Position[int, j][[1,1]]]]; 

dPrint["{i,j}:", {i,j}]; 
int = Sort[{i,j}]; 
]; 
]; 

Return[int];

]

PolygonIntersection[x___]:= (Print["Error: Expecting PolygonIntersection[{point1, point2}, {vertices}] or PolygonIntersection[DirectionVector, {vertices}]"]; $Failed); 


NormalVector[{p1_, p2_}]:= NormalVector[{p1,p2}, 1]; 
NormalVector[{p__?PointQ}, i_Integer]:= Module[{v, e, vec},
v=Append[{p}, First[{p}]];
(* edge vector *)
e={v[[i]], v[[i+1]]};
vec=Vector@@e;
(* normal vector *)
vec = {-vec[[2]], vec[[1]]};
vec = vec/Norm[vec]
];
NormalVector[x___]:= (Print["Expecting NormalVector[{vertex, vertex, ...}, index]."]; $Failed); 



OutwardNormalVector[{pt__?PointQ}]:= OutwardNormalVector[{pt}, 0]; 
OutwardNormalVector[{pt__?PointQ}, j_Integer]:= Module[
{v, OutwardNormal}, 
v=Append[{pt}, First[{pt}]];

OutwardNormal[ i_Integer]:= Module[{ e, vec, origin, epsilon, point},
(* edge vector *)
If[i>= Length[v], Print["Error: OutwardNormalVector: edge ", i, " does not exist: points=", {pt}]; Return[$Failed]]; 

e={v[[i]], v[[i+1]]};
vec=Vector@@e;
(* normal vector *)
vec = {-vec[[2]], vec[[1]]};
vec = vec/Norm[vec];
origin = Mean[e]; 
epsilon=0.01*Norm[e]; 
point=origin+vec*epsilon; 
If[Inside[{pt}, point] , Return[-vec], Return[vec]]; 
];

If[j>0, 
Return[OutwardNormal[j]],
Return[OutwardNormal/@Range[Length[{pt}]]]
];
Print["OutwardNormalVector: Program Error: ", {pt, j}]; 
]; 


OutwardNormalVector[tissue_?TissueQ]:= OutwardNormalVector[tissue, 0, 0]; 
OutwardNormalVector[tissue_?TissueQ, cellNum_]:= OutwardNormalVector[tissue, cellNum, 0]; 
OutwardNormalVector[tissue_?TissueQ, cellNumber_Integer, edgeNumber_Integer]:= Module[{p, nv},
If[cellNumber>0, 
(* single cell *)
p=CellVertexCoordinates[tissue, cellNumber];
Return[OutwardNormalVector[p, edgeNumber]]; 
,
(* all cells *)
(* ignore edge number in this case *)
p=CellVertexCoordinates[tissue];
(* set edgenumber to zero to force all edges *)
nv = OutwardNormalVector[#, 0]&/@p;
Return[nv]; 
];
Print["Error: Outward Normal Vector: Program Error: ", {tissue, cellNumber, edgeNumber}]; 
Return[$Failed]; 
];

OutwardNormalVector[x___]:= (Print["Error; Expecting OutwardNormalVector[{p1,p2,...}, index:0] or OutwardNormalVector[Tissue, cellNumber:0, edgeNumber:0] (0 means all)"]; Return[$Failed]); 


MidPoint[p1_?PointQ, p2_?PointQ]:= Mean[{p1,p2}];
MidPoint[{p1_?PointQ, p2_?PointQ}]:= Mean[{p1,p2}]; 
MidPoint[{p1_?PointQ, p2_?PointQ, p3__?PointQ}]:=MidPoint[{p1,p2, p3}, 0]; 
MidPoint[{p1_?PointQ, p2_?PointQ, p3__?PointQ}, i_Integer]:= Module[{v, mp},
v={p1,p2, p3, p1};
If[i>= Length[v], Print["Error: Midpoint: edge ", i, " does not exist in polygon ", v]; Return[$Failed]];  
If[i>0,
mp=MidPoint[v[[i]], v[[i+1]]];
, 
v= Partition[v, 2, 1]; 
mp = MidPoint/@v;
];
Return[mp];
];
MidPoint[tissue_?TissueQ, cellNumber_Integer]:= MidPoint[tissue, cellNumber, 0]; 
MidPoint[tissue_?TissueQ]:= MidPoint[tissue, 0, 0]; 
MidPoint[tissue_?TissueQ, cellNumber_Integer, edgeNumber_Integer]:= Module[{v, mp},
If[cellNumber>0, 
v=CellVertexCoordinates[tissue, cellNumber];
mp=MidPoint[v, edgeNumber];
,
v=CellVertexCoordinates[tissue]; 
mp=MidPoint/@v;
]; 
Return[mp];
]; 


LambertPlaneToDome[{p_, q_}]:= Module[{x,y,z, r, theta},
(* transform to a dome with the north pole at (0,0,-1) *)
r=p^2+q^2;
If[r <=2, 
x=p Sqrt[1-(r/4)];
y=q Sqrt[1-(r/4)];
z=(r/2)-1;
(* switch south pole to north pole *)
(* z=2-z-2; *) 
z=1-r/2; 
Return[{x,y,z}]
];
(* Need Code Here for r >4/3*)
theta = ArcTan[p, q];
x=Cos[theta];
y=Sin[theta];  
z=1-r/2; 
z=1-Sqrt[r/2];
(* put the point on the edge of the dome *)
z = 0;
Return[{x,y,z}];
]; 
LambertDomeToPlane[{x_, y_,z_}]:= Module[{p,q, r},
r=2/(1-z); 
p=Sqrt[r*x];
q=Sqrt[r*y];
Return[{p,q}]; 
]


ShowTissueOnDome[tissue_Tissue, opt___?OptionQ]:=Module[{v,n,vdome, c, cc,scalefactor,r,colors,cg,edges,cells,ToDome,cdome, edome, e, eg, radius},
e=TissueEdges[tissue]; 
c=TissueCells[tissue]; 
n=Length[c];

v=TissueVertices[tissue];

cc=Centroid[v[[VerticesOnBoundary[tissue]]]];

radius = "Radius"/.{opt}/.Options[ShowTissueOnDome]; 

v=(#-cc)&/@v;
If[radius>0,
scalefactor=radius,
scalefactor = Max[Norm/@v]
];  

scalefactor=(1/Sqrt[2])*scalefactor;
v=v/(scalefactor);
vdome = scalefactor*LambertPlaneToDome/@v; 

cells=CellVertexCoordinates[tissue];
ToDome[{x_,y_}]:=scalefactor*LambertPlaneToDome[({x,y}-cc)/scalefactor];
ToDome[listOfPairs_]:=ToDome/@listOfPairs;
cdome=ToDome/@cells;

colors = "CellStyle"/.{opt}/.Options[ShowTissueOnDome];
Which[
colors=== Automatic, 
r:=RandomReal[{0,.7}];
colors=Table[Hue[r],{n}];
,
True, 
colors=Flatten[{colors}]; 
If[Length[colors]==1, colors=PadRight[colors, n, First[colors]]]; 
If[Length[colors]<n,  colors=PadRight[colors, n, White]];
If[Length[colors]>n, colors = Take[colors, n]]; 
]; 
cg=MapThread[Graphics3D[{#1,Polygon[#2]}]&,{colors,cdome}];

n=Length[e]; 
colors = "EdgeStyle"/.{opt}/.Options[ShowTissueOnDome];
colors=Flatten[{colors}]; 
If[Length[colors]==1, colors=PadRight[colors, n, First[colors]]]; 
If[Length[colors]<n,  colors=PadRight[colors, n, Black]];
If[Length[colors]>n, colors = Take[colors, n]]; 
edome = Line/@(vdome[[#]]&/@e); 

eg=MapThread[Graphics3D[{#1,#2}]&,{colors,edome}];


With[{gopt=MyFilterOptions[Graphics3D,opt]}, 
Return[Show[cg,eg,  gopt]]
]
]


TissueQ[object_]:=TissueCheck[object, "Quiet"-> True]; 


TissueOrTorusQ[object_]:= Or[TissueQ[object], TorusQ[object]]


TissueCells[tissue_?TissueQ]:=argument[tissue][[3]]; 
TissueCells[torus_?TorusQ]:= TissueCells[TorusTissue[torus]]; 

TissueVertices[tissue_?TissueQ]:= argument[tissue][[1]]; 
TissueVertices[torus_?TorusQ]:= TissueVertices[TorusTissue[torus]]; 

TissueEdges[tissue_?TissueQ]:= argument[tissue][[2]]; 
TissueEdges[torus_?TorusQ]:= TissueEdges[TorusTissue[torus]]; 

NTissueCells[tissue_?TissueQ]:= Length[TissueCells[tissue]]; 
NTissueCells[torus_?TorusQ]:= NTissueCells[TorusTissue[torus]]; 

NTissueVertices[tissue_?TissueQ]:= Length[TissueVertices[tissue]];
NTissueVertices[torus_?TorusQ]:= NTissueVertices[TorusTissue[torus]]; 
 
NTissueEdges[tissue_?TissueQ]:= Length[TissueEdges[tissue]]; 
NTissueEdges[torus_?TorusQ]:= NTissueVertices[TorusTissue[torus]]; 



AdjacentVertices[g_Tissue,i_?IntegerQ]:= Module[{e,vb},
e=TissueEdges[g];
Complement[Union[Flatten[Select[e, MemberQ[#,i]&]]],{i}]
];
AdjacentVertices[x___]:= (Print["Expecting AdjacentVertices[Tisue, integer]"]; Abort[]); 


AdjacentBoundaryVertices[g_Tissue,i_?IntegerQ]:= Module[{e,vb,adj, bv},
e=TissueEdges[g];
bv =VerticesOnBoundary[g]; 
adj=Complement[Union[Flatten[Select[e, MemberQ[#,i]&]]],{i}];
Intersection[adj,bv]
];
AdjacentBoundaryVertices[x___]:= (Print["Expecting AdjacentBoundaryVertices[Tisue, integer]"]; Abort[]); 


VertexOutwardNormal[tis_Tissue, i_, mean_:False]:= Module[{bv, abv, v, P, edges, nvs, center, vc}, 
bv=VerticesOnBoundary[tis]; 
If[!MemberQ[bv,i], Return[{}]]; 
abv=AdjacentBoundaryVertices[tis,i];
v = TissueVertices[tis]; 
P=v[[i]]; 
edges = {P, v[[#]]}&/@abv; 
nvs ={#[[2]], -#[[1]]}&/@ ((#[[2]]-#[[1]])&/@edges);
center =TissueCentroid[tis];
vc=P-center;
nvs = If[vc.#<0, -#, #]&/@nvs;
nvs = Normalize/@nvs;
If[mean, nvs = Mean[nvs]]; 
nvs
]; 

VertexOutwardNormal[x___]:= (Print["Expecting VertexOutwardNormal[tissue, integer]"]; Abort[]); 


VerticesOnTop[g_Tissue]:= Module[{OK,v},
OK[i_]:= Or@@(({0,1}.#> Sqrt[2]/2)&/@VertexOutwardNormal[g,i] ); 
v=VerticesOnBoundary[g]; 
Pick[v, OK/@v]


];
VerticesOnBottom[g_Tissue]:= Module[{OK,v},
OK[i_]:= Or@@(({0,-1}.#> Sqrt[2]/2)&/@VertexOutwardNormal[g,i] ); 
v=VerticesOnBoundary[g]; 
Pick[v, OK/@v]
];
VerticesOnRight[g_Tissue]:= Module[{OK,v},
OK[i_]:= Or@@(({1,0}.#> Sqrt[2]/2)&/@VertexOutwardNormal[g,i] ); 
v=VerticesOnBoundary[g]; 
Pick[v, OK/@v]
];
VerticesOnLeft[g_Tissue]:= Module[{OK,v},
OK[i_]:= Or@@(({-1,0}.#> Sqrt[2]/2)&/@VertexOutwardNormal[g,i] ); 
v=VerticesOnBoundary[g]; 
Pick[v, OK/@v]
];


TissueCheck[Tissue[v_, e_, f_], opt___?OptionQ]:= Module[{ok, notok, num, ne, nv, nf, quiet, qPrint, passed, dangEdge},

quiet = "Quiet"/.{opt}/.{"Quiet"-> False}; 
qPrint[x___]:= If[!quiet, Print[x]]; 
passed = True; 

(* Check Vertices *)
If[ListQ[v], 
nv=Length[v]; 
qPrint[nv, " Vertices."]; 
If[nv<3, qPrint["TissueCheck: Error: There must be at least 3 vertices."]; 
passed=False; 
]; 
ok = numPairQ/@v;
num=Range[nv]; 
MapThread[
If[!#1,qPrint["TissueCheck: Error: Vertex ", #2," = ", #3, " is not a pair of numbers."]]&, 
{ok, num, v}]; 
If[\[Not](And@@ok), passed=False]; 
,
qPrint["TissueCheck: Error: First argument of tissue must be a list of vertex coordinates."];
passed=False; 
]; 

(* Check Edges *) 

If[ListQ[e], 
ne=Length[e]; 
qPrint[ne, " Edges."]; 
If[ne<3, qPrint["TissueCheck: Error: There must be at least 3 edges."]; 
passed=False; 

]; 
ok = intPairQ/@e;
num=Range[ne]; 
MapThread[
If[!#1,qPrint["TissueCheck: Error: Edge ", #2," = ", #3, " is not a pair of integers."]]&, 
{ok, num, e}]; 
If[\[Not](And@@ok), passed=False]; 

Block[{vnumok},
vnumok[x_]:= x>0 \[And] x<= nv; 
vnumok[{i_, j_}]:= vnumok[i] \[And] vnumok[j]; 
ok = vnumok/@e; 

MapThread[
If[!#1,qPrint["TissueCheck: Error: Edge ", #2," = ", #3, " refers to a non-existent vertex."]]&, 
{ok, num, e}]; 
If[\[Not](And@@ok), passed=False]; 
];
,
qPrint["TissueCheck: Error: second argument of tissue must be a list of edges ({i,j} pairs)."];
passed=False; 

]; 

(* Check Faces *)

If[ListQ[f], 
nf=Length[f]; 
qPrint[nf, " Faces."];
If[nf<1, 
qPrint["TissueCheck: Error: there must be at leaat one face."]; 
passed=False; 

]; 
ok = intListQ/@f; 
num=Range[nf]; 
MapThread[
If[!#1,qPrint["TissueCheck: Error: Face ", #2," = ", #3, " is not a list of integers."]]&, 
{ok, num, f}]; 
If[\[Not](And@@ok), passed=False]; 

Block[{enumok},
enumok[x_]:= x>0 \[And] x<= ne; 
enumok[{i__}]:=And@@(enumok/@{i}); 
 
ok = enumok/@f; 

MapThread[
If[!#1,qPrint["TissueCheck: Error: Cell ", #2," = ", #3, " refers to a non-existent edge."]]&, 
{ok, num, f}]; 
If[\[Not](And@@ok), passed=False]; 
];
,
qPrint["TissueCheck: Error: Third argument of tissue must be a list of faces (cells in 2D), each face as list of edge numbers"];
passed=False; 

]; 
Return[passed]; 
];
TissueCheck[x_, opt___?OptionQ]:=Module[{quiet, qPrint},
quiet = "Quiet"/.{opt}/.{"Quiet"-> False}; 
qPrint[v___]:= If[!quiet, Print[v]];
qPrint["TissueCheck: Error: Expecting Tissue[vertices, edges, faces]. Input does not appear to be a Tissue[...] object. "];

 False]; 


DanglingEdges[tissue_?TissueQ]:= Complement[Range[NTissueEdges[tissue]],Union[TissueCells[tissue]//Flatten]];


DanglingVertices[tissue_?TissueQ]:= Complement[Range[NTissueVertices[tissue]], Union[Flatten[TissueEdges[tissue]]]]


UndangleEdge[tissue_?TissueQ, number_]:= Module[{v,e,c, n, q, edgen}, 
v=TissueVertices[tissue];
e=TissueEdges[tissue]; 
c=TissueCells[tissue]; 
n=Length[e]; 
If[!MemberQ[DanglingEdges[tissue], number], 

(* If the edge is not Dangling use RemoveVertices *)

Return[MergeVertices[tissue, number]]


(* Old version - only allows removing dangling edges *)
(* 
Print["Error: UndangleEdge: edge ", number, " is not a dangling edge and cannot be removed."]; Return[tissue];
*)

]; 

(* if last edge, just make it go away *)

If[n==number, 
e=Most[e]; 
q=Tissue[v,e,c];
Return[q]; 
];

(* if not last edge, move edge n to old edge number place *)

edgen=Last[e]; 
e=ReplacePart[Most[e], number-> edgen]; 
c = c/.{n-> number}; 
q=Tissue[v,e,c];
Return[q]; 
];

UndangleEdge[x___]:= (Print["Error: Expecting UndangleEdge[tissue, number]"]; $Failed); 

RemoveEdge[x___]:= UndangleEdge[x]; 


UndangleEdges[tissue_?TissueQ]:= Module[{danglers, q}, 
danglers = DanglingEdges[tissue];
danglers = Reverse[Sort[danglers]]; 
q=tissue; 
While[Length[danglers]>0, 
q=UndangleEdge[q, First[danglers]]; 
danglers=Rest[danglers]; 
];
Return[q]; 
];
UndangleEdges[x___]:= (Print["Expecing UndangleEdges[tissue]"]; $Failed); 


UndangleVertex[tissue_?TissueQ, vNumber_?IntegerQ]:= Module[{dv, nv, ne, rule, i, e, c, v}, 

dv = DanglingVertices[tissue]; 
If[!MemberQ[dv, vNumber], Print["Error: UndangleVertex: Vertex: ", vNumber, " is not dangling and cannot be removed."]; Return[tissue]]; 

e=TissueEdges[tissue]; 
c=TissueCells[tissue]; 
v=TissueVertices[tissue]; 

nv = Length[v]; 

(* if its at the end, no need to renumber *)

If[vNumber==nv, v=Most[v]; Return[Tissue[v, e, c]]]; 

(* remove the vertex *)

v=Drop[v, {vNumber}]; 

ne = Length[e]; 

(* renumber all the vertex references for all the higher numberd vertices *)

For[i=vNumber, i<= nv, i++, 
rule = Rule[i, i-1]; 
e = e/.rule
]; 

Return[Tissue[v, e, c]]; 
];

UndangleVertex[x___]:= (Print["Expecting[UndangleVertex[tissue, vertexNumber]"]; $Failed); 

RemoveVertex[x___]:= UndangleVertex[x]; 


UndangleVertices[tissue_?TissueQ]:= Module[{dv, q}, 
dv = DanglingVertices[tissue]; 
dv = Reverse[Sort[dv]]; 
q=tissue;
While[Length[dv]>0,
q=UndangleVertex[q, First[dv]]; 
dv = Rest[dv]; 
]; 
Return[q];
]; 
UndangleVertices[x___]:= (Print["Expecting UndangleVertices[tissue]"]; $Failed); 


EdgeVertices[{i_, j_}, vertices_]:={vertices[[i]], vertices[[j]]};

EdgeVertices[{edge__?intPairQ}, vertices_]:= EdgeVertices[#, vertices]&/@{edge};

EdgeVertices[tissue_?TissueQ]:=EdgeVertices[TissueEdges[tissue], TissueVertices[tissue]]; 


EdgeLengths[tissue_?TissueQ]:= distance@@#&/@EdgeVertices[tissue];  
EdgeLength[tissue_?TissueQ, i_?IntegerQ]:= Module[{ne, el}, 
ne=NTissueEdges[tissue];
If[i>ne \[Or] i< 1, Print["Error: EdgeLength: edge ", i, " does not exist."]; Return[$Failed]]; 
 el = distance@@EdgeVertices[tissue][[i]];
Return[el]
];
EdgeLength[x___]:= (Print["Expecting EdgeLength[tissue, edgeNumber]"]; Abort[]); 
EdgeLengths[x___]:= (Print["Expecting EdgeLengths[tissue]"]; Abort[]); 
CellEdgeLengths[tissue_?TissueQ, cellNumber_?NumberQ]:=EdgeLength[tissue, #]&/@TissueCells[tissue] [[cellNumber]];
CellEdgeLengths[x___]:= (Print["Expecting CellEdgeLengths[tissue, cellNumber]"]; Abort[]);




SortCellsCounterClockwise[tis_Tissue]:=Module[{centroids, c,nc, e, s, v, clockwise, snew, i, vnext, enext},
centroids=Centroid[tis];
c=TissueCells[tis];
nc=Length[c]; 
e=TissueEdges[tis];
v=TissueVertices[tis]; 
s=SortCellEdges[c[[#]], e]&/@Range[nc];

clockwise[i_]:= Module[{v1,v2, \[Theta]1,\[Theta]2},
v1=v[[("Vertices"/.s[[i]])[[1]]]]-centroids[[i]];
v1=v1/Norm[v1];
v2=v[[("Vertices"/.s[[i]])[[2]]]]-centroids[[i]];
v2=v2/Norm[v2];

v1[[1]]v2[[2]]-v2[[1]]v1[[2]]<0
];
snew={}; 
For[i=1, i<= nc, i++,
If[clockwise[i],
vnext=RotateRight[Reverse["Vertices"/.s[[i]]],1];
enext =Reverse["Edges"/.s[[i]]];
AppendTo[snew, {"Edges"-> enext, "Vertices"-> vnext}]; 
,
AppendTo[snew, s[[i]]];
]; 
];
Return[snew]
];
SortCellsCounterClockwise[x_]:= (Print["Expecting SortCellsCounterClockwise[tissue]"]; Abort[]); 


SortCellEdges[cell_?intListQ, edges_]:= Module[{ep, num , sortedep, sortednums, edge, v2,p, index, vertices},
ep=edges[[#]]&/@cell;
ep = Sort/@ep;
edge=First[ep]; 
sortedep={edge};
index=1; 
sortednums={index};
num=Range[2, Length[cell]]; 

While[Length[sortednums]<Length[cell],
v2=edge[[2]]; 
p=Position[ep, v2];
p = Select[p, First[#]!= index&]; 
If[Length[p]<1, Print["Error: SortCellEdges: Cell ", cell, " is unsortable. Edge Pairs: ", ep]; Return[$Failed]];  
p=p[[1, 1]]; 
edge = ep[[p]]; 
If[edge[[1]]!= v2, edge=Reverse[edge]]; 
AppendTo[sortedep, edge]; 
AppendTo[sortednums, p]; 
index = p; 

(* Print[{sortedep, sortednums, v2, p, edge}]; *)
 
]; 
sortednums=cell[[sortednums]];

sortedep = First/@sortedep; 
Return[{"Edges"-> sortednums, 
"Vertices"-> sortedep
}]; 
 
]; 
SortCellEdges[x___]:= (Print["Expecting SortCellEdges[cell, edges], where cell={e1,e2,...} and edges={{v11,v12}, {v21, v22}, ...}"]; Abort[]); 


CellVertexNumbers[cell_?intListQ, edges_]:= Module[{f},
f=SortCellEdges[cell, edges]; 
If[f===$Failed, 
Print["Error: CellVertexNumbers: Failure code from SortCellEdges."]; 
Return[$Failed]]; 
Return["Vertices"/.f]
]; 

CellVertexNumbers[{cell__?intListQ}, edges_]:= CellVertexNumbers[#,edges]&/@{cell};
CellVertexNumbers[tissue_?TissueQ, cellNumber_]:= CellVertexNumbers[TissueCells[tissue][[cellNumber]], TissueEdges[tissue]]; 
CellVertexNumbers[tissue_?TissueQ]:= CellVertexNumbers[tissue, #]&/@Range[NTissueCells[tissue]]


CellVertexCoordinates[cell_?intListQ, edges_, vertices_]:= Module[{v},
v=CellVertexNumbers[cell, edges]; 
If[v===$Failed, Print["Error: CellVertexCoordinates: Failure code returned from CellVertexNumbers."]; Return[$Failed]]; 

v=vertices[[v]]; 
Return[v]; 
];
CellVertexCoordinates[tiss_?TissueQ, n_]:= Module[{v},
If[n>NTissueCells[tiss] \[Or] n<1, Print["Error: CellVertexCoordinates: nonexistent cell number ", n, " requested."]; Return[$Failed]]; 
v=CellVertexCoordinates[
TissueCells[tiss][[n]],
TissueEdges[tiss],
TissueVertices[tiss]
];
If[v===$Failed, Print["Error: CellVertexCoordinates: Failure code returned from CellVertexNumbers for cell ",n]; Return[$Failed]]; 
Return[v]; 
];
CellVertexCoordinates[tiss_?TissueQ]:= Module[
{v,e, c, n, cvc},
n=NTissueCells[tiss] ; 
v=TissueVertices[tiss];
e=TissueEdges[tiss]; 
c=TissueCells[tiss]; 
cvc = CellVertexCoordinates[#, e, v]&/@c; 
Return[cvc]
];




EdgesOnBoundary[tissue_?TissueQ]:= Module[{ne, c,e,  keep, edgenums},
e=TissueEdges[tissue];
ne=Length[e]; 
c=TissueCells[tissue];
edgenums=Range[ne];
keep =(Length[#]==1)&/@(Cases[c,#, 2]&/@edgenums);
keep=Pick[edgenums, keep]; 
(* Print[keep]; 
keep="Edges"/.SortCellEdges[keep, e]; 
*)
Return[keep]; 
]


EdgesNotOnBoundary[tissue_?TissueQ]:=Complement[Range[NTissueEdges[tissue]], EdgesOnBoundary[tissue]]


VerticesOnBoundary[tissue_?TissueQ]:= Module[{be, e},
be=EdgesOnBoundary[tissue]; 
e=TissueEdges[tissue]; 
Return[
(* Union[Flatten[e[[be]]]]*)
"Vertices"/.SortCellEdges[be, e]
];
]


VerticesNotOnBoundary[tissue_?TissueQ]:= Complement[Range[NTissueVertices[tissue]], VerticesOnBoundary[tissue]]; 


CellsOnBoundary[tissue_?TissueQ]:= Module[{be, c, keep},
be=EdgesOnBoundary[tissue];
c=TissueCells[tissue];
keep = (Length[#]>0)&/@(Intersection[be, #]&/@c);
Return[Pick[Range[Length[c]], keep]]; 
]; 
CellsOnBoudary[x___]:= (Print["Expecting CellsOnBoundary[tissue]"];Abort[]); 


InteriorCells[tissue_?TissueQ]:= Module[{nc,bc,ic},
bc=CellsOnBoundary[tissue];
nc=NTissueCells[tissue];
Return[Complement[Range[nc], bc]]
];
InteriorCells[x___]:=(Print["Expecting InteriorCells[tissue]"];Abort[]);


DivideEdges[tissue_?TissueQ, edgeNumbers_?intListQ,
segments_?IntegerQ, randomness_:0]:= Module[
{edges2divide, next, new},

edges2divide=edgeNumbers;
new=tissue; 
While[Length[edges2divide]>0,
next=First[edges2divide]; 
edges2divide=Rest[edges2divide]; 
new = DivideEdge[new, next, segments, randomness];
]; 
Return[new]; 
];

DivideEdges[tissue_?TissueQ,segments_?IntegerQ, randomness_:0]:= Module[{n}, 
n=NTissueEdges[tissue]; 
Return[DivideEdges[tissue,  Range[n], segments, randomness]]]; 

DivideEdges[x___]:= (Print["Error: expecting DivideEdges[tissue, segments, random] or DivideEdges[tissue, {n1,n2, ...}, segments, random]"]; $Failed); 


DivideEdge[tissue_?TissueQ, edgeNumber_?IntegerQ,
parts_?IntegerQ, random_:0]:= Module[{r, e, ne,nv, i, j,v, c,  vi, vj, dbg=False, dPrint, vnew, newEdgeNumbers, newEdges, length, randoms, q},

dPrint[x___]:= If[dbg, Print[x]]; 

(* limit randomization to 25% *) 
r=Min[Max[0, random], .25]; 
If[r!= random, Print["Warning: DivideEdge: random must be in [0,.25]; value used:  ", r]]; 

(* check validity of input *)

e=TissueEdges[tissue]; 
ne = Length[e]; 
If[edgeNumber<1 \[Or] edgeNumber > ne, Print["Error: DivideEdge: nonexistent edge ", edgeNumber," requested. Must be between 1 and ", ne]; Return[tissue]]; 

If[parts<2, Return[tissue]]; 

(* input is all valid *)

{i, j} = e[[edgeNumber]];
v=TissueVertices[tissue]; 
nv=Length[v]; 
{vi,vj}={v[[i]], v[[j]]}; 

vnew = (vi + (1.0*#/parts)(vj-vi))&/@Range[1, parts-1]; 

(* and randomness *) 
length = distance[vi,vj]*(1.0/parts); 
randoms = length*Table[{RandomReal[{-r,r}], RandomReal[{-r,r}]}, {parts-1}];
vnew = vnew+randoms; 

v=Join[v, vnew];

newEdgeNumbers=Range[ne+1, ne+parts]; 
newEdges=Transpose[{
Flatten[{i, Range[nv+1, nv+parts-1]}],
Flatten[{Range[nv+1, nv+parts-1], j}]
}];
e=Join[e, newEdges]; 

c=Flatten/@(TissueCells[tissue]/.{edgeNumber-> newEdgeNumbers}) ;
c=("Edges"/.#)&/@(SortCellEdges[#, e]&/@c);

dPrint["{i,j}: ", {i,j}, "\n{vi,vj}:", {vi,vj}, 
"\nrandoms:", randoms,"\nvnew=", vnew, "\nv (revised):", v, "\nnewEdgeNumbers:", newEdgeNumbers,"\nnewEdges:", newEdges, "\ne (revised):", e, "\nc (revised):", c]; 

q=Tissue[v,e,c]; 

dPrint["Undangling old edge ", edgeNumber]; 
q=UndangleEdge[q, edgeNumber]; 

Print["Warning: Edge ", #, " is dangling and should be removed."]&/@DanglingEdges[q]; 

Return[q]; 
];



DivideEdge[tissue_?TissueQ, edgeNumber_?IntegerQ,  {x_?NumericQ, y_?NumericQ}]:= Module[{v,e,c,ne, v1, v2,e1, e2,  nv, q}, 
e=TissueEdges[tissue];
ne=Length[e]; 
If[edgeNumber>ne \[Or] edgeNumber<1, 
Print["Error: DivideEdge: requested edge ", edgeNumber," does not exist."]; 
Return[tissue];
];

(* add the new vertex *)

v=TissueVertices[tissue];
AppendTo[v, {x,y}]; 
nv = Length[v];

c=TissueCells[tissue]; 

(* add new edge at end, and replace old edge *)
(* (v1,v2) --> (v1, ne) + (ne, v2) *)
(* need to keep each edge sorted with v1 < v2 *)

{v1, v2} = e[[edgeNumber]];
e1={v1, nv};
e2={v2, nv}; 
e=ReplacePart[e, edgeNumber-> e1]; 
AppendTo[e, e2]; 

(* fix cells *)
c = c/.{edgeNumber-> Sequence@@{edgeNumber, ne+1}};

q=Tissue[v,e,c];
Return[q];
];


DivideEdge[x___]:= (Print["Error: Expecting DivideEdge[tissue, edge number, parts, random] or \nDivideEdge[tissue, edge number, {x,y}]\ninstead of \n",{x}]; $Failed); 


MergeEdges[tissue_?TissueQ, e1_?IntegerQ, e2_?IntegerQ, opt___?OptionQ]:= Module[{v,e,c, tnew, edge1, edge2,ne, vcommon, v1, v2, enew, cnew, cchanged, cnum, csorted, cunsorted, undangle},
v=TissueVertices[tissue]; 
e=TissueEdges[tissue];
ne = Length[e]; 
If[e1>ne \[Or] e1<1 \[Or]e2>ne \[Or]e2<1, Print["Error: MergeEdges: edge numbers must be between 1 and ", ne, " requested values are ", e1, ",",e2]; Return[$Failed];
]; 

edge1=e[[e1]];
edge2=e[[e2]]; 
vcommon = Intersection[edge1,edge2]; 
If[Length[vcommon]<1, 
Print["Error: MergeEdges: edges ", e1, " = ", edge1, " and ", e2, " = ", edge2, " do not share a common vertex."];
Return[$Failed]; 
]; 

v1 = Complement[edge1, vcommon][[1]]; 
v2= Complement[edge2, vcommon][[1]]; 
vcommon = First[vcommon]; 

enew = Sort[{v1, v2}]; 
AppendTo[e, enew]; 
ne = ne+1; 

c=TissueCells[tissue]; 
cnew = c/.{e1-> ne, e2-> ne}; 

cchanged = Pick[Range[Length[c]],
MapThread[#1!= #2&,{c,cnew}]
];  
While[Length[cchanged]>0,
cnum = First[cchanged]; 
cchanged=Rest[cchanged];
cunsorted = Union[cnew[[cnum]]]; 
 
csorted = "Edges"/.SortCellEdges[cunsorted, e]; 
cnew = ReplacePart[cnew, cnum-> csorted]; 
]; 

tnew = Tissue[v,e,cnew]; 

undangle = "Undangle"/.{opt}/.{"Undangle"-> True}; 
If[undangle,
tnew = UndangleEdges[tnew]; 
tnew = UndangleVertices[tnew]; 
]; 
Return[tnew];
]; 
MergeEdges[x___]:= (Print["Error: Expecting MergeEdges[tissue, e1, e2]"]; $Failed); 


MergeVertices[tissue_Tissue, edge_Integer, opt___?OptionQ]:= Module[{v,e,c,ne, v1, v2, keep, chuck, enew, cnew,vnew,vkeep, tnew, edgeChanges},
c=TissueCells[tissue];
e=TissueEdges[tissue];
v=TissueVertices[tissue]; 
ne=Length[e]; 
If[edge>ne \[Or] edge <1, Print["Error: MergeVertices: Edge ", edge, " does not exist." ]; Return[tissue]]; 
{v1,v2}=e[[edge]];
keep=Min[v1,v2];
chuck=Max[v1,v2]; 
vkeep=0.5(v[[keep]]+v[[chuck]]); 
vnew = ReplacePart[v, keep-> vkeep]; 
enew = e/.{chuck-> keep};
cnew = c/.{edge-> {}};
cnew=Flatten/@cnew; 
tnew= Tissue[vnew, enew, cnew];
tnew = RemoveEdge[tnew, edge];
tnew=UndangleVertices[tnew];

If["Changes"/.{opt}/.{"Changes"-> False}, 
If[edge<ne, edgeChanges={ne-> edge}, edgeChanges={ne-> {}}]; 
AppendTo[edgeChanges, edge-> {}]; 
Return[{Union[edgeChanges], tnew}];
]; 
Return[tnew];
]; 
MergeVertices[tissue_Tissue, {v1_Integer, v2_Integer}, opt___?OptionQ]:= Module[{i},
e=Sort/@TissueEdges[tissue]; 
i=Position[e, Sort[{v1,v2}]];

If[Length[i]<1, Print["Error: MergeVertices: Edge ", {v1,v2}, " not found."]; 
If["Changes"/.{opt}/.{"Changes"-> False}, 
Return[{{}, tissue}], 
Return[tissue]]]; 
If[Length[i]>1, Print["Error: MergeVertices: Edge ", {v1, v2}, " found in multiple locations in tissue. Check tissue for errors."]; Abort[]]; 
i=First[Flatten[i]]; 
Print[i]; 
MergeVertices[tissue, i, opt]]; 
MergeVertices[x___]:= (Print["Expecting MergeVertices[tissue, {v1,v2}] or MergeVertices[tissue, edgeNumber.]"]; Abort[]); 


DivideCell[tiss_?TissueQ, j_?IntegerQ, {p1in_?NumericPointQ, p2in_?NumericPointQ}, opt___?OptionQ]:= Module[{dbg, dPrint, c,v,e, nv, ne, nc, cvc, intersections, ce1,ce2, e1,e2, v1, v2, enew, e1val, e2val, e1new, e2new,ne1, ne2,  ne1new, ne2new, cold, cnew, coldvn, cnewvn, Sorted, p1, p2, edgechanges, cj},
Sorted[{x_,y_}]:= x<=y; 
 
p1=p1in; p2=p2in;

dbg = "Debug"/.{opt}/.{"Debug"-> False}; 
dPrint[x___]:= If[dbg, Print["DivideCell: ", x]]; 

dPrint["points: ", {p1, p2}]; 

c=TissueCells[tiss];
v=TissueVertices[tiss]; 
e=TissueEdges[tiss]; 

(* Sort pairs so that indices are {smaller, larger} 
   bug fix 2.1.a.20 *)
e=Sort/@e;
dPrint["Sorted: ", And@@(Sorted/@e)];
nc=Length[c];
nv=Length[v];
ne=Length[e]; 

dPrint["c[[j]]:", c[[j]]]; 

(* If c[[j]] is not sorted then Cell Vertex Coordinates might return the vertices in backwards order *)
cj="Edges"/.SortCellEdges[c[[j]], e];
dPrint["cj sorted:", cj]; 
c=ReplacePart[c, j-> cj]; 
dPrint["c[[j]]:", c[[j]]]; 


cvc = CellVertexCoordinates[tiss,j]; 
dPrint["cvc: ", cvc]; 

intersections = PolygonIntersection[{p1,p2}, cvc]; 
dPrint["intersections: ", intersections];

Block[{V,  iteration, theta, k, p2new},
iteration=1; 
p2new=p2; 
k=1; 
While[Length[intersections]>2, Print["Warning: DivideCell: Existing Vertex or non-convex cell."];
If[iteration++>5, Abort[]]; 
Print["Attempting Recovery, rotating line of division by ", k, " degrees"]; 
theta = (k*Pi/180.0); 
(* move each end point a little bit 
   perpendicular to line *)
V=p2-p1;
p2new = p1+RotationMatrix[theta].V;

intersections = PolygonIntersection[{p1,p2new}, cvc];
k=(k+1); 
]; 
p2=p2new;
];




{{ce1, v1}, {ce2, v2}}=intersections; 

(* add in the new vertices and determine their vertex numbers *)
(* first use v1,v2 as coordinates; then as vertex numbers *)
AppendTo[v, v1]; 
AppendTo[v, v2]; 
v1=nv+1;
v2=nv+2; 
dPrint["New Vertices are ",v1,",",v2]; 

(* add in the new edge for the dividing line *)
(* first use enew as an edge, then as an edge number *)

enew = {v1,v2}; 
AppendTo[e,Sort[enew]]; 
enew = ne+1; 
dPrint["Sorted: ", And@@(Sorted/@e)];

(* modify the old edges *)
(* ne1, ne2 are edges numbers of the two split edges *)
(* e1val, e2val are the vertex numbers (before splitting *)
ne1 = c[[j,ce1]];
ne2 = c[[j, ce2]]; 
e1val = e[[ne1]]; 
e2val = e[[ne2]]; 
dPrint["{ne1,ne2}:", {ne1, ne2}]; 
dPrint["(e1val, e2val}: ", {e1val, e2val}]; 

(* e1 becomes e1+e1new, e2 becomes e2+e2new *)
(* define the new edges and add them in *)

e1={e1val[[1]], v1}//Sort; 
e1new = {v1, e1val[[2]]}//Sort;
AppendTo[e, e1new]; 
ne1new = ne+2; 
dPrint["(edge ", ne1,") e1\[Rule]", e1, " e1new\[Rule]", e1new, " (edge ", ne1new,")"]; 


e2 = {e2val[[1]] ,v2}//Sort; 
e2new = {v2, e2val[[2]]}//Sort; 
AppendTo[e ,e2new]; 
ne2new = ne+3; 
dPrint["(edge ", ne2,") e2\[Rule]", e2, " e2new\[Rule]", e2new, " (edge ", ne2new, ")"]; 



(* distribute the edges in the daughter cells *)
(* make sure edges are sorted or this won't work! *)

cold =SortCellEdges[ c[[j]], e]; 

(* list of old cell as vertex numbers *)
coldvn = e[[c[[j]]]]; 
(* replace each split edge with new pair of daughter edges *)
cnewvn= coldvn/.{e1val-> Sequence[e1,e1new], e2val-> Sequence[e2, e2new]};

dPrint["cold: ", cold];
dPrint["coldvn: ", coldvn]; 
dPrint["cnewvn: ", cnewvn]; 

(* replace the original edges with their "first" half *)
e=ReplacePart[e, ne1-> e1]; 
e=ReplacePart[e, ne2-> e2]; 


Block[{vn, vxy, vec, vecs, angles, angle1, angle2, cell1, cell2, pe1, pe2}, 
(* determine which vertices go with which cell *)

vn=Union[Flatten[coldvn]];
vxy = v[[vn]];  
vec=p2-p1; 
vecs = (#-p1)&/@vxy; 
angles = Mod[ArcTan@@#&/@vecs, 2Pi]; 
angle1=Mod[ArcTan@@vec, 2Pi];
angle2=Mod[Pi+angle1, 2Pi]; 
{angle1,angle2}=Sort[{angle1,angle2}]; 
cell1=(angle1<= # \[And] #<= angle2)&/@angles;
cell2=Not/@cell1;  
cell1 = Pick[vn, cell1]; 
cell2=Pick[vn, cell2]; 

dPrint["vn:", vn];
dPrint["vxy:", vxy];
dPrint["vecs: ", vecs]; 
dPrint["angles: ", angles]; 
dPrint["angle1,2: ", {angle1, angle2}]; 
dPrint["cell1: ", cell1]; 
dPrint["cell2: ", cell2]; 


(* now figure which edges *)
(* position in the list of vertex pairs *)
cell1 = Union[Flatten[First/@Position[cnewvn, #]&/@cell1]];
cell2=  Union[Flatten[First/@Position[cnewvn, #]&/@cell2]];

cell1=Sort/@Append[cnewvn[[cell1]], {v1,v2}]; 
cell2= Sort/@Append[cnewvn[[cell2]], {v1,v2}];

dPrint["cell1: ", cell1]; 
dPrint["cell2: ", cell2]; 

cell1=Flatten[Position[e, #]&/@cell1];
cell2=Flatten[Position[e,#]&/@cell2]; 

dPrint["cell1 Flattened Positions: ", cell1]; 
dPrint["cell2 Flattened Positions: ", cell2]; 

cell1=SortCellEdges[cell1, e]; 
If[SameQ[cell1, $Failed], Print["Error Exit: DivideCell."]; Return[$Failed]]; 
cell1="Edges"/.cell1; 

cell2=SortCellEdges[cell2, e]; 
If[SameQ[cell2, $Failed],Print["Error Exit: DivideCell"];  Return[$Failed]]; 
cell2 = "Edges"/.cell2; 

dPrint["cell1: ", cell1]; 
dPrint["cell2: ", cell2]; 

(* put in the new cells *)

c=ReplacePart[c, j-> cell1]; 
AppendTo[c, cell2];

(* check to see if either edge is part of any other cell! *)

pe1=Complement[First/@Position[c, ne1], {j,nc+1}]; 
pe2=Complement[First/@Position[c, ne2], {j, nc+1}]; 
dPrint["pe1,pe2:", {pe1, pe2}]; 

If[Length[pe1]>0, 
pe1=First[pe1]; 
cell1 = c[[pe1]]/.{ne1-> Sequence[ne1, ne1new]}; 
cell1 ="Edges"/.SortCellEdges[cell1, e]; 
dPrint["bordering cell1: ", cell1]; 
c=ReplacePart[c, {pe1-> cell1}]; 
]; 

If[Length[pe2]>0,
pe2=First[pe2];  
cell2=  c[[pe2]]/.{ ne2-> Sequence[ne2, ne2new]}; 
cell2="Edges"/.SortCellEdges[cell2, e];
dPrint["bordering cell2: ", cell2]; 
c=ReplacePart[c, {pe2-> cell2}]; 

]; 


];

edgechanges={{}-> enew, ne1-> {ne1, ne1new}, ne2-> {ne2, ne2new}};
dPrint["edgeChanges:", edgechanges]; 

If["Changes"/.{opt}/.{"Changes"-> False}, 
Return[{edgechanges, Tissue[v,e,c]}], 

Return[Tissue[v,e,c]]; 
]; 

]; 

DivideCell[x___]:= (Print["Error: Expecting DivideCell[tissue, cell-number, {point1,point2}]"]; $Failed); 


RemoveCell[tissue_?TissueQ, cellNumber_?IntegerQ]:= Module[{nc, c, v, e, q},
v=TissueVertices[tissue]; 
e=TissueEdges[tissue]; 
c=TissueCells[tissue]; 
nc=Length[c]; 
If[cellNumber> nc \[Or] cellNumber < 1, Print["Error: RemoveCell: Cell ", cellNumber, " does not exist and cannot be removed."]; 
Return[tissue]]; 
c=Drop[c, {cellNumber}]; 
q = Tissue[v, e, c]; 
q=UndangleEdges[q]; 
q=UndangleVertices[q]; 
Return[q]; 
] ;


RemoveCell[tissue_?TissueQ, {cellNumber__?IntegerQ}]:= Module[{nc, c, v, e, q, keep, remove},
v=TissueVertices[tissue]; 
e=TissueEdges[tissue]; 
c=TissueCells[tissue]; 
nc=Length[c]; 
If[#> nc \[Or] # < 1, Print["Error: RemoveCell: Cell ", cellNumber, " does not exist and cannot be removed."]]&/@{cellNumber};

(* pick out which cells to remove *)

remove = Select[{cellNumber}, (#>0 \[And] #<= nc)&]; 
keep = Table[True, {nc}]; 
While[Length[remove]>0,
keep[[First[remove]]]=False;  
remove=Rest[remove];
];

c=Pick[c, keep]; 

q = Tissue[v, e, c]; 
q=UndangleEdges[q]; 
q=UndangleVertices[q]; 
Return[q]; 
] ;

RemoveCell[x___]:=(Print["Expecting RemoveCell[tissue, cellNumber]"]; $Failed); 


AddVertex[tissue_?TissueQ, {x_?NumericQ, y_?NumericQ}]:= Module[{v,e,c, q},
v=Append[TissueVertices[tissue], {x,y}];
e=TissueEdges[tissue];
c=TissueCells[tissue]; 
Return[Tissue[v,e,c]]; 
];
AddVertex[x___]:= (Print["Expecting AddVertex[Tissue, {number, number}]"]; Return[$Failed]); 


AddEdge[tissue_?TissueQ, {i_?IntegerQ, j_?IntegerQ}]:= Module[{v,e,c, nv, q, failed},
v=TissueVertices[tissue];
nv=Length[v]; 
failed=False; 
If[#<1 \[Or] #>nv, 
Print["Error: AddEdge: Vertex ", #, " does not exist."]; failed=True]&/@{i,j};
If[failed, Return[$Failed]]; 
e=Append[TissueEdges[tissue], {i,j}];
c=TissueCells[tissue]; 
q=Tissue[v,e,c];
Return[q]; 
];
AddEdge[x___]:= (Print["Expecting AddEdge[Tissue, {int, int}]"]; Return[$Failed]); 


AddCell[tissue_?TissueQ, {i_?IntegerQ, j_?IntegerQ, k__?IntegerQ}]:= Module[{v,e,c,ne, q, failed},
v=TissueVertices[tissue];
e=TissueEdges[tissue]; 
ne=Length[e]; 
c=TissueCells[tissue]; 
failed=False; 
If[#<1 \[Or] #>ne, 
Print["Error: AddCell: Edge ", #, " does not exist."]; failed=True]&/@{i,j, k};
If[failed, Return[$Failed]]; 
c=Append[c, {i,j,k}]; 
q=Tissue[v,e,c];
Return[q]; 

]; 


EntangledVertices[tissue_?TissueQ]:= Module[
{e,v, entangled, entanglements, unresolved, rv, nv, ne},
e=TissueEdges[tissue];
ne=Length[e]; 
v=TissueVertices[tissue]; 
nv=Length[v]; 
rv=Range[nv]; 

(* entanglement[e, v] returns True/Fals if v falls on edge *)

entangled[edgeNumber_, vertexNumber_]:= 
PointOnLineSegment[v[[e[[edgeNumber]]]], v[[vertexNumber]]];

(* entanglements[e] returns a list of the points that fall on edge e *)
entanglements[edgeNumber_]:=Pick[rv,entangled[edgeNumber, #]&/@rv];

(* unresolved[e] returns a list of vertices that fall on edge e but are not endpoints of e *)

unresolved[edgeNumber_]:= Complement[entanglements[edgeNumber], e[[edgeNumber]]]; 

unresolved/@Range[ne]
]


DisentangleVertices[tissue_?TissueQ]:= Module[{ ev, v, dbg=False, dPrint, e, ne, c, nc, entangled, rules, tnew},
dPrint[x___]:= If[dbg, Print[x]];  
v= TissueVertices[tissue]; 

e=TissueEdges[tissue];
e=Sort/@e; 
 
ne=Length[e]; 

c=TissueCells[tissue]; 
nc = Length[c]; 

ev=EntangledVertices[tissue];

entangled = (Length[#]>0)&/@ev; 
ev=Pick[ev, entangled]; 
entangled=Pick[Range[ne], entangled]; 

(* just fix the first one in each case; if there are multiple, come back and fix it on a recursive call *)

dPrint["ev: ", ev, " entangled: ", entangled];
MapThread[dPrint["edge ",#1, " is entangled by vertices ", #2]&, {entangled, ev}]; 

If[Length[ev]<1, 
dPrint["There are no entanglements remaining."]; 
Return[tissue]]; 

(* ... code to fix the first entanglements *)
Block[{edges, vertices, nextedge, nextvertex, nextvertices, p, q, new, new1, new2, pnew1, pnew2, ep, eq}, 
edges=entangled; 
vertices = ev; 
rules = {}; 

(* Loop through all problem edges *) 
While[Length[edges]>0,
nextedge = First[edges]; 
edges = Rest[edges]; 
nextvertices=First[vertices]; 
vertices=Rest[vertices];

(* Loop through all problem vertices on all problem edges *)

While[Length[nextvertices]>0,
nextvertex = First[nextvertices]; 
nextvertices=Rest[nextvertices];
{p, q} = e[[nextedge]];  
dPrint["Fixing edge ", nextedge," = ", {p, q},  " vertex ", nextvertex]; 
new =Sort/@( {nextvertex, #}&/@{p,q}); 
{new1, new2}=new; 
pnew1=Position[e,new1];
pnew2=Position[e, new2]; 

dPrint[".. new: ", new, " curently at positions ", pnew1, " and ", pnew2]; 

If[Length[pnew1]<1, 
e = Append[e, new1];
ep=Length[e]; ,
ep = pnew1[[1,1]]
]; 
If[Length[pnew2]<1, 
e = Append[e, new2];
eq=Length[e]; , 
eq  = pnew2[[1,1]];
]; 
AppendTo[rules, (nextedge-> {ep, eq})]; 
dPrint["rules: ", rules]; 

];  (*  End whlie Length[nextvertices] *)
True; 
];  (* End while Length[edges]>0*)
True; 
]; (* end Block *)

c= c/.rules; 
c= Flatten/@c; 

tnew = Tissue[v, e, c]; 
tnew = UndangleEdges[tnew]; 

Return[tnew]; 

]; 


SmootheCell[tissue_?TissueQ, cellNumber_?IntegerQ]:= 
SmootheCells[tissue, {cellNumber}]; 
SmootheCell[x___]:= (Print["Error: expecting SmootheCell[tissue, integer]"]; $Failed); 


SmootheCells[tissue_?TissueQ, {cellNumbers___?IntegerQ}]:= Module[{c,v,e, nc, ne, bc,be,  cell,edges,  dbg=False, dPrint, newEdge, newCell, vertices, sortedEdgeNumbers, newTissue, cn}, 
dPrint[x___]:= If[dbg, Print["SmoothCell: ", x]]; 

cn={cellNumbers}; 
If[Length[cn]==0, Return[tissue]]; 

newTissue=tissue; 

While[Length[cn]>0, 
cellNumber=First[cn];
cn=Rest[cn]; 

c=TissueCells[newTissue]; 
nc=Length[c];
e=TissueEdges[newTissue]; 
v=TissueVertices[newTissue]; 

(* test for existing cell *)

If[cellNumber<1 \[Or] cellNumber>nc,
Print["Error: SmoothCell: Cell ", cellNumber, " does not exist."]; 
Return[$Failed]; 
];  

(* test for smoothable cell *)
bc = CellsOnBoundary[newTissue]; 
If[!MemberQ[bc, cellNumber], Print["Error: SmoothCell: Cell ", cellNumber, " is not on the boundary."]; 
Return[$Failed]]; 

be=EdgesOnBoundary[newTissue]; 

cell = c[[cellNumber]]; 
cell = Intersection[cell, be]; 
dPrint["edges on the boundary in cell ", cellNumber, ": ", cell]; 

edges = e[[cell]]; 
dPrint["edge Vertex numbers in cell ", cellNumber, ": ", edges];

Block[{verticesInCellOnBoundary, keepers, uniqueVertices}, 
verticesInCellOnBoundary=Flatten[edges]; 
uniqueVertices=Union[verticesInCellOnBoundary];  
keepers = (Length[Position[verticesInCellOnBoundary, #]]<2)&/@uniqueVertices; 
newEdge = Pick[uniqueVertices, keepers]; 
newEdge=Sort[newEdge]; 
dPrint["vertices on new Edge: ", newEdge]; 
]; 

(* add the new edge *)

e=Append[e, newEdge]; 
ne=Length[e]; 

newCell = Append[Complement[c[[cellNumber]], cell], ne]; 
vertices = e[[newCell]]; 


dPrint["Edges in revised cell ", cellNumber,":", newCell]; 
dPrint["Vertices in revised cell ", cellNumber, ":", vertices]; 

sortedEdgeNumbers="Edges"/.SortCellEdges[Range[Length[newCell]], vertices]; 
sortedEdgeNumbers=newCell[[sortedEdgeNumbers]]; 


dPrint["Sorted Edge numbers in revised cell ", cellNumber, ":", sortedEdgeNumbers]; 

(* modify the cell *)
c=ReplacePart[c, cellNumber-> sortedEdgeNumbers]; 


newTissue=Tissue[v,e,c]; 
];

newTissue=UndangleEdges[newTissue]; 
newTissue=UndangleVertices[newTissue]; (* added 2.1.\[Alpha].20 *)

Return[newTissue]; 
];

SmootheCells[tissue_?TissueQ]:= SmootheCells[tissue, CellsOnBoundary[tissue]]; 

SmootheCells[x___]:= (Print["Error: expecting SmootheCells[tissue, {integer, integer, ...}]"]; $Failed); 


ConnectionList[tissue_?TissueQ, opt___?OptionQ]:= Module[{c, clist, n, i, cell1, connections, cellnums, ut},
c=TissueCells[tissue];
clist={}; 
n=Length[c]; 
cellnums = Range[n]; 
For[i=1, i<= n, i++,
cell1=c[[i]]; 
connections=(Length[Intersection[cell1,#]]>0)&/@c;
connections=Pick[cellnums, connections]; 
connections=Complement[connections, {i}]; 
connections = {i,#}&/@connections; 
clist = Join[clist, connections]; 
]; 
clist=Sort[clist]; 
ut="UpperTriangular"/.{opt}/.{"UpperTriangular"-> False}; 
If[ut, clist = Select[clist, (#[[2]]>#[[1]])&]]; 
Return[clist]; 
]; 

ConnectionMatrix[tissue_?TissueQ, opt___?OptionQ]:= 
SparseArray[(#-> 1)&/@ConnectionList[tissue, opt]]; 
(*
Module[{clist, n, mat, i, p, q},
clist=ConnectionList[tissue,opt];
 n=NTissueCells[tissue]; 
mat=ConstantArray[0, {n,n}]; 
While[Length[clist]>0,
{p,q}=First[clist]; 
clist=Rest[clist]; 
mat[[p,q]]=1
]; 
Return[SparseArray[mat]]; 
];
*)


ConnectionList[torus_?TorusQ, opt___?OptionQ]:= Module[{c, clist, tissue, rules, incell, r, ut},
tissue = TorusTissue[torus]; 
c=TissueCells[tissue];
(* basic connection list *)
clist = ConnectionList[tissue, opt]; 

(* include also toroidal connections *)
rules = TorusRules[torus];

InCell[Rule[a_,b_]]:= {Position[c,a][[1,1]], Position[c,b][[1,1]]};
r=InCell/@rules; 
r=Sort[Join[r, Reverse/@r]];

clist = Join[clist, r];
clist = Sort[clist]; 

ut="UpperTriangular"/.{opt}/.{"UpperTriangular"-> False}; 
If[ut, clist = Select[clist, (#[[2]]>#[[1]])&]]; 


Return[clist]; 
]; 


ConnectionMatrix[torus_?TorusQ, opt___?OptionQ]:= 
SparseArray[(#-> 1)&/@ConnectionList[torus, opt]]; 
(*
Module[{clist, n, mat, i, p, q},
clist=ConnectionList[torus,opt];
 n=NTissueCells[TorusTissue[torus]]; 
mat=ConstantArray[0, {n,n}]; 
While[Length[clist]>0,
{p,q}=First[clist]; 
clist=Rest[clist]; 
mat[[p,q]]=1
]; 
Return[SparseArray[mat]]; 
];
*)


ConnectionList[x___]:= (Print["Error: Expecting ConnectionList[tissue]."]; $Failed); ConnectionMatrix[x___]:= (Print["Error: Expecting ConnectionMatrix[tissue]."]; $Failed); 


InLineVertices[tissue_?TissueQ, opt___?OptionQ]:= Module[{dbg, dPrint,v,e, nv,vn, VerticesInEdge, vie, candidates, removable, inline, vertices, ok},

dbg="Debug"/.{opt}/.{"Debug"-> False}; 
dPrint[x___]:= If[dbg, Print["InLineVertices: ", x]]; 

vertices = "Vertices"/.{opt}/."Vertices"-> "All"; 

v=TissueVertices[tissue];
e=TissueEdges[tissue]; 
nv=Length[v]; 
vn=Range[nv];

If[Not[vertices=== "All"],
ok = ListQ[vertices] \[And] And@@(IntegerQ/@vertices);
If[ok, ok = ok \[And]And@@( (((#>= 0)\[And](#<= nv))&/@vertices))]; 
If[!ok, Print["Error: InLineVertices: Invalid \"Vertices\"=", vertices]; Return[$Failed]]; 
vn=vertices;
]; 

(* find vertices that topologically connect precisely two edges *)

VerticesInEdge[vertexNumber_]:= First/@Position[e,vertexNumber];
vie = VerticesInEdge/@vn;
vie = Transpose[{vn,vie}]; 
candidates=Select[vie, (Length[#[[2]]]==2)&];
dPrint["candidates: ", candidates];

removable[vnum_, {e1_,e2_}]:= Module[{v1,v2, edge1, edge2, onSeg },
edge1=e[[e1]];
edge2=e[[e2]]; 

v1=Complement[edge1, {vnum}][[1]]; 
v2=Complement[edge2, {vnum}][[1]]; 

onSeg = PointOnLineSegment[{v[[v1]], v[[v2]]}, v[[vnum]]];

dPrint["{v, v1, v2, onSeg}:", {vnum, v1,v2, onSeg}]; 
Return[onSeg]; 
];

inline=removable@@#&/@candidates;
(*candidates=First/@candidates;*)  
inline = Pick[candidates, inline]; 
Return[inline]; 
];
InLineVertices[x___]:=(Print["Error: Expecting InLineVertices[tissue]."];Return[$Failed];)


VertexNeighbors[tis_Tissue, n_]:=
Complement[Flatten[Select[TissueEdges[tis],MemberQ[#,n]&]],{n}];
VertexNeighbors[tis_Tissue]:= Module[{n},
n=NTissueVertices[tis];
VertexNeighbors[tis,#]&/@Range[n]
]; 
VertexNeighbors[x___]:= (Print["Expecting VertexNeighbors[tissue, integer]"]; Abort[]); 


CellNeighbors[tis_?TissueQ, p_?IntegerQ]:= Module[{rv, n}, 
n=NTissueCells[tis]; 
If[p>n \[Or] p<1, 
Print["Error: CellNeighbors: Requested Cell Number ", p, " does not exist. "];
Return[$Failed]; 
];
rv=Complement[Union[Flatten[Select[ConnectionList[tis], MemberQ[#, p]&]]], {p}];
Return[rv]
]; 
CellNeighbors[tis_?TorusQ, p_?IntegerQ]:= Module[{rv, n}, 
n=NTissueCells[TorusTissue[tis]]; 
If[p>n \[Or] p<1, 
Print["Error: CellNeighbors: Requested Cell Number ", p, " does not exist. "];
Return[$Failed]; 
];
rv=Complement[Union[Flatten[Select[ConnectionList[tis], MemberQ[#, p]&]]], {p}];
Return[rv]
]; 
CellNeighbors[tis_?TissueOrTorusQ]:= Module[{n, clist, nbrs},
n=NTissueCells[tis]; 
clist = ConnectionList[tis];
nbrs[p_]:= 
Complement[Union[Flatten[Select[clist, MemberQ[#, p]&]]], {p}];

Return[nbrs/@Range[n] ]
];
CellNeighbors[x___]:= (Print["Expecting CellNeigbors[tissue, n] or CellNeighbors[Torus, n]"]; Return[$Failed]); 


EdgeBetween[Q_?TissueQ, p_?IntegerQ, q_?IntegerQ]:= Module[{
c,nc,
edgeNumber}, 
c=TissueCells[Q]; 
nc=Length[c]; 
If[p>nc \[Or] q>nc \[Or] p<1 \[Or] q<1, 
Print["Error: EdgeBetween: invalid connection: ", {p,q}," there are only ", nc," cells."];
Return[$Failed]; 
];

edgeNumber = Intersection[c[[p]], c[[q]]]; 
If[Length[edgeNumber]>0, 
edgeNumber=edgeNumber[[1]]; 
Return[edgeNumber]]; 

Return[{}]; 
];
EdgeBetween[Q_?TorusQ, p_?IntegerQ, q_?IntegerQ]:= Module[{c, nc, edgeNumber, pos, InCell, trules, toroidalconnections, icc}, 
c=TissueCells[TorusTissue[Q]]; 
nc=Length[c]; 
If[p>nc \[Or] q>nc \[Or] p<1 \[Or] q<1, 
Print["Error: EdgeBetween: invalid connection: ", {p,q}," there are only ", nc," cells."];
Return[$Failed]; 
];

edgeNumber = Intersection[c[[p]], c[[q]]]; 
If[Length[edgeNumber]>0, edgeNumber=edgeNumber[[1]]; Return[edgeNumber]]; 

InCell[{a_,b_}]:= {Position[c,a][[1,1]], Position[c,b][[1,1]]};
trules=TorusRules[Q]; 
trules = List@@#&/@trules;
toroidalconnections=Sort[Join[trules, Reverse/@trules]];
icc=InCell/@toroidalconnections;

pos=Position[icc, {p,q}];
If[Length[pos]<1, Return[{}]]; 
pos = pos[[1,1]];

Return[Min[toroidalconnections[[pos]]]]
]
EdgeBetween[x___]:= (Print["Expecting EdgeBetween[tissue, i, j]"]; $Failed); 

EdgesBetween[Q_?TissueQ]:= Module[{
c, edge,  clist, edges}, 
c=TissueCells[Q]; 
clist = ConnectionList[Q]; 

edge[{p_, q_}]:= Module[{e},
e = Intersection[c[[p]], c[[q]]]; 
If[Length[e]>0, Return[First[e]]]; 
Return[0];  
];
edges = edge/@clist;
edges = MapThread[Rule, {clist, edges}]; 
edges = SparseArray[edges]; 
Return[edges]
];
EdgesBetween[Q_?TorusQ]:= Module[{c, clist,   edge, edges}, 
c=TissueCells[TorusTissue[Q]]; 
clist=ConnectionList[Q]; 

edge[{p_, q_}]:= Module[{edgeNumber, InCell, trules, toroidalconnections, pos, icc}, 
edgeNumber = Intersection[c[[p]], c[[q]]]; 
If[Length[edgeNumber]>0, edgeNumber=edgeNumber[[1]]; Return[edgeNumber]]; 
InCell[{a_,b_}]:= {Position[c,a][[1,1]], Position[c,b][[1,1]]};
trules=TorusRules[Q]; 
trules = List@@#&/@trules;
toroidalconnections=Sort[Join[trules, Reverse/@trules]];
icc=InCell/@toroidalconnections;

pos=Position[icc, {p,q}];
If[Length[pos]<1, Return[{}]]; 
pos = pos[[1,1]];

Return[Min[toroidalconnections[[pos]]]]
]; 


edges = edge/@clist;
edges = MapThread[Rule, {clist, edges}]; 
edges = SparseArray[edges]; 
Return[edges]

]



RemoveShortEdges[tis_Tissue, threshold_:0.01]:=Module[{dbg=False, dPrint, el, mean, tooshort, g, ne},
dPrint[x___]:= If[dbg, Print["RemoveShortEdges: ", x]]; 
g=tis; 

el = EdgeLengths[g]; 
mean = Mean[el]; 
ne=NTissueEdges[g]; 

tooshort = Pick[Range[ne], (#<threshold*mean)&/@el]; 
While[Length[tooshort]>0,
dPrint[tooshort]; 

g=MergeVertices[g, First[tooshort]]; 
el = EdgeLengths[g]; 
mean = Mean[el]; 
ne=NTissueEdges[g]; 
tooshort = Pick[Range[ne], (#<threshold*mean)&/@el]; 

];

Return[g];

];
RemoveShortEdges[x___]:= (Print["Expecting RemoveShortEdges[tissue, threshold]"]; Abort[]); 


DelaunayEdges[{vertices__?numPairQ}]:= Module[{dt,xy, pairup, edges, edgeCoords},
xy={vertices}; 

(* 
pairup[{v1_, {vlist__}}]:= {v1,#}&/@{vlist}; 
dt= DelaunayTriangulation[xy];
edges = Union[Sort/@Join@@(pairup/@dt)];
*)
edges=DelaunayPairs[xy]; 

edgeCoords [{i_, j_}]:= {xy[[i]], xy[[j]]}; 
edges = edgeCoords/@edges
];
DelaunayEdges[x___]:= (Print["Expecting DelaunayEdges[{{x,y},{x,y},...}]"]; $Failed); 


DelaunayPairs[{vertices__?numPairQ}]:= Module[{dt,xy, pairup, pairs},
xy={vertices}; 
pairup[{v1_, {vlist__}}]:= {v1,#}&/@{vlist}; 

dt= DelaunayTriangulation[xy];

pairs = Union[Sort/@Join@@(pairup/@dt)];
Return[pairs];
];
DelaunayPairs[x___]:= (Print["Expecting \!\(\*
StyleBox[\"DelaunayPairs\",\nFontWeight->\"Plain\"]\)[{{x,y},{x,y},...}]"]; $Failed); 


DelaunayMean[{vertices__?numPairQ}]:= Module[{xy,  edges,  dmean},
edges = DelaunayEdges[{vertices}]; 
If[SameQ[edges, $Failed], Return[$Failed]]; 
dmean = Mean[Norm/@(Subtract@@#&/@edges)];
Return[dmean]; 
];
DelaunayMean[x___]:= (Print["Expecting DelaunayMean[{{x,y},{x,y},...}]"]; $Failed); 


ConvexHullVertices[points_]:= Module[{ch},
ch=ConvexHull[points];
ch=points[[ch]]
]


GenerateBoundaryLayer[pointsInput_, opt___?OptionQ]:= Module[{chull, diameter, dbg, dPrint, points},
dbg = "Debug"/.{opt}/.{"Debug"-> False}; 
dPrint[x___]:= If[dbg, Print["GenerateBoundaryLayer: ", x]]; 

chull=ConvexHullVertices[pointsInput];
chull = Append[chull, First[chull]]; 

diameter = DelaunayMean[pointsInput]; 
dPrint["diameter: ", diameter]; 

(* block extracted from mPower 1.0 *)
Block[{hull, hullminus, hullplus,  pminus, pplus, p, vplus, vminus, pnew, v, endpoints,p1, p2, additionalpoints, d, n, rn, rpt, rpts}, 

hullminus=Most[chull];
hull=Rest[chull];
hullplus=Append[Drop[chull,2],chull[[2]]];

(*generate points directly out from convex hull*)
points={};
While[Length[hullminus]>0,
pminus=First[hullminus];
hullminus=Rest[hullminus];
pplus=First[hullplus];
hullplus=Rest[hullplus];
p=First[hull];
hull=Rest[hull];
vplus=(p-pminus)/Norm[p-pminus]; 
vminus = (p-pplus)/Norm[p-pplus]; 
v=(vplus+vminus)/Norm[vplus+vminus]; 
pnew=p+diameter*v;
points=Append[points,pnew];
]; (* end of While Length hullminus *)
dPrint["points: ", points]; 


endpoints=Append[points,First[points]];
p2=First[endpoints];
endpoints=Rest[endpoints];
additionalpoints={};

While[Length[endpoints]>0,
p1=p2;
p2=First[endpoints];
endpoints=Rest[endpoints];
d=distance[p1,p2];
If[d>diameter,
v=(p1-p2)/Norm[p1-p2]; 
n=Round[d/diameter+1];
pnew=Range[n-1]*(d/n);

pnew=(p2+v*#)&/@pnew;

(* add in a minute randomization *)
rn:= 0.01*RandomReal[{-diameter, diameter}]; 
rpt:= {rn, rn}; 
rpts = Table[rpt, {Length[pnew]}]; 
pnew = pnew + rpts; 

additionalpoints=Join[additionalpoints,pnew];
]; (* end If d> diameter*)
]; (* end While Length endpoints *)
points = Join[points, additionalpoints]; 
dPrint["points: ", points]; 
]; (* end of block from mPower 1.0 *)

(* sort points, since its convex *)
Block[{cen, angles, vecs}, 
cen = Centroid[points]; 
vecs =(#-cen)&/@points;
angles = ArcTan@@#&/@vecs; 
points = Transpose[{angles, points}]; 
points = Sort[points]; 
points = Transpose[points][[2]]; 

]; 
Return[points];
]


BoundedCellVoronoi[{centers__?numPairQ}, opt___?OptionQ]:= Module[{bl, xy, pts, boundary, bv, n,dPrint,dbg, v,c, vall, tiss},
dbg = "Debug"/.{opt}/.{"Debug"-> False}; 
dPrint[x___]:= If[dbg , Print["BoundedCellVoronoi: ", x]]; 
xy={centers}; 
n=Length[xy]; 
bl = GenerateBoundaryLayer[xy]; 
pts = Join[xy, bl]; 
boundary=bl[[ConvexHull[bl]]];
bv = BoundedDiagram[boundary, pts];
{v, c}=bv; 
c=Last/@Take[c, n];
dPrint["c: ", c]; 
vall = Union[Flatten[c]]; 
dPrint["vall: ", vall];
vall=v[[vall]]; 
dPrint["vall (2):", vall]; 
c=v[[#]]&/@c;
dPrint["c (2): ", c]; 
tiss=CellsByVertexToTissue[vall,c]; 
tiss
];
BoundedCellVoronoi[x___]:= (Print["Expecting BoundedCellVoronoi[{point, point, ...}]"]; $Failed); 


PrunedDelaunayPairs[{points__?numPairQ}, opt___?OptionQ]:= Module[
{dt, cl, w, udt},
dt = DelaunayPairs[{points}]; 
w=BoundedCellVoronoi[{points}]; 
cl = ConnectionList[w]; 
udt = Intersection[cl, dt]
];
PrunedDelaunayEdges[{points__?numPairQ}, opt___?OptionQ]:= Module[
{dt, xy, edgeCoords, edges},
xy={points}; 
 dt= PrunedDelaunayPairs[xy];
edgeCoords [{i_, j_}]:= {xy[[i]], xy[[j]]}; 
edges = edgeCoords/@dt;
Return[edges]; 
];


RandomizeTemplate[q_?TissueQ, rand_:0]:=Module[
{qq, e, v, nv,c, el, r, rn, lengths, directions, offsets},
If[rand>0,
c=TissueCells[q]; 
v=TissueVertices[q];
nv=Length[v]; 
e=TissueEdges[q];
el=Mean[EdgeLengths[q]]; 
r=rand;
If[rand>.25, 
r=.25; 
Print["Warning: RandomizeTemplate: randomization truncated to 25%."]]; 
r=r*el;
lengths = Table[RandomReal[{0,r}], {nv}]; 
directions={Cos[#], Sin[#]}&/@Table[RandomReal[{0,2Pi}], {nv}]; 
offsets = lengths*directions; 
v=v+offsets;
qq=Tissue[v,e,c];
,
qq=q]; 
Return[qq]]; 


TemplateHoneycombCover[xmax_, ymax_]:= Module[{oddxcenters, evenxcenters, centers, y, even, thesecenters, unithex,hexat, v, vcells, vertexNumber, CellsByVertexNumber, cellbyvertex, cellsByEdgePair, edges, cellsByEdgeNumber, edgeNumber},

unithex={Cos[#],Sin[#]}&/@Most[Range[0,2 Pi,Pi/3]];
hexat[{xc_, yc_}]:= {xc,yc}+#&/@unithex; 

(* calculate centers of hexagons *)

oddxcenters = Range[0, xmax, 3];
evenxcenters=Range[3/2, xmax, 3]; 
y=-Sqrt[3]/4;
even=False; 
centers={}; 
While[y<= ymax+Sqrt[3]/4,
If[even, 
thesecenters=evenxcenters,
thesecenters=oddxcenters]; thesecenters = {#,y}&/@thesecenters; 
even=Not[even]; 
y=y+Sqrt[3]/2;
centers = Join[centers, thesecenters]; 
]; 

(* define v as the unique vertices *)

vcells=hexat/@centers;
v=Union[Flatten[vcells,1]];

(* determine cells by vertex numbers *)

Return[CellsByVertexToTissue[v, vcells]]; 
]


TemplateRectangular[nx_, ny_]:= Module[{dbg, dPrint, x,y, v, i, j, bl, br, tr, tl, cvc, cells, tiss},
dPrint[x___]:= If[dbg, Print["TemplateRectangular: ", x]]; 

v=Flatten[Table[{i,j},  {j, 0, ny}, {i, 0, nx}], 1];
dPrint["v: ", v]; 
i=1; cells={}; 
For[y=0, y< ny,y++, 
For [x=0, x< nx,x++, 
bl=1+ y*(nx+1)+x; 
br=bl + 1; 
tr = br+nx+1; 
tl = tr-1; 
cvc = v[[{bl,br, tr, tl}]]; 
dPrint["cell: {x,y}=",i,":", {x,y}, ", bottom:", bl, ",", br, " top: ", tr, ",", tl];
i++;
AppendTo[cells, cvc]; 
]
]; 
tiss=CellsByVertexToTissue[v, cells];
Return[tiss]; 
];
TemplateRectangular[{x0_,xmax_, dx_}, {y0_, ymax_, dy_}]:= Module[{nx, ny, tiss, X, Y, V, v, c, e},
(* generate the tissue on [0, nx+1] * [0,ny+1] *)

nx = (xmax-x0)/dx;
ny=(ymax-y0)/dy;
tiss=TemplateRectangular[nx, ny];

(* transform to [x0, xmax] * [y0, ymax] *)

X[x_]:= x0 + x*(xmax-x0)/nx; 
Y[y_]:= y0 + y * (ymax-y0)/ny;
V[{x_, y_}]:= {X[x], Y[y]}; 
v=TissueVertices[tiss]; 
e=TissueEdges[tiss]; 
c=TissueCells[tiss]; 
v=V/@v;
tiss=Tissue[v,e,c]; 
Return[tiss]; 
]


TemplateRectangularCover[xmax_, ymax_, \[CapitalDelta]x_, \[CapitalDelta]y_, offset_:(1/2), dbg_:False]:= Module[
{n, oddxcenters, evenxcenters, centers, y, even, data, corners, rectangleAt, rline, v, vcells, q, outsiders, dPrint},

dPrint[x___]:= If[dbg, Print["TemplateRectangularCover: ", x]]; 
t1=TimeUsed[]; 

corners = {{-\[CapitalDelta]x/2, \[CapitalDelta]y/2}, {\[CapitalDelta]x/2, \[CapitalDelta]y/2}, {\[CapitalDelta]x/2, -\[CapitalDelta]y/2}, {-\[CapitalDelta]x/2, -\[CapitalDelta]y/2}}; 
rectangleAt[{xc_, yc_}]:=( {xc, yc}+#)&/@corners; 

(* determine centers of rectangles *)

n=xmax/\[CapitalDelta]x;
oddxcenters=Range[-\[CapitalDelta]x, xmax+\[CapitalDelta]x/2, \[CapitalDelta]x];
If[Length[oddxcenters]<n, 
AppendTo[oddxcenters, \[CapitalDelta]x]]; 
 evenxcenters =( \[CapitalDelta]x*offset)+#&/@oddxcenters; 
centers={}; 
y=0; 
even=False; 
While[y<=ymax+\[CapitalDelta]y, 
If[even, data = evenxcenters, data = oddxcenters]; 
data = {#, y}&/@data; 
AppendTo[centers, data]; 
y = y+ \[CapitalDelta]y; 
even=Not[even]
]; 
dPrint["centers: ", TimeUsed[]-t1]; 
t2=TimeUsed[]; 

(** NOTE THERE WILL BE SOME VERTICES THAT ARE IN SOME CELLS THAT ARE NOT ON CORNERS!!! **)
(** NEED TO FIX THIS!!! **)

(* determine corners of rectangles *)
rline[x_]:= rectangleAt/@x; 
v=Map[rline, centers];
(* list of cells as vertex coordinates *)
vcells = Join@@v;
(* list of unique vertices *)
v=Union[Join@@vcells];

(* ... continue as with hexagons  ... *) 
(* determine cells by vertex numbers *)
dPrint["v: ", TimeUsed[]-t2]; 

t3=TimeUsed[]; 
q=CellsByVertexToTissue[v, vcells];
dPrint["q: ", TimeUsed[]-t3]; 
t4=TimeUsed[]; 

(* remove any cells that manage to lie completely outside the desired cover *)

outsiders = OutsideBox[CellVertexCoordinates[q, #], {{0, 0}, {xmax, 0}, {xmax, ymax}, {0, ymax}}]&/@Range[NTissueCells[q]]; 
outsiders = Pick[Range[NTissueCells[q]], outsiders]; 
dPrint["Finding Outsiders: ", TimeUsed[]-t4]; 
dPrint["There are " ,Length[outsiders], " outsiders."]; 
 t5=TimeUsed[]; 

If[Length[outsiders]>0, 
q=RemoveCell[q, outsiders]]; 

(* Fix vertices that were skipped because of edge offset *)
dPrint["Removing Outsiders: ", TimeUsed[]-t5]; 

dPrint["There are ", Length[EntangledVertices[q]], " entanglements."]; 
t6=TimeUsed[]; 
q= DisentangleVertices[q];
dPrint["Disentangling: ", TimeUsed[]-t6]; 
dPrint["Total time: ", TimeUsed[]-t1]; 
 
Return[q]; 
]


CellsByVertexToTissue[v_, vcells_]:= Module[
{vertexNumber, cellbyvertex, CellsByVertexNumber, cellsByEdgePair, edges, edgeNumber, cellsByEdgeNumber}, 
vertexNumber[{xc_, yc_}]:= Position[v, {xc, yc}][[1, 1]]; 
cellbyvertex[{xy__?numPairQ}]:= vertexNumber/@{xy}; 
CellsByVertexNumber=cellbyvertex/@vcells; 

(* determine cells by edge number*)

cellsByEdgePair=Map[Partition[#,2,1,1]&, CellsByVertexNumber]; 

edges = Join@@cellsByEdgePair; 
edges = Sort/@edges;
edges = Union[edges]; 

cellsByEdgePair = Map[Sort/@#&, cellsByEdgePair];
edgeNumber[{i_, j_}]:= Position[edges, {i,j}][[1,1]]; 
cellsByEdgeNumber=Map[edgeNumber/@#&, cellsByEdgePair];

(*
{"v"-> v, "vcells"-> vcells, "cells"-> CellsByVertexNumber, "edges"-> edges, "cellsByEdgePair"->cellsByEdgePair, 
"cellsByEdgeNumber"-> cellsByEdgeNumber};
*)

Tissue[v, edges, cellsByEdgeNumber]
];
 


CellVerticesToTissue[vcells_]:= CellsByVertexToTissue[Union[Join@@vcells], vcells]; 



TemplateCircularHoneycombCover[radius_, mode_:-1]:= Module[{oddxcenters, evenxcenters, centers, y, even, thesecenters, unithex,hexat, v, vcells, vertexNumber, CellsByVertexNumber, cellbyvertex, cellsByEdgePair, edges, cellsByEdgeNumber, edgeNumber, r, topcenters, bottomcenters, tissue, semicircle, allthesecenters},

If[IntegerQ[mode], 
semicircle = (mode>= 0);
, 
Print["Error: TemplateCircularHoneycombCover: expecting an integer > for mode (-1: circle; or # rows to add to bottom)"];
semicircle=False; 
]; 

unithex={Cos[#],Sin[#]}&/@Most[Range[0,2 Pi,Pi/3]];
hexat[{xc_, yc_}]:= {xc,yc}+#&/@unithex; 

(* calculate centers of hexagons *)

evenxcenters = Range[0, radius+3/2, 3]; 
evenxcenters = Join[evenxcenters, -evenxcenters]//Union;
oddxcenters = Range[3/2, radius +  3/2, 3]; 
oddxcenters = Join[oddxcenters, -oddxcenters]//Union; 

y=0; 
even=True; 
centers={}; 
i=0; 
While[y<=radius+Sqrt[3]/2,
If[even, 
thesecenters=evenxcenters,
thesecenters=oddxcenters]; 
allthesecenters=thesecenters; 

thesecenters = Select[thesecenters, (#^2 < (radius+1)^2 - y^2)&]; 
topcenters = {#,y}&/@thesecenters; 

(* if a circle, odd the bottom half *)

If[i>0 ,
If[ !semicircle, 
bottomcenters={#,-y}&/@thesecenters; ,

(* if a semicircle, don't add bottom half of circle *)
(* but do add a flat line if requested *)
(* # of lines = mode *)

If[i<=mode, 
bottomcenters = {#, -y}&/@allthesecenters; ,
 bottomcenters={}
]; 
];
, 
bottomcenters={} 
]; 


even=Not[even]; 
y=y+Sqrt[3]/2;
i=i+1; 
centers = Join[centers, topcenters, bottomcenters]; 
]; 

(* define v as the unique vertices *)

vcells=hexat/@centers;
v=Union[Flatten[vcells,1]];

(* determine cells by vertex numbers *)
tissue = CellsByVertexToTissue[v, vcells];


Return[tissue]; 
]


TemplateRandom[npoints_?IntegerQ, {xy__?numPairQ}, opt___?OptionQ]:= Module[{rx, ry, xmax, ymax, xmin, ymin, i, points,point, itotal, bvd, trace=True, tPrint,  v, val, cells, e, c, cellEdges, boundary, q},

trace = "Debug"/.{opt}/.{"Debug"-> False}; 

tPrint[x___]:= If[trace, Print["TemplateRandom: ", x]]; 

boundary={xy}; 

(* generate random centers *)

xmin = Min[First/@boundary]; 
xmax = Max[First/@boundary]; 
ymin=Min[Last/@boundary]; 
ymax = Max[Last/@boundary];
rx:= RandomReal[{xmin, xmax}]; 
ry:= RandomReal[{ymin, ymax}]; 

i=itotal=0; 
points={}; 
While[i<npoints \[And] itotal<10^5,
itotal++; 
point = {rx, ry}; 
If[Inside[boundary, point], 
i++; 
AppendTo[points, point]; 
]; 
]; 
tPrint[i, " points generated ", 100.0*i/itotal,"% success rate."];

(* tPrint["boundary: ", boundary]; 
tPrint["points: ", points]; *)
(* generate Bounded Voronoi *)

tPrint["Generating Bounded Voronoi .. "]; 
bvd = BoundedDiagram[boundary, points];

{v, val} = bvd; 

tPrint[Length[v], " vertices"]; 
tPrint[Length[val], " cells"]; 

(* list of cells as vertex numbers *)

cells =Last/@ val;

(* list of cells edges as vertex pair numbers *)

cellEdges = Partition[#, 2, 1, 1]&/@cells; 
 cellEdges = Map[Sort/@#&, cellEdges]; 


e = Union[Join@@cellEdges];

Block[{edgeNumber, edgeNumbers}, 
edgeNumber[{i_, j_}]:= Position[e, {i,j}][[1, 1]]; 
edgeNumbers[{ijpair__}]:= edgeNumber/@{ijpair}; 
c=edgeNumbers/@cellEdges; 

]; 

q=Tissue[v, e, c]; 
Return[q]; 

];
TemplateRandom[x___]:= (Print["Error: expecting TemplateRandom[numPoints, convex_bounds_as_list_of_points"]; $Failed); 


TemplateRandomSquareGrid[npoints_?IntegerQ, {xmin_, ymin_}, {xmax_, ymax_}, limit_:0.8, offset_:0.5]:= Module[{rx, ry, i,j,  points,point, itotal, bvd, trace=False, tPrint,  v, val, cells, e, c, cellEdges, boundary, q, ngrids, \[CapitalDelta]x, \[CapitalDelta]y, x1, x2, y1, y2, limitation, off},

tPrint[x___]:= If[trace, Print["TemplateRandomSquareGrid: ", x]]; 

boundary={{xmin, ymin}, {xmax, ymin}, {xmax, ymax}, {xmin, ymax}}; 

(* generate random centers *)

rx:= RandomReal[{xmin, xmax}]; 
ry:= RandomReal[{ymin, ymax}]; 

ngrids = Round[Sqrt[1.0*npoints]];
If[ngrids^2 < npoints, ngrids = ngrids + 1]; 


\[CapitalDelta]x=(xmax-xmin)*1.0/ngrids; 
\[CapitalDelta]y=(ymax-ymin)*1.0/ngrids; 

limitation = Min[Max[limit, 0.0], .8]; 

off = Max[Min[offset, .9], -.9]; 

points={}; 
For[i=1, i<= ngrids, i++, 
x1 = xmin + (i-1/2 -limitation/2)*\[CapitalDelta]x;
x2 = xmin + (i-1/2 + limitation/2)*\[CapitalDelta]x; 

For[j=1, j<= ngrids, j++, 
y1 = ymin + (j-1/2 -limitation/2)*\[CapitalDelta]y;
y2 = ymin + (j-1/2 + limitation/2)*\[CapitalDelta]y; 

Block[{X1,X2}, 
If[EvenQ[j], 
X1=x1+off*\[CapitalDelta]x; 
X2=x2+off*\[CapitalDelta]x;,
X1=x1;
X2=x2;
]; 

Block[{px, py}, 
{px, py} = {RandomReal[{X1,X2}], RandomReal[{y1, y2}]}; 
If[px>xmax, px = px -(xmax-xmin)]; 

point={px, py}; 
]; 

]; 
(* keep all points on odd rods; keep only first n-1 points on even rows because*)
If[i<ngrids \[Or] (i==ngrids \[And] OddQ[j]),
AppendTo[points, point]
]; 

]
]; 
$POINTS=points; 

(* tPrint["boundary: ", boundary]; 
tPrint["points: ", points]; *)
(* generate Bounded Voronoi *)
tPrint["points: ", points]; 
tPrint["boundary: ", boundary]; 

tPrint["Generating Bounded Voronoi .. "]; 

Block[{failed, err}, 
failed=False; 
err:= (Print["TemplateRandomSquareGrid: Error evaluating Bounded Voronoi; please try again. "];failed= True;); 
(* Try to catch the error: BoundedDiagram::nobd: Bounded diagram failed *)

bvd =Check[ BoundedDiagram[boundary, points], err]; 
If[failed, Return[$Failed]]; 
]; 


{v, val} = bvd; 

tPrint[Length[v], " vertices"]; 
tPrint[Length[val], " cells"]; 

(* list of cells as vertex numbers *)

cells =Last/@ val;

(* list of cells edges as vertex pair numbers *)

cellEdges = Partition[#, 2, 1, 1]&/@cells; 
 cellEdges = Map[Sort/@#&, cellEdges]; 


e = Union[Join@@cellEdges];

Block[{edgeNumber, edgeNumbers}, 
edgeNumber[{i_, j_}]:= Position[e, {i,j}][[1, 1]]; 
edgeNumbers[{ijpair__}]:= edgeNumber/@{ijpair}; 
c=edgeNumbers/@cellEdges; 

]; 

q=Tissue[v, e, c]; 
Return[q]; 

];
TemplateRandomSquareGrid[x___]:= (Print["Error: expecting TemplateRandomSquareGrid[numPoints, {xmin, xmax}, {ymin, ymax}]"]; $Failed); 


RandomSquareGridCenters[ {xmin_, ymin_}, {xmax_, ymax_}, nx_, ny_, limit_:0.4, offset_:0.5]:= Module[{rx, ry, i,j,  points,point, itotal, bvd, trace=True, tPrint,  v, val, cells, e, c, cellEdges, boundary, q, ngrids,  x1, x2, y1, y2, limitation, off, \[CapitalDelta]x, \[CapitalDelta]y},

tPrint[x___]:= If[trace, Print["TemplateRandomSquareGrid: ", x]]; 

boundary={{xmin, ymin}, {xmax, ymin}, {xmax, ymax}, {xmin, ymax}}; 

(* generate random centers *)

rx:= RandomReal[{xmin, xmax}]; 
ry:= RandomReal[{ymin, ymax}]; 
 

\[CapitalDelta]x=(xmax-xmin)*1.0/ nx; 
\[CapitalDelta]y=(ymax-ymin)*1.0/ny; 

limitation = Min[Max[limit, 0.0], .4]; 

off = Max[Min[offset, .9], -.9]; 

points={}; 
For[i=1, i<= nx, i++, 
x1 = xmin+(i-1+limitation)*\[CapitalDelta]x;
x2 =  x1+(1-limitation)*\[CapitalDelta]x; 

For[j=1, j<= ny, j++, 
y1=ymin + (j-1 +limitation)*\[CapitalDelta]y; 
y2= y1+(1-limitation) \[CapitalDelta]y; 

Block[{X1,X2}, 
If[EvenQ[j], 
X1=x1+off*\[CapitalDelta]x; 
X2=x2+off*\[CapitalDelta]x;,
X1=x1;
X2=x2;
]; 

Block[{px, py}, 
{px, py} = {RandomReal[{X1,X2}], RandomReal[{y1, y2}]}; 
If[px>xmax, px = px -(xmax-xmin)]; 

point={px, py}; 
]; 

]; 
AppendTo[points, point]; 

]
]; 
Return[points];

];



VoronoiToTissue[points_, boundary_, trace_:False]:= Module[{bvd, v, val, tPrint, cells, cellEdges, e, c, q},

tPrint[x___]:= If[trace, Print["VoronoiToTissue: ", x]]; 

bvd = BoundedDiagram[boundary, points];

{v, val} = bvd; 

tPrint[Length[v], " vertices"]; 
tPrint[Length[val], " cells"]; 

(* list of cells as vertex numbers *)

cells =Last/@ val;

(* list of cells edges as vertex pair numbers *)

cellEdges = Partition[#, 2, 1, 1]&/@cells; 
 cellEdges = Map[Sort/@#&, cellEdges]; 


e = Union[Join@@cellEdges];

Block[{edgeNumber, edgeNumbers}, 
edgeNumber[{i_, j_}]:= Position[e, {i,j}][[1, 1]]; 
edgeNumbers[{ijpair__}]:= edgeNumber/@{ijpair}; 
c=edgeNumbers/@cellEdges; 

]; 

q=Tissue[v, e, c]; 
Return[q]; 

 ];
VoronoiToTissue[x___]:= (Print["Error: Expecting VoronoiToTissue[points, boundary]"]; $Failed); 


TemplateRandomCircularGrid[npoints_?IntegerQ, radius_?NumericQ]:= Module[{n, dbg=False, dPrint, layers,layer,  point, points, cellsInLayer, \[Delta]\[Theta], \[Theta]0, \[Theta]centers, thetas, offset, r, \[Delta]r, rvals, pointsInLayer, q},
dPrint[x___]:= If[dbg, Print["TemplateRandomCircularGrid: ", x]]; 
(* find smallest square integer that is larger or equal to npoints *) 

If[npoints<1, Print["Error: TemplateRandomCircularGrid: Must have at least 1 point."]; Return[$Failed]]; 

(* determine number of layers and layer thickness *)

layers=Sqrt[npoints*1.0]//Round;
If[layers^2<npoints, layers++];
n=layers^2;
\[Delta]r=radius/layers; 

dPrint["n: ", n]; 

dPrint["layers: ", layers]; 
dPrint["\[Delta]r: ", \[Delta]r]; 

(* determine centers in each layer *)

points={{0,0}}; 
cellsInLayer=1; 
offset = 0.1; 
\[Theta]0=0; 
For[layer=2, layer<= layers, layer++,
cellsInLayer=cellsInLayer+2; 
\[Delta]\[Theta]=360.0/cellsInLayer; 
\[Theta]0=RandomReal[{0, 180.0}]; 
dPrint["layer: ", layer, " has ", cellsInLayer, " cells with ", \[Delta]\[Theta], " deg. spacing."]; 

\[Theta]centers=Mod[(\[Theta]0+\[Delta]\[Theta]*#), 360.0]&/@Range[cellsInLayer]; 
thetas = Mod[RandomReal[{#-offset*\[Delta]\[Theta], #+offset*\[Delta]\[Theta]}], 360.0]&/@\[Theta]centers;
thetas = (\[Pi]/180.)*thetas; 
dPrint["thetas: ", thetas]; 

r=(layer-0.5)*\[Delta]r;
rvals = Table[RandomReal[{r-offset*\[Delta]r, r+offset*\[Delta]r}], {cellsInLayer}]; 

dPrint["rvals: ", rvals]; 

pointsInLayer = Transpose[{rvals, thetas}]; 
pointsInLayer = ( (#[[1]])*{Cos[#[[2]]], Sin[#[[2]]]})&/@pointsInLayer; 

dPrint["pointsInLayer: ", pointsInLayer]; 
points = Join[points, pointsInLayer]; 
]; 

(* using the convex hull here makes the outmost layer only half the required thickness *)

dPrint[ListPlot[points, AspectRatio-> 1]]; 
Block[{ch}, 
ch=ConvexHull[points]; 
ch = points[[ch]]; 
q= VoronoiToTissue[points, ch, dbg]; 
]; 

(* now move all the edges vertices out to the requisite boundary *)

Block[{v,c,e, vb, vbxy, pushout, replacements},
v= TissueVertices[q]; 
e=TissueEdges[q];
c=TissueCells[q];

vb = VerticesOnBoundary[q]; 
vbxy= v[[vb]]; 

pushout[{x_,y_}]:= Module[{theta, new}, 
theta = ArcTan[x,y];
new=radius*{Cos[theta], Sin[theta]}; 
Return[new]; 
];
vbxy = pushout/@vbxy; 

replacements=MapThread[Rule, {vb, vbxy}]; 
v=ReplacePart[v, replacements]; 

q=Tissue[v,e,c]; 

]; 
 

Return[q]; 



]; 

TemplateRandomCircularGrid[x___]:= (Print["Error: Expecting TemplateRandomCircularGrid[numPoints, radius]"]; $Failed); 



TemplateRandomSemicircularGrid[nrcpoints_?IntegerQ, radius_?NumericQ, nbot_?IntegerQ]:= Module[{n, dbg=False, dPrint, layers,layer,  point, points, cellsInLayer, \[Delta]\[Theta], \[Theta]0, \[Theta]centers, thetas, offset, r, \[Delta]r, rvals, pointsInLayer, q, npoints, toplayer, bottom, nbottom},
dPrint[x___]:= If[dbg, Print["TemplateRandomCircularGrid: ", x]]; 
(* find smallest square integer that is larger or equal to npoints *) 

npoints =nrcpoints; 
If[npoints<1, Print["Error: TemplateRandomCircularGrid: Must have at least 1 point."]; Return[$Failed]]; 

(* determine number of layers and layer thickness *)

layers=Sqrt[npoints*1.0]//Round;
If[layers^2<npoints, layers++];
n=layers^2;
\[Delta]r=radius/layers; 

dPrint["n: ", n]; 

dPrint["layers: ", layers]; 
dPrint["\[Delta]r: ", \[Delta]r]; 

(* determine centers in each layer *)

points={{0,0}}; 
cellsInLayer=1; 
offset = 0.1; 
\[Theta]0=0; 
For[layer=2, layer<= layers, layer++,
cellsInLayer=cellsInLayer+2; 
\[Delta]\[Theta]=180.0/cellsInLayer; 
\[Theta]0=RandomReal[{0, 180.0}]; 
dPrint["layer: ", layer, " has ", cellsInLayer, " cells with ", \[Delta]\[Theta], " deg. spacing."]; 

\[Theta]centers=Mod[(\[Theta]0+\[Delta]\[Theta]*#), 180.0]&/@Range[cellsInLayer]; 
thetas = Mod[RandomReal[{#-offset*\[Delta]\[Theta], #+offset*\[Delta]\[Theta]}], 360.0]&/@\[Theta]centers;
thetas = (\[Pi]/180.)*thetas; 
dPrint["thetas: ", thetas]; 

r=(layer-0.5)*\[Delta]r;
If[layer==layers, r = r+\[Delta]r/2]; 

rvals = Table[RandomReal[{r-offset*\[Delta]r, r+offset*\[Delta]r}], {cellsInLayer}]; 

dPrint["rvals: ", rvals]; 

pointsInLayer = Transpose[{rvals, thetas}]; 
pointsInLayer = ( (#[[1]])*{Cos[#[[2]]], Sin[#[[2]]]})&/@pointsInLayer; 

dPrint["pointsInLayer: ", pointsInLayer]; 
points = Join[points, pointsInLayer]; 
]; 

(* using the convex hull here makes the outmost layer only half the required thickness *)

nbottom=nbot; 
If[nbottom<1, Print["Error: TemplateRandomSemicircularGrid must have at least 1 bottom row. Input value reset to 1. "]; nbottom=1]; 
bottom= RandomSquareGridCenters[{-radius, -(nbottom+.5)*\[Delta]r*Pi/2}, {radius, -0.5*\[Delta]r}, 2*(layers-1), nbottom]; 
Global`$BOTTOM=bottom; 

points = Join[points, bottom]; 


dPrint[ListPlot[points, AspectRatio-> 1]]; 
Block[{ch}, 
ch=ConvexHull[points]; 
ch = points[[ch]]; 
q= VoronoiToTissue[points, ch, dbg]; 
]; 

dPrint["post-voronoi tissue: ", ShowTissue[q, ImageSize-> 200]]; 


(* now move all the edges vertices  in the top layer out to the requisite boundary *)

Block[{v,c,e, vb, vbxy, pushout, replacements, toplayerv},
v= TissueVertices[q]; 
e=TissueEdges[q];
c=TissueCells[q];

(* all vertices on boundary *)
vb = VerticesOnBoundary[q];  

(* got coordinates *)

dPrint["vb:", vb]; 
vbxy= v[[vb]]; 

(* modify the coordinates *) 

pushout[{x_,y_}]:= Module[{theta, new, oldr, newr}, 
If[x==y==0, Return[{x,y}]]; 
If[y>0, 
oldr = Norm[{x,y}]; 
newr=oldr + \[Delta]r/2; 
theta = ArcTan[x,y];
new=newr*{Cos[theta], Sin[theta]};,

new={x,y}; 
If[y<-(nbottom-.5)*\[Delta]r*Pi/2, new = new + {0,-\[Delta]r/2}]; 
If[x>radius -\[Delta]r, new = new + {\[Delta]r/2, 0}]; 
If[x<-radius+\[Delta]r, new = new + {-\[Delta]r/2, 0}]; 

];  
Return[new]; 
];
 vbxy = pushout/@vbxy;  

replacements=MapThread[Rule, {vb, vbxy}]; 
v=ReplacePart[v, replacements]; 

q=Tissue[v,e,c]; 

]; 
 

Return[q]; 



]; 

TemplateRandomCircularGrid[x___]:= (Print["Error: Expecting TemplateRandomCircularGrid[numPoints, radius, bottom]"]; $Failed); 



TemplatePolygon[sides_Integer, StartAngle_:0, aspect_:1, rnd_:-1, rot_:0]:= Module[{v, nv, e, c}, 
v=RegularPolygon[sides, StartAngle, aspect, rnd, rot]; 
nv=Length[v];
e=Partition[Range[nv], 2,1,1];
c={Range[nv]}; 
Return[Tissue[v,e,c]]
];


Rectangularize[tis_?TissueQ, opt___?OptionQ]:= Module[{v,e,c, bv, corners, method, debug, dPrint, xmin,ymin, xmax, ymax, projections, i, xy, tnew, meanarea, quiet, verbose, Sorted, tissue}, 
Sorted[{x_,y_}]:= x<= y; 

(* force all cells to be "sorted" *)

v=TissueVertices[tis]; 
c=TissueCells[tis]; 
e=TissueEdges[tis]; 
c=("Edges"/.SortCellEdges[#, e])&/@c; 
tissue=Tissue[v,e,c]; 

quiet = "Quiet"/.{opt}/.Options[Rectangularize]; 
verbose[x___]:= If[!quiet, Print[x]]; 

verbose["Projecting vertices .."]; 

v=TissueVertices[tissue]; 
bv=VerticesOnBoundary[tissue];
meanarea = Mean[Area[tissue]]; 

(* identify options *)

debug="Debug"/.{opt}/.Options[Rectangularize];
dPrint[x___]:= If[debug, Print["Rectangularize: ", x]]; 
corners = "Corners"/.{opt}/.Options[Rectangularize]; 
method = "Method"/.{opt}/.Options[Rectangularize]; 
dPrint["{boundary,method}:", {corners, method}];

(* figure out where the new corners are *)

corners=GetCorners[tissue, corners]; 

If[SameQ[corners, $Failed], Return[$Failed]]; 
{{xmin,ymin}, {xmax,ymax}}=corners;

(* find out where the projected points are and project them *)

projections=ProjectVerticesToBoundary[tissue, method, corners, debug];
If[SameQ[projections, $Failed], Return[$Failed]]; 
While[Length[bv]>0,
xy=First[projections]; projections=Rest[projections]; 
i=First[bv]; bv=Rest[bv]; 
v=ReplacePart[v, i-> xy]; 
]; 
c=TissueCells[tissue]; 
e=Sort/@TissueEdges[tissue]; 
dPrint["Sorted: ", And@@(Sorted/@e)];

tnew=Tissue[v,e,c];
dPrint[ShowTissue[tnew, ImageSize-> 175]]; 
dPrint["Sorted: ", And@@(Sorted/@TissueEdges[tnew])];

(* Print[And@@(Sorted/@TissueEdges[tnew])]; *)


(* the corners were not included in the above projection *)
 verbose["Adding corners .."]; 

tnew = AddCorners[tnew, corners]; 
If[SameQ[tnew, $Failed], Return[$Failed]]; 
dPrint["Sorted: ", And@@(Sorted/@TissueEdges[tnew])];
dPrint[ShowTissue[tnew, "Vertices"-> Red, ImageSize-> 175]]; 

(* remove the inline vertices *)
verbose["Merging edges .."]; 
(* ilv = InLineVertices[tnew]; 
dPrint["ilv: ", ilv]; *)
dPrint["Removing inline vertices .."]; 
tnew=RemoveInLineVertices[tnew]; 
dPrint[ShowTissue[tnew, ImageSize-> 175, "Vertices"-> True]]; 
dPrint["Sorted: ", And@@(Sorted/@TissueEdges[tnew])];

(* fix the masses: extended cells will be too big *)
verbose["Regularizing mass .."]; 
tnew =  RegularizeMass[tnew, meanarea, opt]; 
If[SameQ[tnew, $Failed], Print["Error Exit: Rectangularize"]; Return[$Failed]]; 

dPrint["Sorted: ", And@@(Sorted/@TissueEdges[tnew])];

Return[tnew];
]; 
Rectangularize[x___]:= (Print["Error: Expecting Rectangularize[tissue, options]"]; $Failed);


RegularizeMass[tissue_?TissueQ, area_, opt___?OptionQ]:= Module[{dbg=False, dPrint, bc, bcarea, bcareas, sigma, ic,icareas,icarea,  icsigma,  c, nc,  tosplit, cvc, axes, tnew, j, vector, Splittables, nvstart, vfinal,nvfinal,  rand, dist, bv, v2randomize}, 

dbg="Debug"/.{opt}/.{"Debug"-> False}; 
dPrint[x___]:= If[dbg, Print["RegularizeMass: ", x]]; 
c=TissueCells[tissue]; 

(* save this for later *)
nvstart=NTissueVertices[tissue]; 
dist = Sqrt[Mean[Area[tissue]]]; 

nc = Length[c]; 

dPrint["area: ", area]; 
bc = CellsOnBoundary[tissue]; 
ic = Complement[Range[nc], bc]; 
If[Length[ic]<2 \[Or] Length[bc]<2, 
Print["Warning: RegularizeMass: interior cells: ", Length[ic], " Exterior cells: ", Length[bc], " There must be at least 2 in each set. No regularization performed."]; 
Return[tissue];
];

bcareas = Area[tissue, bc]; 
bcarea=Mean[bcareas]; 
sigma=StandardDeviation[bcareas]; 

icareas = Area[tissue, ic]; 
icarea = Mean[icareas];
icsigma = StandardDeviation[icareas]; 

dPrint["bcarea: ", bcarea, " sigma: ", sigma]; 
dPrint["icarea: " ,icarea, " sigma: ", icsigma]; 

(* onesigs = (#>icarea+icsigma)&/@bcareas; 
twosigs = (#>icarea+2*icsigma)&/@bcareas; 
tosplit = (#> 2*(icarea - 2*icsigma))&/@bcareas; 
tosplit = MapThread[And, {tosplit, onesigs}]; 
*)

Splittable[cellArea_]:=(cellArea>icarea+icsigma) \[And](cellArea> 2*(icarea - 2*icsigma)); 
tosplit = Splittable/@bcareas; 

(* onesigs=Pick[bc,onesigs];
twosigs=Pick[bc, twosigs]; *)
tosplit=Pick[bc, tosplit]; 

(* dPrint["Boundary cells > mean + 1 sigma: ", onesigs]; 
dPrint["Boundary cells > mean + 2 sigma: ", twosigs]; *)
dPrint["Boundary cells mass/2 > mean - 2sigma: ", tosplit]; 

(* cvc=CellVertexCoordinates[tissue][[tosplit]]; 
dPrint["cvc: ", cvc]; 
axes = PrimaryAxes/@cvc; *)

(* get Primary axis Vector of each cell *)
axes  = PrimaryAxesVectors[tissue, tosplit]; 
axes = ({-1,1}*Reverse[#])&/@axes; 
dPrint["axes: ", Short[axes, 10]]; 
axes = Last/@axes;
dPrint["axes: ", Short[axes, 10]]; 

tnew = tissue; 

While[Length[tosplit]>0,
j=First[tosplit]; 
vector = First[axes]; 

tosplit=Rest[tosplit];
axes = Rest[axes]; 
dPrint["dividing cell ", j, " along ", vector , " .."]; 
tnew = DivideCell[tnew, j, vector, "Debug"-> dbg]; 

If[SameQ[tnew, $Failed], 
Print["Error Exit: RegularizeMass"]; Return[$Failed]]; 

If[TissueQ[tnew], dPrint[ShowTissue[tnew,"CellNumbers"-> True, ImageSize-> 200]]]; 

(* check daughter cell masses *)

Block[{daughters, areas, more2split, it, newaxes},
daughters = {j,  NTissueCells[tnew]}; 
areas = Area[tnew, daughters]; 
more2split = Pick[daughters, Splittable/@areas]; 
it=1;
If[Length[more2split]>0 ,
dPrint["more2split: ", more2split]; 
newaxes  = PrimaryAxesVectors[tnew, more2split]; 
newaxes =Last/@( ({-1,1}*Reverse[#])&/@newaxes);
dPrint["newaxes", newaxes];

tosplit = Join[tosplit, more2split];  
axes = Join[axes, newaxes]; 

]; 
]; 

]; 
(* Now randomize new internal vertices *)

vfinal = TissueVertices[tnew]; 
nvfinal=Length[vfinal];
bv=VerticesOnBoundary[tnew]; 
v2randomize=Complement[Range[nvstart+1, nvfinal], bv]; 

rand = "Randomness"/.{opt}/.Options[Rectangularize];
dPrint["v2randomize: ", v2randomize]; 
dPrint["rand = ", rand]; 

Block[{vnext , ev, e, maxrand, vold, vnew},
e=TissueEdges[tnew]; 
c=TissueCells[tnew]; 
While[Length[v2randomize]>0, 
vnext = First[v2randomize]; v2randomize=Rest[v2randomize]; 
(* edge numbers that contain vnext *)
ev =First/@ Position[e, vnext];
(* edge vertex pairs *)
ev = e[[ev]]; 
(* edge lengths *)
ev = vfinal[[#]]&/@ev; 
ev = distance@@#&/@ev; 
(* min length *)
dist = Min[ev]; 
maxrand = rand * dist; 

dPrint["vnext: ", vnext, " ev: ", ev, " maxrand: ", maxrand];  

vold = vfinal[[vnext]]; 
vnew = vold + {RandomReal[{-maxrand, maxrand}], RandomReal[{-maxrand, maxrand}]}; 
dPrint["vold: ", vold, " vnew: ", vnew]; 
vfinal=ReplacePart[vfinal, vnext -> vnew]; 
]; 
tnew = Tissue[vfinal, e, c]; 
];


Return[tnew]; 
]; 


(* this form is less elegant and less efficient *)
RemoveInLineVertices[tissue_?TissueQ]:= Module[{tnew,  vnum, e1, e2, ilv,  dPrint, i,imax = 1000,  dbg=False},
dPrint[x___]:=If[dbg, Print["RemoveInLineVertices: ", x]]; 
 
i=1; 
tnew = tissue; 
ilv = InLineVertices[tnew]; 
dPrint[Length[ilv], " vertices to remove."]; 
While[Length[ilv]>0,
{vnum, {e1, e2}}= First[ilv]; 
dPrint["vnum = ", vnum, " {e1, e2}: ", {e1, e2}]; 
tnew = MergeEdges[tnew, e1, e2, "Undangle"-> False]; 
tnew = UndangleEdges[tnew]; 
tnew=UndangleVertices[tnew]; 
If[dbg, Print[ShowTissue[tnew, Frame-> False,  "CellNumbers"-> True,"VertexNumbers"-> True,"EdgeNumbers"-> True,  "Vertices"-> {PointSize[.05], LightBlue}, ImageSize-> 250]]]; 

ilv = InLineVertices[tnew]; 
i++; 
If[i>imax, 
Print["Warning: RemoveInLineVertices: exceeded imax. Infinite loop suspected."];
Return[tnew]]; 
]; 

tnew = UndangleEdges[tnew]; 
tnew=UndangleVertices[tnew]; 

Return[tnew]; 
];

(* This form does not work if there are multiple ilv's in a single edge *)
RemoveInLineVertices[tissue_?TissueQ, ilv_]:= Module[{tnew, v, e, c, toRemove, vnum, e1, e2}, 
v=TissueVertices[tissue];
e=TissueEdges[tissue];
c=TissueCells[tissue]; 

toRemove=ilv;
tnew=tissue;
While[Length[toRemove]>0,
{vnum, {e1, e2}}= First[toRemove]; 
toRemove=Rest[toRemove]; 
tnew = MergeEdges[tnew, e1, e2, "Undangle"-> False]; 
]; 
tnew = UndangleEdges[tnew]; 
tnew=UndangleVertices[tnew]; 

Return[tnew]; 
];


AddCorners[tissue_?TissueQ,{{xmin_,ymin_},{xmax_,ymax_}}]:=Module[{vec,bv,bvxy,debug=False,dPrint,eps,onBottom,onTop,onLeft,onRight,OnBottom,OnTop,OnLeft,OnRight, cvn, TopRight, TopLeft, BottomRight, BottomLeft, cob, bl, br, tl, tr, q, v, e, c, needbl, needbr, needtl, needtr},eps=(0.001)*Sqrt[Mean[Area[tissue]]];dPrint[x___]:=If[debug,Print["AddCorners: ",x]];v=TissueVertices[tissue];
e=TissueEdges[tissue];
c=TissueCells[tissue];

bv=VerticesOnBoundary[tissue];
bvxy=v[[bv]];

(* functions to determine if point is on particular edge *)

OnBottom[{x_,y_}]:=y<=ymin+eps;
OnTop[{x_,y_}]:=y>=ymax-eps;
OnLeft[{x_,y_}]:=x<=xmin+eps;
OnRight[{x_,y_}]:=x>=xmax-eps;

(* classify the points on the boundary *)
onBottom=Pick[bv,OnBottom/@bvxy];
onTop=Pick[bv,OnTop/@bvxy];
onLeft=Pick[bv,OnLeft/@bvxy];
onRight=Pick[bv,OnRight/@bvxy];

dPrint["onBottom:",onBottom];
dPrint["onTop: ",onTop];
dPrint["onLeft:" , onLeft]; 
dPrint["onRight:", onRight]; 

(* identify the edge on each "corner" that has one point on one tissue-edge and one point on another tissue-edge *)

cob = EdgesOnBoundary[tissue];
cvn = e[[cob]]; 

BottomLeft[evn_]:= Length[Intersection[evn, onBottom]]>0 \[And]
Length[Intersection[evn, onLeft]]>0;

BottomRight[evn_]:= Length[Intersection[evn, onBottom]]>0 \[And]
Length[Intersection[evn, onRight]]>0;

TopRight[evn_]:= Length[Intersection[evn, onTop]]>0 \[And]
Length[Intersection[evn, onRight]]>0;

TopLeft[evn_]:= Length[Intersection[evn, onTop]]>0 \[And]
Length[Intersection[evn, onLeft]]>0;

bl=Pick[cob, BottomLeft/@cvn];
br = Pick[cob, BottomRight/@cvn]; 
tl=Pick[cob, TopLeft/@cvn]; 
tr = Pick[cob, TopRight/@cvn]; 

dPrint["{bl,br, tl, tr}:", {bl, br, tl, tr}]; 

Block[{flag},
(* if length = 1, need a corner; if length=2 corner is already there; if length >2 or <1, error *)

{needbl, needbr, needtl, needtr}=(Length[#]==1)&/@{bl, br, tl, tr}; 

flag=False; 
MapThread[If[Length[#1]>2, Print["Error: AddCorners: Incorrect number of ", #2," edges = ", Length[#1], "; should be either one or two."];flag=True;]&, {{bl,br, tl, tr}, {"Bottom-Left","Bottom-Right", "Top-Left", "Top-Right"} }];
If[flag, 
Print[ShowTissue[tissue,"CellNumbers"-> True, "VertexNumbers"-> True, "EdgeNumbers"-> True,  ImageSize-> 250, PlotLabel-> "Tissue at Error"]]; 
Return[$Failed]]; 
]; 

dPrint["{need bl br tl tr}:", {needbl, needbr, needtl, needtr}]; 

{bl, br, tl, tr}=First/@(PadRight[# ,1, $Failed]&/@{bl,br,tl, tr}); 
dPrint["{bl,br, tl, tr}:", {bl, br, tl, tr}]; 

q=tissue;
 If[needbl, q=DivideEdge[q, bl, {xmin,ymin}]]; 
 If[needbr, q=DivideEdge[q, br, {xmax, ymin}]]; 
 If[needtl, q=DivideEdge[q, tl, {xmin, ymax}]]; 
 If[needtr, q=DivideEdge[q, tr, {xmax, ymax}]]; 

Return[q];
]; 

AddCorners[x___]:=(Print["Error: AddCorners."];$Failed);


ProjectVerticesToBoundary[tissue_,"Perpendicular",  {{xmin_,ymin_}, {xmax_, ymax_}}, debug_]:= 
Module[{v,bv, bvxy,  dPrint, top, bottom, left, right, topi,bottomi, lefti, righti, perps, minDist, projections},
dPrint[x___]:= If[debug, Print["ProjectVerticesToBoundary: ", x]]; 

v=TissueVertices[tissue];
bv=VerticesOnBoundary[tissue];
If[debug,  Global`$BV=bv]; 
bvxy=v[[bv]];
If[debug, Global`$BVXY1=bvxy];

bottom={{xmin,ymin}, {xmax,ymin}}; 
top={{xmin,ymax}, {xmax, ymax}}; 
left={{xmin,ymin}, {xmin, ymax}}; 
right={{xmax, ymin}, {xmax, ymax}}; 

bottomi=DropPerpendicular[#, bottom]&/@bvxy;
topi=DropPerpendicular[#,top]&/@bvxy;
lefti=DropPerpendicular[#,left]&/@bvxy;
righti=DropPerpendicular[#, right]&/@bvxy;
perps={bottomi, topi, lefti, righti}; 
perps=Transpose[perps]; 
If[debug,Global`$PERPS=perps]; 

dPrint["bvxy: ",Short[ bvxy, 5]];
(* dPrint["int points: ", perps];  *)

minDist[pt_?NumericPointQ, {pts__?NumericPointQ}]:= Module[{distances, projection}, 
distances = 1.0*distance[pt,#]&/@{pts};
distances=Transpose[{distances, {pts}}];
projection=distances=Sort[distances][[1,2]];
Return[projection]; 
];

projections = MapThread[minDist, {bvxy, perps}];
dPrint["projections: ",Short[ projections, 5]];
If[debug, Global`$Projections=projections]; 

Return[projections];
];
ProjectVerticesToBoundary[tissue_,method_,  {{xmin_,ymin_}, {xmax_, ymax_}}, debug_]:= (Print["Error: ProjectVerticesToBoundary: Unkown Method: ", method]; Return[$Failed]); 


GetCorners[tissue_?TissueQ, "Automatic"]:= Module[{v,  xmin, ymin, xmax, ymax},
v=TissueVertices[tissue]; 

xmin = Min[First/@v]; 
xmax = Max[First/@v];
ymin = Min[Last/@v]; 
ymax = Max[Last/@v]; 

{{xmin,ymin}, {xmax,ymax}}
]; 
GetCorners[tissue_?TissueQ, {{xmin_, ymin_}, {xmax_, ymax_}}]:= Module[{axmin,aymin,axmax,aymax},
{{axmin,aymin}, {axmax, aymax}}= GetCorners[tissue, "Automatic"]; 
If[xmin> axmin \[Or] xmax < axmax \[Or] ymin > aymin \[Or] ymax < aymax,
Print["Error: GetCorners: specified corners must be exterior to tissue. Input values will be ignored."];
Return[{{axmin, aymin}, {axmax, aymax}}]
];
Return[{{xmin,ymin}, {xmax, ymax}}]
]; 
GetCorners[tissue_?TissueQ, x___]:= (Print["Error: GetCorners: Corners type not implemented: ", x, " Expecting \"Automatic\" or {{xmin,ymin}, {xmax,ymax}}"]; $Failed); 
GetCorners[x___]:= (Print["Error: Expecting corners[tissue, corners]"]; $Failed); 



ToTorus[tissue_?TissueQ, opt___?OptionQ]:= Module[{tnew,v,e,c, debug,inputtolerance, tolerance, dPrint,xs, ys,  bottom, top, left, right, tv, bv, lv, rv, vertexNumbers, nv, el, er, et, eb, eob, whichedges, corners, newvr, newvl, newvt, newvb, nnewvl, nnewvr, nnewvt, nnewvb, nnewvlj, nnewvrj, nnewvtj, nnewvbj, VertexOnEdge, VerticesOnWhichEdge, VertexEdgePairs, EdgeMatches},
debug = "Debug"/.{opt}/.Options[ToTorus]; 
inputtolerance="Tolerance"/.{opt}/.Options[ToTorus]; 
dPrint[x___]:= If[debug, Print["ToTorus: ", x]]; 

v=TissueVertices[tissue]; 
c=TissueCells[tissue];
e=TissueEdges[tissue];
eob = EdgesOnBoundary[tissue]; 
 
nv = Length[v]; 
vertexNumbers=Range[nv]; 

tolerance = inputtolerance * Sqrt[Mean[Area[tissue]]]; 

dPrint["Tolerance:", tolerance]; 

(* determine the edges *)

{xs, ys}= Transpose[v]; 
bottom = Min[ys]; top = Max[ys]; 
left = Min[xs]; right = Max[ys]; 

(* determine the vertices on the edges *)

tv =Pick[vertexNumbers, (Abs[#-top]<tolerance)&/@ys]; 
bv =Pick[vertexNumbers, (Abs[#-bottom]<tolerance)&/@ys]; 
lv= Pick[vertexNumbers,(Abs[#-left]<tolerance)&/@xs];
rv =Pick[vertexNumbers,(Abs[#-right]<tolerance)&/@xs]; 

(* determine the edge numbers of the edges *)

whichedges[ver_]:=  Select[eob, MemberQ[ver, First[e[[#]]]] \[And] MemberQ[ver, Last[e[[#]]]]&];

et =whichedges[tv]; 
eb = whichedges[bv]; 
el= whichedges[lv]; 
er = whichedges[rv]; 

(* now remove the corners - this must be done AFTER the edges are identified *)

corners=Join[Intersection[tv,lv], Intersection[tv,rv], Intersection[bv,lv], Intersection[bv,rv]]; 
dPrint["corners: ", corners]; 
tv=Complement[tv, corners]; 
bv=Complement[bv, corners]; 
lv=Complement[lv, corners]; 
rv=Complement[rv, corners]; 

dPrint["top:    ", tv, ", edges: ", et];
dPrint["bottom: ", bv,  ", edges: ", eb]; 
dPrint["left:   ", lv, ", Edges: ", el]; 
dPrint["right:  ",rv, ", Edges: ", er];

(* add new vertices *)

newvt={v[[#, 1]], top}&/@bv;
nnewvt = Length[newvt]; 
nnewvtj=Range[nv+1, nv + nnewvt]; 
nv = nv+nnewvt;

newvb={v[[#, 1]], bottom}&/@tv; 
nnewvb = Length[newvb]; 
nnewvbj=Range[nv+1, nv+nnewvb]; 
nv = nv + nnewvb; 

newvl={left, v[[#, 2]]}&/@rv;
nnewvl = Length[newvl]; 
nnewvlj=Range[nv+1, nv+nnewvl]; 
nv = nv+nnewvl; 

newvr={right, v[[#, 2]]}&/@lv; 
nnewvr = Length[newvr]; 
nnewvrj = Range[nv+1, nv+nnewvr]; 
nv = nv+nnewvr; 

dPrint["new top v indices:    ", nnewvtj]; 
dPrint["new bottom v indices: ", nnewvbj]; 
dPrint["new left v indices:   " , nnewvlj]; 
dPrint["nnew right v indices:  ", nnewvrj];
dPrint["new nv: ", nv]; 
v=Join[v, newvt, newvb, newvl, newvr]; 

(* figure out which outer edge each new vertex lies on *)

VertexOnEdge[vnum_, enum_]:= 
PointOnLineSegment[v[[e[[enum]]]],v[[vnum]]];

VerticesOnWhichEdge[vnums_, enums_]:= Module[{vonedge, nver, vertex, k,savebug, dbg=False, edges},
savebug=debug; 
debug=dbg; 
nver =Length[vnums]; 
edges={}; 
For[k=1,k<= nver, k++ , 
vertex = vnums[[k]]; 
vonedge = VertexOnEdge[vertex, #]&/@enums;
dPrint["k: ", k, " vertex: ", vertex, " enums: ", enums, " vonedge: ", vonedge]; 
vonedge = Pick[enums, vonedge]; 
If[Length[vonedge]>1, Print["Error: ToTorus: VerticesOnEdge: Vertex ", vertex," is on multple edges: ", vonedge];
]; 
If[Length[vonedge]<1, Print["Error: ToTorus: VerticesOnEdge: Vertex ", vertex, " is not on any edge."]; 
vonedge={$Failed}; 
];
vonedge=First[vonedge]; 
AppendTo[edges, vonedge]; 
dPrint["vertex: ", vertex, " edge: ", vonedge]; 
];
debug=savebug; 
Return[Transpose[{vnums, edges}]]; 
];

(* get a list of the outer new vertices and their corresponding edges *)

VertexEdgePairs=Join[
VerticesOnWhichEdge[nnewvtj, et],
VerticesOnWhichEdge[nnewvbj, eb], 
VerticesOnWhichEdge[nnewvlj, el], 
VerticesOnWhichEdge[nnewvrj, er] 
]; 
dPrint["VertexEdgePairs: ", VertexEdgePairs]; 

(* divide the tissue at the identified locations *)

tnew = tissue;
Block[{vertex, edge, vep},
vep = VertexEdgePairs; 
While[Length[vep]>0,
{vertex, edge}=First[vep];
dPrint["inserting vertex ", vertex, " in edge ", edge, " .."];  
vep=Rest[vep]; 
vertex=v[[vertex]]; 
tnew = DivideEdge[tnew, edge, vertex];
]
]; 

eob=EdgesOnBoundary[tnew];
dPrint["eob: ", eob]; 

(* deterermine the toroidal matching *)
Block[{eobv,eobvxy,  edges, vert, topedges, bottomedges, leftedges, rightedges, matches, ETopQ, EBottomQ, ERightQ, ELeftQ, ELeft, ERight, ETop, EBottom, GetLeftx, GetBottomy, ETopx, EBottomx, ELefty, ERighty, SortBy}, 
matches[x_, y_]:= Abs[x-y]<tolerance;
matches[x_, y_, z_]:= And[matches[x,y], matches[y,z]];  

edges = TissueEdges[tnew]; 
vert = TissueVertices[tnew]; 

eobv = edges[[#]]&/@eob;
eobvxy = vert[[#]]&/@eobv; 
dPrint["eobv: ", eobv]; 
dPrint["eobvxy: ", eobvxy]; 

ETopQ[{{x1_, y1_}, {x2_, y2_}}]:= matches[y1, y2, top]; 
EBottomQ[{{x1_, y1_}, {x2_, y2_}}]:= matches[y1, y2, bottom]; 
ELeftQ[{{x1_, y1_}, {x2_, y2_}}]:= matches[x1, x2, left]; 
ERightQ[{{x1_, y1_}, {x2_, y2_}}]:= matches[x1, x2, right]; 

ETop =Pick[eob,  ETopQ/@eobvxy]; 
EBottom =Pick[eob,  EBottomQ/@eobvxy]; 
ELeft =Pick[eob,  ELeftQ/@eobvxy]; 
ERight =Pick[eob,  ERightQ/@eobvxy]; 
GetLeftx[{{x1_, y1_}, {x2_, y2_}}]:=First[ Sort[{x1, x2}]]; 
GetBottomy[{{x1_, y1_}, {x2_, y2_}}]:= First[Sort[{y1, y2}]]; 

ETopx =GetLeftx/@Pick[eobvxy,  ETopQ/@eobvxy]; 
EBottomx =GetLeftx/@Pick[eobvxy,  EBottomQ/@eobvxy]; 
ELefty =GetBottomy/@Pick[eobvxy,  ELeftQ/@eobvxy]; 
ERighty =GetBottomy/@Pick[eobvxy,  ERightQ/@eobvxy]; 


If[Length[ETop]!= Length[EBottom], Print["Program Error: ToTorus: Number of Top Edges = ", ETop, " is different from the number of Bottom Edges= ", EBottom]; Return[$Failed]; ]; 
If[Length[ELeft]!= Length[ERight], Print["Program Error: ToTorus: Number of Left Edges = ", ELeft, " is different from the number of Right Edges= ", ERight]; Return[$Failed]; ]; 

dPrint["ETop:    ", ETop]; 
dPrint["EBottom: ", EBottom]; 
dPrint["ERight:  " ,ERight]; 
dPrint["ELeft:   ", ELeft]; 

dPrint["ETopx:    ", ETopx]; 
dPrint["EBottomx: ", EBottomx]; 
dPrint["ERighty:  " ,ERighty]; 
dPrint["ELefty:   ", ELefty]; 

SortBy[list_, keys_]:=Last[ Transpose[Sort[Transpose[{keys, list}]]]]; 

ETop = SortBy[ETop, ETopx]; 
EBottom = SortBy[EBottom, EBottomx]; 
ELeft= SortBy[ELeft, ELefty]; 
ERight = SortBy[ERight, ERighty]; 

dPrint["ETop:    ", ETop]; 
dPrint["EBottom: ", EBottom]; 
dPrint["ERight:  " ,ERight]; 
dPrint["ELeft:   ", ELeft]; 


EdgeMatches =Sort[Join[
MapThread[Rule, {ETop, EBottom}], 
MapThread[Rule, {EBottom, ETop}], 
MapThread[Rule, {ELeft, ERight}], 
MapThread[Rule, {ERight, ELeft}]
]]; 

(* Pick out matches (larger edge #)--> (Smaller Edge #) only *)

EdgeMatches=
Rule@@#&/@Union[Reverse/@Sort/@EdgeMatches/.{Rule-> List}];

dPrint["EdgeMatches: ", EdgeMatches]; 

]; (* end Block *)

Return[Torus[tnew, EdgeMatches]]; 

(*
Return[Tissue[v,e,c]];
*) 


];



TorusQ[Torus[x_?TissueQ, y_]]:= Module[{isrule, ok}, 
isrule[z_Rule]:= True;
isrule[z___]:= False; 
If[!ListQ[y], Return[False]]; 
ok = isrule/@y; 
Return[And@@ok]; 
];
TorusQ[x___]:= False; 

TorusCheck[Torus[tissue_, rules_]]:= Module[{tissuecheck, isrule, ok}, 
tissuecheck = TissueCheck[tissue]; 
If[!tissuecheck, Print["TorusCheck: First argument of Torus[..] is not a valid Tissue object."];
]; 
isrule[z_Rule]:= True;
isrule[z___]:= False; 
If[!ListQ[rules],
Print["TorusCheck: Second argument is not a list of rules."]; 
 Return[False]]; 
ok = isrule/@rules; 
ok = And@@ok; 
If[ok, Print[Length[rules], " edge matching rules. "]]; 
If[!ok,
Print["TorusCheck: Second argument is not a list of rules."]; 
 Return[False]]; 
Return[tissuecheck]; 
];
TorusCheck[x___]:=(Print["Error: Expecting TorusCheck[Torus[Tissue[], rules]"]; $Failed); 


TorusTissue[Torus[tissue_, rules_]]:= Module[{ok},
ok = TorusQ[Torus[tissue, rules]]; 
If[Not[ok],
Print["Error: TorusTissue: Invalid Torus object. "];
TorusCheck[Torus[tissue, rules]];
 Return[$Failed];
];
Return[tissue]; 
];
TorusTissue[x___]:=(Print["Error: expecting TorusTissue[Torus[..]]."]; $Failed); 
TorusRules[Torus[tissue_, rules_]]:= Module[{ok},
ok = TorusQ[Torus[tissue, rules]]; 
If[Not[ok],
Print["Error: TorusRules: Invalid Torus object. "];
TorusCheck[Torus[tissue, rules]];
 Return[$Failed];
];
Return[rules]; 
];
TorusRules[x___]:=(Print["Error: expecting TorusRules[Torus[..]]."]; $Failed); 


CelleratorNetwork[intracellular_, diffusingSpecies_, 
inputTissue_, 
opt___?OptionQ
]:= Module[{r, k, n, in, out,  diff, reactions, i, j, vPrint, nInside, nDiff, nTotal, ok, istissue, istorus, c, icc,  tissue, dPrint, edgeVariable, areaVariable, debug, verbose, dynamic}, 

debug = "Debug"/.{opt}/.{"Debug"-> False};
verbose="Verbose"/.{opt}/.{"Verbose"-> True}; 

edgeVariable="Edge"/.{opt}/.{"Edge"-> None}; 
areaVariable="Area"/.{opt}/.{"Area"-> None}; 

dynamic = Not[edgeVariable === None] \[Or] Not[areaVariable===None];
If[dynamic, 
If[edgeVariable===None , 
edgeVariable = Unique["Global`edge"]; 
Print["Warning: CelleratorNetwork: Both \"Edge\" and \"Area\" options must be used if either is used. Set \"Edge\"\[Rule]", edgeVariable];
];
If[areaVariable===None,
areaVariable=Unique["Global`area"]; 
Print["Warning: CelleratorNetwork: Both \"Edge\" and \"Area\" options must be used if either is used. Set \"Area\"\[Rule]", areaVariable]; 
]; 
]; 

dPrint[x___]:= If[debug, Print["CelleratorNetwork: ", x]]; 

istissue=TissueQ[inputTissue]; 
istorus=TorusQ[inputTissue]; 

ok=istissue \[Or] istorus;
If[!ok, Print["Error: Expecting CelleratorNetwork[net, diffusion, tissue]."]; Return[$Failed]]; 

If[istissue, tissue = inputTissue]; 
If[istorus, tissue = TorusTissue[inputTissue]];

c=TissueCells[tissue]; 

dPrint["Tissue: ", istissue, " Torus: ", istorus]; 

vPrint[x___]:= If[verbose, Print[x]]; 

(* generate intracellular reactions *)

r=lowLevelReactions[intracellular]; 
r=indexify[r, i];
n=NTissueCells[tissue]; 
vPrint[n, " Cells."]; 
vPrint[Length[r], " internal reactions in each cell."]; 
in = Join@@Table[r/.{i-> k}, {k, 1, n}]; 
nInside=Length[in]; 
vPrint[nInside, " intracellular reactions."]; 

(* generate diffusion reactions *)
diff={}; 
If[Length[diffusingSpecies]>0,
Block[{  edgeLengths, diffusionReaction, diffusionReactions,allneighbors,  neighbors, edgeBetween, l,  areas, beta, Y, difSpec, temp, allEdgesBetween, diffData, func, One},

One[p_,q_]:= 1; 

allneighbors = CellNeighbors[inputTissue];  

(* neighbors[p_]:= CellNeighbors[inputTissue, p]; *)
neighbors[p_]:= allneighbors[[p]]; 

edgeLengths = EdgeLengths[tissue]; 

allEdgesBetween=EdgesBetween[inputTissue]; 
dPrint["allEdgesBetween: ", Short[MatrixForm[allEdgesBetween]]]; 

(* edgeBetween[p_, q_]:= EdgeBetween[inputTissue, p, q];  *)
edgeBetween[p_, q_]:= allEdgesBetween[[p,q]];


l[p_,q_]:= If[dynamic,
edgeVariable[edgeBetween[p,q]][Global`t],
edgeLengths[[edgeBetween[p,q]]]
]; 
areas = Area[tissue]; 

If[dynamic,
diffusionReaction[X_,\[Beta]_,  {p_, q_}]:={X[p]\[RightArrowLeftArrow]Global`\[EmptySet], (\[Beta] l[p,q] func[p,q])/areaVariable[p][Global`t], (\[Beta] l[p,q] func[p,q])/areaVariable[p][Global`t] X[q][Global`t]}; , 

diffusionReaction[X_,\[Beta]_,  {p_, q_}]:={X[p]\[RightArrowLeftArrow]Global`\[EmptySet], (\[Beta] l[p,q] func[p,q])/areas[[p]], (\[Beta] l[p,q] func[p,q])/areas[[p]] X[q][Global`t]}; 
]; 

diffusionReactions[X_, \[Beta]_, p_]:= Table[
diffusionReaction[X, \[Beta], {p, inbr}], {inbr, neighbors[p]}];

difSpec=diffusingSpecies;
While[Length[difSpec]>0,
(* {Y, beta} = First[difSpec]; *)

dPrint["difSpec: ", difSpec];

diffData = First[difSpec]; 
difSpec=Rest[difSpec]; 

diffData = Flatten[{diffData}]; 
Y=diffData[[1]]; 
beta = If[Length[diffData]>1, diffData[[2]], 0]; 
func = If[Length[diffData]>2, diffData[[3]], One]; 

temp = Join@@(diffusionReactions[Y, beta, #]&/@Range[n]);
diff = Join[diff, temp];  
]; 
]; 
]; 
nDiff=Length[diff]; 
vPrint[nDiff, " diffusion reactions."]; 

(* generate intercellular reactions if spectified *)
out  = {}; 
(** this is TBD *)

reactions=Join[in, diff, out]; 
nTotal = Length[reactions]; 
vPrint[nTotal, " total reactions."]; 
Return[reactions];
]; 
CelleratorNetwork[x___]:= (Print["Error: CelleratorNetwork: Expecting CelleratorNetwork[reactions, diffusion, tissue]"]; $Failed);


X2SSANetwork[net_, diff_,  tissue_?TissueQ, verbose_:True]:= Module[{bignet},
bignet = CelleratorNetwork[net, diff, tissue, verbose]; 
bignet=XLR8RtoSSA[bignet]; 
Return[bignet]; 
]


SSANetwork[net_, diff_,  tissue_?TissueQ, verbose_:True]:= Module[{bignet},
bignet = SSAtoXLR8R[net]; 
bignet = X2SSANetwork[bignet, diff, tissue, verbose]; 
Return[bignet]; 
]


indexify[net_,index_]:=Module[{species,reactions,rateRules,rules,indexedSpecies, mysub, mysup, myexpr, dbg=False, dPrint, lengths},

dPrint[x___]:= If[dbg, Print["indexify: ", x]]; 

(*generate replacement rules x-->x[index],...*)


mysub[x__]:= stringify[InputForm[Subscript[x]]]; 
mysup[x__]:= stringify[InputForm[Superscript[x]]]; 


species=interpret[net][[2]];
indexedSpecies=#[index]&/@species;
rules=MapThread[Rule,{species,indexedSpecies}];
(*separate rate rules from reactions:this is becasue we may have a rate constant like Subscript[k,CLV] where CLV is the name of a species*)reactions=First/@net;
rateRules=Rest/@net;

(* hide any super/subscripts in the rate constants *) 

rateRules = rateRules/.{Subscript-> mysub, Superscript-> mysup}; 
lengths = Length/@rateRules;

dPrint["rateRules (1):", rateRules]; 
dPrint["lengths: ", lengths]; 

(* apply the indices to the rate constants, just in case there is a species in there *)

rateRules=rateRules/.rules;
dPrint["rateRules (2):", rateRules]; 

(* recover any hidden superscrips/subscripts in the rate constants *)

(* rateRules=Flatten[rateRules]; 
dPrint["rateRules (3):", rateRules]; *)

rateRules = InputForm/@rateRules; 
dPrint["rateRules (4):", rateRules]; 

rateRules=stringify/@rateRules;
dPrint["rateRules (5):", rateRules]; 

rateRules = StringReplace[#, {"\""-> ""}]&/@rateRules; 
rateRules=ToExpression/@rateRules; 
(* rateRules=List/@rateRules; *)
dPrint["rateRules (6):", rateRules]; 


(*apply the indexing to the species*)reactions=reactions/.rules;
(*join the reactions back to the rate rules*)reactions=MapThread[Prepend[#1,#2]&,{rateRules,reactions}];
Return[reactions]];


RunSim[bignet_, parameters_, ic_, {tstart_, tend_}, opt___?OptionQ]:= Module[{sim},
sim = run[bignet,{tstart, tend},  xlr8r`initialConditions-> ic, xlr8r`rates-> parameters, opt]; 
sim=Flatten[sim]; 
Return[sim]
]


SimPlot[solution_, var_, {tbegin_, tend_}, opt___?OptionQ]:= Module[{allvars, vars, s, n, timepoints, dt, fline, lines, colors, nvars},
n="Points"/.{opt}/.{"Points"-> 100};
dt=(tend-tbegin)/n;  
timepoints=1.0*Range[tbegin, tbegin+n*dt, dt]; 

s=Flatten[solution]; 
allvars = First/@s;
vars = Select[allvars, SameQ[#,var]\[Or]SameQ[Head[#], var]&];
nvars=Length[vars]; 
s=vars/.s;

fline [if_]:=Line[{#, if[#]}&/@timepoints]; 
lines = fline/@s;

colors = Hue/@((1.0/(nvars+1))*Range[0,nvars-1]);
{Length[colors], Length[lines]};

lines = MapThread[Graphics[{#1, #2}]&, {colors, lines}]; 
If[Length[lines]<1, lines={Graphics[]}]; 

With[{sopt=MyFilterOptions[Plot,opt]}, 
Show[lines, sopt, Frame-> True, 
AspectRatio-> 1, PlotLabel-> ToString[var]]
]
];


SimPlot[solution_, {var__}, {tbegin_, tend_}, opt___?OptionQ]:= Module[{ plots, columns}, 
(* make the plots *)
plots = SimPlot[solution, #, {tbegin, tend}, opt]&/@{var};
If["Grid"/.{opt}/.{"Grid"-> False},
columns = "Columns"/.{opt}/.{"Columns"-> 3}; 
While[Mod[Length[plots], columns]!= 0,
AppendTo[plots, Graphics[{}]]
];
plots = Partition[plots, columns]; 
plots=GraphicsGrid[plots];
]; 
plots

]


SimPlot[solution_, var_, opt___?OptionQ]:= Module[{ plot, columns, tbegin, tend}, 
(* make the plots *)
{tbegin,tend}=CommonTimeDomain[solution]; 
plot = SimPlot[solution, var, {tbegin, tend}, opt];
Return[plot];
]


SimPlot[solution_, {tbegin_, tend_}, opt___?OptionQ]:= Module[{allvars,  plots, columns},
allvars = IndexedVarsInSolution[solution]; 
plots = SimPlot[solution, #, {tbegin, tend}, opt]&/@allvars;
If["Grid"/.{opt}/.{"Grid"-> False},
columns = "Columns"/.{opt}/.{"Columns"-> 3}; 
While[Mod[Length[plots], columns]!= 0,
AppendTo[plots, Graphics[{}]]
];
plots = Partition[plots, columns]; 
plots=GraphicsGrid[plots];
]; 
plots
]


SimPlot[solution_, opt___?OptionQ]:= Module[{start, stop, times,p},

(* determine common time domain *)
times=CommonTimeDomain[solution];  
If[SameQ[times, $Failed], Print["Error: SimPlot: No common time domain."]; Return[$Failed]]; 
{start, stop}=times; 

p=SimPlot[solution, {start, stop}, opt]; 
Return[p]; 

];


MultiSimPlot[{solutions__}, var_, opt___?OptionQ]:= Show[SimPlot[#,var, opt]&/@{solutions}]


IndexedVarsInSolution[solution_]:= Module[{s, allvars, indexed, nonindexed},
s=Flatten[solution]; 
allvars = First/@s;
indexed = Select[allvars, IndexedQ]; 
nonindexed=Complement[allvars, indexed]; 
indexed = Union[Head/@indexed]; 
allvars = Flatten[{indexed, nonindexed}];
Return[allvars]; 
];


CommonTimeDomain[solution_]:= 
Module[{s, domains, maxs, mins, start, stop}, 
s=Last/@Flatten[solution];
domains = InterpolatingFunctionDomain/@s;
domains=Flatten/@domains;
domains=Union[domains]; 
domains = Transpose[domains];
{mins, maxs}=domains; 
start = Max[mins]; 
stop = Min[maxs]; 
If[start > stop, Return[$Failed]]; 
Return[{start, stop}];
]


IndexedQ[var_?AtomQ]:= False; 
IndexedQ[var_[index__]]:= True; 
IndexedQ[x___]:= False;


SimShow[solution_,variable_, time_,  tissue_?TissueQ, {rgbfrom_RGBColor, rgbto_RGBColor}, {vmin_, vmax_}, opt___?OptionQ]:= Module[{allvars, s, n, colors, g, dbg, dprint},

dbg = "Debug"/.{opt}/.{"Debug"-> False}; 
dprint[x___]:= If[dbg, Print["SimShow(1): ", x]]; 
dprint["SimShow(1)"]; 

n=NTissueCells[tissue]; 
s=Flatten[solution];  

(* get all indexed variables of specified name *)
allvars = First/@s;
allvars = Select[allvars, SameQ[Head[#], variable]&];
dprint["allvars: ", Short[allvars]]; 
If[Length[allvars]<1, Print["Error: SimShow: ", variable, " not found."]; Return[$Failed]]; 

(* get interpolating functions for variable *)
s=allvars/.s;
If[Length[s]!= n, Print["Error: SimShow: Tissue has ", n, " cells; there are ", Length[s] ," solutions."]]; 

(* get values at time *)
s  = #[time]&/@s;
dprint["Length[s]:", Length[s]]; 
dprint["s: ", Short[s]]; 
dprint["{vmin, vmax}:", {vmin, vmax}]; 
dprint["{rgbfrom,rgbto}:", {rgbfrom, rgbto}]; 
colors = RGBInterpolate[#, {vmin, vmax}, {rgbfrom, rgbto}]&/@s;

dprint["colors: ", Short[colors]]; 
dprint["opt: ", opt]; 


g=ShowTissue[tissue, "CellStyle"-> colors, opt];

dprint["g:", g]; 

Return[g]; 

]; 




SimShow[solution_,variable_, time_,  tissue_?TissueQ, {rgbfrom_RGBColor, rgbto_RGBColor}, {vmin_, vmax_}, 
{xmin_, xmax_}, {ymin_, ymax_}, 
opt___?OptionQ]:= Module[
{title, xxmax, legend, legendstyle, g, lxmin, lxmax, lymin, lymax, lbox, lboxcolo ,dbg, dprint},

dbg = "Debug"/.{opt}/.{"Debug"-> False}; 
dprint[x___]:= If[dbg, Print["SimShow(2): ", x]]; 

dprint["SimShow(2)"]; 

title=ToString[variable]<>"["<>ToString[NumberForm[time,{10,2}]]<>"]";

xxmax = xmax + .2*(xmax-xmin); 

legendstyle = "LegendStyle"/.{opt}/.{"LegendStyle"-> {}}; 

lxmin = xmax+ .05(xmax-xmin); 
lxmax =xmax+.15(xmax-xmin);
lymin=ymin+.25(ymax-ymin); 
lymax = ymin +.75(ymax-ymin); 

legend = ColorBlendRectangle[
{lxmin,lymin}, {lxmax,lymax }, {rgbfrom, rgbto}, {NumberForm[vmin,3], NumberForm[vmax,3]}, legendstyle]; 

(* box the legend, the same color as the Cell Boundary if not specified*)

lbox = Line[{{lxmin, lymin}, {lxmax, lymin}, {lxmax, lymax}, {lxmin, lymax}, {lxmin, lymin}}]; 
lboxcolor="LegendBoundary"/.{opt}/.{"LegendBoundary"-> "BoundaryStyle"}; 
lboxcolor =lboxcolor/.{opt}/.{"BoundaryStyle"-> Black}; 
lbox = Graphics[{lboxcolor, lbox}//Flatten]; 

g= SimShow[solution, variable, time, tissue, {rgbfrom, rgbto}, {vmin, vmax}, 
opt, 
PlotRange-> {{xmin, xxmax}, {ymin, ymax}}, 
PlotLabel-> title
];

Show[g, legend, lbox]
]


SimShow[solution_,variable_, time_,  tissue_?TissueQ, {rgbfrom_RGBColor, rgbto_RGBColor}, threshold_,  opt___?OptionQ]:= Module[{allvars, s, n, colors, g, dbg, dprint},

dbg = "Debug"/.{opt}/.{"Debug"-> False}; 
dprint[x___]:= If[dbg, Print["SimShow(1): ", x]]; 
dprint["SimShow(1)"]; 

n=NTissueCells[tissue]; 
s=Flatten[solution];  

(* get all indexed variables of specified name *)
allvars = First/@s;
allvars = Select[allvars, SameQ[Head[#], variable]&];
dprint["allvars: ", Short[allvars]]; 
If[Length[allvars]<1, Print["Error: SimShow: ", variable, " not found."]; Return[$Failed]]; 

(* get interpolating functions for variable *)
s=allvars/.s;
If[Length[s]!= n, Print["Error: SimShow: Tissue has ", n, " cells; there are ", Length[s] ," solutions."]]; 

(* get values at time *)
s  = #[time]&/@s;
dprint["Length[s]:", Length[s]]; 
dprint["s: ", Short[s]]; 

dprint["{rgbfrom,rgbto}:", {rgbfrom, rgbto}]; 
colors = RGBThreshold[#, threshold, {rgbfrom, rgbto}]&/@s;

dprint["colors: ", Short[colors]]; 
dprint["opt: ", opt]; 


g=ShowTissue[tissue, "CellStyle"-> colors, opt];

dprint["g:", g]; 

Return[g]; 

]; 




RGBInterpolate[x_, {xmin_, xmax_}, {RGB1_, RGB2_, RGBS__}]:= Module[{colors, nc, y,r1, r2, X, X1, X2, C1, C2},
colors={RGB1, RGB2, RGBS};
nc = Length[colors];  
X=Min[Max[x, xmin], xmax]; 
y=1+Round[(X-xmin)*(nc-2)/(xmax-xmin)]; 
r1 = y; 
r2=r1+1;
C1=colors[[r1]]; 
C2=colors[[r2]]; 

X1 = ((r1-1)xmax + (nc-r1-1)*xmin)/(nc-2);
X2 = ((r2-1)xmax + (nc-r2-1)*xmin)/(nc-2);
RGBInterpolate[x, {X1, X2}, {C1,C2}]
]


RGBErr=0; 
RGBInterpolate[x_, {xmin_, xmax_}, {RGBmin_RGBColor, RGBmax_RGBColor}]:=Module[{y, RGB, y1, y2, RGBMax=3},
RGB[RGBColor[r_, g_, b_]]:= {r, g, b};
RGB[q___]:= (Print["Error: RGBInterpolate: Not an RGBColor: ", q, " Using Black."];{0,0,0} ); 
y1=RGB[RGBmin]; y2=RGB[RGBmax]; 
{y1, y2};

If[xmin>= xmax, 
y=RGBColor@@((y1+y2)/2);
RGBErr++; 
If[RGBErr<= RGBMax,
Print["Warning: RGBInterpolate: xmax = ", xmax, ", must be < xmin = ", xmin, ": using median value of ", y]; 
If[RGBEr>= RGBMax, Print["Further messages will be suppressed."]]; 
]; 
Return[y];  
]; 

y = y1 +(x-xmin)/(xmax-xmin) (y2-y1);
Return[RGBColor@@y]; 

];
RGBInterpolate[x___]:= (Print["Error: Expecting RGBInterpolate[x, {xmin, xmax}, {rgbmin, rgbmax}], not ", x]; $Failed); 


RGBThreshold[x_,  threshold_, {RGBmin_RGBColor, RGBmax_RGBColor}] := If[x>= threshold, RGBmax, RGBmin];

RGBThreshold[x__]:= (Print["Error: Expecting RGBThreshold[x, {xmin, xmax}, {rgbmin, rgbmax}], not ", x]; $Failed); 


ColorBlendRectangle[{xmin_, ymin_}, {xmax_, ymax_}, {rgbfrom_, rgbto_, rgbs__}, {textmin_:"Min", textmax_:"Max"}, textstyle_:{}]:= Module[
{n, rect, colors, ncolors, deltay,htotal, h, y1s, y2s, boxes, tmin, tmax, r}, 
colors={rgbfrom, rgbto, rgbs};
ncolors=Length[colors]; 
htotal = ymax - ymin;
h = htotal/(ncolors-1); 
n=100/(1+ncolors) + 1;

rect[{x1_,y1_}, {x2_,y2_}, {C1_, C2_}]:= Module[{rnext,y, r, c},
deltay=1.0*(y2-y1)/n; 
y=y1;
r={}; 
While[y<ymax, 
rnext = Rectangle[{x1, y}, {x2, y+deltay}]; 
c=RGBInterpolate[y, {y1, y2} ,{C1, C2}]; 
rnext = Graphics[{c, rnext}]; 
AppendTo[r, rnext]; 
y=y+deltay;
]; 
r
]; 

colors = Partition[colors, 2, 1]; 
y1s = Table[ymin+i*h, {i, 0, ncolors-2}]; 
y2s = Table[ymin+i*h, {i, 1, ncolors-1}]; 
boxes = MapThread[rect[{xmin, #1}, {xmax, #2}, #3]&, {y1s, y2s, colors}]; 

tmin = Style[textmin, textstyle]; 
tmax = Style[textmax, textstyle]; 
AppendTo[boxes, Graphics[Text[tmin, {0.5(xmin+xmax), ymin}, {0,1}]]]; 
AppendTo[boxes, Graphics[Text[tmax, {0.5(xmin+xmax), ymax}, {0,-1}]]]; 
r=Show[boxes]; 
Return[r]; 

];



ColorBlendRectangle[{xmin_, ymin_}, {xmax_, ymax_}, {rgbfrom_, rgbto_}, {textmin_:"Min", textmax_:"Max"}, textstyle_:{}]:= Module[{n, deltay, y, r, rnext, color, tmin, tmax}, 
n=100;
deltay=1.0*(ymax-ymin)/n; 
r={}; 
y=ymin; 
While[y<ymax,
rnext = Rectangle[{xmin, y}, {xmax, y+deltay}]; 
color =RGBInterpolate[y, {ymin, ymax}, {rgbfrom, rgbto}]; 
rnext = Graphics[{color, rnext}]; 
AppendTo[r, rnext]; 
y=y+deltay;
]; 
tmin = Style[textmin, textstyle]; 
tmax = Style[textmax, textstyle]; 
AppendTo[r, Graphics[Text[tmin, {0.5(xmin+xmax), ymin}, {0,1}]]]; 
AppendTo[r, Graphics[Text[tmax, {0.5(xmin+xmax), ymax}, {0,-1}]]]; 
r=Show[r]; 
Return[r]; 
];



SimShowFinal[sim_, variable_, template_, {mincolor_, maxcolor_},  
 opt___?OptionQ]:= Module[
{times, xrange, yrange, varmin, varmax, tmax, p, dbg, dprint}, 

dbg = "Debug"/.{opt}/.{"Debug"-> False}; 

dprint[x___]:= If[dbg, Print["SimShowFinal: ", x]]; 

times = CommonTimeDomain[sim];
dprint["times: ", times]; 

tmax = Last[times]; 
dprint["tmax: ", tmax]; 

{xrange, yrange} = AutoScaleTemplate[template];
dprint["spatial range: ", {xrange, yrange}]; 

{varmin, varmax}=SimRange[sim, variable, tmax]; 
dprint["Variable Range: ", {varmin, varmax}]; 

p=SimShow[sim, variable, tmax, template, {mincolor, maxcolor}, {varmin, varmax}, xrange, yrange, opt, "CellNumbers"-> False, "BoundaryStyle"-> {Thin, Gray}]; 

Return[p]; 
];

SimShowFinal[sim_, variable_, template_, {mincolor_, maxcolor_},  
threshold_?NumericQ, opt___?OptionQ]:= Module[
{times, xrange, yrange, varmin, varmax, tmax, p, dbg, dprint}, 

dbg = "Debug"/.{opt}/.{"Debug"-> False}; 

dprint[x___]:= If[dbg, Print["SimShowFinal: ", x]]; 

times = CommonTimeDomain[sim];
dprint["times: ", times]; 

tmax = Last[times]; 
dprint["tmax: ", tmax]; 

{xrange, yrange} = AutoScaleTemplate[template];
dprint["spatial range: ", {xrange, yrange}]; 

p=SimShow[sim, variable, tmax, template, {mincolor, maxcolor}, threshold,  opt, "CellNumbers"-> False, "BoundaryStyle"-> {Thin, Gray}]; 

Return[p]; 
];



SimShowAt[sim_, variable_,time_,  template_, {mincolor_, maxcolor_},{varmin_, varmax_},   opt___?OptionQ]:= Module[
{times, xrange, yrange,   p, dbg, dprint}, 

dbg = "Debug"/.{opt}/.{"Debug"-> False}; 

dprint[x___]:= If[dbg, Print["SimShowFinal: ", x]]; 

times = CommonTimeDomain[sim];
dprint["times: ", times]; 

If[time > times[[2]] \[Or] time <times[[1]], Print["Error: SimShowAt: time ", time, " not in range ", times]; 
Return[$Failed]]; 

{xrange, yrange} = AutoScaleTemplate[template];
dprint["spatial range: ", {xrange, yrange}]; 

p=SimShow[sim, variable, time, template, {mincolor, maxcolor}, {varmin, varmax}, xrange, yrange, opt, "CellNumbers"-> False, "BoundaryStyle"-> {Thin, Gray}]; 

Return[p]; 
]



SimShowAt[sim_, variable_,time_,  template_, {mincolor_, maxcolor_},  opt___?OptionQ]:= Module[
{times,  varmin, varmax,  p}, 

times = CommonTimeDomain[sim]; 

If[time > times[[2]] \[Or] time <times[[1]], Print["Error: SimShowAt: time ", time, " not in range ", times]; 
Return[$Failed]]; 

{varmin, varmax}=SimRange[sim, variable, time];

p=SimShowAt[sim, variable,time,  template, {mincolor, maxcolor},{varmin, varmax},   opt]; 

Return[p]; 
]



SimInterpolate[sim_, var_, time_]:= Module[{allvars, s, vals, timerange},
timeRange=CommonTimeDomain[sim]; 
If[time>timeRange[[2]] \[Or] time<timeRange[[1]], Print["Error: SimRange: requested time ", time, " is not in the data range of ", timeRange]; Return[$Failed]]; 

s=Flatten[sim]; 
(* get all indexed variables of specified name *)
allvars = First/@s;
allvars = Select[allvars, SameQ[Head[#], var]&];
If[Length[allvars]<1, Print["Error: SimInterpolate: ", var, " not found."]; Return[$Failed]]; 
vals=(#[time]&)/@(allvars/.s)
]


SimRange[sim_, var_, time_?NumericQ]:= Module[{vals, range},
vals = SimInterpolate[sim, var, time]; 
If[SameQ[vals, $Failed], Return[$Failed]]; 
range={Min[vals], Max[vals]};
Return[range]; 
]


SimRange[sim_, var_, {tstart_?NumericQ, tend_?NumericQ, tdelta_?NumericQ}]:= Module[{s},
s=SimRange[sim, var, #]&/@Range[tstart, tend, tdelta]; 
s=Transpose[s]; 
s={Min[s[[1]]], Max[s[[2]]]}; 
Return[s]; 
];

SimRange[x___]:= (Print["Error: Expecting SimRange[sim, var, time] or SimRange[sim, var, {tstart, tend, tdelta}"]; $Failed); 


SimAnimate[sim_, variable_, template_, {tstart_, tend_, tdelta_},
{minColor_, maxColor_}, {minVal_, maxVal_}, {xmin_, xmax_}, {ymin_, ymax_}, opt___?OptionQ]:= Module[{s},
RGBErr=0; 

s=SimShow[sim, variable, #, template, {minColor, maxColor}, {minVal, maxVal}, 
{xmin, xmax}, {ymin, ymax}, opt, "CellNumbers"-> False, "BoundaryStyle"-> {Thin, Black}]&/@Range[tstart, tend, tdelta];
Return[s];
];

SimAnimate[sim_, variable_, template_, {tstart_, tend_, tdelta_},
{minColor_, maxColor_}, {minVal_, maxVal_},  opt___?OptionQ]:=SimAnimate[sim, variable, template, {tstart, tend, tdelta}, {minColor, maxColor}, {minVal, maxVal}, Sequence@@AutoScaleTemplate[template], opt]; 

SimAnimate[sim_, variable_, template_, {tstart_, tend_, tdelta_},
{minColor_, maxColor_},   opt___?OptionQ]:= Module[{minVal, maxVal},
{minVal, maxVal}=SimRange[sim, variable, {tstart, tend, tdelta}]; 
SimAnimate[sim, variable, template, {tstart, tend, tdelta}, {minColor, maxColor}, {minVal, maxVal}, Sequence@@AutoScaleTemplate[template], opt]]; 



AutoScaleTemplate[template_?TissueQ, xpad_:10, ypad_:10]:= Module[{v, x,y, xmin, xmax, ymin, ymax, width, height, dx, dl, dy},
v=TissueVertices[template]; 
{x,y}=Transpose[v]; 
{xmin, xmax}={Min[x], Max[x]}; 
{ymin, ymax}={Min[y], Max[y]}; 

width = xmax-xmin;
height = ymax-ymin; 
dx = (xpad/100.0)*width; 
dy = (ypad/100.0)*height;

xmin = xmin - dx; 
xmax = xmax + dx; 
ymin = ymin  - dy; 
ymax = ymax + dy; 

Return[{{xmin, xmax}, {ymin, ymax}}];

]


SaveFrames[pictures_?ListQ,type_, size_, movieType_:".avi",  label_:"MovieData", framerate_:16]:= Module[{dir,cwd, labl,frnames, moviedir,framedir,  moviefile, runstring,typ,error, FrameName, FrameNames, dotavi, today, $TEMP, rate},

today=DateString[{"Year","-","Month","-","Day"}]; 
$TEMP=ToFileName[$HomeDirectory, "Simulations-"<>today];

dotavi = movieType; 
If[StringTake[dotavi, 1]!= ".", dotavi = "."<>dotavi]; 

FrameName[x_, type1_:"EPS"]:= Module[{y, ty},
ty = ToString[type1]; 
If[StringTake[ty, {1, 1}]!= ".", ty="."<>ty];  
y=ToString[x];
While[StringLength[y]<4, y="0"<>y]; 
Return[ToUpperCase["Frame"<>y<>ty]]
]; 
FrameNames[number_, type1_:"EPS"]:= FrameName[#, type1]&/@Range[number]; 

cwd = Directory[];  

If[Length[FileNames[$TEMP]]<1, 
Print["Creating new output directory ", $TEMP];
CreateDirectory[$TEMP]
]; 
SetDirectory[$TEMP]; 

dir=DateString[ {"Day", "-", "MonthName", "-", "YearShort", "-", "Hour","Minute", "Second"}]; 
labl=ToString[label]; 
If[StringLength[labl]>0, dir =labl<>"-"<> dir]; 
moviefile=dir<>dotavi; 


CreateDirectory[dir]; 
SetDirectory[dir];
moviefile = ToFileName[Directory[], moviefile]; 

CreateDirectory["Frames"]; 
SetDirectory["Frames"]; 
framedir=Directory[]; 

 Print["Putting movie frames in  in " , framedir]; 

frnames=FrameNames[Length[pictures], ToString[type]]; 
MapThread[Export[#1, #2, ImageSize-> size]&, {frnames, pictures}]; 

typ=type; 
If[StringTake[typ, {1,1}]!= ".", typ = "."<>typ]; 

rate=ToString[Round[framerate]]; 

runstring="ffmpeg -sameq -r "<>rate<>" -i 'FRAME%4d"<>typ<>"' '"<>moviefile<>"'";
Print[runstring]; 
error=Run[runstring]; 
If[error!= 0, Print["ffmpeg return code is: ", error]]; 
Print["Created Movie: ", #]&/@FileNames[moviefile];

SetDirectory[cwd]; 

]; 


ToAVI[pics_?ListQ,title_:"MovieData",  size_:400, rate_:16]:= SaveFrames[pics, "JPG", size,".avi", title, rate];
ToMOV[pics_?ListQ,title_:"MovieData",  size_:400, rate_:16]:= SaveFrames[pics, "JPG", size,".mov", title, rate];

ToAVI[___]:= Print["Expecting[ToAVI[{picture, picture, ...}, title_:\"SomeTextLabel\", size_:400]"]; 
ToMOV[___]:= Print["Expecting[ToMOV[{picture, picture, ...}, title_:\"SomeTextLabel\", size_:400]"]; 



Help[]:= Module[{names, usagestrings, print}, 
names=decontextify/@Names["Cellzilla2D`*"];
usagestrings = ToExpression/@((ToString[#]<>"::usage")&/@names); 
print[a_, b_]:= Module[{}, 
If[StringLength[ToString[b]]>0, 
StylePrint[a, "Subsection"]; 
Print[b]; 
];
]; 
StylePrint["Cellzilla2D Help", "Section"]; 
Print["This is the Cellzilla2D Help file. It provides some reference information about each of the externally visible Cellzilla2D functions. It is not a users guide and does not provide any introduction to using Cellzilla2D. It also does not include plugin reference information. \nPlease note that Cellzilla2D is experimental software and as such many of the functions may only contain partial implementations. And like a lot of software documentation in the cybersphere it does not always keep up with the latest implementation. Please check with the developer if you have any questions."];
Print["This file was generated by CelleratorML version "<>$Cellzilla2DVersion<>" on "<>DateString[{"Day", " ", "MonthNameShort", " ", "Year", " at ", "Hour", ":", "Minute", ":", "Second", " (", "TimeZone",")"}]<>" using Mathematica "<>$Version<>" (Version "<>ToString[ $VersionNumber]<>", Release "<>ToString[ $ReleaseNumber]<> ")"];  
MapThread[print, {names, usagestrings}]; 
];


End[];
If[FLAGS`ECHOLOAD,
Print[Style["Cellzilla2D ("<>$Cellzilla2DVersion<> ") loaded "<> DateString[]<>" using xlr8r "<>$XLR8RLOAD<>" and xSSA "<>$XSSALOAD, Bold]];
]; 
EndPackage[]; 
