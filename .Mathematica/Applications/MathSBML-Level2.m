(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



getSBMLlevel2[sbml_,filename_, opt___?OptionQ]:= Module[{ models, modelid,   statistics,modelCounterString, modelName,importedModel={}, numericalSolution, dbg=False, addConstantSpeciesBackIn,expressRule,sm,t0,cpu,modelmetaid
},
dbg=Global`debug/.{opt}/.{Global`debug-> False};

expressRule[Rule[a_?StringQ, b_?StringQ]]:= Rule[ToExpression[a], ToExpression[b]];

addConstantSpeciesBackIn[id_]:= Module[{s},
removeReplacementRule[id]; 
defineVariable[id]; 
addDummyODE[id];

];
addConstantSpeciesBackIn[x___]:= Module[{}, Print["Error: getSBMLLevel2: addConstantSpeciesBackIn: x=",x]];


SBML$Trace = (Global`trace/.{opt}/.{Global`trace-> False});

$SBML$UnitAssociations={};
$SBML$ODES={};
$SBML$NameIDAssociations={};  
$SBML$ConstantSpecies={}; 
$SBML$SpeciesThatAreAmounts={};
$SBML$SpeciesThatAreConcentrations={};
$SBML$Species$IDs={};
$SBML$StoichiometryMatrix={};
$SBML$IDTable={};
$SBML$MetaIDTable={};
$SBML$LocalReactionParameterTable={};
$SBML$KineticLaws={};
$SBML$MetaIDAssociations={};

Clear[hasOnlySubstanceUnitsIndicator];
hasOnlySubstanceUnitsIndicator[x_]:= False;
Clear[SBMLSpeciesCompartment];
SBMLSpeciesCompartment[x_]:=Indeterminate;




debugPrint[dbg\[Or] SBML$Trace,"getSBMLevel2: SBML level.version = ", $SBML$Level$Version ];
If[$SBML$printModelName,
modelCounterString=" ********** Model "<>ToString[$SBML$modelcount]<>" ********** \n",
modelCounterString="";
];
If[saveVerboseData,
 verboseSave[modelCounterString<>"File Name:"<> filename<>"\nSBML Level "<>ToString[$SBML$Level]<>" Version "<>ToString[$SBML$Version],
{},{}];
]; 

getSBMLNotes[sbml]; 

(* check for extraneous objects in file *)

Block[{s, objects},
s=First[sbml];
objects[XMLElement["sbml",a_, b_]]:= b; 
s=objects[s]/.{XMLElement-> List};
s=First/@s;
s= Complement[s, {"model", "notes", "annotation"}];

Print["Error: "//boldRed,
" Unknown or invalid object:"//boldBlack, #//boldBlue, " in SBML container. Allowed objects are: "//boldBlack, 
"annotation, "//boldBlue, "notes, "//boldBlue, "model"//boldBlue
]&/@s;

];

(***** Models *****)

$SBML$Model = Cases[sbml,XMLElement["model",___],3]; 
{modelid, modelName, modelmetaid}=getLevel2ModelName[]; 
If[MB$Load, 
MB$ID=modelid; 
MB$Name=modelName;
MB$MetaID=modelmetaid;

newModel[Global`level-> $SBML$Level,Global`version-> $SBML$Version, Global`echo-> MB$Echo, Global`id-> MB$ID, Global`name-> MB$Name, Global`metaid-> MB$MetaID];
MB$ModelAnnotation=getAnnotations[$SBML$Model]//Flatten; 
MB$ModelNotes=getNotes[$SBML$Model]//Flatten;
]; 

If[dbg, Print["getSBMLlevel2: MB$Load:",MB$Load]];
If[dbg, Print["getSBMLlevel2: MB$ModelNotes:",MB$ModelNotes]];


$SBML$Model = First[$SBML$Model]; 

checkModelOrder[$SBML$Model];

debugPrint[dbg\[Or] SBML$Trace,"getSBMLlevel2:: modelid, modelName",{modelid,modelName}];
debugPrint[dbg,"$SBML$Model: ",$SBML$Model];

t0=TimeUsed[];
debugPrint[ SBML$Trace,"Trace>> Calling getLevel2Functions"];
getLevel2Functions[]; 
cpu=TimeUsed[]-t0;
debugPrint[SBML$Trace,"CPU: ",cpu];

debugPrint[ SBML$Trace,"Trace>> Calling getLevel2units"];
getLevel2units[];
cpu=TimeUsed[]-t0;
debugPrint[SBML$Trace,"CPU: ",cpu];

debugPrint[ SBML$Trace,"Trace>> Calling getLevel2compartmentTypes"];
t0=TimeUsed[];
getLevel2compartmentTypes[]; 
cpu=TimeUsed[]-t0;
debugPrint[SBML$Trace,"CPU: ",cpu];

debugPrint[ SBML$Trace,"Trace>> Calling getLevel2speciesTypes"];
t0=TimeUsed[];
getLevel2speciesTypes[]; 
cpu=TimeUsed[]-t0;
debugPrint[SBML$Trace,"CPU: ",cpu];

debugPrint[ SBML$Trace,"Trace>> Calling getLevel2compartments"];
t0=TimeUsed[];
getLevel2compartments[]; 
cpu=TimeUsed[]-t0;
debugPrint[SBML$Trace,"CPU: ",cpu];

debugPrint[ SBML$Trace,"Trace>> Calling getLevel2species"];
t0=TimeUsed[];
getLevel2species[];
cpu=TimeUsed[]-t0;
debugPrint[SBML$Trace,"CPU: ",cpu];

debugPrint[ SBML$Trace,"Trace>> Calling getLevel2parameters"];
t0=TimeUsed[];
getLevel2parameters[];
cpu=TimeUsed[]-t0;
debugPrint[SBML$Trace,"CPU: ",cpu];

SBMLBoundaryConditionQ[unknownX_]:= False;
SBMLConstantQ[unknownX_]:= False;

getLevel2InitialAssignments[];

debugPrint[ SBML$Trace,"Trace>> Calling getLevel2rules"];
t0=TimeUsed[];
getLevel2rules[];
cpu=TimeUsed[]-t0;
debugPrint[SBML$Trace,"CPU: ",cpu];

getLevel2constraints[];

debugPrint[ SBML$Trace,"Trace>> Calling getLevel2reactions"];
t0=TimeUsed[];
getLevel2reactions[];
cpu=TimeUsed[]-t0;
debugPrint[SBML$Trace,"CPU: ",cpu];

checkParameterShadowing[];

debugPrint[ SBML$Trace,"Trace>> Calling getLevel2events"];
getLevel2events[];

 
(* addConstantSpeciesBackIn/@$SBML$ConstantSpecies; *) 

(***** Verbose Listing *****)
debugPrint[ SBML$Trace,"Trace>> Handling Verbose data"];
If[$SBML$verbose, verbosePrint[]]; 

(***** Return Data *****)
debugPrint[ SBML$Trace,"Trace>> Handling Return data"];
If[SBMLRead$return,

If[SBMLRead$returnContext, importedModel=Append[importedModel,Global`SBMLContext-> $SBML$Context]];

If[SBMLRead$returnODES, importedModel=Append[importedModel,Global`SBMLODES-> $SBML$ODES]];

If[SBMLRead$returnIC, importedModel=
Append[importedModel,
Global`SBMLIC->ToExpression[initialize[SBMLVariables]]
]];

If[SBMLRead$returnConstants, importedModel=Append[importedModel,Global`SBMLConstants->(SBMLReplacementRules)]];
If[SBMLRead$returnBoundaryConditions, importedModel=Append[importedModel,Global`SBMLBoundaryConditions->(SBMLBoundaryConditions)]];



If[SBMLRead$returnGlobalParameters, importedModel=Append[importedModel,Global`SBMLParameters->(SBMLGlobalParameters)]];

If[SBMLRead$returnSpeciesTypes,
If[ToExpression[$SBML$Level$Version]>2.15,
importedModel=Join[importedModel, {Global`SBMLSpeciesTypes->$SBML$SpeciesTypes ,
Global`SBMLSpeciesTypeAssociations-> $SBML$SpeciesTypeAssociations
}];
];
];


If[SBMLRead$returnMetaIDAssociations, importedModel=Append[importedModel,Global`SBMLMetaIDAssociations->($SBML$MetaIDAssociations)]
];

If[SBMLRead$returnCompartmentTypes,
If[ToExpression[$SBML$Level$Version]>2.15,
importedModel=Join[importedModel, {Global`SBMLCompartmentTypes->$SBML$CompartmentTypes,Global`SBMLCompartmentTypeAssociations-> $SBML$CompartmentTypeAssociations} ];
];
];


If[SBMLRead$returnSpecies, importedModel=Append[importedModel,
Global`SBMLSpecies->functionate[$SBML$Species$IDs]
]];

If[SBMLRead$returnModelVariables, 
importedModel=Append[importedModel,
Global`SBMLModelVariables->ToExpression[functionate[SBMLVariables]]
];
];



If[SBMLRead$returnAssignmentRules, importedModel=Append[importedModel,Global`SBMLAssignmentRules-> $SBML$Assignment$Rules]];

If[SBMLRead$returnAlgebraicRules, importedModel=Append[importedModel,Global`SBMLAlgebraicRules-> $SBML$Algebraic$Rules]];

If[ToExpression[$SBML$Level$Version]>2.15,
If[SBMLRead$returnConstraints, importedModel=Append[importedModel,Global`SBMLConstraints-> $SBML$Constraints]];
If[SBMLRead$returnInitialAssignments, importedModel=Append[importedModel,Global`SBMLInitialAssignments-> $SBML$InitialAssignments]];
];

If[SBMLRead$returnReactions, importedModel=Append[importedModel,Global`SBMLReactions-> $SBML$Reactions]];

If[SBMLRead$returnKineticLaws, importedModel=Append[importedModel,Global`SBMLKineticLaws-> $SBML$KineticLaws]];

If[SBMLRead$returnStoichiometryMatrix,
importedModel=Append[importedModel, Global`SBMLStoichiometryMatrix->$SBML$StoichiometryMatrix ];
];

If[SBMLRead$returnConservationMatrix,
If[MatrixQ[$SBML$StoichiometryMatrix],
importedModel=Append[importedModel, Global`SBMLConservationMatrix->conservationMatrix[$SBML$StoichiometryMatrix ]],
importedModel=Append[importedModel, Global`SBMLConservationMatrix->{}]
];
];


If[SBMLRead$returnMassBalanceEquations,
importedModel=Append[importedModel, Global`SBMLMassBalanceEquations->SBML$MassBalanceEquations ];
];
If[SBMLRead$returnMassActionEquations, importedModel=Append[importedModel, Global`SBMLMassActionEquations-> SBML$MassAction$Equations];
importedModel=Append[importedModel,Global`SBMLMassActionVariables->$SBML$MassActionVariables ];
];

If[SBMLRead$returnFunctions,importedModel= Append[importedModel,Global`SBMLFunctions-> $SBML2$Functions];]; 

If[SBMLRead$returnUnitDefinitions, importedModel=Append[importedModel,Global`SBMLUnitDefinitions-> $SBML$UnitRules]];
If[SBMLRead$returnUnitAssociations,importedModel=Append[importedModel,Global`SBMLUnitAssociations-> $SBML$UnitAssociations]];


If[SBMLRead$returnNameIDAssociations,
importedModel = Append[importedModel, Global`SBMLNameIDAssociations-> $SBML$NameIDAssociations]; 
];


If[SBMLRead$returnEvents,
importedModel = Append[importedModel,Global`SBMLEvents-> $SBML$Events];
]; 

If[SBMLRead$returnModelName,
importedModel = Append[importedModel,Global`SBMLModelName-> modelName];
importedModel = Append[importedModel, Global`SBMLModelid-> modelid];
];
If[SBMLRead$returnCompartments,
importedModel = Append[importedModel,Global`SBMLCompartments-> ToExpression/@$SBML$Compartmentids];
];

If[SBMLRead$returnSpeciesCompartmentAssociations,
importedModel = Append[importedModel,Global`SBMLSpeciesCompartmentAssociations-> expressRule/@$SBML$SpeciesCompartmentAssociations];
];

If[SBMLRead$returnSolution>0, 

debugPrint[ SBML$Trace,"Trace>> Determining Numerical Solution, duration = "<>ToString[SBMLRead$returnSolution]<>" NDSolveOptions-> "<>ToString[SBML$NDSolveOptions]];
numericalSolution = SBMLNDSolve[importedModel, SBMLRead$returnSolution, SBML$NDSolveOptions]; 
importedModel = Append[importedModel, Global`SBMLNumericalSolution-> numericalSolution];
];


];

importedModel=Append[importedModel, Global`SBMLLevelVersion-> ToExpression[$SBML$Level$Version]];

printStatistics[];

If[MB$Load \[And] MB$Echo, 
Print["SMBL Model "//boldGreen, modelid//boldBlue," loaded into Model Builder "//boldGreen];
];

Return[importedModel];


];


checkModelOrder[XMLElement["model", stuff_, morestuff_]]:=Module[{s, so, types, order, bad, number, numbers,lv},

lv = ToExpression[$SBML$Level$Version];

If[lv < 2.15,
types={"listOfFunctionDefinitions",
"listOfUnitDefinitions",
"listOfCompartments", 
"listOfSpecies",
"listOfParameters",
"listOfRules",
"listOfReactions", 
"listOfEvents"
};
,
types={"listOfFunctionDefinitions",
"listOfUnitDefinitions",
"listOfCompartmentTypes",
"listOfSpeciesTypes",
"listOfCompartments", 
"listOfSpecies",
"listOfParameters",
"listOfInitialAssignments",
"listOfRules",
"listOfConstraints",
"listOfReactions", 
"listOfEvents"
};
];

order[x_]:=Position[types,x][[1, 1]];



s=morestuff/.{XMLElement-> List};
s=First/@s;
s=Select[s, !MemberQ[{"notes", "annotation"}, #]&];

(* see if there are unknown model elements *)

bad = Complement[s, types];
Print["Error: "//boldRed, "The model contains an unknown top level element "//boldBlack, #//boldBlue]&/@bad;
s = Select[s, MemberQ[types, #]&]; 

(* see if there are duplicated elements *)

number[object_]:= Length[Position[s, object]];
numbers = number/@types;

MapThread[If[#1>1, 
Print["Error: "//boldRed, "The model contains multiple "//boldBlack, #2//boldBlue]
]&, {numbers, types}];


(* see if the elements are in the correct order *)

so = order/@s;

Block[{i,type1, type2, i1, i2},
For[i=2, i<= Length[s], i++,
i1=so[[i-1]]; 
i2=so[[i]];
If[i1>i2,
type1=types[[i1]]; 
type2=types[[i2]]; 
Print["Error: "//boldRed,
" The model contains objects that are not in the proper order: "//boldBlack,
type2//boldBlue , " is not allowed to follow "//boldBlack, type1//boldBlue, "\nThe proper order is:\n"//boldBlack, 
(StringJoin@@("\t\t"<>#<>"\n"&/@types))
//boldBlue
];

];
];

];

];


checkModelOrder[u_]:=Print["Error: "//boldRed, "checkModelOrder: not a model:"//boldBlack, u//boldBlue]; 


If[$$LoadBug, Print["Loading: level-2 specific functions"]];


$SBML$IDTable={}; (* force initialization at load time *)
$SBML$MetaIDTable={}; (* force initialization at load time *)

identifyID[id_]:=Module[{type}, 
p = Position[$SBML$IDTable, id];
If[Length[p]>0, 
p=p[[1,1]];
type=$SBML$IDTable[[p, 2]];
Return[type];
];
Return["Unknown"]; 
]

addID[id_, kind_, check_:True]:= Module[{did, dbg=False},

If[dbg, Print["addID: adding: kind: ", kind, " id: ", id]; ]; 

did = decontextify[id]; 
If[check,collisionCheck[did,kind,True]];
$SBML$IDTable=Append[$SBML$IDTable, stringer/@{did,kind}];
Return[id];
];
addMetaID[meta_, id_, kind_, check_:True]:= Module[{did, dbg=False},

If[dbg, Print["addMetaID: meta(in): ", meta]];

did = decontextify[meta]; 
If[check,metacollisionCheck[did,id,kind,True]];
AppendTo[$SBML$MetaIDTable, stringer/@{did,kind}];
AppendTo[$SBML$MetaIDAssociations, 
Rule[did, stringer[id]]
]; 
If[dbg, Print["addMetaID: meta(out): ", meta-> id]];

Return[meta];
];
removeID[id_, kind_]:= Module[{did, matches, meta, dbg=False},

If[dbg, Print["removeID:", {id , kind}]];
did=decontextify[id];
If[!MemberQ[$SBML$IDTable, stringer/@{did,kind}], 
matches = Select[$SBML$IDTable, Equal[stringer[id], First[#]]&]; 
Print["Warning: "//boldRed, "removeID: "//boldBlack, #[[1]]//boldBlue, " is listed as a "//boldBlack, #[[2]]//boldBlue, " and not as a "//boldBlack,  kind//boldBlue," in the symbol table."//boldBlack]&/@matches;
];

If[dbg, Print[ "removeID:  stringer/@{did,kind}: ", stringer/@{did,kind}]]; 

$SBML$IDTable=Complement[$SBML$IDTable, {stringer/@{did,kind}}];

(* remove any metaid's that are pointing to this id!! *)


meta = Select[$SBML$MetaIDAssociations, 
Equal[id, decontextify[Last[#]]]&];

 
If[Length[meta]>0, 
meta = First/@meta;

If[dbg, Print["removeID: meta: ", meta]];
removeMetaID[#, kind]&/@meta;

$SBML$MetaIDAssociations=Complement[$SBML$MetaIDAssociations, meta];
If[dbg, Print["removeID: $SBML$MetaIDAssociations: ", $SBML$MetaIDAssociations]];
If[dbg, Print["removeID: $SBML$MetaIDTable: ", $SBML$MetaIDTable]];
 
]; 


];
removeMetaID[id_, kind_]:= Module[{did, matches, dbg=False, sel},
did=decontextify[id];
If[!MemberQ[$SBML$MetaIDTable, stringer/@{did,kind}], 
matches = Select[$SBML$MetaIDTable, Equal[stringer[id], First[#]]&]; 
Print["Warning: "//boldRed, "removeMetaID: "//boldBlack, #[[1]]//boldBlue, " is listed as a "//boldBlack, #[[2]]//boldBlue, " and not as a "//boldBlack,  kind//boldBlue," in the symbol table."//boldBlack]&/@matches;
];


$SBML$MetaIDTable=Complement[$SBML$MetaIDTable,{ stringer/@{did,kind}}];

If[dbg, Print["removeMetaID: kind: ", kind]]; 
If[dbg, Print["removeMetaID: did: ", did]]; 

$SBML$MetaIDAssociations= Select[$SBML$MetaIDAssociations, (First[#] != did )&];
 

];
collisionCheck[id_, kind_, msg_:True]:= Module[{matches,found},
matches = Select[$SBML$IDTable, Equal[stringer[id], First[#]]&]; 
found = Length[matches]>0;
If[msg, 
Print["Error:"//boldRed,kind//boldBlue, ":"//boldBlack, id//boldBlue," collides with previously defined "//boldBlack,#[[2]]//boldBlue,":"//boldBlack,#[[1]]//boldBlue]&/@matches;
]; 
Return[matches];
];
metacollisionCheck[metaid_,id_, kind_, msg_:True]:= Module[{matches,found},
matches = Select[$SBML$MetaIDTable, Equal[stringer[metaid], First[#]]&]; 
found = Length[matches]>0;
If[msg, 
Print["Error:"//boldRed,kind//boldBlue, " metaid:"//boldBlack, metaid//boldBlue," (id="//boldBlack, decontextify[id]//boldBlue, 
") collides with previously defined "//boldBlack,#[[2]]//boldBlue," metaid:"//boldBlack,#[[1]]//boldBlue, 

" (id = "//boldBlack ,boldBlue[ decontextify[#[[1]]/.($SBML$MetaIDAssociations)]], ")"//boldBlack
]&/@matches;
]; 
Return[matches];
]


getLevel2ModelName[]:= Module[{modeloptions, modelid, modelName, meta,sbo, header},
abortIfNoTag[$SBML$Model, "model"];
modeloptions = Map[extractXMLOptions,$SBML$Model];
modelid=Map["id"/.#/.{"id"-> "Model"<>ToString[$SBML$modelcount]}&, modeloptions];
modelName=Map["name"/.#/.{"name"-> ""}&, modeloptions];
meta=Map["metaid"/.#/.{"metaid"-> ""}&, modeloptions];
sbo=Map["sboTerm"/.#/.{"sboTerm"-> ""}&, modeloptions];

If[Length[modelid]<1, 
Print["Error: "//boldRed, "no "//boldBlack, "model"//boldBlue, " found in SBML."//boldBlack];
];

Print["Error: "//boldRed, "The SBML contains multiple models.\nThe model "//boldBlack,
First[modelid]//boldBlue," will be used."//boldBlack,
"\nThe model "//boldBlack, #//boldBlue, " will be ignored."//boldBlack]&/@Rest[modelid];


modelid = First[modelid] // makeIntoValidSId;
meta = First[meta]//makeIntoValidSId;
sbo=First[sbo];

(* *)
If[SBML$CheckModelContext, 
If[MemberQ[Contexts[],modelid<>"`"],
If[!MemberQ[PreviousModelContexts,modelid<>"`"],
Print["Warning: "//boldRed, "The model id "//boldBlack,modelid//boldBlue," collides with an existing Mathematica context [this could occur if the model has been previously read during the same Mathematica session]."//boldBlack];
];
];
];
(* *) 

modelName = First[modelName]; 
saveNameIDAssociation[modelName,modelid]; 

If[saveVerboseData, 
header="Model id: "<>modelid; 
If[modelName!= "", header = "Model name: "<>modelName<>"\n"<>header]; 
If[meta!= "", header = header<>"\nModel metaid: "<>meta]; 
If[sbo!= "", header = header<>"\nModel sboTerm: "<>sbo]; 
verboseSave[header, {}, {}];
]; 



setModelContext[modelid]; 
Return[{modelid, modelName, meta}];
];


saveNameIDAssociation[name_, id_]:= Module[{},
If[((name!= "") \[And]( name!= id) \[And]( id!= "Indeterminate")), 
$SBML$NameIDAssociations=Append[$SBML$NameIDAssociations, id-> name]; 
]; 
];


getLevel2Functions[]:= Module[{f,dbg=False, getFunction,id, name,opts,args,functionDefinition,htmlfunctiondef, fdef, farg,fid,fname},

getFunction[functionXML_]:= Module[{f,math,meta,sboTerm, id, sym},

f= functionXML;
debugPrint[dbg,"getFunction: f:", f];

opts = extractXMLOptions[f];
id = "id"/.Flatten[{opts}]/.{"id"-> "Indeterminate"}; 
meta = "metaid"/.Flatten[{opts}]/.{"metaid"-> ""}; 
sboTerm="sboTerm"/.Flatten[{opts}]/.{"sboTerm"-> ""}; 

(* addID[id, "function"]; *)

id = makeIntoValidSId[id];
If[stringer[id]=="Indeterminate",
id = "function"<>ToString[MB$functioncounter++];
Print["Error: "//boldOrange,"Required function id missing from <functionDefinition../>. Assigned "//boldBlack,id//boldRed];
];

If[MB$Load,addFunction[f]];

name = "name"/.Flatten[{opts}]/.{"name"-> ""};
id = contextify[id]; 

checkForSymbolCollision[id,"function"];

debugPrint[dbg,"getFunction: {id, name}:", {id, name}];
math= Cases[f,XMLElement["math",___],3]; 
If[Length[math]>0, 
math = First[math],
Print["Error:"//boldRed, " getLevel2Functions: functionDefintion for "//boldBlack, id//boldBlue, " is missing the <math> element:\n"//boldBlack,
Sequence@@XMLHighlightForm[f,Purple, "functionDefinition"]
];
Print[f];
 Abort[]; 
]; 
debugPrint[dbg,"getFunction: math:", math];

(* 2.5.24 added the next line *)
math =checkMathMLElements[math];
 
functionDefinition = SymbolicSBMLMathMLToExpression[math];

(* 2.3.36 check for any symbols that are not arguments, and assume that they are defined somewhere in the model, such as other functions, and contextify them 
*)
sym =getSymbols[functionDefinition];

sym=Complement[sym,{ Global`t}]; 

sym=decontextify/@sym;
debugPrint[dbg,"getFunction: sym:", sym];

(* list of {XMLElement[bvar,...] } *) 
args = Cases[functionXML,XMLElement["bvar",___], Infinity]; 

(*  list of {XMLElement[ci,{},variable],... } *) 
args = Flatten[extractXMLSubElements/@args]; 
(*  list of variable names *) 
args =extractXMLSubElements/@args; 
args = ToExpression/@Flatten[args];
sym = Complement[sym,args];
sym = Map[Rule[#, contextify[#]]&, sym];

debugPrint[dbg,"getFunction: args:", args];
debugPrint[dbg,"getFunction: sym:", sym];


functionDefinition = (functionDefinition//.sym)//InputForm//ToString;
debugPrint[dbg,"getFunction: functionDefinition:", functionDefinition];
 
$SBML2$Functions = Append[$SBML2$Functions,ToExpression[id<>"->"<>functionDefinition]];
saveNameIDAssociation[name,id]; 

If[saveVerboseData,
If[!$SBML$verboseContext, id = decontextify[id]];
]; 

If[ToExpression[$SBML$Level$Version]>2.15, 
Return[{id,meta, name, functionDefinition,sboTerm}],
Return[{id,meta, name, functionDefinition}]
];
]; (* end of getFunction *) 
$SBML2$Functions = {}; 

f = Cases[$SBML$Model,XMLElement["listOfFunctionDefinitions",___],3]; 
debugPrint[dbg,"getLevel2Functions: f(1): ",f];


f= Cases[f,XMLElement["functionDefinition",___],3]; 
debugPrint[dbg,"getLevel2Functions: f(2): ",f];

f = Map[getFunction, f];
debugPrint[dbg,"getLevel2Functions: f(3): ",f];

htmlfunctiondef[z_]:=Module[{f,fdef,fid,fmeta, fname},
f=z;
fdef = f[[4]];
fid=f[[1]];
fmeta=f[[2]];
fname=f[[3]];
fdef=StringReplace[fdef,{"Function"-> ""} ];
fdef = "{"<>StringDrop[StringDrop[fdef,1],-1]<>"}";
fdef = ToExpression[fdef];
farg =fid<>"["<>StringDrop[StringDrop[ First[fdef]//stringer,1],-1]<>"]:=";
fdef = StringDrop[StringDrop[Rest[fdef]//stringer,1],-1];
fdef = farg<>fdef;
fdef = StringReplace[fdef,","-> "@COMMA"];
Return[{fname,fmeta, fdef}];
];

If[saveVerboseData,
If[ToExpression[$SBML$Level$Version]>2.15,
(* Move SBOTerm from part 5 to part 3*) 
If[Length[f]>0,
Block[{f1,f2,f3,f4,f5},
{f1,f2,f3,f4,f5} = Transpose[f];
f = Transpose[{f1,f2,f5,f3,f4}];
];
]; 


If[$SBML$OutputFormatIsHTML, 
f=htmlfunctiondef/@f;
verboseSave["Function Definitions", {"Name","MetaID","SBOTerm", "Definition (id[arguments]:=def)"}, f]
,
verboseSave["Function Definitions", {"ID", "MetaID","SBOTerm","Name", "Function Definition"}, f]
];
,
If[$SBML$OutputFormatIsHTML, 
f=htmlfunctiondef/@f;
verboseSave["Function Definitions", {"Name","MetaID", "Definition (id[arguments]:=def)"}, f]
,
verboseSave["Function Definitions", {"ID", "MetaID","Name", "Function Definition"}, f]
];

];
];

]


getLevel2units[opt___?OptionQ]:= Module[{u,
dbg=False,defaultUnitsNeeded,defaultUnitRules,checkBuiltInRedef,
specTable3={"substance"-> "mole","volume"-> "litre", "time"-> "second","area"-> "metre^2", "length"-> "metre"}, 
L2V1AllowedScalableDefaultUnits={
"substance"-> {"mole", "item"},
"volume"-> {"litre", "metre^3"},
"area"-> {"metre^2"}, 
"length"-> {"metre"},
"time"-> {"second"}
}, 
L2V2AllowedScalableDefaultUnits={
"substance"-> {"dimensionless","mole", "item", "gram", "kilogram"},
"volume"-> {"dimensionless","litre", "metre^3"},
"area"-> {"dimensionless","metre^2"}, 
"length"-> {"dimensionless","metre"},
"time"-> {"dimensionless","second"}
}, 
allowedScaling, 
builtInQuantities={"substance","volume","time","area", "length"},
builtInDefs,comment,
commonMisspellings={"meter","liter"},cms,
correctSpellings={"meter"-> "metre", "liter"-> "litre"},
getSBMLUnitDefinition,
unitDefinitions,names,defs,ids,
allowedKinds={"ampere","becquerel","candela","Celsius","coulomb","dimensionless","farad","gram","gray","henry","hertz","item","joule","katal","kelvin","kilogram","litre","lumen","lux","metre","mole","newton","ohm","pascal","radian","second","siemens","sievert","steradian","tesla","volt","watt","weber"},
unitsDefinedInThisModel,inherentKinds, unitOptions, metas
},
names={}; ids={}; defs={}; metas={};
allowedScaling=Switch[
$SBML$Level$Version,
"2.1",L2V1AllowedScalableDefaultUnits,
"2.2",L2V2AllowedScalableDefaultUnits,
"2.3",L2V2AllowedScalableDefaultUnits,  
"2.4",L2V2AllowedScalableDefaultUnits,  (* no changes here in L2V3 so use same variable *)
_, Print["Error: "//boldRed, "getLevel2Units: Table 3 Values undefined for SBML Level.Version = "//boldBlack, $SBML$Level$Version//boldBlue]
];

(* Set flags used elsewehere for checking to see if units are scaled properly*)
$ScalableUnits$Substance="substance"/.allowedScaling;
$ScalableUnits$Volume="volume"/.allowedScaling;
$ScalableUnits$Area="area"/.allowedScaling;
$ScalableUnits$Length="length"/.allowedScaling;
$ScalableUnits$Time="time"/.allowedScaling;


inherentKinds=Join[allowedKinds,builtInQuantities]; 
specTable3= unitsContextify[specTable3];
builtInQuantities=unitsContextify[builtInQuantities]; 
commonMisspellings=unitsContextify[commonMisspellings];
correctSpellings= unitsContextify[correctSpellings];
allowedKinds = unitsContextify[allowedKinds];
unitsDefinedInThisModel={};
debugPrint[dbg,"getLevel2units: inherentKinds:",inherentKinds]; 

getLevel2UnitDefinition[z_]:= Module[{opts,units,listofunits,name, unitspecs,kinds,exponents,levelVersion,scales,disallowedKinds,unitdef,unitdefinition,dbg=False,id,meta, rawid, multipliers, getUnitFields, offsets},


debugPrint[dbg,"--->getLevel2UnitDefinition:z ",z]; 
getUnitFields[x_]:= Module[{k,e,s,m,o},
k = "kind"/.x/.{"kind"-> "Indeterminate"};
k = unitsContextify[k];

e="exponent"/.x/.{"exponent"-> "1"};
s = "scale"/.x/.{"scale"-> "0"};
m="multiplier"/.x/.{"multiplier"-> "1"};

levelVersion=ToExpression[$SBML$Level$Version]; 

(* revised in version 2.9.0 to only check for 2.1 & lower vers 2.2 & higher rather than specific versions *)

If[levelVersion< 2.15,  o="offset"/.x/.{"offset"-> "0"};,
o="offset"/.x;
If[o!= "offset",
Print["Error:"//boldRed, "getLevel2Units: the "//boldBlack,
"offset"//boldBlue, " field in a unit definition is not allowed in SBML Level 2 Version 2:\n"//boldBlack,
Sequence@@XMLHighlightForm[z, Purple, "offset=\""<>o<>"\""]
];
];
o="0"; (* small letter oh = quote zero *)
If[decontextify[k]== "Celsius",
Print["Error:"//boldRed, "getLevel2Units: the value "//boldBlack,
"Celsius"//boldBlue, " is not an allowed unit kind in SBML Level 2 Version 2:\n"//boldBlack,
Sequence@@XMLHighlightForm[z, Purple, "kind=\"Celsius\""]
];
];
];
Return[{k,e,s,m,o}];
];

unitdef[{kind_, exp_, scale_,multiplier_, offset_}]:=Module[{v},
(* v=ToExpression[multiplier<>"* 10^"<>scale<>"*("<>kind<>")^"<>exp<>" +"<>offset]; *) 
(* revised version 4/25/05 v2 .4.13 based on L2v1 errata *)

v=ToExpression["("<>multiplier<>"* 10^"<>scale<>"*("<>kind<>"))^"<>exp<>" +"<>offset];

debugPrint[dbg, "\!\(\*
StyleBox[\"unitdef\",\nFontColor->RGBColor[0, 0, 1]]\): v ",v];

Return[v];
];


opts = extractXMLOptions[z];
id = "id"/.Flatten[{opts}]/.{"id"-> "Indeterminate"}; 
meta = "metaid"/.Flatten[{opts}]/.{"metaid"-> ""};

(* addID[id, "unit"]; *)

id =  makeIntoValidSId[id];
rawid=id;

id = unitsContextify[id];

checkForSymbolCollision[id,"unit"];

name = "name"/.Flatten[{opts}]/.{"name"-> ""};
If[id=="Indeterminate",
If["name"=="",
 printWarning["<unitDefinition ...> has neither an 'id' nor a 'name'."];
,
id =  unitsContextify[makeIntoValidSId[name]];
printWarning["<unit Definition ...> for unit with name=\""<>name<>"\" has no 'id' specification. An an assignment of id=\""<>id<>"\" has been performed."]; 
]; 
]; 
saveNameIDAssociation[name,id]; 

debugPrint[dbg, "getSBMLUnitDefinition: input ",z];
debugPrint[dbg, "getSBMLUnitDefinition: opts ",opts];

listofunits = Cases[z,XMLElement["listOfUnits",___],3]; 
debugPrint[dbg, "getSBMLUnitDefinition: listofunits ",listofunits];

If[Length[listofunits]>0,
units =Cases[listofunits,XMLElement["unit",___],3];
debugPrint[dbg, "getSBMLUnitDefinition: units ",units];

If[Length[units]>0, 
unitOptions = Map[extractXMLOptions,units];

unitspecs=Map[getUnitFields,unitOptions];

{kinds,exponents,scales,multipliers, offsets}=Transpose[unitspecs];

disallowedKinds=Complement[kinds,allowedKinds];

cms = Intersection[commonMisspellings, disallowedKinds]; 
If[Length[cms]>0,
kinds = kinds/.correctSpellings;
unitspecs = unitspecs/.correctSpellings;
disallowedKinds=Complement[kinds,allowedKinds];
Map[Print["Error: "//boldRed, "getLevel2UnitDefinition: Possible mispelling: "//boldBlack, "Invalid unit kind "//boldBlack, #//boldBlue, " replaced with "//boldBlack, (#/.correctSpellings)//boldBlue
]&,cms];

]; 
Print["Error: "//boldRed, "getLevel2Units: invalid unit kind "//boldBlack, decontextify[#]//boldBlue,"\n",
Sequence@@XMLHighlightForm[z, Purple, "kind=\""<>decontextify[#]<>"\""]
]&/@disallowedKinds;
,
unitOptions={};
kinds={ToString[id]/.specTable3/.{ToString[id]-> "Indeterminate"}};
exponents={"1"};  scales={"0"}; multipliers={"1"};  offsets={"0"}; 
unitspecs = Transpose[{kinds,exponents,scales, multipliers, offsets}];

Print["Error: "//boldRed, "empty "//boldBlack, "<listOfUnits>"//boldBlue," in unitDefinition:\n"//boldBlack,
Sequence@@XMLHighlightForm[z, Purple, "listOfUnits"]
];

];
debugPrint[dbg, "\!\(\*
StyleBox[\"getLevel2UnitDefinition\",\nFontColor->RGBColor[0, 0, 1]]\): unitspecs ",unitspecs];
debugPrint[dbg, "\!\(\*
StyleBox[\"getLevel2UnitDefinition\",\nFontColor->RGBColor[0, 0, 1]]\): unitOptions ",unitOptions];
debugPrint[dbg, "\!\(\*
StyleBox[\"getLevel2UnitDefinition\",\nFontColor->RGBColor[0, 0, 1]]\): kinds ",kinds];

unitdefinition=Apply[Times,Map[unitdef,unitspecs]]//InputForm//ToString;
debugPrint[dbg, "\!\(\*
StyleBox[\"getLevel2UnitDefinition\",\nFontColor->RGBColor[0, 0, 1]]\): unitdefinition ",unitdefinition];

,
unitdefinition="Indeterminate";
Print["Error: "//boldRed, "getLevel2UnitDefinition: no "//boldBlack, "listOfUnits"//boldBlue, " in unit definition:\n"//boldBlack,
Sequence@@XMLHighlightForm[z, Purple, "unitDefinition"]
]; 
];
(* check for nesting  2.4.18; l2v2 nesting removed in 2.5.26 *)
kinds=decontextify/@kinds;
debugPrint[dbg, "\!\(\*
StyleBox[\"getLevel2UnitDefinition\",\nFontColor->RGBColor[0, 0, 1]]\): kinds ",kinds];


Map[If[MemberQ[unitsDefinedInThisModel,#],
Print["Error: "//boldRed," getLevel2Units: Nested unit definitions are not permitted:\n"//boldBlack,
Sequence@@XMLHighlightForm[z, Purple, "kind=\""<>#<>"\""]
];
]&,kinds];


unitsDefinedInThisModel=Append[unitsDefinedInThisModel,rawid];
debugPrint[dbg, "getLevel2UnitDefinition: unitsDefinedInThisModel ",unitsDefinedInThisModel];

checkBuiltInRedef[id_, allowed_, formula_]:= Module[{math,allowable,did,ok},
did=unitsDecontextify[id];
math=unitsDecontextify[formula];
math=ToExpression[math];
allowable=ToExpression/@allowed;
ok=math/allowable;
ok=NumberQ/@ok;
ok=Or@@ok;
If[!ok,
Print["Error: "//boldRed, "getLevel2UnitDefinition: Invalid redefinition of built-in unit "//boldBlack, did//boldBlue, " as "//boldBlack,
math//boldBlue,
"\nAny redefinition of "//boldBlack, did//boldBlue, " must be a rescaling of "//boldBlack, allowed//boldBlue]
];
]; (* end checkBuiltInRedef *)

If[MemberQ[builtInQuantities, id],
checkBuiltInRedef[id, decontextify[id]/.allowedScaling, unitdefinition];
];

Return[{id, meta, name,unitdefinition}];
]; (* end getSBMLUnitDefinition *)



$SBML$UnitsDefined =allowedKinds;

u = Cases[$SBML$Model,XMLElement["listOfUnitDefinitions",___],3]; 

debugPrint[dbg, "getLevel2units: u(1): ",u];
u= Cases[u,XMLElement["unitDefinition",___],3]; 
debugPrint[dbg, "getLevel2units: u(2): ",u];

If[MB$Load, addUnit/@u];
debugPrint[dbg, "getLevel2units: returned from addUnit/@u "];

debugPrint[dbg, "getLevel2units: calling  \!\(\*
StyleBox[\"getLevel2UnitDefinition\",\nFontColor->RGBColor[0, 0, 1]]\) "];

unitDefinitions=Map[getLevel2UnitDefinition,u];



debugPrint[dbg, "getLevel2units: unitDefinitions ",unitDefinitions];


If[Length[unitDefinitions]>0, {ids,metas, names, defs} = Transpose[unitDefinitions];
$SBML$UnitsDefined = Join[$SBML$UnitsDefined, ids]//Union;

$SBML$UnitRules=MapThread[#1->#2&,{Map[ToExpression,ids],
Map[ToExpression,defs]}];

(* remove indeterminate rules *) 

$SBML$UnitRules = Select[$SBML$UnitRules,ToString[InputForm[Last[#]]]!= "Indeterminate"&]; 

defaultUnitsNeeded = Complement[builtInQuantities,ids];
defaultUnitRules=Map[ToExpression[#]->ToExpression[ (#/.specTable3)]&,defaultUnitsNeeded];
debugPrint[dbg,"getSBMLUnits: defaultUnitRules ",defaultUnitRules];
$SBML$UnitRules=Join[$SBML$UnitRules, defaultUnitRules];

,
(* corrected 2.3.35 to return to expressions *) 
$SBML$UnitRules= Map[Rule[ToExpression[First[#]],ToExpression[Last[#]]]&,specTable3];
];

$SBML$UnitsDefined=Join[$SBML$UnitsDefined,builtInQuantities]//Union;

builtInQuantities=ToExpression/@builtInQuantities;
builtInDefs = builtInQuantities//.$SBML$UnitRules;


If[dbg,
debugPrint[True, "getSBMLunits: $SBML$UnitRules ",$SBML$UnitRules];
debugPrint[True, "getSBMLunits: $SBML$UnitsDefined ",$SBML$UnitsDefined];
debugPrint[True, "getSBMLunits: ids ",ids];
debugPrint[True, "getSBMLunits: defs ",defs];
debugPrint[True, "getSBMLunits: builtInQuantities ",builtInQuantities];
debugPrint[True, "getSBMLunits: builtInDefs ",builtInDefs];
debugPrint[True, "getSBMLunits: $SBML$verboseBuiltInUnits ",$SBML$verboseBuiltInUnits];
]; 



If[saveVerboseData,

comment=" (Excluding Built-in Units)";
If[$SBML$verboseBuiltInUnits, 
ids = Join[ids, stringer/@builtInQuantities];
names  = Join[names, unitsDecontextify[stringer/@builtInQuantities]];
defs = Join[defs, stringer/@builtInDefs];
metas = Join[metas,Table["", {Length[builtInDefs]}]];


comment=" (Including Built-in Units)";
debugPrint[dbg, "getSBMLunits: ids ",ids];
debugPrint[dbg, "getSBMLunits: defs ",defs]; 
];

If[!$SBML$verboseContext,
ids =decontextify[ids];
defs = unitsDecontextify[defs];
]; 

verboseSave["Unit Definitions"<>comment,{"ID", "MetaID","Name", "Formula"}, Transpose[{ids,metas,  names,defs}]
];
];


Return[];
];


getLevel2compartmentTypes[]:= Module[{dbg=False,st,ids,metas, names}, 
st= Cases[$SBML$Model,XMLElement["listOfCompartmentTypes",___],3]; 

If[ToExpression[$SBML$Level$Version]<2.15,
If[Length[st]>0,
Print["Error: "//boldRed," listOfCompartmentTypes "//boldBlue, "is not supported in SBML Level "//boldBlack, $SBML$Level$Version//boldBlack];
];
Return[];
];

debugPrint[dbg,"getLevel2compartmentTypes: st(1)", st]; 
st= Cases[st,XMLElement["compartmentType",___],3]; 

debugPrint[dbg,"getLevel2compartmentTypes: st(2)", st]; 
If[MB$Load, addCompartmentType/@st];

st = Map[extractXMLOptions,st];
debugPrint[dbg,"getLevel2compartmentTypes: st(3)", st]; 

ids =makeIntoValidSId/@( Map["id"/.#/.{"id"-> ""}&, st]);
(* addID[#, "compartmentType"]&/@ids; *)

names = Map["name"/.#/.{"name"-> ""}&,st];
metas = Map["metaid"/.#/.{"metaid"-> ""}&,st];

debugPrint[dbg,"getLevel2compartmentTypes: {ids,names}:", {ids,names}]; 


ids=contextify[ids];
$SBML$CompartmentTypes=ToExpression/@ids;
checkForSymbolCollision[#,"compartmentType"]&/@ids;

MapThread[saveNameIDAssociation,{names,ids}];

If[saveVerboseData,
If[!$SBML$verboseContext,ids = decontextify[ids];];
verboseSave["CompartmentTypes",{"ID","MetaID", "Name"},Transpose[{ids,metas, names}]
]; 
]; 

];


getLevel2compartments[opt___?OptionQ]:= Module[{
c,dbg=False,ids,cids, vids, names,spatialDimensions, sizes, units,outsides, constants,ctypes,vctypes,
derivedunits,fixid, fixspatialDimensions, fixUnits, checkConstant, spatialUnits,conversionFactors, normalizedSizes,vdata,vhead, metas
},

debugPrint[dbg,"getLevel2compartments: $SBML$Model", $SBML$Model]; 
c = Cases[$SBML$Model,XMLElement["listOfCompartments",___],3]; 
debugPrint[dbg,"getLevel2compartments: c(1)", c]; 

c= Cases[c,XMLElement["compartment",___],3]; 
debugPrint[dbg,"getLevel2compartments: c(2)", c]; 

If[MB$Load, addCompartment/@c];

If[Length[c]<1  , 
ids = {""}; names = {""}; spatialDimensions={"3"} ; 
sizes={"1"}; units = {unitsContextify["volume"]};
outsides={ ""};
constants={"true"};  $SBML$NCompartments =1; 

(* this is the else clause, i.e, Length[c]>= 1 *) 
,
$SBML$NCompartments=Length[c]; 

c = Map[extractXMLOptions, c];
debugPrint[dbg,"getLevel2compartments: c(3)", c]; 

(* get information *) 

ids = Map["id"/.#/.{"id"-> ""}&, c];
vids = Map[makeIntoValidSId, ids]; 
ids = vids;

metas = Map["metaid"/.#/.{"metaid"-> ""}&, c]; 

(* addID[#, "compartment"]&/@ids; *)

checkForSymbolCollision[contextify[#],"compartment"]&/@ids;

names = Map["name"/.#/.{"name"-> ""}&,c];
spatialDimensions=Map["spatialDimensions"/.#/.{"spatialDimensions"-> "3"}&,c];
sizes = Map["size"/.#/.{"size"-> "Indeterminate"}&, c]; 
units = Map["units"/.#/.{"units"-> "Indeterminate"}&,c];
units=unitsContextify[units];

outsides = Map["outside"/.#/.{"outside"-> ""}&,c];
constants = Map["constant"/.#/.{"constant"-> "true"}&, c]; 

If[ToExpression[$SBML$Level$Version]>2.15,

ctypes=Map["compartmentType"/.#/.{"compartmentType"-> "Indeterminate"}&,c];
ctypes=Map[makeIntoValidSId,ctypes];
vctypes=contextify/@ctypes;

ctypes={contextify/@ids,vctypes}//Transpose;
ctypes=Select[ctypes, (Last[#]!= "Indeterminate")&]//ToExpression;
$SBML$CompartmentTypeAssociations=Rule@@#&/@ctypes;
Map[
If[!MemberQ[$SBML$CompartmentTypes,Last[#]],Print["Error: "//boldRed,"Compartment "//boldBlack,decontextify[First[#]]//boldBlue, " is defined as an unknown compartmentType: "//boldBlack, decontextify[Last[#]]//boldBlue]]&,
ctypes
];
];
]; 

debugPrint[dbg,"getLevel2compartments:{ids,names,spatialDimensions,sizes,units,outsides,constants}(1)",{ids,names,spatialDimensions,sizes,units,outsides,constants}]; 

(* check ids *) 

fixid[id_?StringQ, name_?StringQ, num_?IntegerQ]:= Module[{},
If[id!= "", Return[id]]; 
If[name!= "",Return[makeIntoValidSId[name]]]; 
Return["Compartment"<>ToString[num]];
]; (* end of fixid *) 

ids = MapThread[fixid, {ids, names, Range[$SBML$NCompartments]}]; 
ids = contextify[ids];
(* defineParameter[ids]; *)

debugPrint[dbg,"getLevel2compartments:{ids,names,spatialDimensions,sizes,units,outsides,constants}(2)",{ids,names,spatialDimensions,sizes,units,outsides,constants}]; 

(* save name-id associations where appropriate *) 

MapThread[saveNameIDAssociation, {names, ids}]; 

(* check spatialDimentions *) 

fixspatialDimensions[d_, id_]:= Module[{},
If[MemberQ[CharacterRange["0","3"], d], Return[d]]; 
If[d!= "" \[And] $SBML$warnings,Print["Warning: "//boldOrange,
 "Invalid spatialDimensions of "//boldBlack,
ToString[d]//boldRed," for compartment "//boldBlack,id//boldRed, " set to 3."//boldBlack]
]; 
Return["3"]; 
]; (* end fixspatialDimensions *) 
spatialDimensions = MapThread[fixspatialDimensions,{spatialDimensions,ids}]; 

debugPrint[dbg,"getLevel2compartments:{ids,names,spatialDimensions,sizes,units,outsides,constants}(3)",{ids,names,spatialDimensions,sizes,units,outsides,constants}]; 

(* check sizes *)
 
sizes = stringulate[fromEForm/@sizes];

debugPrint[dbg,"getLevel2compartments:{ids,names,spatialDimensions,sizes,units,outsides,constants}(4)",{ids,names,spatialDimensions,sizes,units,outsides,constants}]; 

(* check units *) 

fixUnits[unit_, compartment_, spatialDimensions_]:= Module[{fixed,derived,allowed,ok,dbg=False, whichallowed, conversionFactor},
allowed=unitsContextify[Switch[spatialDimensions,
"0","dimensionless",
"1", "length",
"2", "area",
"3", "volume"
]]; 

debugPrint[dbg,"getLevel2compartments: fixUnits:{unit,compartment}", {unit , compartment}];
debugPrint[dbg,"getLevel2compartments: allowed", allowed];

If[unit== "Indeterminate", 
allowed = ToExpression[allowed];
derived =allowed//.$SBML$UnitRules;
whichallowed=derived;
conversionFactor=1;
 debugPrint[dbg,"getLevel2compartments: fixUnits: Indeterminate:  {allowed, derived}: ",{allowed,derived}];
 debugPrint[dbg,"getLevel2compartments: fixUnits: Returning: {allowed,derived,whichallowed, conversionFactor}: ",{allowed,derived,whichallowed, conversionFactor}];

Return[{allowed,derived,whichallowed, conversionFactor}]
]; 
If[!MemberQ[$SBML$UnitsDefined,unit] \[And] $SBML$warnings, 
Print["Warning: "//boldOrange,
"Invalid units="//boldBlack,unit//boldRed," in compartment id="//boldBlack,compartment//boldRed," The 'units' field must refer to a previously defined unitDefinition 'id' attribute value."//boldBlack]; 
]; 
fixed = unit/.unitsContextify[{"meter"-> "metre", "liter"-> "litre"}]; 
printWarning[fixed!= unit, "Units '"<>decontextify[unit]<>"' specified for compartment '"<>compartment<>"' assumed to be '"<>decontextify[fixed]<>"'."
];

debugPrint[dbg,"getLevel2compartments: fixUnits: fixed",fixed];
debugPrint[dbg,"getLevel2compartments: fixUnits: $SBML$UnitRules", $SBML$UnitRules];
derived = ToExpression[fixed]//.$SBML$UnitRules;
debugPrint[dbg,"getLevel2compartments: fixUnits: derived",derived];
allowed=unitsContextify[Switch[spatialDimensions,
"0",{"dimensionless"},
"1", {"length", "metre"},
"2", {"area", "metre^2"},
"3", {"volume","metre^3", "litre"}
]]; 
allowed =ToExpression[ allowed]//.$SBML$UnitRules;
debugPrint[dbg,"getLevel2compartments: fixUnits: allowed", allowed];

ok = Map[{derived,#}&, allowed];
ok = Map[#[[1]]/#[[2]]&, ok];
ok = Map[NumberQ, ok];
whichallowed=Position[ok,True]; 
ok = Apply[Or, ok]; 
 debugPrint[dbg,"getLevel2compartments: fixUnits: ok: ",ok];
 
If[(!ok) \[And] $SBML$warnings, Print["Warning: "//boldRed,
"Specified units="//boldBlack,fixed//boldBlue," for compartment "//boldBlack,compartment//boldBlue," do not appear to be valid units for a compartment of spatialDimensions="//boldBlack,spatialDimensions//boldBlue," Valid units are any units derived from one of the following: "//boldBlack,list2CommaSeparatedString[Map[InputForm,allowed]//Union]//boldBlue,"-- the only units that can be derived from "//boldBlack,fixed//boldBlue," are "//boldBlack,ToString[derived]//boldBlue
]]; 
debugPrint[dbg,"getLevel2compartments: fixUnits: return value: ",{fixed,derived}];

While[ListQ[whichallowed]\[And]Length[whichallowed]>0, 
whichallowed=First[whichallowed]];
If[NumberQ[whichallowed],
whichallowed=allowed[[whichallowed]];
conversionFactor=derived/whichallowed;
,
whichallowed=Indeterminate;
conversionFactor=Indeterminate;
];

If[dbg,
Print["getLevel2compartments:fixUnits: compartment:",compartment];
Print["getLevel2compartments:fixUnits: allowed:",allowed];
Print["getLevel2compartments:fixUnits: whichallowed:",whichallowed];Print["getLevel2compartments:fixUnits: derived:",derived];Print["getLevel2compartments:fixUnits: conversionFactor:",conversionFactor];
];

Return[{fixed,derived,whichallowed, conversionFactor}]; 
]; (* end of fixUnits *) 

units = MapThread[fixUnits,{units, ids, spatialDimensions}];
{units,derivedunits,spatialUnits,conversionFactors}=Transpose[units];
normalizedSizes=(ToExpression/@sizes)*conversionFactors;


debugPrint[dbg, "getLevel2compartments: {units,derivedunits,spatialUnits,conversionFactors,normalizedSizes}",{units,derivedunits,spatialUnits,conversionFactors,normalizedSizes}];

$SBML$UnitAssociations=Join[$SBML$UnitAssociations,MapThread[Rule[ToExpression[#1], #2]&, {ids,derivedunits}]];


debugPrint[dbg,"getLevel2compartments:{ids,names,spatialDimensions,sizes,units,outsides,constants}(5)",{ids,names,spatialDimensions,sizes,units,outsides,constants}]; 

(* check constants *) 
constants = Map[If[ToUpperCase[#]=="FALSE",False,True]&,constants]; 

MapThread[definef[SBMLIC,#1,#2]&,{ids,sizes}];
MapThread[definef[SBMLIC\[UnderBracket]SI, ToExpression[#1], #2]&, {ids, normalizedSizes}]; 
cids = ToExpression/@MapThread[If[#1, #2,functionate[ #2]]&,{constants, ids}]; 
MapThread[definef[SBMLCompartmentSize,#1, #2]&, {ToExpression/@ids,(conversionFactors*cids)}]; 

checkConstant[id_, constant_]:= Module[{},
SBMLConstantQ[id]=constant;
If[constant, 
defineParameter[id]; 
addReplacementRule[id]; 
, 
defineVariable[id];
];
]; (* end of checkConstant*) 

MapThread[checkConstant, {ids,constants}];

(* check outsides *) 
outsides = Map[makeIntoValidSId, outsides]; 
outsides = Map[If[#== "", #,contextify[#]]&, outsides];
MapThread[printWarning[(#1!= "")\[And](!MemberQ[ids, #1]),
"Outside compartment \""<>#1<>"\" indicated for compartment \""<>#2<>"\ is not a known compartment."]&,  {outsides, ids}];


$SBML$CompartmentNames=names;

$SBML$Compartmentids=ids; 
$SBML$CompartmentSizes=MapThread[Symbol[#1]-> ToExpression[#2]&,{ids,sizes}]; 
$SBML$CompartmentUnits=MapThread[#1-> #2&, {ids, units}]; 
$SBML$CompartmentOutsides=outsides;
$SBML$CompartmentSpatialDimensions=MapThread[#1-> #2&, {ids,spatialDimensions}];

If[saveVerboseData,

If[!$SBML$verboseContext,
ids = decontextify[ids];
outsides = decontextify[outsides];
units = unitsDecontextify[units];
derivedunits=unitsDecontextify[derivedunits];
derivedunits = ToString/@(InputForm/@derivedunits); 
spatialUnits=stringer/@unitsDecontextify[spatialUnits];
If[ToExpression[$SBML$Level$Version]>2.15,vctypes=decontextify[vctypes]];

];

vhead={"ID","MetaID", "Name"};
If[ToExpression[$SBML$Level$Version]>2.15,AppendTo[vhead,"CompartmentType"]];
vhead=Join[vhead,
{"Dimension","Size","Units","Derived Units", "Outside","Constant"}];
 vdata={ids,metas, names};
If[ToExpression[$SBML$Level$Version]>2.15,AppendTo[vdata,vctypes]];
vdata=Join[vdata,{spatialDimensions,sizes, units,derivedunits,outsides,constants}];

If[$SBML$verboseNormalizedValues,
vhead=Join[vhead,
{"Normalized","Normalized Units"}];
vdata=Join[vdata,{normalizedSizes,spatialUnits}];
]; 
verboseSave["Compartments",vhead,Transpose[vdata]];
]; 

Return[];
];


getLevel2speciesTypes[]:= Module[{dbg=False,st,ids,metas, names}, 
st= Cases[$SBML$Model,XMLElement["listOfSpeciesTypes",___],3]; 

If[ToExpression[$SBML$Level$Version]<2.2,
If[Length[st]>0,
Print["Error: "//boldRed," listOfSpeciesTypes "//boldBlue, "is not supported in SBML Level "//boldBlack, $SBML$Level$Version//boldBlack];
];
Return[];
];

debugPrint[dbg,"getLevel2speciesTypes: st(1)", st]; 
st= Cases[st,XMLElement["speciesType",___],3]; 

debugPrint[dbg,"getLevel2speciesTypes: st(2)", st]; 
If[MB$Load, addSpeciesType/@st];

st = Map[extractXMLOptions,st];
debugPrint[dbg,"getLevel2speciesTypes: st(3)", st]; 

ids =makeIntoValidSId/@( Map["id"/.#/.{"id"-> ""}&, st]);

checkForSymbolCollision[contextify[#],"speciesType"]&/@ids;


names = Map["name"/.#/.{"name"-> ""}&,st];
debugPrint[dbg,"getLevel2speciesTypes: {ids,names}:", {ids,names}]; 

metas = Map["metaid"/.#/.{"metaid"-> ""}&,st];
metas = stringer/@metas;

ids=contextify[ids];

$SBML$SpeciesTypes=ToExpression/@ids;


MapThread[saveNameIDAssociation,{names,ids}];

If[saveVerboseData,
If[!$SBML$verboseContext,ids = decontextify[ids];];
verboseSave["SpeciesTypes",{"ID","MetaID","Name"},Transpose[{ids,metas, names}]
]; 
]; 

];


setCrossProduct[l1_, l2_]:=Module[{f},
f[x_]:= Map[{x,#}&, l2];
Return[Partition[Map[f,l1]//Flatten,2]];
];


getIDandName[opt_, def_]:= Module[{id, vid,name},
id = "id"/.opt/.{"id"-> def};
vid=makeIntoValidSId[id];
id = vid;
id = contextify[id];
defineVariable[id]; 
name ="name"/.opt/.{"name"-> ""};
saveNameIDAssociation[ name,id]; 
Return[{id,name}];
];


getLevel2species[opt___]:= Module[{dbg=False,s, getSpecies,n},


$SBML$SpeciesCompartmentAssociations={};

getSpecies[s_]:= Module[{sp,id,name,compartment,initialAmount,initialConcentration,units,boundaryCondition,charge,constant,isConcentration, isAmount,type,ok, allowedUnitNumerators, allowedUnitDenominators,sd, possibleUnits,ic, tfvalue,substanceConversion,compartmentDerivedUnits,speciesBaseUnits,speciesType,
derivedSubstanceUnits,derivedSpatialSizeUnits,check,vol,normalizedInitialAmount,
substanceUnits, spatialSizeUnits, defSpatialSizeUnits,dim,hasOnlySubstanceUnits, initialSubstanceAmount,fixCubicMetres, conversionFactor,idoft,newrule,comp, returnValue, headers, t0, cpu, t1, CPU,dbg=False,  debug=False},

t0=TimeUsed[];
If[dbg, Print["------> getSpecies:",TimeUsed[]-t0]];

debugPrint[debug, "getSpecies: s ",s]; 

fixCubicMetres[u_]:= Module[{str, s1, s2},
str=ToString[InputForm[u]];
s1 = StringPosition[str, "metre"]//Length;
s2=StringPosition[str, "litre"]//Length;
If[s1>0 \[And] s2>0,Return[(u/.{
Rule[
unitsContextify["litre"]//ToExpression, (unitsContextify["metre"]//ToExpression)^3
]})]];
Return[u];
]; (* end of fixCubicMetres *) 

tfvalue["true"]:= True;
tfvalue["false"]:= False;
tfvalue[___]:= False;

sp = extractXMLOptions[s];
If[dbg, Print["getLevel2Species: getSpecies:XML options extracted:",TimeUsed[]-t0]]; 

debugPrint[debug, "getSpecies: sp ",sp]; 


n++; 

(* getID&Name also has defineVarible in it *)
{id,name} = getIDandName[sp, "species"<>ToString[n]]; 
If[dbg, Print["getLevel2Species: getSpecies:id:", id,":",TimeUsed[]-t0]]; 
checkForSymbolCollision[id,"species"];
If[dbg, Print["getLevel2Species: getSpecies:checked for symbol collision: ",TimeUsed[]-t0]]; 


(* addID[id, "species"]; *)
If[dbg, Print["getLevel2Species: getSpecies:id added:",TimeUsed[]-t0]]; 

$SBML$Species$IDs=Append[$SBML$Species$IDs,ToExpression[id]];

(* replace option checking with getSBMLfield to allow things like "compartment"-> "compartment" etc. 5/17/04
*) 
speciesType=getSBMLfield["speciesType",s];
If[StringLength[speciesType]>0, 

speciesType=makeIntoValidSId[speciesType]; 
speciesType=contextify[speciesType]; $SBML$SpeciesTypeAssociations=Append[
$SBML$SpeciesTypeAssociations,
Rule[ToExpression[id],ToExpression[speciesType]]]; 

If[!MemberQ[$SBML$SpeciesTypes,ToExpression[speciesType]],
Print["Warning: "//boldOrange, "Species "//boldBlack,decontextify[id]//boldBlue, " is defined as an unknown speciesType "//boldBlack,decontextify[speciesType]//boldBlue];
];
];

compartment=contextify[getSBMLfield["compartment",s]];

If[decontextify[compartment]=="",
printWarning["Species \""<>id<>"\" is ="],
If[!MemberQ[$SBML$Compartmentids,compartment], 

Block[{dc}, 
dc=decontextify[compartment]; 
dc=quote[dc];

Print["Error: "//boldRed, "unknown compartment "//boldBlack,decontextify[compartment]//boldBlue," specified for species "//boldBlack, decontextify[id]//boldBlue,"\n",
Sequence@@XMLHighlightForm[s, Purple, "compartment="<>dc]
];
]; 

];



];
dim = compartment/.$SBML$CompartmentSpatialDimensions/.{compartment-> "Indeterminate"};

If[dim == "Indeterminate",
Print["Warning: "//boldRed, " Unable to determine spatial dimensions of compartment "//boldBlack, decontextify[compartment]//boldBlue ]
];

debugPrint[debug, "getSpecies: dim", dim]; 

If[SBMLConstantQ[compartment],
$SBML$SpeciesCompartmentAssociations=Append[$SBML$SpeciesCompartmentAssociations, id-> compartment];
SBMLSpeciesCompartment[functionate[id]//ToExpression]=compartment//ToExpression;

,
$SBML$SpeciesCompartmentAssociations=Append[$SBML$SpeciesCompartmentAssociations, id-> functionate[compartment]];
SBMLSpeciesCompartment[functionate[id]//ToExpression]=functionate[compartment]//ToExpression;

];

type = ""; 
initialAmount="initialAmount"/.sp/.{"initialAmount"->""};
isAmount=(initialAmount!= "");
If[isAmount,
type="initialAmount";
initialAmount = initialAmount//fromEForm//InputForm//ToString;
ic = initialAmount;
];

initialConcentration="initialConcentration"/.sp/.{"initialConcentration"->  ""};
isConcentration = (initialConcentration !="");
If[isConcentration, 
type="initialConcentration";
initialConcentration=initialConcentration//fromEForm//InputForm//ToString;
ic = initialConcentration;
];

If[((id/.$SBML$CompartmentSpatialDimensions) == "0")  \[And] isConcentration,
printWarning["Field \"initialConcentration\" setting for compartment \""<>id<>"\" ignored because the compartment has a \"spatialDimensions\"=\"0\"."];
isConcentration=False;
initialConcentration="";
type="initialAmount";
If[isAmount, ic=initialAmount, ic=$SBML$IndeterminateValue ];
]; 

If[isAmount \[And] isConcentration ,
isAmount=False; 
initialAmount= "";
type="initialConcentration";
ic = initialConcentration; 
printWarning[
"Fields \"initialAmount\" and \"initialConcentration\" are both set for species \""<>id<>"\". These fields are mutually exclusive.  \"initialAmount\" will be ignored."]; 
];

If[!(isAmount \[Or] isConcentration), 
ic = $SBML$IndeterminateValue; 
type="Indeterminate"
];

substanceUnits="substanceUnits"/.sp/.{"substanceUnits"-> "substance"};
substanceUnits=unitsContextify[substanceUnits];
derivedSubstanceUnits=ToExpression[substanceUnits]//.$SBML$UnitRules;
debugPrint[debug, "getlevel2Species: getSpecies: substanceUnits:", substanceUnits];
debugPrint[debug, "getlevel2Species: getSpecies: derivedSubstanceUnits:", derivedSubstanceUnits];
debugPrint[debug, "getlevel2Species: getSpecies: $SBML$UnitRules:", $SBML$UnitRules];

check = (derivedSubstanceUnits/(ToExpression[unitsContextify["substance"]]))//.$SBML$UnitRules;


If[debug, Print["\!\(\*
StyleBox[\"getSpecies\",\nFontColor->RGBColor[0, 0, 1]]\): check="//boldRed,check]];

If[!NumberQ[check],
(* add additional calculations 2.666 because earlier check only checks one of the
ultimate units, not all the possibilities *)
If[dbg, 
Print["$ScalableUnits$Substance:", $ScalableUnits$Substance]; 
Print["derivedSubstanceUnits:", derivedSubstanceUnits]; 
]; 

derivedSubstanceUnits=decontextify[derivedSubstanceUnits]/(ToExpression/@$ScalableUnits$Substance); 
check =Or@@( NumberQ/@derivedSubstanceUnits); 
If[dbg, 
Print["derivedSubstanceUnits:", derivedSubstanceUnits]; 
Print["check=",check]; 
]; 

If[!check, Print["Warning: "//boldRed,"species id="//boldBlack, id//boldBlue," substanceUnits = "//boldBlack,decontextify[substanceUnits]//boldBlue," derived units = "//boldBlack, derivedSubstanceUnits//boldBlue, " do not appear to simplify to units of substance."//boldBlack];
]; 

];

If[$SBML$warnings \[And] !MemberQ[$SBML$UnitsDefined, substanceUnits],
Print["Warning: "//boldRed,
"Unknown substanceUnits = "//boldBlack,decontextify[substanceUnits]//boldRed,
" specified for species "//boldBlack,id//boldRed, "\nKnown units are "//boldBlack,(decontextify/@$SBML$UnitsDefined)//boldBlack];
];


hasOnlySubstanceUnits="hasOnlySubstanceUnits"/.sp/.{"hasOnlySubstanceUnits"-> "false"};
If[!MemberQ[{"true","false"}, hasOnlySubstanceUnits], hasOnlySubstanceUnits="false"]; 

hasOnlySubstanceUnitsIndicator[ToExpression[functionate[id]]]=tfvalue[hasOnlySubstanceUnits];

spatialSizeUnits="spatialSizeUnits"/.sp/.{"spatialSizeUnits"-> "1"};
If[dbg, Print["getLevel2species: spatialSizeUnits(0):",spatialSizeUnits, ":",TimeUsed[]-t0]];
debugPrint[debug, "getSpecies: spatialSizeUnits(0): ", spatialSizeUnits];
debugPrint[debug, "getSpecies: hasOnlySubstanceUnits: ", hasOnlySubstanceUnits];

If[tfvalue[hasOnlySubstanceUnits],
debugPrint[debug, "getSpecies: spatialSizeUnits(1): ", spatialSizeUnits];

If[spatialSizeUnits!= "1",
debugPrint[debug, "getSpecies: spatialSizeUnits(2): ", spatialSizeUnits];

(* spatialSizeUnits should not be specified but were *)
Print["Warning: "//boldOrange, " spatialSizeUnits = "//boldRed,spatialSizeUnits//boldRed," may not be specified for species "//boldBlack, id//boldRed," because hasOnlySubstanceUnits = false."//boldBlack];
spatialSizeUnits="1";
];
 ,

debugPrint[debug, "getSpecies: spatialSizeUnits(3): ", spatialSizeUnits];

If[spatialSizeUnits=="1",
(*spatialSizeUnits should have been given but were not *)
defSpatialSizeUnits=((compartment/.$SBML$CompartmentUnits/.{compartment-> "Indeterminate"})//decontextify)//stringer;
debugPrint[debug, "getSpecies: defSpatialSizeUnits(1): ", defSpatialSizeUnits];

If[defSpatialSizeUnits=="Indeterminate",
defSpatialSizeUnits=Switch[dim,
"0","dimensionless",
"1","length",
"2","area",
"3","volume",
_,"Indeterminate"
]; 
];
debugPrint[debug, "getSpecies: defSpatialSizeUnits(2): ", defSpatialSizeUnits];

spatialSizeUnits="spatialSizeUnits"/.sp/.{"spatialSizeUnits"-> defSpatialSizeUnits};
If[dbg, Print["compartment:",compartment," defSpatialSizeUnits:",defSpatialSizeUnits, " spatialSizeUnits:", spatialSizeUnits];];
debugPrint[debug, "getSpecies: spatialSizeUnits(4): ", spatialSizeUnits];

];

]; 
debugPrint[debug, "getSpecies: spatialSizeUnits(5): ", spatialSizeUnits];


If[dbg, Print["getLevel2species: spatialSizeUnits(1):",spatialSizeUnits, ":",TimeUsed[]-t0]];

If[spatialSizeUnits=="1",
spatialSizeUnits="Indeterminate";
units=substanceUnits;
,
spatialSizeUnits=unitsContextify[spatialSizeUnits];
units="("<>substanceUnits<>")/("<>spatialSizeUnits<>")";
]; 
If[dbg, Print["getSpecies: units (1) :(", id,"),", units, ":",TimeUsed[]-t0]]; 

If[spatialSizeUnits!= "Indeterminate",
If[dbg,Print["getLevel2species: spatialSizeUnits,$SBML$UnitsDefined:",spatialSizeUnits,$SBML$UnitsDefined, ":",TimeUsed[]-t0]];

If[$SBML$warnings \[And] !MemberQ[$SBML$UnitsDefined, spatialSizeUnits],
Print["Error: "//boldRed,
"Unknown spatialSizeUnits = "//boldBlack,decontextify[spatialSizeUnits]//boldBlue,
" specified for species "//boldBlack,decontextify[id]//boldBlue, 
Sequence@@XMLHighlightForm[s, Purple, "spatialSizeUnits="<>quote[decontextify[spatialSizeUnits]]]];
];


derivedSpatialSizeUnits=ToExpression[spatialSizeUnits]//.$SBML$UnitRules;

check = Switch[dim,
"0",unitsContextify["dimensionless"],
"1",unitsContextify["length"],
"2",unitsContextify["area"],
"3",unitsContextify["volume"],
_,"Indeterminate"
]//ToExpression;

vol = check//.$SBML$UnitRules;

check = (derivedSpatialSizeUnits/check)//.$SBML$UnitRules; 
If[dbg,Print["check:",check, ":",TimeUsed[]-t0]];


check = fixCubicMetres[check];
If[dbg, Print["getLevel2species: check=",check, ":",TimeUsed[]-t0]];

If[!NumberQ[check],
Print["Waring: "//boldRed,"spatialSizeUnits = "//boldBlack,spatialSizeUnits//decontextify//boldBlue," for species = "//boldBlack, decontextify[id]//boldBlue, " may be incorrect for compartment "//boldBlack,
decontextify[compartment]//boldBlue, 
" which has spatialDimensions = "//boldBlack, dim//boldBlue ];
];
];

units=ToExpression[units];
If[dbg, Print["getSpecies: units (2) :(", id,"),", units, ":",TimeUsed[]-t0]]; 
derivedUnits = units//.$SBML$UnitRules ;
If[dbg, Print["getSpecies: derivedUnits(1) :(", id,"),", derivedUnits, ":",TimeUsed[]-t0]]; 
derivedUnits = fixCubicMetres[derivedUnits];

compartmentDerivedUnits=(ToExpression[compartment]/.$SBML$UnitAssociations)//.$SBML$UnitRules;

If[dbg, 
Print["getSpecies: derivedSubstanceUnits: (species=",id,"),",derivedSubstanceUnits, ":",TimeUsed[]-t0]; 
Print["getSpecies: derivedUnits (2) : (species=",id,"),",derivedUnits, ":",TimeUsed[]-t0]; 
Print["getSpecies: compartment: (species=",id,"),",compartment, ":",TimeUsed[]-t0]; 
Print["getSpecies: compartment volume: (species=",id,"),",ToExpression[compartment]/.SBMLReplacementRules, ":",TimeUsed[]-t0]; 
Print["getSpecies: compartment derived units: (species=",id,"),",compartmentDerivedUnits, ":",TimeUsed[]-t0]; 
]; 

substanceConversion=derivedSubstanceUnits/derivedUnits;


debugPrint[dbg,"ID: getSpecies: {id,name,compartment,type,ic,substanceUnits,spatialSizeUnits,units}", {id,name,compartment,type,ic,substanceUnits,spatialSizeUnits,units}]; 
definef[SBMLIC, id, ic ];


$SBML$UnitAssociations = Append[$SBML$UnitAssociations, ToExpression[id]-> derivedUnits];
debugPrintPrint[dbg,"getSpecies: $SBML$UnitAssociations:",$SBML$UnitAssociations]; 

speciesBaseUnits = ToExpression[unitsContextify["substance"]]//.$SBML$UnitRules;

If[!tfvalue[hasOnlySubstanceUnits],
speciesBaseUnits =speciesBaseUnits/vol;
];

conversionFactor=fixCubicMetres[derivedUnits/speciesBaseUnits];

If[$SBML$Normalize,
normalizedInitialAmount = ToExpression[ic]*derivedUnits/speciesBaseUnits; 
If[!tfvalue[hasOnlySubstanceUnits],
normalizedInitialAmount =normalizedInitialAmount/ToExpression[SBMLIC[compartment]];
];
normalizedInitialAmount = fixCubicMetres[normalizedInitialAmount]; 

If[dbg, Print["getSpecies: id=",id," normalizedInitialAmount=",normalizedInitialAmount, " speciesBaseUnits: ",speciesBaseUnits, ":",TimeUsed[]-t0] ]; 
 

If[NumberQ[normalizedInitialAmount],
ic = stringer[normalizedInitialAmount];
,
Print["Warning: getSpecies:"//boldOrange, "Unable to numerically normalize initial conditions for species "//boldBlack, id//boldRed," to "//boldBlack, speciesBaseUnits//boldRed, " derived initial amount = "//boldBlack, normalizedInitialAmount//boldRed];
]; 
,
normalizedInitialAmount=ic;
];

If[dbg,
Print["compartment:",compartment," sub:",tfvalue[hasOnlySubstanceUnits]," cf:", conversionFactor, ":",TimeUsed[]-t0];
];

idoft=functionate[id]//ToExpression;
comp = ToExpression[compartment]; 

If[tfvalue[hasOnlySubstanceUnits],
newrule=Rule[idoft,((idoft*conversionFactor)/SBMLCompartmentSize[comp])];
SBMLSpeciesToUnitsOfTheSpecies[idoft]=SBMLCompartmentSize[comp]/conversionFactor;
,
newrule=Rule[idoft, (idoft*conversionFactor*SBMLIC\[UnderBracket]SI[comp]/SBMLCompartmentSize[comp])]; 
SBMLSpeciesToUnitsOfTheSpecies[idoft]=1/conversionFactor;
];
SBMLSpeciesSIConcentration=Append[SBMLSpeciesSIConcentration,newrule]; 



boundaryCondition="boundaryCondition"/.sp/.{"boundaryCondition"-> "false"};
boundaryCondition=(ToUpperCase[boundaryCondition]=="TRUE");

SBMLBoundaryConditionQ[id]=boundaryCondition;

constant="constant"/.sp/.{"constant"-> "false"};
constant=(ToUpperCase[constant]=="TRUE");
SBMLConstantQ[id]=constant;

If[constant, 
defineParameter[id]; 
addReplacementRule[id]; 
(* save for later: want to add them back in as Species for SBMLNDSolve compatibility *) 
$SBML$ConstantSpecies=Append[$SBML$ConstantSpecies,id]; 
];

charge="charge"/.sp/.{"charge"-> ""};
If[charge!= "", 
printWarning[!IntegerQ[ToExpression[charge]], "Species \""<>id<>"\" charge=\""<>charge<>"\" is not an integer."];
];
If[isConcentration,
$SBML$SpeciesThatAreConcentrations=Append[$SBML$SpeciesThatAreConcentrations,id],
$SBML$SpeciesThatAreAmounts=Append[$SBML$SpeciesThatAreAmounts,id]];

cpu=TimeUsed[]-t0;
If[dbg, Print["getSpecies: ",id," cpu:",cpu]];

If[saveVerboseData, 
units = units//InputForm//ToString;
 derivedUnits=derivedUnits//InputForm//ToString; 
If[derivedUnits=="1", derivedUnits="dimensionless"];
If[!($SBML$verboseContext),
id = decontextify[id];
name = decontextify[name];
speciesType=decontextify[speciesType]; 
compartment = decontextify[compartment];
units = unitsDecontextify[units];
derivedUnits=unitsDecontextify[derivedUnits];
speciesBaseUnits=MathSBML`Private`unitsDecontextify[speciesBaseUnits]//InputForm//ToString;
];



returnValue={id,name};
If[ToExpression[$SBML$Level$Version]>2.1, returnValue=Append[returnValue,speciesType]]; 
returnValue=Join[returnValue,{compartment,
type, If[isConcentration,  initialConcentration, initialAmount],
units,derivedUnits, boundaryCondition,constant,charge, normalizedInitialAmount, speciesBaseUnits}];
Return[returnValue];

]; 
debugPrint[dbg,"getSpecies:: SBMLVariables(2)",SBMLVariables];

(* if verbose data is not being saved, no need to return anything!! *) 
Return[{}]; 

];(* end of getSpecies*) 

(* begin main source code for getLevel2species *) 

 n=0; 

s = Cases[$SBML$Model,XMLElement["listOfSpecies",___],3]; 
debugPrint[dbg,"getLevel2species:: s(1)",s];

s = Cases[s,XMLElement["species",___],3];
debugPrint[dbg,"getLevel2species:: s(2)",s];

If[MB$Load, addSpecies/@s ];

s = Map[getSpecies,s]; 
debugPrint[dbg,"getLevel2species:: s(3)",s];

SBMLBoundaryConditions=Pick[$SBML$Species$IDs,
SBMLBoundaryConditionQ[ToString[#]]&/@$SBML$Species$IDs];

If[saveVerboseData,
headers={ "ID", "Name"};
If[ToExpression[$SBML$Level$Version]>2.1, headers=Append[headers,"SpeciesType"];]; 

headers=Join[headers,{"Compartment", 
"initialType", "Value", "Units of the Species", "Derived Units of the Species", "B.C", "Constant", "Charge"}];

If[$SBML$verboseNormalizedValues,
headers=Join[headers,{"Normalized Initial Value", "Normalized Units"}];
verboseSave["Species",headers,s];,
s=Drop[#,-2]&/@s;
verboseSave["Species",headers,s];
];

]; 

If[dbg, Abort[]]; 

Return[];
];


getLevel2parameters[opt___]:= Module[
{dbg=False,p,getParameter,n, lv},

lv=ToExpression[$SBML$Level$Version]; 

getParameter[optList_]:= Module[{name, id, value,units, derivedUnits, metaid,sbo,info, constant},
n++; 
$SBML$NGlobalParameters++; 

{id,name} = getIDandName[optList, "parameter"<>ToString[n]]; 
checkForSymbolCollision[id,"parameter"];
(* addID[id, "parameter"]; *)
defineParameter[id]; 

metaid=stringer["metaid"/.optList/.{"metaid"-> ""}];
sbo=stringer["sboTerm"/.optList/.{"sboTerm"-> ""}];

value = ("value"/.optList/.{"value"-> $SBML$IndeterminateValue}); 
value = value//fromEForm;
value=If[StringQ[value], value,ToString[InputForm[value]]];

definef[SBMLIC,id, value]; 
addReplacementRule[id]; 

units = ("units"/.optList/.{"units"-> $SBML$IndeterminateValue});
units = unitsContextify[units];

$SBML$UnitAssociations = Append[$SBML$UnitAssociations, ToExpression[id]-> ToExpression[units]];

If[units!= $SBML$IndeterminateValue,
If[$SBML$warnings \[And] !MemberQ[$SBML$UnitsDefined, units],
Print["Error: "//boldRed, "Unknown units = "//boldBlack, decontextify[units]//boldBlue, " specified for global parameter "//boldBlack, decontextify[id]//boldBlue];
];
]; 

derivedUnits=ToExpression[units]//.$SBML$UnitRules;
derivedUnits=ToString[InputForm[derivedUnits]];

constant="constant"/.optList/.{"constant"-> "true"};
constant=(ToUpperCase[constant]=="TRUE");
SBMLConstantQ[id]=constant;

(* corrected 7-28-03: to reverse order of following two ifs, otherwise non-constant parameters are decontextified!! *) 

If[!constant,
defineVariable[id];
 removeReplacementRule[id];
];

If[constant,
SBMLGlobalParameters=Append[SBMLGlobalParameters,id],
SBMLGlobalParameters=Append[SBMLGlobalParameters,functionate[id]]
];

If[saveVerboseData,
If[!$SBML$verboseContext, id = decontextify[id];
units=unitsDecontextify[units];
derivedUnits=unitsDecontextify[derivedUnits];
];
]; 

If[lv>2.15, 
info={id,metaid,  sbo, name, value,units, derivedUnits, constant}, 
info={id,metaid,  name, value,units, derivedUnits, constant}
];

Return[info];
]; (* end of getParameter *)
 
$SBML$NGlobalParameters=0; 
n=0; 
p = Cases[$SBML$Model,XMLElement["listOfParameters",___],3]; 
p = Cases[p,XMLElement["parameter",___],3]; 

debugPrint[dbg,"getLevel2parameters","adding Parameters"]; 


If[MB$Load, addParameter/@p];

p = Map[extractXMLOptions,p]; 
debugPrint[dbg,"getLevel2parameters:: p(1)", p]; 

p = Map[getParameter,p]; 
debugPrint[dbg,"getLevel2parameters:: p(2)", p]; 

If[saveVerboseData,
If[lv>2.15,
verboseSave["Global Parameters", 
{"ID", "MetaID","SBOTerm",  "Name", "Value", "Units", "Derived Units", "Constant"}, p]; ,verboseSave["Global Parameters", 
{"ID", "MetaID", "Name", "Value", "Units", "Derived Units", "Constant"}, p]; 
];
]; 

Return[];
];



getLevel2InitialAssignments[opt___?OptionQ]:= Module[{c, info,getAnInitialAssignment},
getAnInitialAssignment[r_]:= Module[{math, sbo, meta, msg, symbol},




addInitialAssignment[r];

sbo=getSBMLfield["SBOTerm",r];
meta=getSBMLfield["metaid",r];
symbol=getSBMLfield["symbol",r];

subXML=extractXMLSubElements[r];

math=Cases[subXML, XMLElement["math",___],1];
math=First[math];

math=contextifyFormula[math];
math = StringReplace[math, "[t]"-> "[0]"];

(* math=XMLOut[math];
math=MathMLToInfix[math];
math = ToString[InputForm[math]]; 
*)
Return[{ToExpression[symbol], meta, sbo, ToExpression[math]}];

];(***** end getAnInitialAssignment *****)

$SBML$InitialAssignments={};
c = Cases[$SBML$Model,XMLElement["listOfInitialAssignments",___],3]; 

If[ToExpression[$SBML$Level$Version]<2.15,
If[Length[c]>0,
Print["Error: "//boldRed," listOfInitialAssignments "//boldBlue, "is not supported in SBML Level "//boldBlack, $SBML$Level$Version//boldBlack];
];
Return[];
];




c = Cases[c,XMLElement["initialAssignment",___],3]; 
info=getAnInitialAssignment/@c;

$SBML$InitialAssignments = Map[Rule[contextify[functionate[#[[1]],0]],#[[4]]]&, info];

verboseSave["Initial Assignments",{"Symbol","Metaid","SBOTerm","Formula"}, info];

]


checkMathMLElements[XMLElement["math",{opt___},formula_]]:= Module[{dbg=False,f,myXML},
myXML["ci",{z___},{id_}]:= Module[{r,v, vid},
If[id=="t", 
v = "Global`t";
,
vid = makeIntoValidSId[id,"`"]; (* don't change context delimiter, added 7/29/03 *) 
v=contextify[vid];
If[MemberQ[SBMLVariables,v],
(* v=functionate[v]; *)(* rev 2.6.2 for version 6 compatibility*)
(* this should work except that there is an ERROR in Mathematica version 6.0 *)
(*
v=XMLElement["apply",{}, {XMLElement["ci",{"type"-> "function"},{ stringer[v]}], XMLElement["ci",{},{"t"}]}];
*)
v=stringer[v]<>"$of$t$";

];
]; 
r=XMLElement["ci",{z},{v}];
Return[r];
]; 

myXML[{xmlns_, "ci"},{z___},{id_}]:= myXML["ci",{z},{id}];

(* "cn" stuff added 2.5.17 6/16/06 *)

myXML["cn",{"type"-> "real"},{x_?mantissaFormQ}]:=XMLElement["cn",{"type"-> "real"},{x}];

myXML["cn",{"type"-> "real"},{numstring_?eFormQ}]:= 
Module[{y,man,exp,instead},
{man,exp}=eForm2MantissaExponent[numstring];
instead=XMLElement["cn",{"type"-> "e-notation"},{man,XMLElement["sep",{},{}],exp}];
Print["Error: "//boldRed," exponential notation is not permitted in "//boldBlack,
XMLElement["cn",{"type"-> "real"},{numstring}]//XMLOut//boldBlue,
" Attempting recovery as "//boldBlack,
instead//XMLOut//boldBlue,
"\nNote:  This is not standard SBML. "//boldRed
];
instead=fixXMLeNotation[instead]; (* because of bug in Mathematica conversion of eformat *)
Return[instead]
];

myXML["cn",{"type"-> "real"},{numstring_?FortranEFormQ}]:= 
Module[{y,man,exp,instead},
{man,exp}=eForm2MantissaExponent[numstring];
instead=XMLElement["cn",{"type"-> "e-notation"},{man,XMLElement["sep",{},{}],exp}];
Print["Error: "//boldRed," FORTRAN-style exponential notation is not permitted in "//boldBlack,
XMLElement["cn",{"type"-> "real"},{numstring}]//XMLOut//boldBlue,
" Attempting recovery as "//boldBlack,
instead//XMLOut//boldBlue,
"\nNote:  This is not standard SBML. "//boldRed
];
instead=fixXMLeNotation[instead]; (* because of bug in Mathematica conversion of eformat *)
Return[instead]
];

myXML["cn",{"type"-> "real"},{x_}]:=Module[{instead,z},
If[StringQ[x],z=x,z=ToString[x]]; 
z=StringJoin@@Prepend[Select[Characters[z],DigitQ],"0"]//ToExpression//ToString;
instead=XMLElement["cn",{"type"-> "real"},{z}];
Print["Error:"//boldRed," invalid floating point number in "//boldBlack,
XMLOut[XMLElement["cn",{"type"-> "real"},{x}]]//boldBlue,"\nThe value has been replaced with "//boldBlack,instead//XMLOut//boldBlue," in the model. "//boldBlack,"Note that this interpretation may not conform to the intent of the original model and could produce unexpected results."//boldRed
];
Return[instead]
];

myXML["cn",{"type"-> "integer"},{x_?IntegerFormQ}]:=XMLElement["cn",{"type"-> "integer"},{x}];

myXML["cn",{"type"-> "integer"},{numstring_?mantissaFormQ}]:= 
Module[{instead},
instead=XMLElement["cn",{"type"-> "real"},{numstring}];
Print["Error: "//boldRed," real numbers are not permitted in "//boldBlack,
XMLElement["cn",{"type"-> "integer"},{numstring}]//XMLOut//boldBlue,
" Attempting recovery as "//boldBlack,
instead//XMLOut//boldBlue,
"Note that this interpretation may not conform to the intent of the original model and could produce unexpected results."//boldRed
];
Return[instead]
];

myXML["cn",{"type"-> "integer"},{numstring_?eFormQ}]:= 
Module[{y,man,exp,instead},
{man,exp}=eForm2MantissaExponent[numstring];
instead=XMLElement["cn",{"type"-> "e-notation"},{man,XMLElement["sep",{},{}],exp}];
Print["Error: "//boldRed," exponential notation is not permitted in "//boldBlack,
XMLElement["cn",{"type"-> "integer"},{numstring}]//XMLOut//boldBlue,
" Attempting recovery as "//boldBlack,
instead//XMLOut//boldBlue,
"\nNote:  This is not standard SBML. "//boldRed
];
instead=fixXMLeNotation[instead]; (* because of bug in Mathematica conversion of eformat *)
Return[instead]
];

myXML["cn",{"type"-> "integer"},{x_}]:=Module[{instead,z},
If[StringQ[x],z=x,z=ToString[x]]; 
z=StringJoin@@Prepend[Select[Characters[z],DigitQ],"0"]//ToExpression//ToString;
instead=XMLElement["cn",{"type"-> "integer"},{z}];
Print["Error:"//boldRed," invalid integer in "//boldBlack,
XMLOut[XMLElement["cn",{"type"-> "integer"},{x}]]//boldBlue,"\nThe value has been replaced with "//boldBlack,instead//XMLOut//boldBlue," in the model. "//boldBlack,"Note that this interpretation may not conform to the intent of the original model and could produce unexpected results."//boldRed
];
Return[instead]
];


myXML[z___]:= XMLElement[z]; 
f=XMLElement["math",{opt}, formula]; 
f = (f/.{XMLElement-> myXML}); 

Return[f];
];
checkMathMLElements[x___]:= Module[{dbg=True},
Print["Warning:"//boldRed,"checkMathMLElements: Invalid formula (not an XMLElement[math...]) = \n"//boldBlack,ToString[InputForm[f]]//boldBlue];
Return[f];
];


contextifyFormula[{f_}]:= contextifyFormula[f];
contextifyFormula[XMLElement["math",{opt___},formula_]]:= Module[{dbg=False,f},

debugPrint[dbg,"contextifyFormula: f(0)",formula]; 
f= XMLElement["math",{opt},formula];

debugPrint[dbg,"contextifyFormula: f(1)",f]; 
f=checkMathMLElements[f];
debugPrint[dbg,"contextifyFormula: f(2)",f]; 

If[dbg, Print["contextifyFormula: Calling SymbolicSBMLMathMLToExpression"]];
f=SymbolicSBMLMathMLToExpression[f]; 
debugPrint[dbg,"contextifyFormula: f(3)",f];

(* the following inserted version 2.3.19 *)
f=f/.{XML`MathML`Symbols`Piecewise->piecewise};
debugPrint[dbg,"contextifyFormula: f(4)",f];

f=(f//InputForm)//ToString; 
debugPrint[dbg,"contextifyFormula: f(5)",f];
Return[f];
];

contextifyFormula[XMLElement[{xmlns_, "math"},{opt___},formula_]]:=
contextifyFormula[XMLElement["math",
{{"http://www.w3.org/2000/xmlns/","xmlns"}-> xmlns},formula]];


contextifyFormula[f_]:= Module[{dbg=True},
Print["Warning:"//boldRed,"contextifyFormula: Invalid formula (not an XMLElement[math...]) = \n"//boldBlack,ToString[InputForm[f]]//boldBlue];
Return[f];
]


getLevel2rules[opt___]:= Module[{lv,
dbg=False,getRule,addODE,r },

$SBML$Algebraic$Rules={};
$SBML$Assignment$Rules={};
$SBML$Constraint$Rules={};

$SBML$NRules=0; 

lv=ToExpression[$SBML$Level$Version]; 


addODE[ODE_?StringQ]:= Module[{},
$SBML$ODES=Append[$SBML$ODES,ToExpression[ODE]];
];

addODE[x___]:= printWarning["addODE: program Error: argument must be a string: \""<>ToString[x]<>"\""];

getRule[XMLElement[type_,opts_,formula_]]:=Module[{r,form,f,fnew,v,g,metaid, isASpecies, comp,hasOnlySubstanceUnits,c,fOFv,irule,hf, sbo},
$SBML$NRules++;


debugPrint[dbg,"getRule: formula", formula];

v="variable"/.opts/.{"variable"-> ""};
debugPrint[dbg,"getRule: v", v];
sbo="sboTerm"/.opts/.{"sboTerm"-> ""}; 


form = Cases[formula,XMLElement["math",__],Infinity];
If[$SBML$warnings \[And] Length[form]<1, 
irule=XMLElement[type,opts,{XMLElement["math",{"xmlns"->"http://www.w3.org/1998/Math/MathML"},{XMLElement["cn",{"type"->"integer"},{"1"}]}]}];
Print["Error: "//boldRed,"getRule: No <math...> found in the following rule:\n"//boldBlack,
XMLPrintForm[XMLElement[type,opts,formula],Purple],
"\nAttempting to recover from the error as\n"//boldBlack,
XMLPrintForm[irule,Purple],
"\nNote: this recovery is not standard SBML and may not be correct."//boldRed
];
Return[getRule[irule]];

];
If[$SBML$warnings \[And]  Length[form]>1, form=First[form];
 Print["Warning:"//boldRed,"Multiple <math ...> blocks in same rule (type="//boldBlack,type//boldBlue,", variable="//boldBlack,v//boldBlue,"): \n"//boldBlack,
Sequence@@XMLHighlightForm[XMLElement[type,opts,formula],Purple,"<math"]

];
]; 


metaid =stringer[ "metaid"/.opts/.{"metaid"-> ""}]; 
If[metaid=="",
metaid="rule"<>ToString[MB$rulecounter++];,
MB$rulecounter++ ];
debugPrint[dbg,"getRule: metaid", metaid];
debugPrint[dbg,"getRule: form", form];


f=contextifyFormula[form];

debugPrint[dbg,"getRule: f", f];

If[$SBML$evaluateParameters,
f=ToExpression[f];
f = f//.SBMLReplacementRules;
f=ToString[InputForm[f]];
];
debugPrint[dbg,"getRule: f", f];


If[StringLength[v]>0, v=contextify[v]]; 
debugPrint[dbg,"getRule: v", v];

debugPrint[dbg,"getRule: type", type];

Switch[type,
"algebraicRule",
g="0=="<>f;
$SBML$Algebraic$Rules = Append[$SBML$Algebraic$Rules,ToExpression[g]];
,

"constraintRule",
g=f;
$SBML$Constraint$Rules=Append[$SBML$Constraint$Rules, ToExpression[g]]; 
,

"assignmentRule",

(* mod 2.3.20 - add add rule structure and treat as DAE *)

g=functionate[v]<>"=="<>f;
$SBML$Assignment$Rules = Append[$SBML$Assignment$Rules,ToExpression[g]];

If[TrueQ[$VersionNumber>= 5.0], 

(* Treat as part of DAE system in Version >= 5.0 *)

removeReplacementRule[v];
defineVariable[v];

,
(*Treat as a replacement rule in Version < 5*)
removeVariable[v];
g=v<>"->"<>f;
defineParameter[v];
SBMLIC[v]=f;
addReplacementRule[v]; 
];

,
"rateRule",
If[SBMLConstantQ[v], 



Print["Error: "//boldRed, "getRule: can not define a rate rule for "//boldBlack,decontextify[v]//boldBlue," because it is 'constant'"//boldBlack,"\n",
Sequence@@XMLHighlightForm[XMLElement[type,opts,formula],Purple,type<>" variable=\""<>stringer[decontextify[v]]<>"\""]
];
g=functionate[v<>"'"]<>"=="<>f<>" (This rule ignored because '"<>v<>"' is a Constant - This is an error in the model.)";
,

(* add in correction for concentration units: when computing the ODE from reactions, the entire right hand side of the equation will be divided by the compartment volume if this is a species with units of the species concentration. We don't want to do this for the rate rule so we need to multiply by the compartment size in advance to cancel out this correction on this term of the ODE only. v 2.5.9 16Mar06 *)

isASpecies=MemberQ[$SBML$Species$IDs,ToExpression[v]];
debugPrint[dbg,"getRule: rateRule: {v,isASpecies} ", {v,isASpecies}];
If[isASpecies,
fOFv=ToExpression[functionate[v]];
hasOnlySubstanceUnits=hasOnlySubstanceUnitsIndicator[fOFv];
debugPrint[dbg,"getRule: rateRule: hasOnlySubstanceUnits ", hasOnlySubstanceUnits];
If[Not[hasOnlySubstanceUnits],
c=SBMLSpeciesCompartment[fOFv];
fnew=ToString[c]<>"*("<>f<>")";
debugPrint[dbg,"getRule: rateRule: {c,f, fnew} ",{ c, f,fnew}];
f=fnew;
];
];

g=functionate[v<>"'"]<>"=="<>f;
defineVariable[v];


addODE[g];
];
,
_,

Print["Error:"//boldRed,"getRule: Unrecognized rule type: "//boldBlack,type//boldBlue," in the following rule:\n"//boldBlack,

Sequence@@XMLHighlightForm[XMLElement[type,opts,formula],Purple,type]
];

];
debugPrint[dbg, "getRule: saveVerboseData:", saveVerboseData]; 

r={}; 
If[saveVerboseData,
If[!$SBML$verboseContext,g=decontextify[g,$SBML$Context];];
If[lv > 2.15, 
r={metaid,sbo, type,g},
r={metaid, type, g}
]
]; 
debugPrint[dbg , "getRule: r", r]; 
Return[r];
] ; (* end of  getRule *)

getRule[x___]:= (Print["Unexpected format for rule: ", x]; Abort); 


r = Cases[$SBML$Model,XMLElement["listOfRules",___],3]; 
debugPrint[dbg,"getLevel2rules: r(1)",r];

If[Length[r]>1, 
Print["Error:"//boldRed,"getRules: Multiple 'listOfRules' found. Only the first will be used."//boldBlack]];

If[Length[r]<1,
verboseSave["Rules",{"MetaID", "Type","Formula"}, {}];
 Return[];
];

r=First[r];
r=extractXMLSubElements[r];
debugPrint[dbg,"getLevel2rules: r(2)",r];
debugPrint[dbg,"getLevel2rules: MB$Parameters(2)",MB$Parameters];

If[dbg, Print["getLevel2rules: MB$Load: "//boldRed, MB$Load//boldBlue]];


If[MB$Load, 
If[dbg,Print["getLevel2rules: Calling addRule/@r"//boldRed]];  
addRule/@r
]; 


If[dbg , Print["getLevel2rules: Model Builder loaded."]]; 

r = Map[getRule,r];

debugPrint[dbg,"getLevel2rules: r(3)",r];
debugPrint[dbg,"getLevel2rules: MB$Parameters(3)",MB$Parameters];
If[lv>2.15, 
verboseSave["Rules",{"Metaid","SBOTerm", "Type","Formula"}, r],verboseSave["Rules",{"Metaid", "Type","Formula"}, r]
];

Return[];
];


makeTF[str_?StringQ]:= Switch[ToUpperCase[str],
"TRUE",True,"FALSE",False,_, False];
makeTF[x___]:= (Print["Error: makeTF[",x,"] unrecognized argument must be a string \"true\" or \"false\""]; Abort[]);


getLevel2constraints[opt___?OptionQ]:= Module[{c, info,getConstraintInfo},
getConstraintInfo[r_]:= Module[{math, sbo, meta, msg},
addConstraint[r];
sbo=getSBMLfield["SBOTerm",r];
meta=getSBMLfield["metaid",r];
subXML=extractXMLSubElements[r];

math=Cases[subXML, XMLElement["math",___],1];
math=First[math];
math=contextifyFormula[math];


(* math=XMLOut[math];
math=MathMLToInfix[math];
math = ToString[InputForm[math]];  *)

msg = Cases[subXML, XMLElement["message",___],1];
If[Length[msg]>0, msg=msg[[1]]];

Return[{meta, sbo, math, msg}];

];(***** end getConstraintInfo *****)

$SBML$Constraints={};
c = Cases[$SBML$Model,XMLElement["listOfConstraints",___],3]; 

If[ToExpression[$SBML$Level$Version]<2.15,
If[Length[c]>0,
Print["Error: "//boldRed," listOfConstraints "//boldBlue, "is not supported in SBML Level "//boldBlack, $SBML$Level$Version//boldBlack];
];
Return[];
];


c = Cases[c,XMLElement["constraint",___],3]; 
info=getConstraintInfo/@c;

$SBML$Constraints = Map[Rule[#[[3]],#[[4]]]&, info];

info = Most/@info; (* get rid of message *)

verboseSave["Constraints",{"Metaid","SBOTerm","Formula"}, info];


];


ODEfor[var_,odes_:$SBML$ODES, timevar_:Global`t]:=Module[{ode},
ode=Cases[odes,Equal[D[var[timevar],timevar],_]];
If[Length[ode]==0, Return[0]];
If[Length[ode]>1, Print["Warning: ODEfor: multiple differential equations found for ", var]];

While[ListQ[ode], ode=First[ode]];
ode = Last[ode/.{Equal-> List}];
Return[ode]
];


getLevel2reactions[opt___]:= Module[{r, dbg=False, trace=False, i=0, reaction,lhs, rhs, vars,varpositions,DEQs,header={"ID","Name","Reaction","Parameters","Kinetic Law"},
ids, names, fasts, reactions, lps, fs,des, mods, conversionFactors, cfvars,v,s,vsm,spid, reactionContexts,myequal,reactionmetaids, reactantspecies, productspecies, parametas,parasbo,klawsbo,
selectODEs4Variables, getReaction,label, stoichiometryMatrix, unitsOfTheSpeciesCorrection
},


getReaction[XMLElement["reaction",opts_,r_]]:= Module[{id,name,reversible, fast,defaultID,
reactants,products,rspecies={},pspecies={},rstoic={},pstoic={},kineticLaw,modifiers,dbg=False,formula, localParameters,nparameters,ids,names, values,productDEQs={}, reactantDEQs={}, DEQs,rdenoms,pdenoms,productStoicRules, reactantStoicRules, stoichiometryMatrixColumn,netStoichiometry,mbe,marate,productRHS,reactantRHS,thereaction,reactionmetaid, reactantmetaids, productmetaids, modifiermetaids, 
reactantsboterms, productsboterms, modifiersboterms,reactionsboterm, parametermetaids,parametersboterms,kineticlawsboterm,sboterms,cysmbols, 
getStoichiometries, getLocalParameters, sumStoichiometryRules
},
thereaction=XMLElement["reaction",opts,r];

getStoichiometries[XMLElement[listName_,options_,stuff_]]:= Module[{species,vspecies,number,dbg=False, smath},
debugPrint[dbg,"getStoichiometries: input", XMLElement[listName, options, stuff]];
species = ("species"/.options)/.{"species"-> "Indeterminate"};
printWarning[species=="Indeterminate", 
"No 'species' name specified for reaction '"<>id<>"' '"<>listName<>"'"];
smath = Cases[stuff, XMLElement["stoichiometryMath",___]];
debugPrint[dbg,"getStoichiometries: smath(1)", smath];
number={};
If[Length[smath]>0,
smath=First[smath]; 
debugPrint[dbg,"getStoichiometries: smath(2)", smath];
smath=extractXMLSubElements[smath];
debugPrint[dbg,"getStoichiometries: smath(3)", smath];
number = Cases[smath,XMLElement["math",___]];
debugPrint[dbg,"getStoichiometries: number(1)", number];
If[Length[number]>0, number=contextifyFormula[number[[1]]],number="1"];
debugPrint[dbg,"getStoichiometries: number(1.0)", number];
,
debugPrint[dbg,"getStoichiometries: options", options];
number = "stoichiometry"/.options/.{"stoichiometry"-> "1"};
debugPrint[dbg,"getStoichiometries: number(1.A)", number];

number = ToExpression[fromEForm[number]];
debugPrint[dbg,"getStoichiometries: number(2): ", number];

];


vspecies = contextify[species//makeIntoValidSId];
debugPrint[dbg,"getStoichiometries: vspecies:", vspecies];
species = vspecies;
species = ToExpression[species];
debugPrint[dbg,"getStoichiometries: species: ", species];

(* moved into earlier if statement 2.5.3 *)
(*
number = ToExpression[fromEForm[number]];
debugPrint[dbg,"getStoichiometries: number(2): ", number];
*)

debugPrint[dbg,"getStoichiometries: {species, number} [return value]", {species,number}];

Return[{species,number}];
];(* end of getStoichiometries *)
getStoichiometries[x_]:= printWarning["Invalid argument to getStoichiometry: "<>ToString[InputForm[x]]];

getLocalParameters[x_]:= Module[{pid, pname, value,cid, units},
pid = ("id"/.x/.{"id"-> $SBML$IndeterminateValue}); 
pname = "name"/.x/.{"name"-> ""};
value="value"/.x/.{"value"-> $SBML$IndeterminateValue};
value = value//fromEForm//InputForm//ToString;(* remove embedded quotes*) 
value = StringReplace[value,"\""-> ""];

$SBML$LocalReactionParameterTable=Append[$SBML$LocalReactionParameterTable, 
{pid, decontextify[id]}

];

(* fully contextified parameter *) 
cid = contextify[pid//makeIntoValidSId,id];
defineParameter[cid]; 
definef[SBMLIC,cid, value]; 
addReplacementRule[cid]; 

units = ("units"/.x/.{"units"-> $SBML$IndeterminateValue});
units = unitsContextify[units];
$SBML$UnitAssociations = Append[$SBML$UnitAssociations, ToExpression[cid]-> ToExpression[units]];


(* locally contextify parameter *) 
cid = contextify[pid//makeIntoValidSId,decontextify[id]];

Return[(pid-> cid)];

]; (* end of getLocalParameters *)


$SBML$NReactions++;
debugPrint[dbg,"getReaction ===================== reaction #",$SBML$NReactions];
debugPrint[dbg, "getReaction: all species=",$SBML$Species$IDs]; 


defaultID="reaction_"<>ToString[$SBML$NReactions];
{id,name}=getIDandName[opts,defaultID];
(* addID[id, "reaction"]; *)
removeVariable[id];

reactionmetaid="metaid"/.opts/.{"metaid"-> ""}; 

reversible="reversible"/.opts/.{"reversible"-> "true"}; 
reversible = makeTF[reversible];
fast = "fast"/.opts/.{"fast"-> "false"}; 
fast = makeTF[fast];

reactants = Cases[r,XMLElement["listOfReactants",___]]; 
products = Cases[r,XMLElement["listOfProducts",___]]; 
kineticLaw=Cases[r,XMLElement["kineticLaw",___]];
modifiers = Cases[r,XMLElement["listOfModifiers",___]];

reactants=Cases[reactants,XMLElement["speciesReference",___],3];
products=Cases[products,XMLElement["speciesReference",___],3];
modifiers=Cases[modifiers,XMLElement["modifierSpeciesReference",___],3];

reactantmetaids = getSBMLfield["metaid", #]&/@reactants;
productmetaids = getSBMLfield["metaid", #]&/@products;
modifiermetaids = getSBMLfield["metaid", #]&/@modifiers;

reactantsboterms = getSBMLfield["sboTerm", #]&/@reactants;
productsboterms= getSBMLfield["sboTerm", #]&/@products;
modifiersboterms = getSBMLfield["sboTerm", #]&/@modifiers;




reactants = Map[getStoichiometries,reactants];
products = Map[getStoichiometries,products];
modifiers = Map[getStoichiometries,modifiers];



If[Length[reactants]>0, {rspecies,rstoic}=Transpose[reactants];
];

If[Length[products]>0, {pspecies,pstoic}=Transpose[products];
];

If[Length[modifiers]>0, modifiers = Map[First,modifiers]];

reaction = reactionForm[rspecies, rstoic,pspecies,pstoic, reversible];
debugPrint[dbg, "getReaction: reaction(reactionForm):", reaction]; 

debugPrint[dbg,"getReaction: {id,name}",{id,name}];
debugPrint[dbg,"getReaction: reactants",reactants];
debugPrint[dbg,"getReaction: products",products];
debugPrint[dbg,"getReaction: modifiers",modifiers];
debugPrint[dbg,"getReaction: kineticLaw",kineticLaw];

(* sumStoichiometryRules added 2.5.7 2-2-05 to handle files that have the same reactant or product listed more than once in the same reaction, i.e., the SBML files has A+A-> B instead of 2A-> B, etc. *)

sumStoichiometryRules[rules___?OptionQ]:= Module[{lhs,rnew, sums, vars,valuesof},
rnew=Flatten[{rules}];
lhs=First/@rnew;
vars=Union[lhs];
rnew=rnew/.{Rule-> List};
valuesof[var_]:=Plus@@( Last/@(Cases[rnew,{var,_}]));
sums=valuesof/@vars;
rnew=MapThread[Rule,{vars,sums}];
Return[rnew];
];

productStoicRules=sumStoichiometryRules[Map[Apply[Rule,#]&,products]];
reactantStoicRules =sumStoichiometryRules[ Map[Apply[Rule,#]&,reactants]];




debugPrint[dbg,"getReaction: productStoichRules",productStoicRules];
debugPrint[dbg,"getReaction: reactantStoicRules",reactantStoicRules];

netStoichiometry[x_]:= Module[{st,ls,rs},
ls = x/.productStoicRules/.{x-> 0};
rs = x/.reactantStoicRules/.{x-> 0};
st = ls-rs;
Return[st];];

stoichiometryMatrixColumn = netStoichiometry/@$SBML$Species$IDs;
debugPrint[dbg,"getReaction: net stoichiometry: ",stoichiometryMatrixColumn];
stoichiometryMatrix=Append[stoichiometryMatrix,stoichiometryMatrixColumn];


localParameters = Cases[kineticLaw,XMLElement["listOfParameters",___],3];
localParameters = Cases[localParameters,XMLElement["parameter",___],3];
localParameters=Map[extractXMLOptions,localParameters];

parametermetaids=("metaid"/.#/.{"metaid"-> ""})&/@localParameters;
parametersboterms=("sboTerm"/.#/.{"sboTerm"-> ""})&/@localParameters;

nparameters=Length[localParameters];
$SBML$NLocalParameters += nparameters;
localParameters = Map[getLocalParameters,localParameters];

debugPrint[dbg,"getReaction: localParameters",localParameters];

formula = Cases[kineticLaw,XMLElement["math",___],3];
debugPrint[dbg,"getReaction: formula(1)",formula];

Block[{}, 
XML["csymbol",_, x_]:=x;
XML[___]:= {};
csymbols = Cases[formula, XMLElement["csymbol",___], Infinity];
csymbols = csymbols/.{XMLElement-> XML}; 
csymbols=Flatten[csymbols];
debugPrint[dbg, "getReaction: csymbols: ", csymbols];
];

If[Length[formula]>0, 
formula = First[formula];
 If[nparameters>0,
(* localParameters has form k->reaction`form *)
formula = formula/.localParameters;
debugPrint[dbg,"getReaction: formula(1a)",formula];

localParameters = Map[Last,localParameters];
localParameters = contextify[localParameters];
localParameters = parameterate[localParameters]; 
debugPrint[dbg,"getReaction: localParameters",localParameters];
(* local parameters has form "model`reaction`k->value" *)
];
debugPrint[dbg,"getReaction: formula(1.9)",formula];
formula = contextifyFormula[formula];
debugPrint[dbg,"getReaction: formula(2)",formula];
If[ (nparameters>0) \[And] $SBML$evaluateParameters,
lps = Map[ToExpression,localParameters];
lps = Select[lps,ToString[ Last[#]]!="Indeterminate"&];
formula =(ToExpression[formula]/.lps);
debugPrint[dbg,"getReaction: formula(2a)",formula];
formula=ToString[InputForm[formula]]; 
debugPrint[dbg,"getReaction: formula(2b)",formula];
];

,
formula="Indeterminate";
]; 
debugPrint[dbg,"getReaction: formula(3)",formula];
If[$SBML$UseUnits, formula = ToString[InputForm[(ToExpression[formula]/.SBMLSpeciesSIConcentration)]]; ]; 
debugPrint[dbg,"getReaction: formula(4)",formula];
If[ListQ[kineticLaw],

If[Length[kineticLaw]>1, 
Print["Error: "//boldRed, "getLevel2Reaction: multiple kineticLaws in reaction:\n"//boldBlack,
Sequence@@XMLHighlightForm[thereaction,Purple,"kineticLaw"]
];
];

kineticLaw=First[kineticLaw];

];


kineticlawsboterm=getSBMLfield["sboTerm", kineticLaw];


selectODEs4Variables[q_]:= Module[{odes, varname,isvariable},

varname[ode_]:= Module[{DE},
DE = ToExpression[ode];
DE = First[DE]; 
DE = ToString[DE];
DE = StringReplace[DE,{"'[t]"-> ""}];
Return[DE];
];

isvariable[ode_]:=Module[{v},
v = varname[ode];
Return[ \[Not](MathSBML`Private`SBMLBoundaryConditionQ[v] \[Or] MathSBML`Private`SBMLConstantQ[v])]
];

Return[Select[q, isvariable]];
]; (* end of selectODEs4Variables *) 

(* calculate marate even (especially) if there is no kinetic law *)
 
debugPrint[dbg,"getReaction: pstoic",pstoic];
debugPrint[dbg,"getReaction: rstoic",rstoic];
marate = Times@@MapThread[functionate[#1]^#2&, {rspecies,rstoic}];
debugPrint[dbg,"getReaction: marate",marate];

$SBML$MassActionReactionRates=Append[$SBML$MassActionReactionRates,marate];

If[formula== "Indeterminate",
DEQs={},


If[$SBML$evaluateParameters,
formula =( ToExpression[formula]//.SBMLReplacementRules);
formula=ToString[InputForm[formula]]; 
];

debugPrint[dbg,"getReaction: pspecies",pspecies];
debugPrint[dbg,"getReaction: rspecies",rspecies];
debugPrint[dbg,"getReaction: $SBML$SpeciesThatAreConcentrations",$SBML$SpeciesThatAreConcentrations];

pdenoms = Map[If[MemberQ[$SBML$SpeciesThatAreConcentrations,#//stringer], (#//stringer)/.$SBML$SpeciesCompartmentAssociations/.{stringer[#]-> "Indeterminate"},"1"]&,pspecies ];
rdenoms = Map[If[MemberQ[$SBML$SpeciesThatAreConcentrations,#//stringer], (#//stringer)/.$SBML$SpeciesCompartmentAssociations/.{stringer[#]-> "Indeterminate"},"1"]&,rspecies ];

debugPrint[dbg,"getReaction: pdenoms",pdenoms];
debugPrint[dbg,"getReaction: rdenoms",rdenoms];


productDEQs=MapThread[functionate[ToString[#1]<>"'"]<>"== ("<>ToString[#2]<>")*("<>formula<>")/("<>#3<>")"&,{pspecies,pstoic,pdenoms}];
reactantDEQs=MapThread[functionate[ToString[#1]<>"'"]<>"==-("<>ToString[#2]<>")*("<>formula<>")/("<>#3<>")"&,{rspecies,rstoic,rdenoms}];

debugPrint[dbg,"getReaction: productDEQs",productDEQs];
debugPrint[dbg,"getReaction: reactantDEQs",reactantDEQs];

(* select only those odes that are not for constants or boundary conditions *)

DEQs= Join[productDEQs, reactantDEQs];
DEQs =selectODEs4Variables[DEQs];
DEQs=Map[ToExpression,DEQs];

If[$SBML$evaluateParameters,
DEQs = DEQs//.SBMLReplacementRules]; 


]; 

(* This is not done by default because it can sometimes take a LOT of CPU - but you can end up with things in both the numerator and denominator that SHOULD be cancelled if you don't do it*)
If[$SBMLSimplifyRateLaws, 
debugPrint[dbg,"getReaction: Cancelling ... "];
myequal[a_, b_]:= Equal[a,Cancel[b]];
DEQs=DEQs/.{Equal-> myequal};
];

debugPrint[dbg, "getReaction: DEQS (1) :", DEQs]; 
debugPrint[dbg,"getReaction: Joining ... "];

$SBML$ODES = Join[$SBML$ODES, DEQs];


(* convert local DEQs to a convenient form for printing*)
debugPrint[dbg,"getReaction: Converting ... "];
DEQs = Map[ToString[First[#]]<>"=="<>ToString[InputForm[Last[#]]]&, DEQs];
$SBML$Reactions=Append[$SBML$Reactions, reaction];
debugPrint[dbg, "getReaction: DEQS (2) :", DEQs]; 

debugPrint[dbg,"getReaction: calling checkKineticLaw."]; 
Block[{re,p,f, locals,myrule,ok},
myrule[x_,y_]:=x; 
re=stringer/@decontextify/@First/@reactants;
p=stringer/@decontextify/@First/@products;
f=StringReplace[formula,{"[t]"-> "",id<>"`"-> "",$SBML$Context-> ""}];
locals=decontextify/@ToString/@((ToExpression/@localParameters)/.{Rule->myrule}); 
ok=checkKineticLaw[
invokedBy-> "getReaction",
Global`id-> decontextify[id],
Global`reactants-> re,
Global`products-> p,
Global`modifiers->decontextify/@ modifiers,
Global`parameters-> locals,
Global`kineticLaw->ToExpression[f], 
csymbolsused-> csymbols
];
debugPrint[dbg,"getReaction: reaction is ok:",ok];
];

If[trace, Print["getReaction: ",++i,":",id,":",reaction,":",formula]];


Block[{reacts, prods},

(* reactant, modifier, and product information is returned as a triple {id, metaid, sboterm} *)

reacts=decontextify/@First/@reactants;
prods=decontextify/@First/@products;

If[ToExpression[$SBML$Level$Version]>2.15, 

reacts = Transpose[{reacts, reactantmetaids, reactantsboterms}];
prods = Transpose[{prods, productmetaids, productsboterms}]; 
modifiers = Transpose[{modifiers, modifiermetaids, modifiersboterms}];
,

reacts = Transpose[{reacts, reactantmetaids}];
prods = Transpose[{prods, productmetaids}]; 
modifiers = Transpose[{modifiers, modifiermetaids}];

]; (* end if *)

 If[dbg, 
Print["return value from getReaction:",
{"id=",id, "\nmetaid=",reactionmetaid, "\nname=", name,"\nfast=", fast,"\nreaction=",reaction,"\nreacts=",reacts, "\nprods=",prods,"\nmodifiers=", modifiers,"\nlocalParameters=", localParameters,
"\npar meta ids=",parametermetaids,"\npar sbo=",parametersboterms,
"\nformula=",formula,"\nkinetic law sbo=",kineticlawsboterm,
"\nDEQs=",DEQs}
];
]; 


Return[{id, reactionmetaid,  name, fast,reaction,reacts, prods, modifiers, localParameters,
parametermetaids,parametersboterms,
formula,kineticlawsboterm,
DEQs}]

]; (* end Block ..reacts, prods *) 

]; (* end of getReaction normal form*) 

getReaction[r__]:= Module[{},printWarning["Invalid reaction format."]; Return[r]];(* end of getReaction error form *)



$SBML$NReactions=0;
$SBML$NLocalParameters=0;
$SBML$Reactions={};
stoichiometryMatrix={};
$SBML$MassActionReactionRates={};



r = Cases[$SBML$Model,XMLElement["listOfReactions",___],3];

 
printWarning[Length[r]>1, 
"Multiple 'listOfReactions' found. Only the first will be used."];

If[Length[r]<1,verboseSave["Reactions",header, {}]; Return[];
];

r = Cases[r,XMLElement["reaction",___],3]; 
debugPrint[dbg,"getLevel2reactions: r",r];

If[MB$Load, 
MB$reactioncounter = Length[r]+1; 
addReaction/@r];

If[Length[r]<1,verboseSave["Reactions",header, {}]; 
Return[];
];

sboterms=getSBMLfield["sboTerm",#]&/@r;

r = Map[getReaction,r];
debugPrint[dbg,"getLevel2reactions: r(2)",r];

Block[{ids, formulas},
ids = First/@r;
defineVariable/@ids;
formulas = (#[[12]])&/@r;
$SBML$KineticLaws=Map[Equal[functionate[ToExpression[#[[1]]]], ToExpression[#[[12]]]]&, r]//Flatten;
]; 

$SBML$StoichiometryMatrix=Transpose[stoichiometryMatrix];

If[SBMLRead$returnMassBalanceEquations,
v=SBML$RateVectorID;
v = Array[v,Length[r]]; 
v = stringer/@v;
v = contextify/@v;
v=expressionate/@v;
debugPrint[dbg,"getLevel2reactions: v",v];
debugPrint[dbg,"getLevel2reactions: $SBML$StoichiometryMatrix",$SBML$StoichiometryMatrix];
debugPrint[dbg,"getLevel2reactions: $SBML$MassActionReactionRates",$SBML$MassActionReactionRates];

SBML$MassBalanceEquations=$SBML$StoichiometryMatrix.v;
debugPrint[dbg,"getLevel2reactions: SBML$MassBalanceEquations",SBML$MassBalanceEquations];

SBML$MassAction$Equations=$SBML$StoichiometryMatrix.(v*$SBML$MassActionReactionRates);

$SBML$MassActionVariables=functionate/@$SBML$Species$IDs;

s=stringer/@$SBML$Species$IDs;
s=Map[#<>"'"&,s];
s=expressionate/@ functionate/@s;

SBML$MassBalanceEquations=MapThread[#1==#2&,{s,
SBML$MassBalanceEquations}];
SBML$MassAction$Equations=MapThread[#1==#2&, {s, SBML$MassAction$Equations}]; 
];

$SBML$MassActionVariables=functionate/@$SBML$Species$IDs;

(* Combine ODES together *)
debugPrint[dbg, "getLevel2reactions: $SBML$ODES: precombined:\n", $SBML$ODES//Sort];

(* vars gives the unique variables *)
lhs = Map[First, $SBML$ODES];
rhs = Map[Last,$SBML$ODES];
vars = lhs//Union;

(* find positions of unique variables in entire list*) 
varpositions = Map[Position[lhs,#]&, vars];
varpositions=Map[Flatten,varpositions];

debugPrint[dbg, "getLevel2reactions: lhs:", lhs];
debugPrint[dbg, "getLevel2reactions: vars:", vars];
debugPrint[dbg, "getLevel2reactions: varpositions:", varpositions];
debugPrint[dbg, "getLevel2reactions: rhs:", rhs];

(* collect the rhs for each unique variable and add them up *)
rhs = Map[rhs[[#]]&, varpositions];
debugPrint[dbg, "getLevel2reactions: rhs:", rhs];
rhs = Map[Apply[Plus,#]&, rhs]; 
debugPrint[dbg, "getLevel2reactions: rhs:", rhs];

(* check for 0-length list, can happen if no kinetic laws anywhere *)
If[Length[vars]>0,
cfvars = ToExpression[StringReplace[ToString/@vars, "'"-> ""]], cfvars={}];

conversionFactors=(SBMLSpeciesToUnitsOfTheSpecies/@cfvars)/.SBMLReplacementRules;
If[dbg, Print["getLevel2reactions: conversionFactors:", conversionFactors," vars:",vars]]; 
If[$SBML$UseUnits,
$SBML$ODES=MapThread[ #1==(#2)(#3)&, {vars,rhs, conversionFactors}];
,
$SBML$ODES=MapThread[ #1==#2&, {vars,rhs}];
]; 

debugPrint[dbg, "getLevel2reactions: $SBML$ODES: combined\n", $SBML$ODES//Sort];

(* correct for compartment volumes if necessary *)
i=0;
unitsOfTheSpeciesCorrection[ode_]:=Module[{v,vdot, newODE,variableName,hasOnlySubstanceUnits,comp, isASpecies,Cdot,ubug=False},

debugPrint[dbg, "unitsOfTheSpeciesCorrection: "<>ToString[++i]<>":"<>stringer[First[ode]]];  

v=First[ode/.{Equal-> List}];
vdot=v;

variableName[x_'[y_]]:=x[y];
variableName[x__]:=Indeterminate;
v=variableName[v];
isASpecies=MemberQ[$SBML$Species$IDs, defunctionate[v]];
debugPrint[ubug, "getLevel2reactions: unitsOfTheSpeciesCorrection: {v,isASpecies}", {v,isASpecies}];

If[!isASpecies, 
debugPrint[dbg,"not a species: ",v];
Return[ode]];

hasOnlySubstanceUnits=hasOnlySubstanceUnitsIndicator[v];
debugPrint[ubug, "getLevel2reactions: unitsOfTheSpeciesCorrection: hasOnlySubstanceUnits",hasOnlySubstanceUnits];

If[hasOnlySubstanceUnits, 
debugPrint[db g, "hasOnlySubstanceUnits:",v]; 
Return[ode]];

comp=SBMLSpeciesCompartment[v];
cdot=ODEfor[defunctionate[comp]];
debugPrint[ubug, "getLevel2reactions: unitsOfTheSpeciesCorrection: {comp,cdot}", {comp,cdot}];

(* newODE=Equal[vdot,Last[(ode/.{Equal-> List})]/comp - cdot/comp]; *)
(* r evised 2.6.0.14 1/30/07 *)
newODE=Equal[vdot,Last[(ode/.{Equal-> List})] - cdot/comp];

debugPrint[dbg,"getLevel2reactions: newODE calculated for ",v];

debugPrint[ubug, "getLevel2reactions: unitsOfTheSpeciesCorrection:ode, newODE", {ode,newODE}];

(* Simplify/@(A==B) is the same as Simplify[a]==Simplify[B] *)
(* commented out 2.5.18 because of CPU usage for very complicated odes *)
(*
newODE=Simplify/@newODE;
*)

debugPrint[dbg,"getLevel2reactions: simplified newODE calculated for ",v];

Return[newODE];
]; (* end of unitsOfTheSpeciesCorrection *)

(* apply the correction *)
(* *)
 $SBML$ODES=unitsOfTheSpeciesCorrection/@$SBML$ODES;


debugPrint[dbg, "getLevel2reactions: $SBML$ODES: corrected\n", $SBML$ODES//Sort//TableForm];

(* process verbose reaction information *) 

If[saveVerboseData,
label="Reactions";
{ids, reactionmetaids, names, fasts, reactions, reactantspecies, productspecies, mods,lps,parametas,parasbo, fs,klawsbo,des}=Transpose[r];

If[!$SBML$verboseContext,
ids = decontextify[ids];
lps = decontextify[lps,$SBML$Context];
reactions = decontextify[reactions, $SBML$Context];
mods = decontextify[mods, $SBML$Context];
(* mods = list2CommaSeparatedString[mods]; *)

lps = MapThread[decontextify[#2,#1<>"`"]&, {ids,lps}];

fs= decontextify[fs, $SBML$Context];
fs = MapThread[decontextify[#2,#1<>"`"]&, {ids,fs}];

des = decontextify[des, $SBML$Context];
des = MapThread[decontextify[#2,#1<>"`"]&, {ids,des}];

label = label<>", contexts suppressed";

];

If[ToExpression[$SBML$Level$Version]>2.15, 
r={ids, reactionmetaids,sboterms, names,fasts,reactions,reactantspecies, productspecies,  mods};
header={"ID","MetaID","SBOTerm", "Name", "Fast","Reaction","Reactants\nID MetaID SBOTerm", "Products\nID MetaID SBOTerm", "Modifiers\nID MetaID SBOTerm"};
,  
r={ids, reactionmetaids, names,fasts,reactions,reactantspecies, productspecies,  mods};
header={"ID","MetaID", "Name", "Fast","Reaction","Reactants\nID MetaID", "Products\nID MetaID", "Modifiers\nID MetaID"};
]; 

If[$SBML$ShowReactionParameters,
(* following line added 2.3.19 to get reaction parameters to print as equals and not arrows *)
lps=(StringReplace[#,{"\[Rule]"-> "=" }]&/@#&)/@lps;




If[ToExpression[$SBML$Level$Version]>2.15, 
lps =Transpose/@Transpose[ {lps, parametas, parasbo}]; (* include also sbo & metaids 2.5.27*)
header=Append[header,"Parameters\nID=val MetaID SBOTerm"];
,  
lps =Transpose/@Transpose[ {lps, parametas}]; (* include also metaids 2.5.27*)
header=Append[header,"Parameters\nID=val MetaID"];
]; 
r=Append[r,lps];



];
If[$SBML$shortenODES , label=label<>", shortened."];
If[$SBML$KineticLaw,

If[$SBML$shortenODES ,
fs=Map[Short[ToExpression[#]]&, fs]
]; 


If[ToExpression[$SBML$Level$Version]>2.15, 
header=Append[header,"Formula\nSBOTerm"];
r=Append[r,Transpose[{fs, klawsbo}]];
,  
header=Append[header,"Formula\n(Substance/Volume)"];
r=Append[r,fs];
]; 


];

(* 
r=Append[r,des];
header=Append[header,"Contribution to ODEs"]; 
*)

verboseSave[label,header, Transpose[r]]; 
];

If[saveVerboseData,
label = "Differential Equations";
DEQs=$SBML$ODES;
If[$SBML$shortenODES ,
DEQs = Map[ToString[First[#]]<>"=="<>ToString[Short[InputForm[Last[#]]]]&,DEQs];
label = label<>", short form";
 ,
DEQs = Map[ToString[First[#]]<>"=="<>ToString[InputForm[Last[#]]]&,DEQs];
];
If[!$SBML$verboseContext,
(* remove global context *)

DEQs=decontextify[DEQs, $SBML$Context];

(* remove local contexts *)

reactionContexts=#<>"`"&/@ids;
While[Length[reactionContexts]>0,
DEQs=decontextify[DEQs, First[reactionContexts]];
reactionContexts=Rest[reactionContexts];
];
 
label=label<>", contexts suppressed";
];

vars = Map[ToString,vars];
vars = Map[decontextify,vars];
vars = Map[StringReplace[#,"'[t]"-> ""]&, vars]; 
verboseSave[label, 
{"Variable", "ODEs"},{vars,DEQs}//Transpose]; 
];

If[saveVerboseData,
If[$SBML$VerboseStoichiometry,
If[!$SBML$verboseContext,$SBML$Species$IDs=decontextify[$SBML$Species$IDs,$SBML$Context]]; 
vsm=Transpose[$SBML$StoichiometryMatrix];
vsm=Prepend[vsm,$SBML$Species$IDs]//Transpose;
verboseSave["Stoichiometry Matrix based on Reaction Stoichiometries",Prepend[ids,"Species"],vsm];
];

If[$SBML$Verbose$MassBalanceEquations,
mbe = SBML$MassBalanceEquations;
If[!$SBML$verboseContext,mbe=decontextify[mbe,$SBML$Context]]; 
mbe = ToString/@mbe;
mbe ={$SBML$Species$IDs,mbe}//Transpose;

verboseSave["Mass Balance Equations based on Stoichiometry Matrix",{"Species","[Species'[t]]=[Stoichometries][rates]"},mbe];
];

If[$SBML$Verbose$MassActionEquations,
spid = ToString/@(First/@SBML$MassAction$Equations);
mbe =Last/@ SBML$MassAction$Equations;
If[!$SBML$verboseContext,mbe=decontextify[mbe,$SBML$Context]]; 
mbe = ToString/@InputForm/@mbe;
mbe = MapThread[#1<>"=="<>#2&,{spid,mbe}]; 

mbe ={$SBML$Species$IDs,mbe}//Transpose;

verboseSave["Mass Action Equations based on Stoichiometry Matrix",{"Species","[Species'[t]]=[Stoichometries][mass-action-rates]"},mbe];
];


];

Return[];

];



checkParameterShadowing[]:=Module[{gpar,collisions},
gpar = Select[$SBML$IDTable, Last[#]=="parameter"&];
gpar =Complement[Flatten[gpar], {"parameter"}];
collisions = Select[$SBML$LocalReactionParameterTable, MemberQ[gpar,#[[1]]]&];
Print["Warning:"//boldRed, " local parameter "//boldBlack,#[[1]]//boldBlue, " in reaction "//boldBlack, #[[2]]//boldBlue, " shadows a global parameter with the same id."//boldBlack]&/@collisions;
]


check4MissingODES[]:= Module[{v,o,varsWithoutODEs, ODEsWithoutVars},
o=Map[First,MathSBML`Private`$SBML$ODES];

v=MathSBML`Private`SBMLVariables;
v=Map[ToExpression[ToString[#]<>"'"<>"[t]"]&,v];

varsWithoutODEs= Complement[v, o];
ODEsWithoutVars = Complement[o,v];


If[Length[varsWithoutODEs]>0,
printWarning["The following variables are specified in the model but do not have differential equations specified: "<>list2CommaSeparatedString[varsWithoutODEs]];
];

If[Length[ODEsWithoutVars]>0,
printWarning["The following variables have differential equations but are not specified as species or parameters in the model: "<>list2CommaSeparatedString[ODEsWithoutVars]];
];
];


addDummyODE[id_?StringQ]:= Module[{dummyODE},

dummyODE=StringReplace[functionate[id],"["-> "'["]<>"==0";

$SBML$ODES=Append[$SBML$ODES, ToExpression[dummyODE]]]


getLevel2events[]:= Module[{e,title="Events",header,

dbg=False, getEvent},


If[ToExpression[$SBML$Level$Version]>2.15,
header = {"ID", "MetaID","SBOTerm","Name", "Trigger","Delay","TimeUnits","Event\nAssignment", "Assignment\nMetaID", "Assignment\nSBOTerm"},
header = {"ID", "MetaID","Name", "Trigger","Delay","TimeUnits","Event\nAssignment", "Assignment\nMetaID"}
]; 


getEvent[XMLElement["event",opt_,ev_]]:= Module[{id, metaid,sboterm,name,defaultID,trigger, delay, timeUnits, eventAssignment,eventAssignmentMetaids, eventAssignmentSBOTerms, dbg = False,  getEventAssignment },
$SBML$NEvents++;
debugPrint[dbg,"getLevel2events: getEvent: ---------------------------event number: ", $SBML$NEvents];
defaultID="event_"<>ToString[$SBML$NEvents];
{id,name}=getIDandName[opt,defaultID];
checkForSymbolCollision[contextify[id],"event"];
(* addID[id, "event"]; *)
removeVariable[id];
debugPrint[dbg,"getLevel2events: getEvent: {id,name}",{id,name}]; 

metaid="metaid"/.opt/.{"metaid"-> ""}; 
sboterm="sboTerm"/.opt/.{"sboTerm"-> ""}; 

trigger = Cases[ev, XMLElement["trigger",___]];
delay = Cases[ev, XMLElement["delay",___]];
timeUnits="timeUnits"/.opt/.{"timeUnits"-> (unitsContextify["time"]//.$SBML$UnitRules)};
eventAssignment=Cases[ev,XMLElement["listOfEventAssignments",___]];

(* *********** Process Trigger ********** *)
debugPrint[dbg,"getLevel2events: getEvent:trigger",trigger]; 
If[Length[trigger]>1,
printWarning["Multple triggers specified for event '"<>id<>"'; all triggers except for the first one were ignored."];
,
If[Length[trigger]<1, "No trigger found for event '"<>id<>"'"]; 
];
If[Length[trigger]>0,
trigger = First[trigger];
trigger = extractXMLSubElements[trigger];
If[Length[trigger]>0, 
trigger=First[trigger];
debugPrint[dbg,"getLevel2events: getEvent:trigger formula",trigger]; 
 trigger = contextifyFormula[trigger];
,
trigger = "False";
];
, 
trigger="False";
]; 
debugPrint[dbg,"getLevel2events: getEvent:trigger formula",trigger]; 

(* ********* Process Delay ********* *)

debugPrint[dbg,"getLevel2events: getEvent:delay",delay]; 
If[Length[delay]>1,
printWarning["Multple delay fields specified for event '"<>id<>"'; all delay fields except for the first one were ignored."];
];

If[Length[delay]>0,
delay = First[delay]; 
delay = extractXMLSubElements[delay];
If[Length[delay]>0, 
delay = contextifyFormula[delay];,
delay = "0";
]; 
,
delay = "0"
];
debugPrint[dbg, "getLevel2events: getEvent: delay formula", delay]; 

(********* process timeUnits *********)

debugPrint[dbg,"getLevel2events: getEvent:timeUnits",timeUnits]; 

(*********** process event assignments **********)

debugPrint[dbg,"getLevel2events: getEvent:listOfEventAssignments",eventAssignment]; 
If[Length[eventAssignment]>1,
printWarning["Multple listOfEventAssignments specified for event '"<>id<>"'; all listOfEventAssignments except for the first one were ignored."];
,
If[Length[listOfEventAssignments]<1, "No listOfEventAssignments found for event '"<>id<>"'"]; 
];
If[Length[eventAssignment]>0,
eventAssignment = First[eventAssignment];
eventAssignment = extractXMLSubElements[eventAssignment];
eventAssignment = Cases[eventAssignment, XMLElement["eventAssignment",___]];



getEventAssignment[XMLElement["eventAssignment",evopt_, formula_]]:= Module[{v},
f=formula;

f = Cases[f, XMLElement["math",___]];

debugPrint[dbg,"getEventAssignment:evopt",evopt]; 
debugPrint[dbg,"getEventAssignment:f",f]; 

v = contextify["variable"/.evopt];
debugPrint[dbg,"getEventAssignment:v",v]; 
If[Length[f]>0,
f= First[f];
debugPrint[dbg,"getEventAssignment:f",f]; 
f= contextifyFormula[f];
debugPrint[dbg,"getEventAssignment:f",f]; 
,
printWarning["No formula specified for event assignment,even id="<>id<>" variable=",v];
f="Indeterminate";
];
debugPrint[dbg,"getEventAssignment:f",f];


f = functionate[v]<>"->"<>f;
Return[f]; 
]; 
getEventAssignment[x___]:= Module[{},
printWarning["Incorrectly formatted eventAssignment="<>ToString[x]];
]; (* end of getEventAssignment *) 

eventAssignmentMetaids=Map[getSBMLfield["metaid",#]&, eventAssignment];
eventAssignmentSBOTerms=Map[getSBMLfield["sboTerm",#]&, eventAssignment]; 


eventAssignment = Map[getEventAssignment, eventAssignment]; 


debugPrint[dbg,"getLevel2events: getEvent:eventAssignments",eventAssignment]; 


];


$SBML$Events = Append[$SBML$Events,
id-> {"trigger"-> trigger,"delay"-> delay,"events"-> eventAssignment}
];
If[saveVerboseData,
If[!$SBML$verboseContext,
id = decontextify[id];
trigger = decontextify[trigger, $SBML$Context];
timeUnits = decontextify[timeUnits];
eventAssignment=decontextify[eventAssignment, $SBML$Context];
delay = decontextify[delay, $SBML$Context];
];

If[$SBML$OutputFormatIsHTML,
trigger=StringReplace[trigger,","-> "@COMMA"];
eventAssignment=StringReplace[#,","-> "@COMMA"]&/@eventAssignment;
];
];
If[ToExpression[$SBML$Level$Version]>2.15, 
Return[{id,metaid,sboterm, name, trigger, delay,timeUnits, eventAssignment, eventAssignmentMetaids, eventAssignmentSBOTerms}],
Return[{id,metaid, name, trigger, delay,timeUnits, eventAssignment, eventAssignmentMetaids}]
];
];(* end of getEvent *)

$SBML$Events = {}; 
$SBML$NEvents=0;

e= Cases[$SBML$Model,XMLElement["listOfEvents",___],3]; 
printWarning[Length[e]>1, 
"Multiple 'listOfEvents' found. Only the first will be used."];

If[Length[e]<1,verboseSave[title,header, {}]; Return[];
];

e= Cases[e,XMLElement["event",___],3]; 
debugPrint[dbg,"getLevel2events: e",e];

If[MB$Load, 
MB$Events++; 
addEvent/@e];

e = Map[getEvent, e];
debugPrint[dbg,"getLevel2events: e",e];


If[saveVerboseData,verboseSave[title,header, e]; 

];

];



Biomodels$Database$URL="http://www.ebi.ac.uk/compneur-srv/biomodels/models-main/publ/"; 

getBiomodel[n_?IntegerQ, opt___?OptionQ]:= Module[{model, name}, 
name = ToString[n];
While[StringLength[name]<10, name = "0"<>name]; 
name = Biomodels$Database$URL<>"BIOMD"<>name<>".xml";
Print["Reading ", name]; 
model = Import[name, "XML"];
model=SBMLRead[model, opt]; 
Return[model];
];
getBiomodel[x___]:= (Print["Expecting getBiomodel[integer model number]"]; Return[$Failed]);


LTPrint["Level 2 support loaded."]
