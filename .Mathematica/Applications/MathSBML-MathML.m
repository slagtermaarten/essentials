(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



piecewise[XML`MathML`Symbols`Piece[ ifclause_,test_], XML`MathML`Symbols`Otherwise[elseclause_]]:= System`If[test, ifclause, elseclause];
piecewise[XML`MathML`Symbols`Piece[ifclause_, test_]]:= System`If[test, ifclause];
piecewise[XML`MathML`Symbols`Piece[ifclause_, test_],otherpieces__,  XML`MathML`Symbols`Otherwise[elseclause_]]:= Module[{therest,f,returnvalue},
therest = piecewise[otherpieces,  XML`MathML`Symbols`Otherwise[elseclause]];
returnvalue=f[test,ifclause,therest];
Return[returnvalue/.{f-> System`If}]
];



piecewiseIf[x___]:= if2piecewise[If[x]];
if2piecewise[If[a_,b_]]:= XML`MathML`Symbols`Piecewise[XML`MathML`Symbols`Piece[a,b]];
if2piecewise[If[a_,b_, If[c__]]]:= Module[{d},
d=if2piecewise[If[c]];
XML`MathML`Symbols`Piecewise[XML`MathML`Symbols`Piece[a,b,d]]//Return
];
if2piecewise[If[a_,b_,c_]]:= XML`MathML`Symbols`Piecewise[XML`MathML`Symbols`Piece[a,b],
XML`MathML`Symbols`Otherwise[c]];


SymbolicSBMLMathMLToExpression[q_]:= Module[{XML,r,
dbg=False},
If[dbg,Print["SymbolicSBMLMathMLToExpression: q:",q]];
XML["csymbol",
{"encoding"->"text","definitionURL"->csymbolTimeURL},{x_}]:= (If[dbg,Print["csymbol: ",x]];XMLElement["ci",{},{"Global`t"}]);
XML["csymbol",
{"definitionURL"->csymbolTimeURL, "encoding"->"text"},{x_}]:= (If[dbg,Print["csymbol: ",x]];XMLElement["ci",{},{"Global`t"}]);
XML[x___]:= (If [dbg,Print["XML:x:",x]];XMLElement[x]); 
r=(q/.{XMLElement-> XML});
If[dbg,Print["SymbolicSBMLMathMLToExpression: r(1):",r]];

checkNames[r]; 

r = XML`MathML`SymbolicMathMLToExpression[r];
If[dbg,Print["SymbolicSBMLMathMLToExpression: r(2):",r]];

(* bug fix for Mathematica Version 6.0 xml bug *)

r=ToExpression[StringReplace[stringer[r], {"$of$t$"-> "[t]"}]];



Return[r];
]


checkNames[xml_]:= Module[{ci,ciG,  varname, varvals, contexts,globalnames, globalvals, mathnames,mathvals,  dbg=False, globaldup, mathdup},
varname["ci", _, {x_}]:= x;  
varname[x___]:= $Failed; 
ci = Cases[xml, XMLElement["ci", ___], Infinity]; 
ci = ci/.{XMLElement-> varname}; 
ci = Union[ci]; 
If[dbg, Print["checkNames: ci(1):" , ci]]; 
ci = decontextify/@ci;
If[dbg, Print["checkNames: ci(2):" , ci]]; 

globalnames=Names["Global`*"]; 
globalnames = Intersection[ci, globalnames]; 
globalvals  =ToString[ ToExpression[#]]&/@globalnames; 
globaldup=MapThread[#1 != #2& ,{globalnames, globalvals} ];
globaldup = Pick[globalnames, globaldup]; 

mathnames = Names["MathSBML`*"]; 
mathnames=Intersection[ci, mathnames];
mathvals = ToString[ToExpression[#]]&/@mathnames;  
mathdup=MapThread[#1 != #2& ,{mathnames, mathvals} ];
mathdup = Pick[mathnames, mathdup]; 

If[dbg, Print[
"checknames: globalnames: ", globalnames, 
"\nchecknames: globalvals: ", Short[globalvals], 
"\nchecknames: globaldup: ", globaldup, 
"\nchecknames: mathnames: ", mathnames,
"\nchecknames: mathvals: ", Short[mathvals], 
"\nchecknames: mathdup: ", mathdup
]]; 

Print["Warning: "//boldRed, "possible conflict of "//boldBlack, ("Global`"<>#)//boldBlue, " with "//boldBlack, identifyID[#]//boldBlue, " ", #//boldBlue, "\nAttempting recovery via "//boldBlack,("Clear["<>#<>"]")//boldBlue,  "  (may produce unexpected results) ..."//boldBlack ]&/@globaldup;
ToExpression [Clear[#]]&/@globaldup;

Print["Warning: "//boldRed, "possible conflict of "//boldBlack, ("MathSBML`"<>#)//boldBlue, " with "//boldBlack, identifyID[#]//boldBlue, " ", #//boldBlue, "\nAttempting recovery via "//boldBlack,("Clear["<>#<>"]")//boldBlue,  " (may produce unexpected results) ..."//boldBlack ]&/@mathdup;
ToExpression[Clear[#]]&/@mathdup;


Return[];

ciG= contextify[#, "Global"]&/@ci; 
If[dbg, Print["checkNames: ciG:" , ciG]]; 

varvals = ToString[ToExpression[#]]&/@ciG; 
varvals = Not/@MapThread[Equal, {varvals, ci}]; 
varvals = Pick[ci, varvals];
contexts =ToString/@( Context/@varvals);

If[dbg, Print["checkNames: varvals:" , varvals, "\ncheckNames: contexts: ", contexts]]; 

(* turn off checking of variables like modelContext`B$of$t$ *)
varvals=Select[varvals, (ToString[Context[#]]=="Global`" \[Or]  ToString[Context[#]]=="MathSBML`")&]; 
contexts = ToString/@( Context/@varvals); 

If[dbg, Print["checkNames: varvals:" , varvals]]; 


MapThread[Print["Warning: "//boldRed,identifyID[#1]//boldBlue, " ", #1//boldBlue, " conflicts with "//boldBlack,(#2<>#1)//boldBlue, "which may cause unexpected results. Use "//boldBlack,("Clear["<> #2<>#1<>"]")//boldBlue, " to avoid unexpected conflicts with this variable. The previous\nAttempting auto-recovery ... this may also cause unexpected results. The following previous value will be cleared:\n "//boldBlack, Short[ToExpression[#2<>#1]]//boldBlue ]&, {varvals, contexts}]; 

(* ToExpression[Clear[#]]&/@varvals; *)
]; 


LTPrint["Loaded Special MathML Support"];
