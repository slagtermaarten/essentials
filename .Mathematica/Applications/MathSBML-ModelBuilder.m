(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



If[$$LoadBug, Print["Loading: Model Builder"]];


(* 
MathMLToInfix[mathml_]:= Module[{s},
s =XML`MathML`MathMLToExpression[mathml]; 
Return[s];
];
*)

MathMLToInfix[mathml_]:= Module[{s,xmlelment,xmlobj},

xmlelement["cn",{"type"->"e-notation"},{m_,XMLElement["sep",{},{}],exp_}]:= 
XMLElement["apply",{},{XMLElement["times",{},{}],XMLElement["apply",{},{XMLElement["power",{},{}],XMLElement["cn",{"type"->"integer"},{"10"}],XMLElement["ci",{},{exp}]}],XMLElement["ci",{},{m}]}];
xmlelement[x___]:= XMLElement[x];

xmlobj["Document"][{},XMLElement[u___],{}]:= XMLElement[u];

s=ImportString[mathml, "SymbolicXML"];
s= s/.{XMLElement-> xmlelement}; 
s=s/.{XMLObject-> xmlobj};

s =XML`MathML`SymbolicMathMLToExpression[s]; 
Return[s];
];


InfixToMathML[infix_]:= Module[{s},
s = XML`MathML`ExpressionToMathML[infix, "Formats"-> {"ContentMathML"}]; 
Return[s];
];


sbmlBoolean[x_]:= Module[{y},
If[x, Return["true"]]; 
y=ToUpperCase[If[StringQ[x], x, ToString[x]]]; 
Return[If[y=="TRUE", "true", "false"]]; 
];


expression2SBML[x__]:= Module[{s},
s = expression2SymbolicSBML[x]; 
s = ExportXMLString[s];
Return[s];
];


reactionToSymbolicSBML[opts___?RuleQ]:= Module[{id, name, reactants, reactantStoichiometry, products, productStoichiometry, modifiers, kineticLaw,parameters, reversible, fast, timeUnits, substanceUnits, reaction, getrp, dbg=True, i, plus,opt,ann,notes,mann,pann,rann,metaid,mnotes,pnotes,rnotes,mmetaids,rmetaids,pmetaids,rsbos, msbos, psbos, sboTerm, n,ksbo,klawmetaid, padNull, getListData, getStringData},

padNull[list_, n_]:= Module[{modifiedList},
modifiedList = list;
While[Length[modifiedList]<n,
modifiedList = Append[modifiedList,{}];
];
Return[modifiedList];
]; (* end of padNull *)

opt=Flatten[{opts}]; 
(* the reaction could be the first option and need to filter this out before checking*)
(* 
checkOptions[reactionToSymbolicSBML, opt, 
{"annotation","fast","id","kineticLaw","kineticLawmetaid", "kineticLawSBOTerm","metaid","modifiers","modifierSBOTerms","name","notes","parameters","productmetaids","products","productSBOTerms","productStoichiometry","reactantmetaids","reactants","reactantSBOTerms","reactantStoichiometry","reaction","reversible","sboTerm","substanceUnits","timeUnits"} ];
*)

dbg = Global`debug/.opt/.{Global`debug-> False};

ann = {Global`annotation/.opt/.{Global`annotation-> {}}}//Flatten//optionToAnnotation;
notes = {Global`notes/.opt/.{Global`notes-> {}}}//Flatten//stringToNotes;

debugPrint[dbg,"reactionToSymbolicSBML: annotations ",ann];

getrp[Plus[r__]-> Plus[p__]]:=Module[{rlist, plist, rstoic, pstoic, getstoic, stoichiometry},

stoichiometry[x_]:=( x/.{Plus-> plus}); 

getstoic[s_* (x_?SIDQ) ]:= {x, s/.{plus-> Plus}};
getstoic[(x_?SIDQ )* s_]:= {x, s/.{plus-> Plus}};
getstoic[x_*y_]:= ( printWarning["Unable to distinguish stoichiometry from identifier in "<>ToString[InputForm[x*y]]]; Abort[];); 
getstoic[x_]:= If[
ToString[Head[x]]=="Symbol", 
Return[{x, 1}], 
Print["Warning: reactionToSymbolicSBML:"//boldRed, "Unable to determine stoichiometry or identifier of reactant "//boldBlack,ToString[InputForm[x]]//boldBlue, " in the reaction "//boldBlack, Plus[r]//boldBlue,"\[Rule]"//boldBlue, Plus[p]//boldBlue ]; 
Abort[];
]; (* end of getstoic *)

rlist = {r}/.{Global`Stoichiometry-> stoichiometry};
rlist = rlist/.{Plus-> List}//Flatten;
plist = {p}/.{Global`Stoichiometry-> stoichiometry};
plist = plist/.{Plus-> List}//Flatten;


rlist = Map[getstoic, rlist];
plist = Map[getstoic, plist];

{rlist, rstoic} = Transpose[rlist]/.{Global`Stoichiometry-> stoichiometry};
{plist, pstoic} = Transpose[plist]/.{Global`Stoichiometry-> stoichiometry}; 

debugPrint[dbg, "getRP: {rlist, rstoic,plist, pstoic}", {rlist, rstoic , plist, pstoic}]; 
Return[{rlist,rstoic, plist, pstoic}];
]; (* end of getrp *)


getrp[x___]:= {"Failed", "Failed","Failed", "Failed"}; 

id = stringer[(Global`id)/.opt/.{Global`id-> " "}];
If[id==" ",id = "reaction"<>ToString[MB$reactioncounter++]; ]; 

name = (Global`name)/.opt/.{Global`name-> id}; 
metaid=Global`metaid/.opt/.{Global`metaid-> ""}; 


sboTerm = Global`sboTerm/.opt/.{Global`sboTerm-> ""}; 
sboTerm = stringer[sboTerm];

debugPrint[dbg, "reactionTOSymbolicSBML opt: id, name:", {id, name}]; 


reaction = Global`reaction/.opt/.{Global`reaction-> {}};

debugPrint[dbg, "reactionToSymbolicSBML opt: reaction:", reaction];

{reactants, reactantStoichiometry, products, productStoichiometry}= getrp[reaction]; 

If[!(ListQ[reactants]&&ListQ[products]), 
debugPrint[dbg,"reactionToSymbolicSBML: !List: ", True]; 
reactants = {(Global`reactants)/.opt/.{Global`reactants-> {}}}//Flatten;
products = {(Global`products)/.opt/.{Global`products-> {}}}//Flatten;

reactantStoichiometry = {(Global`reactantStoichiometry)/.opt/.{Global`reactantStoichiometry-> {}}}//Flatten;
reactantStoichiometry = PadRight[reactantStoichiometry, Length[reactants],1];

productStoichiometry = {(Global`productStoichiometry)/.opt/.{Global`productStoichiometry-> {}}}//Flatten;
productStoichiometry = PadRight[productStoichiometry, Length[products], 1]; 

If[Length[reactants]==0 \[And] Length[products]==0,
reaction =First[opt]; 
{reactants, reactantStoichiometry, products, productStoichiometry}= getrp[reaction]; 
]; 

]; 


debugPrint[dbg, "reactionToSymbolicSBML opt: {reactants, products, reactantStoichimetry, productStoichiometry}", {reactants, products,reactantStoichiometry, productStoichiometry}];


modifiers = {(Global`modifiers)/.opt/.{Global`modifiers-> {}}}//Flatten;
kineticLaw = (Global`kineticLaw)/.opt/.{Global`kineticLaw->Indeterminate};
debugPrint[dbg, "reactionToSymbolicSBML opt: kineticLaw: ", kineticLaw]; 

timeUnits =stringer[ (Global`timeUnits)/.opt/.{Global`timeUnits->"time"}];
substanceUnits =stringer[ (Global`substanceUnits )/.opt/.{Global`substanceUnits ->"substance"}];
klawmetaid =stringer[Global`kineticLawmetaid/.opt/.{Global`kineticLawmetaid-> ""}]; 
ksbo=stringer[Global`kineticLawSBOTerm/.opt/.{Global`kineticLawSBOTerm-> ""}];

parameters=(Global`parameters)/.opt/.{Global`parameters-> {}}; 
If[!ListQ[parameters], parameters={parameters}]; 

reversible = (Global`reversible)/.opt/.{Global`reversible-> True};
reversible = sbmlBoolean[reversible]; 

fast = (Global`fast)/.opt/.{Global`fast-> False};
fast = sbmlBoolean[fast];


getListData[tag_, n_]:= Module[{listData},
listData =tag/.opt/.{tag-> Table[{}, {n}]}; 
listData = padNull[listData,n]; 
listData = Take[listData,n];
Return[listData];
];
getStringData[tag_, n_]:= Module[{listData},
listData =tag/.opt/.{tag-> Table["", {n}]}; 
listData=PadRight[listData,n,""]; 
listData = Take[listData,n];
Return[listData];
];
rann = getListData[Global`reactantannotations, Length[reactants]]; 
pann = getListData[Global`productannotations, Length[products]]; 
mann = getListData[Global`modifierannotations, Length[modifiers]]; 

rnotes = getListData[Global`reactantnotes, Length[reactants]]; 
pnotes = getListData[Global`productnotes, Length[products]]; 
mnotes = getListData[Global`modifiernotes, Length[modifiers]]; 

rmetaids = getStringData[Global`reactantmetaids, Length[reactants]]; 
pmetaids= getStringData[Global`productmetaids,Length[products]]; 
mmetaids= getStringData[Global`modifiermetaids,Length[modifiers]]; 

rsbos = getStringData[Global`reactantSBOTerms, Length[reactants]]; 
psbos= getStringData[Global`productSBOTerms,Length[products]]; 
msbos= getStringData[Global`modifierSBOTerms,Length[modifiers]]; 


Return[reactionToSymbolicSBML[id, name,metaid, reactants,reactantStoichiometry,  products, productStoichiometry, modifiers, kineticLaw,klawmetaid,  parameters,timeUnits, substanceUnits, reversible, fast,rann,pann,mann,ann,rmetaids,pmetaids,mmetaids, notes,rnotes,pnotes,mnotes, sboTerm, rsbos, psbos, msbos, ksbo]];

]; 


reactionToSymbolicSBML[{r_, opt___?OptionQ}]:= reactionToSymbolicSBML[Global`reaction-> r, opt]; 

reactionToSymbolicSBML[rid_, rname_,rmetaid_,  rreactants_, rreactantStoichiometry_, rproducts_,rproductStoichiometry_, rmodifiers_, rkineticLaw_,rklawmetaid_, rparameters_, timeUnits_, substanceUnits_, rreversible_, rfast_,rann_, pann_, mann_,annotation_,rmetaids_,pmetaids_,mmetaids_,notes_,rnotes_, pnotes_, mnotes_, sboTerm_, rsbos_, psbos_, msbos_, ksbo_]:= 
Module[
{id, name, reactants, metaid,reactantStoichiometry, products, productStoichiometry, modifiers,modifierStoichiometry, kineticLaw, reversible, fast, speciesReference, SBML,data, dbg=False, getpar,pars,klawann,klawnotes, klawopts,klawdata,  modifierSpeciesReference},


debugPrint[dbg,"reactionToSymbolicSBML: {rreactants, rproducts}", {rreactants, rproducts}]; 
debugPrint[dbg,"reactionToSymbolicSBML: {rreactantStoichiometry, rproductStoichiometry}", {rreactantStoichiometry, rproductStoichiometry}]; 

debugPrint[dbg,"reactionToSymbolicSBML: reactant annotations", rann]; 
debugPrint[dbg,"reactionToSymbolicSBML: product annotations", pann]; 
debugPrint[dbg,"reactionToSymbolicSBML: modifier annotations", mann]; 

modifierSpeciesReference[sp_, st_, ann_,Notes_,metaid_, sbo_:""]:= speciesReference[sp,st,ann,Notes,metaid, sbo]/.{"speciesReference"-> "modifierSpeciesReference"}; 

speciesReference[species_, stoichiometry_, ann_,Notes_, metaid_, sbo_:""]:= Module[
{s, data, sp,m,u},

sp = If[StringQ[species], species, ToString[species]]; 
If[!SIDQ[sp], 
Print["Warning: reactionToSymbolicSBML:"//boldOrange,
"Invalid species id = "//boldBlack,sp//boldRed];
explainSIDError[sp];
Abort[];
]; 

u={"species"-> sp};
m=stringer[metaid];
If[m!= "", u=Append[u,"metaid"-> m]];

If[StringLength[stringer[sbo]]>0,
If[ToExpression[MB$LevelVersion]>2.15, 
AppendTo[u, "sboTerm"-> stringer[sbo]],
Print["Error: "//boldRed, "reactionToSBML: speciesReference: "//boldBlack, 
" reaction: "//boldBlack, id//boldBlue, 
" species: "//boldBlack, species//boldBlue,
" SBOTerms are not permitted in "//boldBlack, "SBML Level "//boldBlue,MB$Level//boldBlue," Version "//boldBlue, MB$Version//boldBlue]


]
];

(* Revised 2.3.24 to put integer stoichiometry inline; revised 2.3.31 to allow any flotaing point value as well *)
If[NumberQ[stoichiometry] ,
If[stoichiometry !=  1, u = Append[u,"stoichiometry"-> ToString[InputForm[stoichiometry]]];
];
data={};
,
data = {expression2SymbolicSBML[stoichiometry]};
(* modified 5-24-04 to add the following *)
data = {XMLElement["stoichiometryMath", {}, data]}
];


data = Join[Notes, ann, data]//Flatten; 

s = XMLElement["speciesReference", u, data];
Return[s]; 
];(* end of speciesReferece *) 

id = If[StringQ[rid], rid, ToString[rid]]; 
If[SIDQ[id], 
data = {"id"-> id},
Print["Error: "//boldRed, "speciesToSymbolicSBML: reaction id "//boldBlack, id//boldRed, " is not a valid SID."//boldBlack];
Abort[]; 
]; 

name = If[StringQ[rname],rname, ToString[rname]];
If[StringLength[name]>0, data = Append[data, "name"-> name]]; 

metaid= stringer[rmetaid];
If[metaid!= "", data = Append[data,"metaid"-> metaid]];

reactants = {rreactants}//Flatten;
reactantStoichiometry = {rreactantStoichiometry}//Flatten;
reactantStoichiometry=PadRight[reactantStoichiometry, Length[reactants], 1];
reactants = MapThread[speciesReference, {reactants, reactantStoichiometry,rann,rnotes,rmetaids, rsbos} ]; 
reactants = XMLElement["listOfReactants", {}, reactants];

products = {rproducts}//Flatten;
productStoichiometry = {rproductStoichiometry}//Flatten;
productStoichiometry = PadRight[productStoichiometry, Length[products], 1]; 
products = MapThread[speciesReference, {products, productStoichiometry, pann,pnotes,pmetaids, psbos} ]; 
products = XMLElement["listOfProducts", {}, products]; 

modifiers = {rmodifiers}//Flatten;
modifierStoichiometry = Table[1, {Length[modifiers]}];
modifiers = MapThread[modifierSpeciesReference, {modifiers,modifierStoichiometry, mann,mnotes,  mmetaids,msbos} ]; 
modifiers = XMLElement["listOfModifiers", {}, modifiers]; 


getpar[pinput_]:= Module[{n,opts,  p,ann,parnotes,pin},
pin = pinput;
If[!(ToString[Head[pin]]== "Rule"),
pin = Rule[pin,{}];
];
n=First[pin]; opts=Last[pin];
If[ToString[Head[opts]]!= "List", 
opts = {"value"-> opts};
];

If[SameQ[Head[pinput], Rule], 
Block[{o}, 
o=Last[pinput];
o=Flatten[{o}]; 
If[OptionQ[o],
checkOptions[reactionToSymbolicSBML`kineticLaw`parameter, o, 
{"annotation","id","metaid","name", "notes", "sboTerm","value"} ]
];
];
];

opts = stringrule/@opts;
ann = "annotation"/.opts;
If[ToString[ann]=="annotation", ann={}]; 
 
parnotes ="notes"/.opts;
If[ToString[parnotes]=="notes",parnotes={},parnotes=stringToNotes[parnotes]];  
opts = Select[opts,( First[#]!= "annotation")\[And](First[#]!= "notes")&];
 
opts =stringrule/@opts;
opts = Select[opts, First[#]!= "id"&];
opts = Prepend[opts,"id"-> stringer[n]]; 
p=XMLElement["parameter", opts,{parnotes,ann}//Flatten];
Return[p];
]; 

(* end of getpar *) 


If[ToString[rkineticLaw]!= "Indeterminate", 
(* figure out parameters *)
 pars=getpar/@rparameters;
pars = XMLElement["listOfParameters",{},pars];
If[OptionQ[rkineticLaw],
klawann = "annotation"/.rkineticLaw;
If[ToString[klawann]=="annotation",klawann={}]; 
kineticLaw="math"/.rkineticLaw;
klawnotes = "notes"/.rkineticLaw;
If[ToString[klawnotes]=="notes",klawnotes={}]; 
,
kineticLaw=rkineticLaw;
klawann={};
klawnotes={};
]; 

debugPrint[dbg, "reactionToSymbolicSBML: kineticLaw:", kineticLaw];

kineticLaw = expression2SymbolicSBML[kineticLaw];

debugPrint[dbg, "reactionToSymbolicSBML: kineticLaw:", kineticLaw];

If[ToExpression[MB$LevelVersion]>2.25, 

(* timeUnits & substanceUnits outlawed in L2V3 *)
klawopts={};

If[stringer[timeUnits] != "time",Print["Error:"//boldRed, "reactionToSymbolicSBML:"//boldBlack, " reaction: "//boldBlack, id//boldBlue, " - \"timeUnits\" "//boldBlue, "(requested value: "//boldBlack,timeUnits//boldBlue,
") is not a permitted option for  a kineticLaw in "//boldBlack, "SBML Level "//boldBlue,MB$Level//boldBlue," Version "//boldBlue, MB$Version//boldBlue]
]; 
If[stringer[substanceUnits] != "substance", Print["Error:"//boldRed, "reactionToSymbolicSBML:"//boldBlack, " reaction: "//boldBlack, id//boldBlue, " - \"substanceUnits\" "//boldBlue, 
"(requested value: "//boldBlack,substanceUnits//boldBlue,  ") is not a permitted option for  a kineticLaw in "//boldBlack, "SBML Level "//boldBlue,MB$Level//boldBlue," Version "//boldBlue, MB$Version//boldBlue]]; 

,

klawopts={"timeUnits"-> timeUnits, "substanceUnits"-> substanceUnits}
];
If[rklawmetaid!= "", klawopts=Prepend[klawopts,"metaid"-> rklawmetaid]]; 

If[stringer[ksbo]!= "", 
If[ToExpression[MB$LevelVersion]>2.15, 
AppendTo[klawopts, "sboTerm"-> ksbo],
Print["Error: "//boldRed, "reactionToSymbolicSBML: "//boldBlack, " reaction: "//boldBlack, id//boldBlue, "kineticLawSBOTerm "//boldBlue, 
" is not permitted in "//boldBlack, "SBML Level "//boldBlue,MB$Level//boldBlue," Version "//boldBlue, MB$Version//boldBlue
]
]
];

klawdata=Join[{klawnotes},{klawann},{kineticLaw}, {pars}]//Flatten;
kineticLaw = XMLElement["kineticLaw", klawopts, klawdata];, 

kineticLaw = XMLElement["kineticLaw", {}, {}]
]; 

reversible = sbmlBoolean[rreversible]; 
data = Append[data, "reversible"-> reversible]; 

fast =sbmlBoolean[rfast];
data = Append[data, "fast"-> fast]; 

If[StringLength[stringer[sboTerm]]>0,
If[ToExpression[MB$LevelVersion]>2.15,
AppendTo[data, "sboTerm"-> sboTerm],
Print["Error: "//boldRed, "reactionToSymbolicSBML: "//boldBlack,"reaction: "//boldBlack, id//boldBlue, "sboTerm "//boldBlue, 
" is not permitted in "//boldBlack, "SBML Level "//boldBlue,MB$Level//boldBlue," Version "//boldBlue, MB$Version//boldBlue]
]

];

SBML = XMLElement["reaction", data,Join[notes, annotation,{reactants, products, modifiers, kineticLaw}]//Flatten];

Return[SBML];
];


speciesToSymbolicSBML[opts___?OptionQ]:= Module[{SBML, id, name, compartment, initialAmount, initialConcentration, units, boundaryCondition, charge, constant, icset,booleanate,opt,pia,pic, amount,concentration, ann,notes, metaid, arrayDimensions,
substanceUnits,spatialSizeUnits, hasOnlySubstanceUnits,  stype,dbg=False},

opt = Flatten[{opts}];

If[ToExpression[MB$LevelVersion]<2.3, 
checkOptions[speciesToSymbolicSBML, opt, {"id", "name", "speciesType", "compartment", "initialAmount", "initialConcentration", "substanceUnits", "spatialSizeUnits", "hasOnlySubstanceUnits","boundaryCondition", "charge", "constant", "metaid", "annotation", "notes"}]
, 
checkOptions[speciesToSymbolicSBML, opt, {"id", "name", "speciesType", "compartment", "initialAmount", "initialConcentration", "substanceUnits", "hasOnlySubstanceUnits","boundaryCondition", "charge", "constant", "metaid", "annotation", "notes"}]
];


If[Length[opt]>0, 
If[MemberQ[First/@opt, "charge"], 
If[ToExpression[MB$LevelVersion]>2.1, 
Print["Warning: "//boldRed, "The charge field has been deprecated in SBML Level "//boldBlack, MB$Level//boldBlack, " Version "//boldBlack, MB$Version//boldBlack]]
]
]; 

booleanate[x_]:= If[ToUpperCase[stringer[x]]=="TRUE","true","false"];
SBML={};

id = (Global`id/.opt/.{Global`id-> ""})//stringer;
If[id=="", 
id = "species"<>ToString[MB$speciescounter++];
Print["Error: "//boldRed, "speciesToSymbolicSBML: species id not specified. A value of "//boldBlack,id//boldBlue," was used."//boldBlack ];
];
name=stringer[Global`name/.opt/.{Global`name-> id}];


If[!SIDQ[id] , Print["Error: "//boldRed, "speciesToSymbolicSBML: Species "//boldBlack,id//boldBlue," is not a valid SID."//boldBlack ];Abort[];];



ann = {Global`annotation/.opt/.{Global`annotation-> {}}}//Flatten//optionToAnnotation;
notes = {Global`notes/.opt/.{Global`notes-> {}}}//Flatten//stringToNotes;
arrayDimensions = getArrayDimensions[id,opt]; 

constant=booleanate[Global`constant/.opt/.{Global`constant-> "false"}];

boundaryCondition=booleanate[Global`boundaryCondition/.opt/.{Global`boundaryCondition-> "false"}]; 

compartment=stringer[Global`compartment/.opt/.{Global`compartment-> ""}]; 

If[compartment=="", 
compartment="compartment"<>ToString[MB$compartmentcounter++];
Print["Error: "//boldRed, "speciesToSBML: compartment not specified for species "//boldBlack, id//boldBlue, "\nThis is a required field. A value of "//boldBlack,compartment//boldBlue, " was used instead."//boldBlack];
]; 

stype=stringer[Global`speciesType/.opt/.{Global`speciesType-> ""}]; 
SBML = {"id"-> id, "name"-> name, "compartment"-> compartment, "boundaryCondition"-> boundaryCondition, "constant"-> constant};

If[stype!= "",
If[ToExpression[MB$LevelVersion]>2.1,
SBML=Append[SBML,"speciesType"-> stype];
,
Print["Warning:"//boldOrange," speciesType is not allowed in version"//boldBlack, MB$LevelVersion//boldBlack, " but was used for species"//boldBlack, id//boldBlack];
]; 
];




metaid = Global`metaid/.opt/.{Global`metaid-> ""}; 
metaid=stringer[metaid];
If[metaid!= "", SBML = Append[SBML,"metaid"-> metaid]]; 


(* allow initial Amount and concentration to be given either as a number or as a string containing a number *)
initialAmount=(Global`initialAmount/.opt/.{Global`initialAmount-> Indeterminate})//deFortranize;
amount = NumberQ[initialAmount];

initialConcentration=(Global`initialConcentration/.opt/.{Global`initialConcentration-> "Indeterminate"})//deFortranize;
concentration = NumberQ[initialConcentration]; 

If[amount \[And] concentration,
(* determine which is first *)
pia = Position[opt,Global`initialAmount];
While[ListQ[pia], pia = First[pia]]; 
pic = Position[opt,Global`initialConcentration];
While[ListQ[pic], pic = First[pic]];

If[pia<pic, amount=True, amount=False];
concentration = Not[amount];

];

icset = False;
If[amount,
initialAmount=ToString[FortranForm[initialAmount]];
SBML = Append[SBML, "initialAmount"-> initialAmount];
]; 

If[concentration,
initialConcentration = ToString[FortranForm[initialConcentration]]; 
SBML = Append[SBML, "initialConcentration"-> initialConcentration]; 
]; 

(* figure out and debug units *)
(* version 1 emulation *) 

units=stringer[Global`units/.opt/.{Global`units-> "Indeterminate"}];
If[units!= "Indeterminate", SBML = Append[SBML, "units"-> units]]; 

(* version 2 unit specifiers *)

substanceUnits=Global`substanceUnits/.opt/.{Global`substanceUnits-> "substance"};
SBML=Append[SBML, "substanceUnits"-> substanceUnits];

hasOnlySubstanceUnits=Global`hasOnlySubstanceUnits/.opt/.{Global`hasOnlySubstanceUnits->False};
SBML=Append[SBML, "hasOnlySubstanceUnits"-> booleanate[hasOnlySubstanceUnits]];

spatialSizeUnits=Global`spatialSizeUnits/.opt/.{Global`spatialSizeUnits->"Indeterminate"};
spatialSizeUnits=stringer[spatialSizeUnits];

If[dbg, Print["speciesToSymbolicSBML: speciesToSymbolicSBML: spatialSizeUnits: ", spatialSizeUnits]];

If[spatialSizeUnits!= "Indeterminate", SBML = Append[SBML, "spatialSizeUnits"-> spatialSizeUnits]]; 

If[dbg, Print["speciesToSymbolicSBML: speciesToSymbolicSBML: SBML: ", SBML]];

(* d on't do any checking with global compartments - that has to be done in addCompartment - because this function may be used as stand-alone *)

charge=Global`charge/.opt/.{Global`charge-> Indeterminate}//deFortranize//Round;

If[NumberQ[charge],
SBML = Append[SBML, "charge"-> ToString[charge]];
If[!IntegerQ[charge],
Print["Warning: "//boldOrange,"charge "//boldBlue," is set to a non integer value for species "//boldBlack, id//boldBlue]
];
, 
If[stringer[charge]!= "Indeterminate", 
Print["Warning: "//boldOrange, "charge \[Rule] "<>stringer[InputForm[charge]]//boldBlue," is not a numeric quantity for species "//boldBlack, id//boldBlue];
];

];
SBML = XMLElement["species", SBML, Join[notes,ann, arrayDimensions]//Flatten];
Return[SBML];
];

speciesToSymbolicSBML[id_,opt___?OptionQ]:= speciesToSymbolicSBML[Global`id-> id, opt];


compartmentTypeToSymbolicSBML[opt___?OptionQ]:= Module[{opts, id, name, value, units, constant, SBML,ann, notes,metaid,fixnotes, arrayDimensions,foreach},

If[ToExpression[MB$LevelVersion]<2.15, 
Print["Error: "//boldRed, "compartmentTypeToSymbolicSBML: compartmentType is not defined in "//boldBlack," SBML Level "//boldBlue, MB$Level//boldBlue," version "//boldBlue, MB$Version//boldBlue ];
];

opts=Flatten[{opt}];

checkOptions[compartmentTypeToSymbolicSBML, opts, {"id", "name", "metaid", "annotation", "notes"}];


id =stringer[ Global`id/.opts/.{Global`id-> ""}];
If[id=="",Print["Error:"//boldRed,"compartmentTypeToSymbolicSBML: A compartmentType id must be specified."//boldBlack];Return[]];
If[!SIDQ[id],
Print["Error: "//boldRed, "compartmentTypeToSymbolicSBML: compartmentType id "//boldBlack, id//boldBlue, " is not a valid SID."//boldBlack];
Abort[];
];
SBML = {"id"-> id}; 
name=stringer[Global`name/.opts/.{Global`name-> ""}];
If[name!= "", SBML =Append[SBML,"name"-> name]]; 

metaid = Global`metaid/.opts/.{Global`metaid-> ""}; 
metaid=stringer[metaid];
If[metaid!= "", SBML = Append[SBML,"metaid"-> metaid]]; 

ann = {Global`annotation/.opts/.{Global`annotation-> {}}}//Flatten//optionToAnnotation; 
notes = {Global`notes/.opts/.{Global`notes-> {}}}//Flatten//stringToNotes;


SBML = XMLElement["compartmentType", SBML, Join[notes,ann]//Flatten];
Return[SBML];
];

compartmentTypeToSymbolicSBML[id_, opt___?OptionQ]:= compartmentTypeToSymbolicSBML[Global`id-> id, opt];


speciesTypeToSymbolicSBML[opt___?OptionQ]:= Module[{opts, id, name, value, units, constant, SBML,ann, notes,metaid,fixnotes, arrayDimensions,foreach},

If[ToExpression[MB$LevelVersion]<2.15, 
Print["Error: "//boldRed, "speciesTypeToSymbolicSBML: speciesType is not defined in "//boldBlack," SBML Level "//boldBlue, MB$Level//boldBlue," version "//boldBlue, MB$Version//boldBlue ];
];


opts=Flatten[{opt}];

checkOptions[speciesTypeToSymbolicSBML, opts, {"id", "name", "metaid", "annotation", "notes"}];

id =stringer[ Global`id/.opts/.{Global`id-> ""}];
If[id=="",Print["Error:"//boldRed,"speciesTypeToSymbolicSBML: A speciesType id must be specified."//boldBlack];Return[]];
If[!SIDQ[id],
Print["Error: "//boldRed, "speciesTypeToSymbolicSBML: speciesType id "//boldBlack, id//boldBlue, " is not a valid SID."//boldBlack];
Abort[];
];
SBML = {"id"-> id}; 
name=stringer[Global`name/.opts/.{Global`name-> ""}];
If[name!= "", SBML =Append[SBML,"name"-> name]]; 

metaid = Global`metaid/.opts/.{Global`metaid-> ""}; 
metaid=stringer[metaid];
If[metaid!= "", SBML = Append[SBML,"metaid"-> metaid]]; 

ann = {Global`annotation/.opts/.{Global`annotation-> {}}}//Flatten//optionToAnnotation; 
notes = {Global`notes/.opts/.{Global`notes-> {}}}//Flatten//stringToNotes;


SBML = XMLElement["speciesType", SBML, Join[notes,ann]//Flatten];
Return[SBML];
];

speciesTypeToSymbolicSBML[id_, opt___?OptionQ]:= speciesTypeToSymbolicSBML[Global`id-> id, opt];


functionToSymbolicSBML[opt___?OptionQ]:= Module[{SBML, name, id,opts,arguments,math,f,x,sx, ann,notes, metaid,sboTerm,  debug= False},(* sx =  StringReplace[ToString[x],"$"-> ""]; *)
sx = "UnusedDummyVariable";
opts = Flatten[{opt}];

If[ToExpression[MB$LevelVersion]>2.15,
checkOptions[functionToSymbolicSBML, opts, {"id", "name","math", "arguments", "sboTerm", "metaid", "annotation", "notes"}]
,
checkOptions[functionToSymbolicSBML, opts, {"id", "name","math","arguments", "metaid", "annotation", "notes"}];
];

id = stringer[( Global`id/.opts)/.{ Global`id-> ""}];
If[id == "", id = "function"<>ToString[MB$functioncounter++]];
If[!SIDQ[id],
Print["Error: "//boldRed, "functionToSymbolicSBML: function id "//boldBlack, id//boldRed, " is not a valid SID."//boldBlack];
Abort[];
];

name = stringer[ Global`name/.opts/.{ Global`name-> id}];

arguments = Global`arguments/.opts/.{ Global`arguments-> {}}//expressionate;
arguments = Flatten[{arguments}];
arguments = destring/@arguments; 

If[Length[arguments]<1, 
(* An argument is required because otherwise Mathematica
will not create a lambda definition *)
arguments={x}; 
]; 

math =  Global`math/.opts/.{ Global`math-> "NONE"};
If[stringer[math]=="NONE", 
Print[
boldRed["Warning: "],
boldBlack["functionToSymbolicSBML: No function definition was specified for the function "],
boldRed[id],
boldBlack["\nA value of 1 will be returned."]
];
math=1;
];
 
math = destring[math]; 

ann = {Global`annotation/.{opt}/.{Global`annotation-> {}}}//Flatten//optionToAnnotation;

metaid = Global`metaid/.{opt}/.{Global`metaid->""};
metaid=stringer[metaid];

sboTerm=stringer[Global`sboTerm/.{opt}/.{Global`sboTerm-> ""}]; 

notes ={ Global`notes/.{opt}/.{Global`notes-> {}}}//Flatten; 
If[debug ,Print["functionToSymbolicSBML: notes:"//boldRed, notes//boldBlue]];
notes =stringToNotes[notes];
If[debug ,Print["functionToSymbolicSBML: notes:"//boldRed, notes//boldBlue]];

SBML = expression2SymbolicSBML[f[arguments, math]/.{f-> Function}, id, name,metaid,ann,notes,sboTerm];
SBML = SBML/.{ToString[x]-> sx};
Return[SBML];
];

functionToSymbolicSBML[x_, opt___?OptionQ]:= functionToSymbolicSBML[Global`id-> x, opt];


parameterToSymbolicSBML[pid_-> (nvalue_?numericalFormQ),opt___?OptionQ]:= parameterToSymbolicSBML[Global`id-> pid, Global`value-> nvalue,opt];

parameterToSymbolicSBML[opt___?OptionQ]:= Module[{opts, id, name, value, units, constant, sbo, SBML,ann, notes,metaid,fixnotes, arrayDimensions,foreach},

opts=Flatten[{opt}];

If[ToExpression[MB$LevelVersion]>2.15, 
checkOptions[parameterToSymbolicSBML, opts, 
{"id", "name", "metaid", "annotation", "notes", "value", "units", "constant","sboTerm"}],
checkOptions[parameterToSymbolicSBML, opts, 
{"id", "name", "metaid", "annotation", "notes", "value", "units", "constant"}]
]; 



id =stringer[ Global`id/.opts/.{Global`id-> ""}];
If[id=="",id = "parameter"<>ToString[MB$parametercounter++]];
If[!SIDQ[decontextify[id]],
Print["Error: "//boldRed, "parameterToSymbolicSBML: parameter id "//boldBlack, id//boldRed, " is not a valid SID, input options: "//boldBlack, {opt}//boldBlue];
Abort[];
];
name=stringer[Global`name/.opts/.{Global`name-> id}];
SBML = {"id"-> id, "name"-> name}; 

metaid = Global`metaid/.opts/.{Global`metaid-> ""}; 
metaid=stringer[metaid];
If[metaid!= "", SBML = Append[SBML,"metaid"-> metaid]]; 

ann = {Global`annotation/.opts/.{Global`annotation-> {}}}//Flatten//optionToAnnotation; 
notes = {Global`notes/.opts/.{Global`notes-> {}}}//Flatten//stringToNotes;
arrayDimensions = getArrayDimensions[id,opts]; 


value=Global`value/.opts/.{Global`value-> "Indeterminate"}//deFortranize; 
If[NumberQ[value], 
 SBML =Append[SBML, "value"-> stringer[FortranForm[value]]]; ];

foreach=(Global`foreach/.opts/.{Global`foreach-> ""})//stringer;
If[foreach!= "",
If[ifArrays[],SBML=Append[SBML,"foreach"-> foreach]];
]; 

units = stringer[Global`units/.opts/.{Global`units-> ""}];
If[units!= "", SBML = Append[SBML, "units"-> units]];

sbo = stringer[Global`sboTerm/.opts/.{Global`sboTerm-> ""}];

If[StringLength[sbo]>0,
If[ToExpression[MB$LevelVersion]>2.15,
SBML=Append[SBML,"sboTerm"-> sbo],
Print["Error: "//boldRed, "parameterToSymbolicSBML: "//boldBlack , "sboTerm"//boldBlue, " is not defined in SBML "//boldBlack,
"Level "//boldBlue, MB$Level//boldBlue," Version "//boldBlue, MB$Version//boldBlue]
];
]; 

constant=stringer[Global`constant/.opts/.{Global`constant-> "true"}];
If[ToUpperCase[constant]!= "TRUE",
If[constant=="false" \[Or] ToUpperCase[constant]=="FALSE",
SBML = Append[SBML, "constant"-> "false"]; 
,
Print["Warning: "//boldOrange, "constant = "//boldBlack, constant//boldRed, " for parameter "//boldBlack, id//boldRed," The constant field must be either \"true\" or \"false\""];
]; 
]; 

SBML = XMLElement["parameter", SBML, Join[notes,ann, arrayDimensions]//Flatten];
Return[SBML];
];

parameterToSymbolicSBML[id_, opt___?OptionQ]:= Module[{dbg=False}, 
If[dbg, Print["parameterToSymbolicSBML: id=", id, " {opt}=", {opt}]]; 
Return[parameterToSymbolicSBML[Global`id-> id, opt]]];


checkUnitKind[id_, kind_]:= Module[{allowedKinds={"ampere","becquerel","candela","Celsius","coulomb","dimensionless","farad","gram","gray","henry","hertz","item","joule","katal","kelvin","kilogram","litre","lumen","lux","metre","mole","newton","ohm","pascal","radian","second","siemens","sievert","steradian","tesla","volt","watt","weber", "substance","volume","time","area", "length"},
nestmsg,ispredefined, isdefined},

nestmsg="";
ispredefined=MemberQ[allowedKinds, stringer[kind]];
isdefined=MemberQ[First/@MB$Units, stringer[kind]];

If[ToExpression[MB$LevelVersion]>2.1,
If[Equal[stringer[kind],stringer[id]],
Print["Error:"//boldOrange," Unit definition "//boldBlack,id//boldOrange," self refers."//boldBlack];
Abort[];
]; 
If[isdefined \[Or] ispredefined, Return[True]];
,
If[ispredefined, Return[True]];
If[isdefined,
nestmsg=boldBlack[" --- Nested unit definitions are not allowed in Level "<>MB$Level<>" Version "<>MB$Version];
];
];
Print["Error:"//boldRed, "Invalid "//boldBlack, "kind"//boldBlue, " = "//boldBlack, stringer[kind]//boldBlue, " specified in listOfUnits for unit "//boldBlack, id//boldBlue,nestmsg, "\nThe allowed values of "//boldBlack, "kind"//boldBlue, " are "//boldBlack, allowedKinds//boldBlue];

Return[False]; 
];



unitToSymbolicSBML[opt___?OptionQ]:= Module[{SBML, name, id,opts,ann,metaid,s,
unit,x, getkind, dbg=False},

If[dbg, Print["unitToSymbolicSBML: {opt}:"//boldRed,{opt}//boldBlue]]; 

checkOptions[unitToSymbolicSBML, Flatten[{opt}], {"id", "name","unit", "metaid", "annotation", "notes"}];

getkind[kind_-> (optin___?OptionQ)]:= Module[{opts,exponent,scale,multiplier,offset,unit,ann, metaid},
opts=Flatten[{optin}]; 

checkOptions[unitToSymbolicSBML`unit, opts,
{"exponent","scale","multiplier", "offset","kind", "annotation", "notes","metaid"}
];

exponent=Global`exponent/.opts/.{Global`exponent-> 1};
scale = Global`scale/.opts/.{Global`scale-> 0}; 
multiplier=Global`multiplier/.opts/.{Global`multiplier-> 1};
offset=Global`offset/.opts/.{Global`offset-> 0};

ann = Global`annotation/.opts/.{Global`annotation-> {}};
ann = Flatten[{ann}]//optionToAnnotation; 

metaid=stringer[Global`metaid/.opts/.{Global`metaid-> ""}]; 

unit={"kind"-> stringer[kind]};
If[metaid!= "", unit=Append[unit,"metaid"->metaid]]; 

If[exponent!= 1, unit=Append[unit,"exponent"-> ToString[FortranForm[exponent]]]];
If[scale!= 0, unit=Append[unit,"scale"->ToString[FortranForm[ scale]]]];
If[multiplier!= 1, unit=Append[unit,"multiplier"-> ToString[FortranForm[multiplier]]]];
If[offset!= 0, unit=Append[unit,"offset"-> ToString[FortranForm[offset]]]];


If[!checkUnitKind[id, kind],Abort[]]; 
unit=XMLElement["unit",unit,ann]; 
Return[unit];

]; 
getkind[kind_]:=Module[{},
If[!checkUnitKind[id, kind],Abort[]]; 
Return[XMLElement["unit",{"kind"-> stringer[kind]},{}]]
];
getkind[kind___]:=Module[{},
Print["Warning:"//boldOrange,"Invalid unit kind for "//boldBlack,id//boldRed," kind = "//boldBlack, kind//boldRed," assumed dimensionless."//boldBlack];
Return[XMLElement["unit",{"kind"-> "dimensionless"},{}]]
];


opts = Flatten[{opt}];
id = stringer[( Global`id/.opts)/.{ Global`id-> ""}];
If[id == "", id = "unit"<>ToString[MB$unitcounter++]];
If[!SIDQ[id],
Print["Error: "//boldOrange, "unitToSymbolicSBML: unit id "//boldBlack, id//boldRed, " is not a valid SID."//boldBlack];
Abort[];
];
name = stringer[ Global`name/.opts/.{ Global`name-> id}];
unit = Global`unit/.opts/.{Global`unit-> {"dimensionless"-> {}}}; 
ann = {Global`annotation/.opts/.{Global`annotation-> {}}}//Flatten//optionToAnnotation;

If[Length[unit]<1, 
Print["Warning: "//boldOrange, "No <unit kind=.../> specified for "//boldBlack,id//boldRed, ". At least one unit must be specified."//boldBlack];
]; 

If[dbg, Print["unitToSymbolicSBML: unit(1):"//boldRed,unit//boldBlue]]; 

unit = Map[getkind, unit];
If[dbg, Print["unitToSymbolicSBML: unit(2):"//boldRed,unit//boldBlue]]; 

SBML = Join[ann,{XMLElement["listOfUnits",{},unit]}]; 

s={"id"->stringer[ id],"name"-> stringer[name]};

metaid = Global`metaid/.opts/.{Global`metaid-> ""}; 
metaid=stringer[metaid]; 
If[metaid!= "", s = Append[s,"metaid"-> metaid]]; 


SBML=XMLElement["unitDefinition",s ,SBML];
Return[SBML];
];


compartmentToSymbolicSBML[opt___?OptionQ]:= Module[{opts, id, name, spatialDimensions, size, units, outside, constant, SBML,ann,notes, metaid, arrayDimensions,allowedOpts,ctype},

allowedOpts={Global`id,Global`name,Global`spatialDimensions, Global`size,Global`units,Global`outside,Global`constant,Global`notes,Global`annotation,Global`metaid};
If[ToExpression[MB$LevelVersion]>2.1, allowedOpts=Append[allowedOpts,Global`compartmentType];
]; 

opts=Flatten[{opt}]; 

checkOptions[compartmentToSymbolicSBML, opts, allowedOpts];

id = stringer[( Global`id/.opts)/.{ Global`id-> ""}];
If[id == "", id = "compartment"<>ToString[MB$compartmentcounter++]];

If[!SIDQ[id],
Print["Error: "//boldRed, "compartmentToSymbolicSBML: compartment id "//boldBlack, id//boldBlue, " is not a valid SID."//boldBlack];
Abort[];
];

name = stringer[ Global`name/.opts/.{ Global`name-> id}];
SBML = {"id"-> id, "name"-> name};
metaid =( Global`metaid/.opts/.{Global`metaid-> ""})//stringer;
metaid=stringer[metaid];
If[metaid!= "", SBML = Append[SBML,"metaid"-> metaid]]; 

ann = {Global`annotation/.opts/.{Global`annotation-> {}}}//Flatten//optionToAnnotation;
notes = {Global`notes/.opts/.{Global`notes-> {}}}//Flatten//stringToNotes; 


spatialDimensions=stringer[Global`spatialDimensions/.opts/.{Global`spatialDimensions-> 3}];
If[spatialDimensions!= "3",
If[MemberQ[{"0","1","2"}, spatialDimensions],
SBML=Append[SBML,"spatialDimensions"-> spatialDimensions]
, 
Print["Error:"//boldRed," compartmentToSymbolicSBML: Invalid "//boldBlack, " spatialDimensions \[Rule] "//boldBlue, spatialDimensions//boldBlue, " for compartment "//boldBlack,id//boldBlue," Allowed values of spatialDimensions are: 0, 1, 2, or 3."//boldBlack];
];
,
SBML=Append[SBML,"spatialDimensions"-> spatialDimensions];
];
units = stringer[Global`units/.opts/.{Global`units-> ""}]; 

If[units=="",
Switch[spatialDimensions,
"3",units="volume",
"2",units="area",
"1",units="length",
"0",units="dimensionless"
];
];
If[units!= "", SBML=Append[SBML,"units"-> units],
Print["Error:"//boldRed," compartmentToSymbolicSBML: Unable to determine units for compartment "//boldBlack, name//boldBlue]]; 

size = deFortranize[Global`size/.opts/.{Global`size-> "Indeterminate"}];
If[NumberQ[size],SBML = Append[SBML,"size"-> stringer[FortranForm[size]]]];

constant =stringer[ Global`constant/.opts/.{Global`constant-> "true"}]//ToUpperCase;
If[constant=="FALSE",
SBML = Append[SBML, "constant"-> "false"];,
If[constant!= "TRUE",
Print["Error: "//boldRed, "allowed values for constant are true and false, not "//boldBlack, constant//boldBlue];
SBML = Append[SBML, "constant"-> "true"];
]];


outside = stringer[Global`outside/.opts/.{Global`outside-> ""}];
If[outside!= "",SBML = Append[SBML,"outside"-> outside]];

If[ToExpression[MB$LevelVersion]>2.1, 
ctype=stringer[Global`compartmentType/.opts/.{Global`compartmentType-> ""}];
If[ctype!= "", SBML=Append[SBML,"compartmentType"-> ctype]]; 
]; 



(* If Arrays are allowed, check for dimensions: note that getArrayDimensions always returns a list: with an XMLElment if arrays are allowed, and an empty list if not! *) 

arrayDimensions = getArrayDimensions[id,opts]; 

SBML = XMLElement["compartment",SBML,Join[notes,ann,arrayDimensions]//Flatten];
Return[SBML];
];


initialAssignmentToSymbolicSBML[opt___?OptionQ]:= Module[{allowedOptions={Global`symbol, Global`math, Global`sboTerm, Global`notes, Global`annotation, Global`metaid}, opts,meta, sbo, s, expr, ann, notes},
s= Global`symbol/.{opt}/.{Global`symbol-> ""};
expr=Global`math/.{opt}/.{Global`math-> "?"};
sbo=stringer[Global`sboTerm/.{opt}/.{Global`sboTerm-> ""}];
meta=stringer[Global`metaid/.{opt}/.{Global`metaid-> ""}];

If[stringer[s]=="", 
Print["Error: "//boldRed, "initialAssignmentToSymbolicSBML: no symbol."//boldBlack];
];
If[stringer[expr]=="?", 
Print["Error: "//boldRed, "initialAssignmentToSymbolicSBML: no math."//boldBlack];
expr=1;
];

ann =Flatten[{Global`annotation/.{opt}/.{Global`annotation-> {}}}]; 
If[Length[ann]>0, ann={annotationToSymbolicSBML@@ann}]; 
notes = {Global`notes/.{opt}/.{Global`notes-> {}}}//Flatten//stringToNotes;



checkOptions[initialAssignmentToSymbolicSBML, Flatten[{opt}], {"symbol","math", "sboTerm", "metaid", "annotation", "notes"}];

(* opts =First/@{opt};
opts=Complement[opts, allowedOptions];
Print["Error: "//boldRed, "initialAssignmentToSymbolicSBML: invalid Option: "//boldBlack, quote[#]//boldBlue, " valid options are: "//boldBlack, allowedOptions//boldBlack]&/@opts;
*)

Return[initialAssignmentToSymbolicSBML[s, expr,ann, notes, meta,sbo]];

];
initialAssignmentToSymbolicSBML[symbol_, math_,ann_, notes_,metaid_,  SBOTerm_:""]:= Module[{mathml, opts,sub, sbo,ia, meta},

If[!MemberQ[First/@$SBML$IDTable,stringer[symbol]], Print["Error: "//boldRed, "initialAssignmentToSymbolicSBML: "//boldBlack, 
" Unknown symbol\[Rule]"//boldBlack, symbol//boldBlue, " not previously defined specified in initialAssignment."//boldBlack
]];

mathml ={ expression2SymbolicSBML[math]};
opts={"symbol"-> stringer[symbol]};
sbo = stringer[SBOTerm];
If[StringLength[sbo]>0,
opts= Append[opts, "SBOTerm"-> sbo];
];
meta=stringer[metaid];
If[StringLength[meta]>0, 
opts=Append[opts, "metaid"-> meta];
];

sub=mathml;

If[Length[notes]>0, 
sub=Flatten[Append[{sub},notes]]
];
If[Length[ann]>0, 
sub=Flatten[Append[{sub},ann]]
];
ia = XMLElement["initialAssignment", opts, sub];
Return[ia]
];


ruleToSymbolicSBML[opt___?OptionQ]:= Module[{SBML,type, TYPE,opts,math,variable,varname,data,subdata, id,  metaid, ann, notes, arrayDimensions,variableLink,setAnnotation,matrixresult,fromindices, toindices, sboTerm,fromcompartment, tocompartment, debug=False, connection, indices,mathinput, inputType},




varname[]:= Module[{v},
v = stringer[Global`variable/.opts/.{Global`variable-> ""}];
(* If[v=="",v="variable"<>ToString[MB$variablecounter++]; ];*) 
If[v=="",
Print["Error:"//boldRed,"ruleToSymbolicSBML: "//boldBlack,
"A variable is required for an "//boldBlack,type//boldBlue,
" --- No variable was specified for the rule (type="//boldBlack,inputType//boldBlue,") with math "//boldBlack,mathinput//boldRed
];
Abort[];
];

If[!MemberQ[First/@$SBML$IDTable,v], Print["Error: "//boldRed, "ruleToSymbolicSBML: "//boldBlack, 
" Unknown "//boldBlack, " variable\[Rule]"//boldBlue, v//boldBlue, " not previously defined in model specified in rule  ("//boldBlack,"type\[Rule]"//boldBlue, inputType//boldBlue,")."//boldBlack
]];

Return[v];  
]; 

opts=Flatten[{opt}];
If[ToExpression[MB$LevelVersion]>2.15, 

(* "id" is translated to "metaid" later in the program *)

checkOptions[ruleToSymbolicSBML, opts, 
{ "metaid", "annotation", "notes","math","variable","id","type","sboTerm"}],
checkOptions[ruleToSymbolicSBML, opts, 
{ "metaid", "annotation", "notes","math","variable","id", "type"}]
];

type = stringer[Global`type/.opts/.{Global`type-> ""}];
inputType=type;

TYPE = ToUpperCase[type];
math = Global`math/.opts/.{Global`math-> Indeterminate}; 

If[SameQ[math,Indeterminate] \[And] TYPE != "INITIALASSIGNMENTRULE",
Print["Error:"//boldRed,
"The "//boldBlack,"math "//boldBlue," option is required for any rule. Options found: "//boldBlack,({opt})//boldBlue
];
Abort[];
];

If[debug,
Print["ruleToSymbolicSBML: math:"//boldRed,math//boldBlue];
Print["ruleToSymbolicSBML: StringQ[math]:"//boldRed,StringQ[math]//boldBlue];
];

If[StringQ[math], math=ToExpression[math]];
If[debug,Print["ruleToSymbolicSBML: math:"//boldRed,math//boldBlue];];

mathinput=math;
math ={ expression2SymbolicSBML[math]};

ann = {Global`annotation/.opts/.{Global`annotation-> {}}}//Flatten//optionToAnnotation;

notes = {Global`notes/.opts/.{Global`notes-> {}}}//Flatten//stringToNotes; 

arrayDimensions = getArrayDimensions[id,opts]; 
variableLink=getObjectLink[Global`variableLink,opt]; 

matrixresult=ifArrays[]\[And]Global`matrixResult/.opts/.{Global`matrixrResult-> False};

If[ifArrays[],connection=(Global`connection/.opts/.{Global`connection-> ""})//stringer;
indices = {Global`indices/.opts/.{Global`indices-> {}}}//Flatten;
,
connection="";
indices={};
];

(* If id is given, add metaid since there is no id field in SBML for rules*)

metaid = stringer[Global`metaid/.opts/.{Global`metaid-> ""}];id = stringer[Global`id/.opts/.{Global`id-> ""}];
If[metaid=="" \[And] id!= "", metaid=id];

If[metaid!= "",If[!SIDQ[metaid],
Print["Error: "//boldRed, "ruleToSymbolicSBML: rule metaid "//boldBlack, metaid//boldBlue, " is not a valid SID."//boldBlack];
];
]; 

sboTerm = stringer[Global`sboTerm/.opts/.{Global`sboTerm-> ""}];

data = {};
setAnnotation=False; 


Switch[TYPE,

"ALGEBRAICRULE",
type = "algebraicRule";
data = {};
subdata = Join[notes, ann,arrayDimensions, math]//Flatten;
,


"ASSIGNMENTRULE",
type = "assignmentRule";
variable=varname[]; 
If[Length[variableLink]<1,data = {"variable"-> variable}];
subdata = Join[notes, ann,arrayDimensions,variableLink, math]//Flatten;

,

"CONSTRAINTRULE",
Print["Error:"//boldRed,"constraintRules were proposed in an eralier draft of the SBML Level 2 Version 2 specification but were not adopted, in lieu of the constraint object. Please revise your model accordingly"//boldBlack]; 
type = "constraintRule";
subdata = Join[notes, ann,arrayDimensions,variableLink, math]//Flatten;
,

"RATERULE",
type="rateRule";
variable=varname[]; 
If[Length[variableLink]<1,data = {"variable"-> variable}];
subdata = Join[notes, ann,arrayDimensions,variableLink, math]//Flatten;
,
"CONNECTIONRULE",
If[debug,Print["ruleToSymbolicSBML: connectionRule:"//boldRed]];
If[!ifArrays[],
Return[stringToNotes["Connection Rule inhibited because Arrays->False."]];
]; 
type="connectionRule";
fromcompartment=stringer[ Global`from/.opts/.{Global`from-> ""}]; 
tocompartment=stringer[ Global`to/.opts/.{Global`to-> ""}]; 
If[fromcompartment=="" \[Or] tocompartment=="", 
Print["Error:"//boldOrange," connectionRule: both from and to fields must be specified."//boldBlack];
Return[stringToNotes["Connection Rule inhibited because either from or to field is missing"]];
];

(* from/to indices added in 2.5.5 11/9/05 *)

fromindices=Global`listOfIndicesFrom/.opts/.{Global`listOfIndicesFrom-> {}};
toindices=Global`listOfIndicesTo/.opts/.{Global`listOfIndicesTo-> {}};

fromindices=XMLElement["ci",{},{stringer[#]}]&/@Flatten[{fromindices}];
toindices =XMLElement["ci",{},{stringer[#]}]&/@ Flatten[{toindices}]; 

fromindices={XMLElement["listOfIndicesFrom",{},fromindices]};
toindices={XMLElement["listOfIndicesTo",{},toindices]}; 


subdata = Join[notes, ann,arrayDimensions, fromindices, toindices, math]//Flatten;
data = {"from"-> fromcompartment, "to"-> tocompartment};
,
"INITIALASSIGNMENTRULE",
If[debug,Print["ruleToSymbolicSBML: InitialAssignmentRule:"//boldRed]]; 

If[!ifArrays[],Return[stringToNotes["Initial Assignment Rule inhibited because Arrays->False."]]]; 

variable=varname[]; 
type="initialAssignmentRule";
data = (Global`data/.opts/.Global`data-> Indeterminate);
If[VectorQ[data],
data={vectorToSymbolicSBML[data]},
If[MatrixQ[data],
data={matrixToSymbolicSBML[data]},
If[stringer[data]!= "Indeterminate", 
data= {expression2SymbolicSBML[data]},
data = math;
];
];
];

arrayDimensions = Cases[arrayDimensions,XMLElement["listOfDimensions",___],Infinity]; 

subdata = Join[notes,ann,arrayDimensions,variableLink,data];
If[Length[variableLink]<1,data = {"variable"-> variable}, data={}];
If[ifArraysAreAnnotations[], setAnnotation=True];


,

(* MISSING TYPE *) 
"",
Print["Error: "//boldRed,"No type specified for rule "//boldBlack,metaid//boldBlue," Valid types are "//boldBlack, "algebraicRule, assignmentRule, rateRule"//boldBlue ];
type = "algebraicRule"; data={}; 
math ={ expression2SymbolicSBML[0]};
subdata = Join[notes, ann,arrayDimensions,variableLink, math]//Flatten;
,
(* UNKNOWN TYPE *) 

_,Print["Warning: "//boldRed,"Unknown type\[Rule]"//boldBlack,type//boldBlue," for rule "//boldBlack,metaid//boldBlue," Valid types are algebraicRule, assignmentRule, or rateRule."//boldBlack ];
Abort[];
math ={ expression2SymbolicSBML[0]}; type = "algebraicRule"; data={}; 
subdata = Join[notes, ann,arrayDimensions,variableLink, math]//Flatten;
];

If[metaid!= "", data = Append[data,"metaid"-> metaid]]; 

If[sboTerm!= "",
If[ToExpression[MB$LevelVersion]>2.15, 
AppendTo[data, "sboTerm"-> sboTerm],
Print["Error: "//boldRed, "ruleToSymbolicSBML: "//boldBlack, "sboTerm"//boldBlue, " is not permitted in "//boldBlack, "SBML Level "//boldBlue, MB$Level//boldBlue, " Version "//boldBlue, MB$Version//boldBlue];
];
];



If[matrixresult, data = Append[data, "matrixResult"-> "true"]];

If[ifArrays[]\[And] connection!= "", 
data = Append[data, "connection"-> connection];
];
If[ifArrays[] \[And] Length[indices]>0, 
indices=indicesToSymbolicSBML[indices];
subdata = Append[subdata, indices];
];

SBML=XMLElement[type,data,subdata];


If[setAnnotation,SBML=annotationToSymbolicSBML[SBML ]];
If[debug,Print["ruleToSymbolicSBML: InitialAssignmentRule:"//boldRed, SBML//boldBlue]]; 

Return[SBML];
];


constraintToSymbolicSBML[opt___?OptionQ]:= Module[{ msg, opts,meta, sbo, s, expr, ann, notes, dbg=False},

checkOptions[constraintToSymbolicSBML, Flatten[{opt}], 
{ "metaid", "annotation", "notes","math","message","sboTerm"}];
If[dbg, Print["constraintToSymbolicSBML: options:ok"]];

msg=stringer[Global`message/.{opt}/.{Global`message-> ""}];
expr=Global`math/.{opt}/.{Global`math-> "?"};
sbo=stringer[Global`sboTerm/.{opt}/.{Global`sboTerm-> ""}];
meta=stringer[Global`metaid/.{opt}/.{Global`metaid-> ""}];

If[stringer[expr]=="?", 
Print["Error: "//boldRed, "constraintToSymbolicSBML: no math."//boldBlack];
expr=True;
];

ann =Flatten[{Global`annotation/.{opt}/.{Global`annotation-> {}}}]; 
If[Length[ann]>0, ann={annotationToSymbolicSBML@@ann}]; 
notes = {Global`notes/.{opt}/.{Global`notes-> {}}}//Flatten//stringToNotes;


opts =First/@{opt};
If[dbg, Print["constraintToSymbolicSBML: opts:",opts]];

Return[constraintToSymbolicSBML[expr,msg, ann, notes, meta,sbo]];

];
constraintToSymbolicSBML[math_,message_, ann_, notes_,metaid_,  SBOTerm_:""]:= Module[{mathml, opts,sub, sbo,ia, meta,m,newmath,  dbg=False,MYANGLE},

MYANGLE[x_, "time"]:= x;
MYANGLE[x_, "delay"]:= x; 


If[dbg, Print["constraintToSymbolicSBML:",{math,message, ann,notes, metaid, SBOTerm}]];

mathml ={ expression2SymbolicSBML[math]};

If[dbg, Print["constraintToSymbolicSBML: mathml: ",mathml]];

opts={};
sbo = stringer[SBOTerm];
If[StringLength[sbo]>0,
opts= Append[opts, "sboTerm"-> sbo];
];
meta=stringer[metaid];
If[StringLength[meta]>0, 
opts=Append[opts, "metaid"-> meta];
];
If[dbg, Print["constraintToSymbolicSBML: opts: ",opts]];

sub=mathml;
If[dbg, Print["constraintToSymbolicSBML: sub(1): ",sub]];
If[dbg, Print["constraintToSymbolicSBML: message: ", message]]; 

If[StringLength[message]>0,
m= stringToNotes[message];
If[dbg, Print["constraintToSymbolicSBML: m(1): ",m]];
,
newmath=math//.{MyAngleBracket-> MYANGLE};
If[dbg, Print["constraintToSymbolicSBML: newmath: ", newmath]]; 

newmath=StringReplace[stringer[newmath], {">"-> ".gt.","<"-> ".lt." }];
newmath="constraint violation: "<>newmath;
If[dbg, Print["constraintToSymbolicSBML: newmath: ", newmath]]; 
m=stringToNotes[newmath];
If[dbg, Print["constraintToSymbolicSBML: m(2): ",m]];

];
m = (m/.{"notes"-> "message"});
If[dbg, Print["constraintToSymbolicSBML: m(3): ",m]];

sub=Flatten[Append[{sub}, m]];


If[Length[notes]>0, 
sub=Flatten[Append[{sub},notes]]
];
If[Length[ann]>0, 
sub=Flatten[Append[{sub},ann]]
];

If[dbg, Print["constraintToSymbolicSBML: sub(2): ",sub]];

ia = XMLElement["constraint", opts, sub];

If[dbg, Print["constraintToSymbolicSBML: ia: ",ia]];

Return[ia]
];


eventToSymbolicSBML[opt___?OptionQ]:= Module[{SBML,opts,id, name, trigger, delay, timeUnits, eventAssignment, data, eventVariables,okevent,metaid, ann, notes,eventAssignmentNotes,eventAssignmentMetaids,nasg,eventAssignmentSBOTerms,eventAssignmentAnnotations,eventAssignmentStuff, easbos, dbg=False},

opts=Flatten[{opt}];

If[ToExpression[MB$LevelVersion]<2.3, 
checkOptions[eventToSymbolicSBML, opts, 
{"annotation","delay","eventAssignment","eventAssignmentAnnotations","eventAssignmentMetaids","eventAssignmentNotes","eventAssignmentSBOTerms","id","metaid","name", "notes","sboTerm","timeUnits","trigger"}],
checkOptions[eventToSymbolicSBML, opts, 
{"annotation","delay","eventAssignment","eventAssignmentAnnotations","eventAssignmentMetaids","eventAssignmentNotes","eventAssignmentSBOTerms","id","metaid","name", "notes","sboTerm","trigger"}]
]; 


If[dbg, Print["eventToSymbolicSBML: options checked."]]; 

id = stringer[( Global`id/.opts)/.{ Global`id-> ""}];
If[id == "", id = "event"<>ToString[MB$eventcounter++]];


If[!SIDQ[id],
Print["Error: "//boldOrange, "eventToSymbolicSBML: event id "//boldBlack, id//boldRed, " is not a valid SID."//boldBlack];
Abort[];
];

If[dbg, Print["eventToSymbolicSBML: id=",id]]; 

name = stringer[ Global`name/.opts/.{ Global`name-> id}];
SBML = {"id"-> id, "name"-> name}; 
metaid =( Global`metaid/.opts/.{Global`metaid-> ""});
metaid=stringer[metaid];
If[StringLength[metaid]>0, SBML = Append[SBML,"metaid"-> metaid]]; 

If[dbg, Print["eventToSymbolicSBML: metaid=",metaid, " name=", name, " SBML=", SBML]]; 

(* Print["metaid=",metaid];
Print["SBML=",SBML]; *)
If[ToExpression[MB$LevelVersion]<2.3, 
timeUnits = stringer[Global`timeUnits/.opts/.{Global`timeUnits-> ""}]; 
If[timeUnits!= "", SBML = Append[SBML,"timeUnits"-> timeUnits]]; 
If[dbg, Print["eventToSymbolicSBML: timeUnits=",timeUnits,  " SBML=", SBML]]; 
]; 

trigger = Global`trigger/.opts/.{Global`trigger-> ""}; 
If[dbg, Print["eventToSymbolicSBML: trigger(1)=",trigger]]; 

If[stringer[trigger]=="",
trigger=False;
Print["Warning: "//boldRed,"The event "//boldBlack, id//boldBlue, " does not have a trigger."//boldBlack]
];
If[dbg, Print["eventToSymbolicSBML: trigger(2)=",trigger]]; 
If[ListQ[trigger], 
Print["Error:"//boldRed, "The event "//boldBlack, id//boldBlue, " has an invalid trigger: trigger must be a boolean expression and not a list: "//boldBlack, 
trigger//boldBlue];
];
If[dbg, Print["eventToSymbolicSBML: trigger(3)=",trigger]]; 


trigger = XMLElement["trigger",{},{ expression2SymbolicSBML[trigger]}];
If[dbg, Print["eventToSymbolicSBML: trigger(4)=",trigger]]; 

data = {trigger}; 

delay = Global`delay/.opts/.{Global`delay-> 0}; 
If[stringer[delay]!= "0", 
delay = XMLElement["delay", {}, {expression2SymbolicSBML[delay]}]; 
data = Append[data, delay]; 
];

eventAssignment=Global`eventAssignment/.opts/.{Global`eventAssignment-> {}};
If[dbg, Print["eventToSymbolicSBML: eventAssignment(1)=",eventAssignment]]; 


eventAssignment = Flatten[{eventAssignment}]; 
If[Length[eventAssignment]>0, 
okevent =Apply[And, Map[ToString[Head[#]]=="Rule"&, eventAssignment]];
If[!okevent, 
Print["Warning: "//boldOrange, "eventAssignment for event "//boldBlack,
id//boldRed," is not a list of rules. Requested eventAssignment -> "//boldBlack,eventAssignment//boldRed," eventAssignment must have the form {variable->expression, variable->expression,...}"//boldBlack];
];
If[dbg, Print["eventToSymbolicSBML: eventAssignment(2)=",eventAssignment]]; 

eventAssignment = Flatten[{eventAssignment}];
eventVariables=stringer/@( First/@eventAssignment);
If[dbg, Print["eventToSymbolicSBML: eventAssignment(3)=",eventAssignment]]; 

eventAssignment=Last/@eventAssignment; 
eventAssignment = expression2SymbolicSBML/@eventAssignment;
If[dbg, Print["eventToSymbolicSBML: eventAssignment(4)=",eventAssignment]]; 

nasg = Length[eventVariables]; 

eventAssignmentNotes=Global`eventAssignmentNotes/.opts/.{Global`eventAssignmentNotes->{} };
eventAssignmentNotes=stringer/@eventAssignmentNotes;
While[Length[eventAssignmentNotes]<nasg, eventAssignmentNotes=Append[eventAssignmentNotes,{}]];
eventAssignmentNotes=Take[eventAssignmentNotes,nasg]; 

If[dbg, Print["eventToSymbolicSBML: eventAssignmentNotes(1)=",eventAssignmentNotes]]; 


eventAssignmentMetaids=
Global`eventAssignmentMetaids/.opts/.{Global`eventAssignmentMetaids->{} };
eventAssignmentMetaids=stringer/@eventAssignmentMetaids;
While[Length[eventAssignmentMetaids]<nasg,eventAssignmentMetaids=Append[eventAssignmentMetaids,""]];
eventAssignmentMetaids= Take[eventAssignmentMetaids,nasg]; 
If[dbg, Print["eventToSymbolicSBML: eventAssignmentMetaids(1)=",eventAssignmentMetaids]]; 


eventAssignmentSBOTerms=
Global`eventAssignmentSBOTerms/.opts/.{Global`eventAssignmentSBOTerms->{} };
eventAssignmentSBOTerms=stringer/@eventAssignmentSBOTerms;
While[Length[eventAssignmentSBOTerms]<nasg,eventAssignmentSBOTerms=Append[eventAssignmentSBOTerms,""]];
eventAssignmentSBOTerms= Take[eventAssignmentSBOTerms,nasg]; 
If[dbg, Print["eventToSymbolicSBML: eventAssignmentSBOTerms(1)=",eventAssignmentSBOTerms]]; 

eventAssignmentAnnotations=Global`eventAssignmentAnnotations/.opts/.{Global`eventAssignmentAnnotations->{} };
If[dbg, Print["eventToSymbolicSBML: eventAssignmentAnnotations(1)=",eventAssignmentAnnotations, " nasg: ", nasg]]; 

While[Length[eventAssignmentAnnotations]<nasg, eventAssignmentAnnotations=Append[eventAssignmentAnnotations,{}]];
eventAssignmentAnnotations=Take[eventAssignmentAnnotations,nasg]; 
If[dbg, Print["eventToSymbolicSBML: eventAssignmentAnnotations(2)=",eventAssignmentAnnotations]]; 

eventVariables=Map[Rule["variable",#]&,eventVariables];
eventAssignmentMetaids=Map[If[StringLength[#]>0,Rule["metaid",#],{}]&,eventAssignmentMetaids]; 
eventVariables = Flatten/@({eventVariables,eventAssignmentMetaids}//Transpose);
If[dbg, Print["eventToSymbolicSBML: eventVariables(1)=",eventVariables]]; 


eventAssignment = MapThread[XMLElement["eventAssignment", #1, {#2,#3,#4}//Flatten]&, {eventVariables, eventAssignment,eventAssignmentNotes,eventAssignmentAnnotations}];
If[dbg, Print["eventToSymbolicSBML: eventAssignment=",eventAssignment]]; 

eventAssignment = XMLElement["listOfEventAssignments",{}, eventAssignment];
If[dbg, Print["eventToSymbolicSBML: eventAssignment=",eventAssignment]]; 
data = Append[data, eventAssignment];
If[dbg, Print["eventToSymbolicSBML: data=",data]]; 

,
Print["Warning: "//boldRed,"The event "//boldBlack,id//boldBlue," does not contain an eventAssignment."//boldBlack];
]; 

notes = {Global`notes/.opts/.{Global`notes-> {}}}//Flatten//stringToNotes; 
ann = {Global`annotation/.opts/.{Global`annotation-> {}}}//Flatten//optionToAnnotation;
If[dbg, Print["eventToSymbolicSBML: notes=",notes]]; 
If[dbg, Print["eventToSymbolicSBML: ann=",ann]]; 

data = Join[notes, ann, data]//Flatten; 
If[dbg, Print["eventToSymbolicSBML: data=",data]]; 

SBML = XMLElement["event",SBML,data]; 
If[dbg, Print["eventToSymbolicSBML: SBML=",SBML]]; 

Return[SBML];
];

eventToSymbolicSBML[id_, opt___?OptionQ]:= eventToSymbolicSBML[Global`id-> id, opt];



getSBMLid[XMLElement[tag_, {opt___?OptionQ}, stuff_]]:= Module[{id},
id = "id"/.{opt}/.{"id"-> "*NONE*"};
id = stringer[id];
If[id=="*NONE*",
Print["Warning: "//boldOrange,"There is no "//boldBlack,"id"//boldRed," field in the following symbolic SBML: "//boldBlack, XMLElement[tag,{opt},stuff]//boldRed];
];
Return[id];
];

getSBMLfield[field_,XMLElement["annotation",{z___},{XMLElement[u___]}]]:= getSBMLfield[field,XMLElement[u]];

getSBMLfield[field_, XMLElement[tag_, {opt___?OptionQ}, stuff_]]:= Module[{value, r,identityRule, dbg=False},

If[dbg, Print["getSBMLfield: field: ", field]]; 

Off[Rule::rhs];
identityRule[Rule[b_, b_]]:= True;
identityRule[b___]:= False;

(* Print["getSBMLfield: {opt}:",{opt}];
Print["getSBMLfield: field:",field];  *) 

value = stringer[field]/.{opt}/.{stringer[field]-> ""};
(* Print["getSBMLfield: value:", value]; *)
value = stringer[value];
If[value=="",

(* check for field -> field *) 

r = Select[Flatten[{opt}], (First[#]==stringer[field])&];
If[Length[r]>0,
r=First[r];
If[identityRule[r], value=stringer[field]];
];
];

If[dbg, Print["getSBMLfield: value: ", value]]; 

Return[value];
];

getSBMLfield[field_, XMLElement[x___],opt__?OptionQ]:=Module[{defaultValue,value},
defaultValue=default/.{opt}/.{default-> ""};
value=getSBMLfield[field,XMLElement[x]];
If[value=="", value=defaultValue];
Return[value];
]


Default$Units={"ampere","becquerel","candela","Celsius","coulomb","dimensionless","farad","gram","gray","henry","hertz","item","joule","katal","kelvin","kilogram","litre","lumen","lux","metre","mole","newton","ohm","pascal","radian","second","siemens","sievert","steradian","tesla","volt","watt","weber", "substance","volume","time","area", "length"};
Built$In$Units={"substance","volume","time","area", "length"};
resetDefaultUnits[]:= (default$Units = Default$Units);
resetDefaultUnits[];

defaultUnit[unit_]:= MemberQ[default$Units,stringer[unit]];
builtInUnit[unit_]:=MemberQ[Built$In$Units, stringer[unit]];
removeDefaultUnit[unit_]:= Module[{},
If[defaultUnit[unit],
default$Units = Complement[default$Units,{stringer[unit]}];
If[builtInUnit[unit],
(* Print["Built-in unit: "//boldGreen,unit//boldBlue," redefined. "//boldGreen]; *)
Return[True];
,
Print["Error: "//boldRed,"Illegal redefinition of default unit "//boldBlack,unit//boldBlue];
Return[True]; 
]
];
Return[False];
];

definedUnits[]:=Union[Flatten[{First/@ MB$Units, 
default$Units}
]];
unitExists[unit_]:= MemberQ[definedUnits[],unit];


expression2SymbolicSBML[Function[x___]]:= Module[{id},
id = "function"<>ToString[MB$functioncounter++];
Return[expression2SymbolicSBML[Function[x], id]];
]; 

expression2SymbolicSBML[Function[x__], id_]:= expression2SymbolicSBML[Function[x], id, id];

expression2SymbolicSBML[Function[x__], id_, name_,metaid_,  annotation_, notes_, sboTerm_:""]:= Module[{s,args, sid, sname},


If[StringQ[id], sid = id, sid=ToString[id]]; 
If[StringQ[name], sname=name, sname=ToString[name]]; 

s = Xpression2SymbolicMathML[Function[x]/.{System`Part-> Global`selector,System`Dot-> Global`scalarproduct
(**),System`If-> piecewiseIf(**)}];
s = Join[{s}, annotation, notes]//Flatten; 
args = {"id"-> sid}; 
If[StringLength[sname]>0, args = Append[args, "name"-> sname]]; 
If[StringLength[metaid]>0, args = Append[args, "metaid"-> metaid]]; 

If[ToExpression[MB$LevelVersion]>2.15,
If[StringLength[sboTerm]>0, args = Append[args, "sboTerm"-> sboTerm]]
];

s = XMLElement["functionDefinition",args,s];

s=encodePiecewise[s];
s=encodeCsymbols[s];


(* s = (s/.XMLElement-> myx); *)

Return[s];
];


expression2SymbolicSBML[infix_]:= Module[{s,myx},

s = Xpression2SymbolicMathML[infix/.{System`Part-> Global`selector, System`Dot-> Global`scalarproduct ,System`If-> piecewiseIf  }]; 


s=encodePiecewise[s];
s=encodeCsymbols[s];

Return[s];
];


encodePiecewise[xml_]:= Module[{s,myx},

myx["apply",{},{XMLElement["ci",{},{"XML`MathML`Symbols`Piece"}],a_,b_}]:=
XMLElement["piece",{},{b,a}];
myx["apply",{},{XMLElement["ci",{},{"XML`MathML`Symbols`Otherwise"}],a___}]:=
XMLElement["otherwise",{},{a}];
myx["apply",{},{XMLElement["ci",{},{"XML`MathML`Symbols`Piecewise"}],a___}]:=
XMLElement["piecewise",{},{a}];

myx[x___]:= XMLElement[x];

s = (xml/.XMLElement-> myx);

Return[s];
];


encodeCsymbols[xml_]:= Module[{s,myx},

(* csymbol time *)
(* if it is enclosed in quotes, it will be encoded as an "ms" element, otherwise, as a "ci" element *)

(*
myx["apply",{},{XMLElement["ci",{},{"AngleBracket"}],XMLElement["ci",{},{x_}],XMLElement["ci",{},{"time"}]}]:= XMLElement["csymbol",{"encoding"->"text","definitionURL"->csymbolTimeURL},{XMLElement["ci",{},{stringer[x]}]}];
myx["apply",{},{XMLElement["ci",{},{"AngleBracket"}],XMLElement["ci",{},{x_}],XMLElement["ms",{},{"time"}]}]:= 
XMLElement["csymbol",{"encoding"->"text","definitionURL"->csymbolTimeURL},{XMLElement["ci",{},{stringer[x]}]}];
*)

myx["apply",{},{XMLElement["ci",{},{"AngleBracket"}],XMLElement["ci",{},{x_}],XMLElement["ci",{},{"time"}]}]:= XMLElement["csymbol",{"encoding"->"text","definitionURL"->csymbolTimeURL},{stringer[x]}];
myx["apply",{},{XMLElement["ci",{},{"AngleBracket"}],XMLElement["ci",{},{x_}],XMLElement["ms",{},{"time"}]}]:= 
XMLElement["csymbol",{"encoding"->"text","definitionURL"->csymbolTimeURL},{stringer[x]}];


(* csymbol delay *)
(* if it is enclosed in quotes, it will be encoded as an "ms" element, otherwise, as a "ci" element *)
(*

myx["apply",{},{XMLElement["ci",{},{"AngleBracket"}],XMLElement["ci",{},{x_}],XMLElement["ci",{},{"delay"}]}]:= XMLElement["csymbol",{"encoding"->"text","definitionURL"->csymbolDelayURL},{XMLElement["ci",{},{stringer[x]}]}];
myx["apply",{},{XMLElement["ci",{},{"AngleBracket"}],XMLElement["ci",{},{x_}],XMLElement["ms",{},{"delay"}]}]:= 
XMLElement["csymbol",{"encoding"->"text","definitionURL"->csymbolDelayURL},{XMLElement["ci",{},{stringer[x]}]}];
*)

myx["apply",{},{XMLElement["ci",{},{"AngleBracket"}],XMLElement["ci",{},{x_}],XMLElement["ci",{},{"delay"}]}]:= XMLElement["csymbol",{"encoding"->"text","definitionURL"->csymbolDelayURL},{stringer[x]}];
myx["apply",{},{XMLElement["ci",{},{"AngleBracket"}],XMLElement["ci",{},{x_}],XMLElement["ms",{},{"delay"}]}]:= 
XMLElement["csymbol",{"encoding"->"text","definitionURL"->csymbolDelayURL},{stringer[x]}];

(* unknown csymbol *)
(* if it is enclosed in quotes, it will be encoded as an "ms" element, otherwise, as a "ci" element *)

myx["apply",{},{XMLElement["ci",{},{"AngleBracket"}],XMLElement["ci",{},{x_}],XMLElement["ci",{},{someURL_}]}]:= XMLElement["csymbol",{"encoding"->"text","definitionURL"->stringer[someURL]},{stringer[x]}];
myx["apply",{},{XMLElement["ci",{},{"AngleBracket"}],XMLElement["ci",{},{x_}],XMLElement["ms",{},{someURL_}]}]:= 
XMLElement["csymbol",{"encoding"->"text","definitionURL"->stringer[someURL]},{stringer[x]}];


(* unspecified URL *)

myx["apply",{},{XMLElement["ci",{},{"AngleBracket"}],XMLElement["ci",{},{x_}]}]:= Block[{r}, 
r=XMLElement["csymbol",{"encoding"->"text","definitionURL"->"the-definition-URL-was-not-specified"},{stringer[x]}];
Print["Error: "//boldRed, "expression2SymbolicSBML: no definitionURL supplied for csymbol "//boldBlack, "\[LeftAngleBracket]"<>x<>"\[RightAngleBracket]"//boldBlue," in the expression "//boldBlack , infix//boldBlue, " The expected syntax for a csymbol is \[LeftAngleBracket]variable, definitionURL\[RightAngleBracket],\[LeftAngleBracket]variable, \"time\"\[RightAngleBracket], or \[LeftAngleBracket]variable, \"delay\"\[RightAngleBracket].\nIt has been encoded as:\n"//boldBlack,
XMLPrintForm[r,Purple]
];
Return[r];
];



myx[x___]:= XMLElement[x];

s = (xml/.XMLElement-> myx);
Return[s];
];


simpleSymbolicXML[tag_, value_]:= Module[{string},
string[x_?StringQ]:= x;
string[x_]:= ToString[x];
Return[XMLElement[string[tag],{}, {string[value]}]]
];
simpleXML[tag_,value_]:= XMLOut[simpleSymbolicXML[tag,value]]


optionToAnnotation[{XMLElement[x___]}]:= {XMLElement[x]};
optionToAnnotation[x___]:= Module[{input,outpt,dbg=False},

debugPrint[dbg,"optionToAnnotation: input:",x];

input={x}//Flatten;
If[Length[input]<1, Return[{}]]; 
If[OptionQ[x], 
outpt={Apply[annotationToSymbolicSBML, x]};
debugPrint[dbg,"optionToAnnotation: return value:",outpt];

Return[outpt];
];
Print["Error: "//boldRed,
"optionToAnnotation: invalid argument: "//boldBlack,x//boldBlue," An annotation should have the form string\[Rule]string or string\[Rule]list."//boldBlack
];

Return[annotationToSymbolicSBML[input]];
];


getAnnotations[XMLElement[x_,y_,z_]]:=Cases[z,XMLElement["annotation",___]];
getAnnotations[id_->XMLElement[x___]]:=getAnnotations[XMLElement[x]];
getAnnotations[x_?ListQ]:=getAnnotations/@x;

getAnnotations[tag_,xx_]:=Module[{m},m=Cases[xx,XMLElement[tag,___],Infinity];
Return[getAnnotations[m]];];


isAnnotated[x_]:=Length[getAnnotations[x]]>0;


getNotes[XMLElement[x_, y_, z_]]:=Cases[z, XMLElement["notes",___]];
getNotes[id_-> XMLElement[x___]]:= getNotes[XMLElement[x]];
getNotes[x_?ListQ]:= getNotes/@x;

getNotes[tag_,xx_]:= Module[{m},
m=Cases[xx, XMLElement[tag,___], Infinity];
Return[getNotes[m]];
];


isNoted[x_]:= Length[getNotes[x]]>0;


stringToNotes[XMLElement["notes", x_,y_]]:= XMLElement["notes",x,y];

(* rev 5-31-04 to force XHTML format on notes *) 
(* rev 2.3.24 7-5-04 to not force <body..> on null notes: this should encourage the postprocessor to remove all notes statements that are empty *) 
stringToNotes[""]:= XMLElement["notes",{},{}];
stringToNotes[x_?StringQ]:=XMLElement["notes",{},Cases[ImportString[
"<body xmlns=\"http://www.w3.org/1999/xhtml\">"<>x<>"</body>", "XML"],
XMLElement[___]]
];

 (* XMLElement["notes",{},{x}]; *)

stringToNotes[x_?ListQ]:= stringToNotes/@x;
stringToNotes[x___]:= Print["Error: "//boldRed,"stringToNotes: "//boldBlue," argument must be a string, XMLElement, or list of XMLElements of notes. Input given: "//boldBlack, x];

updateNotes[XMLElement[z___],opt___?OptionQ]:=Module[{oldnotes,newnotes,x,formatNotes},

formatNotes[w_?StringQ]:={w};formatNotes[XMLElement[w1_,w2_,w3_]]:=w3;
formatNotes[w_?ListQ]:=formatNotes/@w;formatNotes[w___]:=Print[boldOrange["Error: "],boldRed["updateNotes: "],boldBlank["invalid call to "],boldRed["formatNotes"],boldBlack[" arguments: "],x];

x=XMLElement[z];
oldnotes=formatNotes[getNotes[x]];

newnotes=Global`notes/. {opt}/. {Global`notes->{}};
newnotes=formatNotes[newnotes];newnotes=Flatten[{oldnotes,newnotes}];
newnotes=StringJoin@@newnotes;
If[newnotes!= "", 
newnotes={XMLElement["notes",{},{newnotes}]},
newnotes={}
]; 
Return[newnotes];
];

updateNotes[{},opt___?OptionQ]:= {};

updateNotes[x___]:=Print[boldOrange["Error: "],boldRed["updateNotes "],boldBlack["called with invalid argment: "],boldRed[ToString[x]]];



updateAnnotations[XMLElement[z__], opt___?OptionQ]:= Module[{x, old, new, ann, checkAnn},

checkAnn[XMLElement["annotation",u___]]:= True;
checkAnn[u_?ListQ]:= And@@(checkAnn/@u);
checkAnn[u___]:= False;

x = XMLElement[z];
old =  getAnnotations[x]//Flatten;
new =Flatten[{ (Global`annotation)/.{opt}/.{Global`annotation-> {}}}];
If[checkAnn[new],
ann = Join[new, old]//Flatten,
ann = old;
Print["Error:"//boldOrange,"updateAnnotations: checkAnn:"//boldRed," annotations must be Symbolic XML or a list of Symbolic XML: input ignored: "//boldBlack,new];
];
Return[ann]; 
];
updateAnnotations[{},opt___?OptionQ]:= {};
updateAnnotations[x___]:= Print["Error: "//boldRed," udpateAnnotations: invalid argument list: "//boldBlack,
boldBlue/@{x}
];


createSymbolicAnnotation[package_, ns_,tag_, {data___?OptionQ}, sub_]:= Module[{string },
string[x_?StringQ]:= x; 
string[x_-> y_]:= string[x]-> string[y]; 
string[x_?ListQ]:= string/@x; 
string[x_]:= ToString[x]; 


 XMLElement["annotation",{"xmlns:"<>string[package]-> string[ns]},{
XMLElement[string[tag],string[{data}],{sub}//Flatten
]

}]
];




If[$$LoadBug, Print["Loading: Model Builder: annotations"]];


setAnnotationNamespace[arg_]:= Module[{},
MB$CurrentAnnotationNamespace = stringer[arg];
]; 
setAnnotationURI[arg_]:= setAnnotationNamespace[arg];
setAnnotationURL[arg_]:= Block[{},
Print["Warning:"//boldRed," setAnnotationURL has been disparaged in favor of setAnnotationURI and will be discontinued in a future version of MathSBML."//boldBlack];
setAnnotationURI[arg];
]; 

setAnnotationPackage[arg_]:= Module[{},
MB$CurrentAnnotationPackage=stringer[arg];
]; 

If[$$LoadBug, Print["Loading: Model Builder: annotationToSymbolicSBML "]];

annotationToSymbolicSBML[a_?StringQ-> ann_]:= annotationToSymbolicSBML[a-> ann, MB$CurrentAnnotationPackage, MB$CurrentAnnotationNamespace]; 

annotationToSymbolicSBML[topLevel_?StringQ->ann_,pkg_:StringQ,URI_?StringQ]:= Module[{a,inline={},tree={},inlineElements,package, URL,treeElements,dbg=False},

package=pkg;
If[package=="",Print["Error: "//boldRed,"annotationToSymbolicSBML: annotation package has not been defined. Use setAnnotationPackage[package-name] to define the name of the package. "//boldBlack];
package="Indeterminate-resource";
];

URL=URI;
If[URL=="http://",Print["Error: "//boldRed,"annotationToSymbolicSBML: annotation URI has not been defined. Use setAnnotationURI[URI] to define the annotation namespace URI. "//boldBlack];
URL="http://sbml.org/Indeterminate-resource-URI/";
];

inlineElements[tool_,data_]:= Module[{r={},in},
in = Select[data,( Head[#]===Rule)\[And]StringQ[Last[#]]&];
r=Rule[tool<>":"<>First[#],Last[#]]&/@in;
Return[r]
];

(* end of inlineElements *)

treeElements[tool_,data_]:= Module[{r={},out,in,ok,notok, nextlevel},
in = Select[data,( Head[#]===Rule)\[And]StringQ[Last[#]]&];
out=Complement[data,in];

If[dbg,Print["treeElements: tree:",out]];

(* first check to make sure only rules are found *)
ok = Select[out,( Head[#]===Rule)&];
notok=Complement[out,ok];
Print["Error: "//MathSBML`Private`boldRed,"annotationToSymbolicSBML: invalid format for annotation data: "//MathSBML`Private`boldBlack,MathSBML`Private`boldBlue[#]," is not a rule."//MathSBML`Private`boldBlack]&/@notok;

(* reject any rules that are not heirarchies of lists  *)

out=ok;
ok = Select[out, ListQ[Last[#]]&]; 
notok=Complement[out,ok];
If[dbg,
Print["treeElements: really ok:",ok];
Print["treeElements: notok:",notok];
]; 

Print["Error: annotationToSymbolicSBML: "//MathSBML`Private`boldRed,
MathSBML`Private`boldBlue[#], " does not have the form string\[Rule]string or string\[Rule]list and will be ignored."//MathSBML`Private`boldBlack
]&/@notok;

nextlevel[u_?StringQ-> {v_?StringQ}]:= XMLElement[tool<>":"<>u,{},{v}];
nextlevel[u_?StringQ-> v_?ListQ]:= Module[{in,out},
in=inlineElements[tool,v];
out=treeElements[tool,v];
XMLElement[tool<>":"<>u,in,out]
];
nextlevel[u___]:= {};
ok=nextlevel/@ok;

Return[ok]
];
(* end of treeElements *)

(* "a"-> "b" *)
(* normally this would be inline but not at the top level *)
If[StringQ[ann],
 tree={ann},
 
(* "a"-> { ... } *)
If[ListQ[ann], 

(* "a"-> {"b",..} *) 
If[StringQ[First[ann]],
If[Length[ann]==1, 

(* "a"->{"b"} *) 
tree=ann, 

(* "a"-> {"b", other stuff} *) 
Print["Error: "//MathSBML`Private`boldRed," annotationToSymbolicSBML: invalid format for annotation: If the first element in a list is a string, there should not be any additional elements in the list: "//MathSBML`Private`boldBlack,MathSBML`Private`boldBlue[ann], " will be interpreted as "//MathSBML`Private`boldBlack,{First[ann]}//MathSBML`Private`boldBlue];
tree={First[ann]};
];
,
(* First[ann] is not a string *)
inline=inlineElements[package,ann];
 tree=treeElements[package,ann]; 

]; (* end If StringQ[First[ann]] *)


(* end TRUE part of If ListQ[ann]*)
,
(* ann is not a list and not a string *)
tree={}; 
Print["Error: annotationToSymbolicSBML: annotation must be of the form string-> string or string -> List"];

(* "a"-> {stuff } *) 

]; (* end if ListQ[ann]*)
]; (* end if StringQ[ann] *)

a=XMLElement[
"annotation",
{},
{XMLElement[package<>
":"<>topLevel, Join[{"xmlns:"<>package-> URL},inline], tree]}
];

Return[a];
];


annotationToSymbolicSBML[XMLElement["annotation",x___]]:= XMLElement["annotation",x];

annotationToSymbolicSBML[XMLElement[x___]]:= XMLElement["annotation",{},{XMLElement[x]}];

annotationToSymbolicSBML[x___]:= Block[{},
If[Length[{x}]>0, Print["Error: "//boldRed," annotationToSymbolicSBML: incorrect format for argument: "//boldBlack,x//boldBlue," argument should be string\[Rule]string or string\[Rule]list."//boldBlack]; 
]; 
Return[{}]];


If[$$LoadBug, Print["Loading: Model Builder: annotationToSBML "]];

(* annotationToSBML[opt___?OptionQ]:= XMLOut[annotationToSymbolicSBML[opt]];*)

annotationToSBML[x___]:= XMLOut[annotationToSymbolicSBML[x]];


If[$$LoadBug, Print["Loading: Model Builder: setModelAnnotation "]];

setModelAnnotation[x___]:= Module[{ann},
ann = annotationToSymbolicSBML[x];
(* If[!ListQ[ann], ann={ann}]; *) 
MB$ModelAnnotation=Append[MB$ModelAnnotation, ann];
Return[ann];
]; 
 setSBMLAnnotation[x___]:= Module[{ann,debug=False},
 ann =annotationToSymbolicSBML[x];
(* If[!ListQ[ann], ann={ann}]; *)
MB$SBMLAnnotation=Append[MB$SBMLAnnotation,ann];
If[debug,Print["setSBMLAnnotation: ann:",ann]];
If[debug,Print["setSBMLAnnotation: MB$SBMLAnnotation:",MB$SBMLAnnotation]];

Return[ann];
]; 




If[$$LoadBug, Print["Loading: Model Builder: symbolicXMLForm "]]
(* 
symbolicXMLForm[attribute_-> value_?StringQ]:= If[StringLength[MB$CurrentAnnotationPackage]>0,XMLElement[MB$CurrentAnnotationPackage<>":"<>stringer[attribute],{},{value}],
XMLElement[stringer[attribute],{},{value}]
];
symbolicXMLForm[attribute_-> value_?ListQ]:=Module[{element,SXML, attributeValuePairs, data, ruleQ,listRuleQ, listRules, simpleRules,values, nonRules,srule,bo,br,bb,dbg=False},

srule[x_-> y_]:=
If[StringLength[MB$CurrentAnnotationPackage]>0,Rule[MB$CurrentAnnotationPackage<>":"<>stringer[x],stringer[y]],
Rule[stringer[x],stringer[y]]
];
listRuleQ[x_-> y_?ListQ]:= True;
listRuleQ[x___]:= False;

ruleQ[x_-> y_]:=True;
ruleQ[x___]:=False;

element =stringer[attribute];

values = Select[value, ruleQ];
nonRules=Complement[value,values];
listRules= Select[values, listRuleQ];
simpleRules = Complement[values, listRules];
simpleRules=srule/@simpleRules;

If[dbg, Print["symbolicXMLForm: listRules:",listRules,"\nsimpleRules:",simpleRules,"\nbadRules:",nonRules]; ];

Map[Print["Error: symbolicXMLForm: "//boldOrange,"The following input was ignored because it is not a rule: "//boldBlack,#//boldRed]&,nonRules];
attributeValuePairs=simpleRules;
data={}; 
data = symbolicXMLForm/@listRules;

SXML=XMLElement[element,attributeValuePairs,data];
Return[SXML];
];


symbolicXMLForm[attribute_-> value_]:= symbolicXMLForm[attribute-> stringer[value]];
symbolicXMLForm[x_?ListQ]:= symbolicXMLForm/@x;
symbolicXMLForm[x__?RuleQ]:= symbolicXMLForm[{x}];
symbolicXMLForm[x___]:= Module[{},Print["Error: symbolicXMLForm: "//boldOrange,"input is not a rule, a sequence of rules, or a list of rules: "//boldBlack, {x}//boldRed];Return[{}]];

*)


annotate[XMLElement[x_, y_, z_], XMLElement["annotation",u_, v_]]:= XMLElement[x, y, Join[z, {XMLElement["annotation",u,v]}]];

annotate[XMLElement[x_, y_, z_], u_?ListQ]:= Fold[annotate, XMLElement[x,y,z], u];


If[$$LoadBug, Print["Loading:arrays"]];


dimensionIsDefined[variable_, index_]:= Module[{x,i,p},
x=stringer[variable];
i=stringer[index];
p = Position[MB$Dimensions,x];
If[Length[p]<1, Return[False]];
p=First[Flatten[p]];
Return[MemberQ[MB$Dimensions[[p,2]],i]];
];



SymbolQ[x_]:= ToString[Head[x]]=="Symbol";
idQ[x_]:= SymbolQ[x]\[Or]StringQ[x];
dimensionToSymbolicSBML[id_?idQ,min_, max_,opt___?OptionQ]:= Module[{name,lower,upper,dim,tags,metaid,ann,notes,data},
tags={"id"-> stringer[id]};

(* If[Length[Names["MathSBML`Private`MB$CurrentDimension"]]<1, MB$CurrentDimension={}]; *) 
MB$CurrentDimension=Append[MB$CurrentDimension,stringer[id]]; 

name = Global`name/.{opt}/.{Global`name-> ""}//stringer; 
If[name!= "", tags = Append[tags,"name"-> name]]; 

metaid=Global`metaid/.{opt}/.{Global`metaid-> ""}//stringer; 
If[metaid!= "", tags = Append[tags,"metaid"-> metaid]]; 

If[NumberQ[min],
lower = {};
tags = Append[tags, "lowerLimit"-> ToString[min]];
,
lower = expression2SymbolicSBML[min];
lower=XMLElement["lowerLimit",{},{lower}];
];

If[NumberQ[max],
upper={};
tags = Append[tags, "upperLimit"-> ToString[max]];
,
upper = expression2SymbolicSBML[max];
upper = XMLElement["upperLimit",{},{upper}]; 
];

ann = {Global`annotation/.{opt}/.{Global`annotation-> {}}}//Flatten; 
notes = {Global`notes/.{opt}/.{Global`notes-> {}}}//Flatten//stringToNotes; 

data =Join[ann,notes,{upper,lower}]//Flatten; 
dim = XMLElement["dimension",tags,data];
Return[dim];
];
dimensionToSymbolicSBML[id_-> {min_,max_, opt___?OptionQ},opts___?OptionQ]:= dimensionToSymbolicSBML[id,min,max,opt];
dimensionToSymbolicSBML[u_?ListQ,opt___?OptionQ]:= Module[{dims, tags={}, metaid, ann, notes},
dims = dimensionToSymbolicSBML/@u;
metaid=Global`metaid/.{opt}/.{Global`metaid-> ""}//stringer; 
If[metaid!= "", tags = Append[tags,"metaid"-> metaid]]; 
ann = {Global`annotation/.{opt}/.{Global`annotation-> {}}}//Flatten; 
notes = {Global`notes/.{opt}/.{Global`notes-> {}}}//Flatten//stringToNotes; 
Return[XMLElement["listOfDimensions",tags,Join[ann,notes,dims]]];
]; 
dimensionToSymbolicSBML[u___]:= {}; 
dimensionToSBML[u___]:= XMLOut[dimensionToSymbolicSBML[u]];


listOfIndicesToSymbolicSBML[x___,opt___?OptionQ]:= Module[{indices,metaid, tags={}, ann, note},
indices = expression2SymbolicSBML/@Flatten[{x}];


metaid=Global`metaid/.{opt}/.{Global`metaid-> ""}//stringer;
If[metaid!= "", tags = Append[tags,"metaid"-> metaid]];  


ann = {Global`annotation/.{opt}/.{Global`annotation-> {}}}//Flatten; 
notes = {Global`notes/.{opt}/.{Global`notes-> {}}}//Flatten//stringToNotes; 

indices = XMLElement["listOfIndices",tags, Join[ann,notes,indices]];

Return[indices];
]


indexToSymbolicSBML[id_]:=Module[{type},
If[NumberQ[id], type="cn", type="ci"];
Return[XMLElement["index", {"id"-> stringer[id], "type"-> type},{}]];
];
indicesToSymbolicSBML[{i__}]:= Module[{ii,listOfIndices},
ii=Flatten[{i}];
listOfIndices = indexToSymbolicSBML/@ii;
listOfIndices = XMLElement["listOfIndices", {}, listOfIndices];
Return[listOfIndices];
];
indicesToSymbolicSBML[i__]:= indicesToSymbolicSBML[{i}];
indexToSBML[x___]:= XMLOut[indexToSymbolicSBML[x]];
indicesToSBML[x___]:= XMLOut[indicesToSymbolicSBML[x]];


objectLinkToSymbolicSBML[link_, object_, {indices___},opt___?OptionQ]:= Module[{listOfIndices,linkXML={},slink,metaid,tags,data,ann,notes,knownLinks={"compartmentLink","foreachLink","outsideLink","speciesLink","variableLink"}},

If[ifArrays[],
slink = stringer[link];
If[!MemberQ[knownLinks,slink],
Print["Error: "//boldOrange, "objectLinkToSymbolicSBML: unknown link "//boldBlack,slink//boldRed,"; allowed types are: "//boldBlack,knownLinks//boldBlack];
Return[{}]; 
]; 
tags = {"object"-> stringer[object]}; 

metaid=Global`metaid/.{opt}/.{Global`metaid-> ""}//stringer;
If[metaid!= "", tags = Append[tags,"metaid"-> metaid]];  


listOfIndices = {listOfIndicesToSymbolicSBML[indices]};
 
ann = {Global`annotation/.{opt}/.{Global`annotation-> {}}}//Flatten; 
notes = {Global`notes/.{opt}/.{Global`notes-> {}}}//Flatten//stringToNotes; 
data = Join[listOfIndices,ann, notes];


linkXML=XMLElement[slink, tags, data];

]; 

Return[linkXML];
];


getObjectLink[tag_, opt___?OptionQ]:= Module[{v,l,ruleQ,variables, indices,tagstring,opts},
opts=Flatten[{opt}]; 
ruleQ[x_]:= ToString[Head[x]]=="Rule";
l={}; 
If[ifArrays[],
v=tag/.opts/.{tag-> {}}; 
v=Flatten[{v}]; 
If[And@@ruleQ/@v,
variables = First/@v;
indices = Flatten/@List/@Last/@v;
tagstring=decontextify[tag]//stringer;
l=MapThread[objectLinkToSymbolicSBML[tagstring,#1,#2]&,{variables,indices}];

;,
Print["Error: "//boldOrange, tag//boldRed,"\[Rule]"//boldRed,v//boldRed," incorrectly formatted, should be "//boldBlack,tag//boldBlack," \[Rule]{var\[Rule]{i,j,k,...},var\[Rule]{i,j,k},...}"//boldBlack];
]; 
]; 
Return[l];
];  


getArrayDimensions[var_, opt___?OptionQ]:= Module[{dim},

dim={};
If[ifArrays[], 
dim = Global`ArrayDimensions/.opt/.{Global`ArrayDimensions-> {}};
If[Length[dim]>0, 
MB$CurrentDimension={}; 
dim = dimensionToSymbolicSBML[dim]; 
MB$Dimensions = Prepend[MB$Dimensions,{var,MB$CurrentDimension}]; 

If[ifArraysAreAnnotations[],
dim={annotationToSymbolicSBML[dim ]};
,
dim={dim};
];
];
]; 
Return[dim];
];



symbolicMathML[m_]:= Module[{p},
p=Flatten[{m}];
p=XMLElement["math",{"xmlns"-> "http://www.w3.org/1998/Math/MathML"},p];
Return[p];
]; 



matrixToSymbolicSBML[mat_?MatrixQ,opt___?OptionQ]:= Module[{mrows,m, matrixrow},
matrixrow[x_]:= XMLElement["matrixrow",{},Map[XMLElement["cn",{},{ToString[FortranForm[#]]}]&, x]];
mrows = matrixrow/@mat;
m=symbolicMathML[XMLElement["matrix",{},mrows]];
Return[m];
] ;
matrixToSymbolicSBML[mat_]:= Module[{},
Print["Error:"//boldOrange," matrixToSymbolicSBML:"//boldBlack,mat//boldRed," is not a matrix."//boldBlack];
Return[stringToNotes["\nMathSBML: matrixToSymbolicSBML: InvalidInput:\n"<>ToString[InputForm[mat]]<>"\n"]];
]

matrixToSBML[x___]:= XMLOut[matrixToSymbolicSBML[x]];


vectorToSymbolicSBML[vec_?VectorQ,opt___?OptionQ]:= Module[{v},
v = Map[XMLElement["cn",{},{ToString[FortranForm[#]]}]&, vec];
v=symbolicMathML[XMLElement["vector",{},v]];
Return[v];
] ;
vectorToSymbolicSBML[mat_]:= Module[{},Print["Error:"//boldOrange," vectorToSymbolicSBML: "//boldBlack,mat//boldRed," is not a vector."//boldBlack];
Return[stringToNotes["\nMathSBML: vectorToSymbolicSBML: Invalid Input:\n"<>ToString[InputForm[mat]]<>"\n"]];
];
vectorToSBML[x___]:= XMLOut[vectorToSymbolicSBML[x]];



MIRIAMcreatorToSymbolicXML[]:= MIRIAMcreatorToSymbolicXML[MIRIAMcreatorFamily,MIRIAMcreatorGiven,MIRIAMcreatorEMAIL,MIRIAMcreatorOrgname];

MIRIAMcreatorToSymbolicXML[family_?StringQ, given_?StringQ, email_?StringQ, org_?StringQ]:=Module[
{v,b,t,d,warn, dbg=False},

If[dbg, Print["dbg: MIRIAMcreatorToSymbolicXML: setMIRIAMCreator"]]; 
setMIRIAMcreator[family,given,email,org];

If[dbg, Print["dbg: MIRIAMcreatorToSymbolicXML: vCardToSymbolicXML"]]; 

v=vCardToSymbolicXML[MIRIAMcreatorFamily,MIRIAMcreatorGiven,MIRIAMcreatorEMAIL,MIRIAMcreatorOrgname];

If[dbg, Print["dbg: MIRIAMcreatorToSymbolicXML: warnings"]]; 

warn[test_, descr_]:= If[test,Print["Warning:"//boldRed,"MIRIAM creator "//boldBlack, descr//boldBlue," is not specified."//boldBlack]];

warn[family=="Indeterminate","Family"];
warn[given=="Indeterminate","Given"];
warn[org=="Indeterminate","Orgname"];
warn[StringMatchQ[org,RegularExpression[".*Indeterminate.*"]],"EMAIL"];

If[dbg, Print["dbg: MIRIAMcreatorToSymbolicXML: createBag"]]; 

b=createBag[];
b=appendToBag[b,v];
b=XMLElement["dc:creator",{"rdf:ParseType"->"Resource"},{b}]; 

If[dbg, Print["dbg: MIRIAMcreatorToSymbolicXML: setMIRIAMcreatedTime"]]; 
setMIRIAMcreatedTime[];
t=MIRIAMCreateTimeToSymbolicXML[];
If[MB$MetaID=="",Print["Warning:"//boldRed,"MIRIAMcreatorToSymbolicXML: Model MetaID has not been defined."//boldBlack]];

d=XMLElement["rdf:Description",{"rdf:about"-> stringer[MB$MetaID]},{b, t}];
d=XMLElement["rdf:RDF",{
"xmlns:rdf"-> "http://www.w3.org/1999/02/22-rdf-syntax-ns#","xmlns:dc"-> "http://purl.org/dc/elements/1.1/",
"xmlns:dcterms"-> "http://purl.org/dc/terms/",
"xmlns:vCard"-> "http://www.w3.org/2001/vcard-rdf/3.0#"
},{d}];
If[dbg, Print["dbg: MIRIAMcreatorToSymbolicXML: annotationToSymbolicSBML"]]; 
d=annotationToSymbolicSBML[d];
Return[d];
];
MIRIAMcreatorToSymbolicXML[x___]:=Print["Error: "//boldRed,"MIRIAMcreatorToSymbolicXML: correct format is \n\tMIRIAMcreatorToSymbolicXML[family,given,email,org]\nwhere all arguments are strings."//boldBlack];


setMIRIAMcreator[family_, given_, email_, org_]:= Module[{a,b,c,d},
a=setMIRIAMcreatorFamily[family];
b=setMIRIAMcreatorGiven[given];
c=setMIRIAMcreatorEMAIL[email];
d=setMIRIAMcreatorOrgname[org];
{a,b,c,d}//Return
]; 

resetMIRIAMcreator[]:=setMIRIAMcreator["Indeterminate", "Indeterminate", "Indeterminate@Indeterminate.Indeterminate", "Indeterminate"]

MIRIAMcreatorFamily="Indeterminate";
setMIRIAMcreatorFamily[x_?StringQ]:= (MIRIAMcreatorFamily=x);
setMIRIAMcreatorFamily[x___]:= Print["Error: "//boldRed,"setMIRIAMcreatorFamily: argument must be a string."//boldBlack];

MIRIAMcreatorGiven="Indeterminate";
setMIRIAMcreatorGiven[x_?StringQ]:=(MIRIAMcreatorGiven=x);
setMIRIAMcreatorGiven[x___]:= Print["Error: "//boldRed,"setMIRIAMcreatorGiven: argument must be a string."//boldBlack];

(* 
eMailAddressQ[x_?StringQ]:= StringMatchQ[x,RegularExpression["([a-zA-Z1-9_]+)((\\.[a-zA-Z1-9_]*[^.])*"<>")@([a-zA-Z1-9_]+)((\\.[a-zA-Z1-9_]*[^.])*"<>")"]]; 
*)


eMailAddressQ[x_?StringQ, echo_:False]:= Module[{ok, chars,badchars, emailAsciiStartCharacter, emailAsciiEndCharacter, invalidAsciiEmailCharacters,emailWord , emailsword,emailListOfWords,okemail, Eprint },

Eprint[xx___]:= If[echo, Print[xx]]; 

emailAsciiStartCharacter=FromCharacterCode[33];
emailAsciiEndCharacter=FromCharacterCode[126];
invalidAsciiEmailCharacters=Characters["()[]<>,;:'\\\""];
emailWord="["<>emailAsciiStartCharacter<>"-"<>emailAsciiEndCharacter<>"]+";
emailListOfWords=emailWord<>"((."<>emailWord<>")*)";
okemail= emailListOfWords<>"@"<>emailListOfWords;

(* basic address *)
(* ascii(.ascii)* @ ascii(.ascii)* *)

ok=StringMatchQ[x, RegularExpression[okemail]];
If[ok==False,
EPrint["Warning: ", "The email address ", "\""<> x<>"\"", " is invalid because it does not specify the pattern specified in RFC 2822, stuff[(.stuff)+]@stuff[(.stuff)+]"];
]; 

(* check for special cases *)

chars=Characters[x];
badchars = Intersection[chars, invalidAsciiEmailCharacters]; 

If[Length[badchars]>0, 
badchars=Union[badchars];
EPrint["Warning: ", "The character: \""<>#<>"\" in the email address ","\""<> x<>"\"", " is not allowed by RFC 2822"]&/@badchars;
ok=False;]; 

If[Length[StringCases[x, "@"]]>1, 
EPrint["Warning: ", "The email address ", "\""<> x<>"\"", " is invalid because only one \"@\" is permitted in an email address."];
ok=False;
]; 

If[StringTake[x, -1]==".", 
EPrint["Warning: ", "The email address ", "\""<> x<>"\"", " is invalid because an email address may not terminate with a period."];
ok=False;]; 

If[StringTake[x, -1]=="@", 
EPrint["Warning: ", "The email address ", "\""<> x<>"\"", " is invalid because an email address may not terminate with an @."];
ok=False;]; 

If[Length[StringCases[x, ".@"]]>0, 
EPrint["Warning: ", "The email address ", "\""<> x<>"\"", " is invalid because a period may not immediately precede the \"@\" in an email address."];
ok=False;
]; 
If[Length[StringCases[x, "@."]]>0, 
EPrint["Warning: ", "The email address ", "\""<> x<>"\"", " is invalid because a period may not immediately follow the \"@\" in an email address."];
ok=False;
]; 
If[Length[StringCases[x, ".."]]>0,
EPrint["Warning: ", "The email address ", "\""<> x<>"\"", " is invalid because two periods may not be adjacent to one another in an email address."];
ok=False;]; 

Return[ok]
];
eMailAddressQ[x___]:= False;

MIRIAMcreatorEMAIL="Indeterminate@Indeterminate.Indeterminate";
setMIRIAMcreatorEMAIL[x_?StringQ]:=Module[{ok},
If[eMailAddressQ[x],
(MIRIAMcreatorEMAIL=x),
Print["Error:"//boldRed,"The string: "//boldBlack,x//boldBlue," does not appear to be a valid email address."//boldBlack]
];
Return[MIRIAMcreatorEMAIL];
];
setMIRIAMcreatorEMAIL[x___]:= Print["Error: "//boldRed,"setMIRIAMcreatorEMAIL: argument must be a string."//boldBlack];

MIRIAMcreatorOrgname="Indeterminate";
setMIRIAMcreatorOrgname[x_?StringQ]:=(MIRIAMcreatorOrgname=x);
setMIRIAMcreatorOrgname[x___]:= Print["Error: "//boldRed,"setMIRIAMcreatorOrgname: argument must be a string."//boldBlack];




checkW3CDTF[s_?StringQ]:= Module[{monthDay,time,year},

monthDay="(((0[13578]|1[02])-(0[1-9]|[12][0-9]|3[0-1]))"<>"|"<>"((0[469]|11)-(0[1-9]|[12][0-9]|30))"<>"|"<>"(02-(0[1-9]|[12][0-9])))";
time="(T([0-1][0-9]|2[0-4]):([0-5][0-9]):([0-5][0-9]))";
year="(2[0-9][0-9][0-9]-)";
Return[StringMatchQ[s,RegularExpression[year<>monthDay<>time]]];
];

MIRIAMcreatedTime="Indeterminate";
setMIRIAMcreatedTime[]:=(MIRIAMcreatedTime=W3CDTF[]);
setMIRIAMcreatedTime[s_?StringQ]:= Module[{},
If[checkW3CDTF[s],
(MIRIAMcreatedTime=W3CDTF[]);
Return[s];
,
Print["Error: "//boldRed,"setMIRIAMcreatedTime: the input string "//boldBlack,
s//boldBlue," does not appear to be in W3CDTF yyyy-mm-ddThh:mm:ss"//boldBlack];
Return[setMIRIAMcreatedTime[]];
];
]; 

MIRIAMmodifiedTime="Indeterminate";
setMIRIAMmodifiedTime[]:=(MIRIAMmodifiedTime=W3CDTF[]);
setMIRIAMmodifiedTime[s_?StringQ]:= Module[{},
If[checkW3CDTF[s],
(MIRIAMmodifiedTime=W3CDTF[]);
Return[s];
,
Print["Error: "//boldRed,"setMIRIAMmodifiedTime: the input string "//boldBlack,
s//boldBlue," does not appear to be in W3CDTF yyyy-mm-ddThh:mm:ss"//boldBlack];
Return[setMIRIAMmodifiedTime[]];
];
]


MIRIAMCreateTimeToSymbolicXML[]:= 
XMLElement["dcterms:created",{"rdf:parseType"->"Resource"},{XMLElement["dcterms:W3CDTF",{},{MIRIAMcreatedTime}]}];

MIRIAMmodifiedTimeToSymbolicXML[]:= 
XMLElement["dcterms:created",{"rdf:parseType"->"Resource"},{XMLElement["dcterms:W3CDTF",{},{MIRIAMmodifiedTime}]}]



createBag[]:= XMLElement["rdf:Bag",{},{}];
getBagSize[XMLElement["rdf:Bag",l1_?ListQ,l2_?ListQ]]:=Length[l2];
getBagSize[z___]:=Print["Error: "//boldRed: " getBagSize: "//boldBlack,z//boldBlue," does not appear to be an rdf:Bag."//boldBlack];
appendToBag[
XMLElement["rdf:Bag",l1_?ListQ,l2_?ListQ], 
XMLElement["rdf:li",l3_?ListQ,l4_?ListQ]]:= 
XMLElement["rdf:Bag",l1,
Append[l2,XMLElement["rdf:li",l3,l4]]];
appendToBag[z_]:=Print["Error: "//boldRed: " appendToBag: "//boldBlack,z//boldBlue," Invalid syntax."//boldBlack]



vCardToSymbolicXML[family_?StringQ, given_?StringQ, email_?eMailAddressQ, org_?StringQ]:= 
XMLElement["rdf:li",{"rdf:parseType"-> "Resource"},
{XMLElement["vCard:N" ,{"rdf:parseType"-> "Resource"},
{XMLElement["vCard:Family",{},{family}],
XMLElement["vCard:Given",{},{given}]}
],
XMLElement["vCard:EMAIL",{},{email}],
XMLElement["vCard:ORG",{},{XMLElement["vCard:Orgname",{},{org}]}]
}];
vCardToSymbolicXML[x___]:= Module[{nargs,family, given, email, org},
nargs=Length[{x}]; 
If[nargs!=4,
Print["Error: "//boldRed,"vCardToSymbolicSBML: invalid argument syntax "//boldBlack,boldBlue/@{x},"; expected 4 arguments."//boldBlack]];
If[nargs>= 1, 
family={x}[[1]];
If[!StringQ[family],
Print["Error:"//boldRed," vCardToSymbolicXML The expression: "//boldBlack,family//boldBlue," does not appear to be a valid \"family\" String. Attempting Recovery"//boldBlack];
family=ToString[family];
],
family="Unspecified";
];
If[nargs>=2, 
given={x}[[2]];
If[!StringQ[given],
Print["Error:"//boldRed," vCardToSymbolicXML The expression: "//boldBlack,given//boldBlue," does not appear to be a valid \"given\" String. Attempting Recovery. "//boldBlack];
given=ToString[given];
],
given="Unspecified";
];
If[nargs>=3, 
email={x}[[3]];
If[!eMailAddressQ[email],
Print["Error:"//boldRed,"The expression: "//boldBlack,email//boldBlue," does not appear to be a valid email address string."//boldBlack];
email="Indeterminate@Email.Address";
],
email="Unspecified@Email.Address";
];
If[nargs>=4, 
org={x}[[4]];
If[!StringQ[org],
Print["Error:"//boldRed," vCardToSymbolicXML The expression: "//boldBlack,org//boldBlue," does not appear to be a valid \"Orgname\" String. Attempting Recovery."//boldBlack];
org=ToString[org];
],
org="Unspecified";
];
vCardToSymbolicXML[family,given,email, org]//Return
];





LTPrint["Model Builder loaded."]
