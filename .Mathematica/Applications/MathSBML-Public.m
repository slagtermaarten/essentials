(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



If[$$LoadBug, Print["Loading:functions"]];


init[]:= Module[{},
$SBML$SessionWarnings = 0;
$SBML$FileWarnings=0;
MathSBML`Private`$SBML$warnings= True;
]; 
init[];


Options[SBMLRead]={Global`debug-> False,Global`verbose-> False, Global`warnings-> True,Global`evaluateParameters-> True,Global`showKineticLaw-> True,
Global`showReactionParameters-> True,
Global`shortenODES-> False,Global`stats->False,Global`concise-> False, Global`underscore-> "\[UnderBracket]",Global`defaultIC-> "Indeterminate",Global`defaultParameterValue->"Indeterminate",Global`indeterminateValueString-> "Indeterminate",
Global`printModelName-> False,
Global`printSessionStats-> False ,
Global`return-> {Global`SBMLODES-> True, 
Global`SBMLIC-> True, 
Global`SBMLConstants-> True, 
Global`SBMLParameters-> True,
Global`SBMLModelVariables-> True,
Global`SBMLSpecies-> True,
Global`SBMLBoundaryConditions-> True,
Global`SBMLAlgebraicRules-> True,
Global`SBMLAssignmentRules-> True,
Global`SBMLConstraints-> True,
Global`SBMLInitialAssignments-> True,
Global`SBMLContext-> True,
Global`SBMLUnitDefinitions-> True,
Global`SBMLUnitAssociations->True, 
Global`SBMLReactions-> True,
Global`SBMLModelName-> True, 
Global`SBMLFunctions-> True, 
Global`SBMLEvents-> True,
Global`SBMLNameIDAssociations-> True,
Global`SBMLNumericalSolution-> 0,
Global`SBMLCompartments-> True,
Global`SBMLSpeciesCompartmentAssociations-> True,
Global`SBMLStoichiometryMatrix-> False,
Global`SBMLConservationMatrix-> False, 
Global`SBMLMassBalanceEquations-> False,
Global`SBMLMassActionEquations-> False,
Global`SBMLSpeciesTypes-> True,
Global`SBMLCompartmentTypes-> True, 
Global`SBMLKineticLaws-> True,
Global`SBMLMetaIDAssociations-> True},
Global`SBMLMassBalanceRateVector-> Automatic,
Global`SBMLSimplifyRateLaws-> False, 
Global`context-> "Automatic",
Global`verboseContext-> False,
Global`align-> "Left",
Global`NDSolveOptions-> {}, 
MathSBMLSaveVerboseData-> "False",
Global`PlotOptions-> {},
Global`LoadModelBuilder-> True,
Global`EchoLoad-> False,
Global`rationals-> False,
Global`verboseBuiltInUnits-> False,
Global`verboseNormalizedValues-> False,
Global`units-> False,
Global`verboseStoichiometry-> False,
Global`verboseMassBalanceEquations-> False,
Global`verboseMassActionEquations-> False, 
Global`reportMissingODES-> False
};


$SBML$modelcount = 0;
$SBML$SessionWarnings = 0;
$SBML$SessionStartTime=TimeUsed[];
$SBML$FilesRead=0;
$SBML$OutputFormatIsHTML=False;


SBMLRead[x_,opt___?OptionQ]:= Module[
{sbml, returnFlags, plot,plotopt, solve},


Off[General::"spell"];
Off[General::"spell1"];
Off[Part::"pspec"]; 

previouslyDefinedNamesInTheMathematicaEnvirnoment=Names["*"];
previouslyDefinedContextsInTheMathematicaEnvironment=Contexts[];

$CPU$Trace=False;
$CPUZero=TimeUsed[];
$CPU=$CPUZero;
$SBML$InitialCPU=TimeUsed[];
$SBML$debug = Global`debug/.{opt}/.Options[SBMLRead];
$SBML$verbose = Global`verbose/.{opt}/.Options[SBMLRead];
SBML$VerboseData = {}; 


$ReportMissingODE=Global`reportMissingODES/.{opt}/.Options[SBMLRead]; 

If[$SBML$debug,
Print["SBMLRead: {opt}:"//boldRed,{opt}//boldBlue];
Print["SBMLRead: $SBML$debug:"//boldRed,$SBML$debug//boldBlue];
];

MB$Load = Global`LoadModelBuilder/.{opt}/.Options[SBMLRead];
MB$Load=True; (* need for force this for checking *)
MB$Echo = Global`EchoLoad/.{opt}/.Options[SBMLRead];
$SBML$MetaIDAssociations={}; 

If[MB$Load, newModel[opt,Global`echo-> MB$Echo]]; 

If[$SBML$debug \[And] MB$Load,
Print["SBMLRead: Model Builder Loaded."//boldRed];
];

$SBML$Rationals=Global`rationals/.{opt}/.Options[SBMLRead];
$SBML$verboseContext=Global`verboseContext/.{opt}/.Options[SBMLRead];
$SBML$verboseBuiltInUnits = Global`verboseBuiltInUnits/.{opt}/.Options[SBMLRead]; 
$SBML$verboseNormalizedValues=Global`verboseNormalizedValues/.{opt}/.Options[SBMLRead];

$SBML$UseUnits=Global`units/.{opt}/.Options[SBMLRead];
$SBML$verboseNormalizedValues = And[$SBML$verboseNormalizedValues, $SBML$UseUnits];

$SBML$Normalize=$SBML$UseUnits; 

$SBML$printModelName = Global`printModelName/.{opt}/.Options[SBMLRead];
$SBML$modelcount++; 
$SBML$FileWarnings=0;
$SBML$warnings = Global`warnings/.{opt}/.Options[SBMLRead];

$SBML$evaluateParameters = Global`evaluateParameters/.{opt}/.Options[SBMLRead];


$SBML$KineticLaw = Global`showKineticLaw/.{opt}/.Options[SBMLRead];
$SBMLSimplifyRateLaws=Global`SBMLSimplifyRateLaws/.{opt}/.Options[SBMLRead];
$SBML$ShowReactionParameters=Global`showReactionParameters/.{opt}/.Options[SBMLRead];
$SBML$shortenODES = Global`shortenODES/.{opt}/.Options[SBMLRead];
$SBML$Stats = Global`stats/.{opt}/.Options[SBMLRead];
$SBML$Underscorecharacter=Global`underscore/.{opt}/.Options[SBMLRead];
$SBML$IndeterminateValue=Global`indeterminateValueString/.{opt}/.Options[SBMLRead];
$SBML$DefaultIC= ToString[Global`defaultIC/.{opt}/.Options[SBMLRead]];
$SBML$UseDefaultIC =($SBML$DefaultIC!= $SBML$IndeterminateValue);
$SBML$DefaultParameterValue=ToString[ Global`defaultParameterValue/.{opt}/.Options[SBMLRead]];
$SBML$UseDefaultParameterValue =($SBML$DefaultParameterValue!= $SBML$IndeterminateValue );
$SBML$VerboseAlign = ToString[(Global`align/.{opt}/.Options[SBMLRead])];

$SBML$ReportCPU = False; (* change this line to enable CPU observation *) 
If[$SBML$ReportCPU, $SBML$CPU={TimeUsed[]}]; 

SBMLUndefinedConstants={};

If[Global`concise/.{opt}/.Options[SBMLRead], 
$SBML$verbose=False;
$SBML$warnings=False;
$SBML$Stats=False;
];

If[$SBML$debug,
Print["SBMLRead: Basic constants set ."//boldRed];
];

saveVerboseData = $SBML$verbose \[Or] (MathSBMLSaveVerboseData/.{opt}/.Options[SBMLRead]); 

If[$SBML$debug,
Print["SBMLRead: verbose flag set ."//boldRed];
];

Clear[SBMLVariableQ];
Clear[SBMLParameterQ];
Clear[SBMLIC]; 
Clear[SBMLIC\[UnderBracket]SI];
Clear[SBMLSpeciesToSubstanceUnits];
Clear[SBMLSpeciesSIConcentration];
Clear[SBMLCompartmentSize];
Clear[SBMLSpeciesToUnitsOfTheSpecies];

If[$SBML$debug,
Print["SBMLRead: SBML parameters cleared."//boldRed];
];

SBMLVariableQ[unknownVariable_]:= False;
SBMLParameterQ[unknownParameter_]:= False;
SBMLIC[unknownVariable_]:= ToString[$SBML$IndeterminateValue];
SBMLSpeciesToSubstanceUnits[unknownVariable_]:= unknownVariable;
SBMLSpeciesSIConcentration={};

SBMLCompartmentSize[unknownVariable_]:= unknownVariable;
SBMLSpeciesToUnitsOfTheSpecies[unknownVariable_]:= 1;
SBMLIC\[UnderBracket]SI[unknownVariable_]:= SBMLIC[unknownVariable];

SBMLVariables={}; 
SBMLConstants={}; 
SBMLBoundaryConditions={};
SBMLGlobalParameters={}; 
SBMLReplacementRules={}; 
$SBML$MassActionVariables={};
SBML$MassAction$Equations={};
$SBML$SpeciesTypes={};
$SBML$SpeciesTypeAssociations={};
$SBML$CompartmentTypes={};
$SBML$CompartmentTypeAssociations={};

(* determine what needs to be returned *) 

returnFlags=(Global`return/.{opt}/.Options[SBMLRead]);

If[$SBML$debug,
Print["SBMLRead: setting return flags; {returnFlags}="//boldRed,{returnFlags}//boldBlue];
];


SBMLRead$return = (ToUpperCase[ToString[returnFlags]]!= "NONE");
If[SBMLRead$return,
returnFlags = Join[returnFlags,Global`return/.Options[SBMLRead]];

SBMLRead$returnODES= Global`SBMLODES/.returnFlags;
SBMLRead$returnContext=Global`SBMLContext/.returnFlags;
SBMLRead$returnIC= Global`SBMLIC/.returnFlags;
SBMLRead$returnConstants= 
 Global`SBMLConstants/.returnFlags;
SBMLRead$returnBoundaryConditions=Global`SBMLBoundaryConditions/.returnFlags;
SBMLRead$returnGlobalParameters=Global`SBMLParameters/.returnFlags;
SBMLRead$returnModelVariables= Global`SBMLModelVariables/.returnFlags;
SBMLRead$returnSpecies= Global`SBMLSpecies/.returnFlags;
SBMLRead$returnSpeciesTypes= Global`SBMLSpeciesTypes/.returnFlags;
SBMLRead$returnCompartmentTypes=Global`SBMLCompartmentTypes/.returnFlags;
SBMLRead$returnAlgebraicRules= Global`SBMLAlgebraicRules/.returnFlags;SBMLRead$returnConstraints= Global`SBMLConstraints/.returnFlags;
SBMLRead$returnInitialAssignments = Global`SBMLInitialAssignments/.returnFlags;
SBMLRead$returnAssignmentRules=Global`SBMLAssignmentRules/.returnFlags;
 SBMLRead$returnUnitDefinitions= Global`SBMLUnitDefinitions/.returnFlags;
SBMLRead$returnUnitAssociations=Global`SBMLUnitAssociations/.returnFlags;
SBMLRead$returnKineticLaws=Global`SBMLKineticLaws/.returnFlags;
SBMLRead$returnReactions= Global`SBMLReactions/.returnFlags;
SBMLRead$returnModelName=Global`SBMLModelName/.returnFlags;
SBMLRead$returnFunctions=Global`SBMLFunctions/.returnFlags;
SBMLRead$returnEvents=Global`SBMLEvents/.returnFlags;
SBMLRead$returnNameIDAssociations=Global`SBMLNameIDAssociations/.returnFlags;
SBMLRead$returnSolution=Global`SBMLNumericalSolution/.returnFlags;
SBMLRead$returnCompartments=Global`SBMLCompartments/.returnFlags;
SBMLRead$returnSpeciesCompartmentAssociations = Global`SBMLSpeciesCompartmentAssociations/.returnFlags;
SBMLRead$returnMetaIDAssociations=Global`SBMLMetaIDAssociations/.returnFlags;

SBML$NDSolveOptions = Sequence[Global`NDSolveOptions/.{opt}/.Global`NDSolveOptions-> {}];

solve = NumberQ[SBMLRead$returnSolution] \[And] SBMLRead$returnSolution>0; 
If[!NumberQ[SBMLRead$returnSolution],
Print[boldRed["Warning:"],
boldBlack["SBMLNDSolve must be assigned a numerical value, not "],
boldBlue[SBMLRead$returnSolution]
];
SBMLRead$returnSolution = 0; 
];
 

If[$SBML$debug,
Print["SBMLRead: basic SBMLRead return flags set, returnFlags="//boldRed,{returnFlags}//boldBlue];
];

SBMLRead$returnMassBalanceEquations=Global`SBMLMassBalanceEquations/.returnFlags;
SBMLRead$returnConservationMatrix=Global`SBMLConservationMatrix/.returnFlags;
SBMLRead$returnStoichiometryMatrix=(SBMLRead$returnConservationMatrix \[Or] (Global`SBMLStoichiometryMatrix/.returnFlags));

SBMLRead$returnMassActionEquations=And[Global`SBMLMassActionEquations/.returnFlags, SBMLRead$returnMassBalanceEquations];

If[$SBML$debug,
Print["SBMLRead:  SBMLRead$returnStoichiometryMatrix flags set"//boldRed];
];


If[SBMLRead$returnMassBalanceEquations,
SBML$RateVectorID=Global`SBMLMassBalanceRateVector/.{opt}/.Options[SBMLRead];
SBML$RateVectorID=stringer[SBML$RateVectorID];
If[SBML$RateVectorID=="Automatic",SBML$RateVectorID=Unique["v"];];
SBML$RateVectorID=ToExpression[SBML$RateVectorID];
SBML$MassBalanceEquations={};
];
If[$SBML$debug,
Print["SBMLRead:  mass balance flags set"//boldRed];
];


$SBML$VerboseStoichiometry=Global`verboseStoichiometry/.{opt}/.Options[SBMLRead]; 

$SBML$Verbose$MassBalanceEquations=And[SBMLRead$returnMassBalanceEquations,Global`verboseMassBalanceEquations/.{opt}/.Options[SBMLRead]]; 
$SBML$Verbose$MassActionEquations=And[SBMLRead$returnMassActionEquations,Global`verboseMassActionEquations/.{opt}/.Options[SBMLRead]]; 


];
If[$SBML$debug,
Print["SBMLRead: stoichiometric SBMLRead return flags set"//boldRed];
];

$SBML$Context = Global`context/.{opt}/.Options[SBMLRead];
$SBML$Context=ToString[$SBML$Context];

If[$SBML$debug,
Print["SBMLRead: Return flags set ."//boldRed];
];

cpuSet[]; 

If[$SBML$debug,
Print["SBMLRead::calling getSBML: x:"//boldRed,x//boldBlue];
Print["SBMLRead::calling getSBML: {opt}:"//boldRed,{opt}//boldBlue];
]; 

sbml  = getSBML[x,opt]; 

If[$SBML$debug,
Print["SBMLRead::returned from getSBML: sbml:"//boldRed,sbml//boldBlue];
]; 

plotopt=Global`PlotOptions/.{opt}/.Options[SBMLRead];
plot=(ListQ[plotopt] \[And] (Length[plotopt]>0))\[Or] ((ToUpperCase[ToString[plotopt]]) =="TRUE");

If[plot,
If[solve,
If[ToUpperCase[ToString[plotopt]]=="TRUE", 
SBMLPlot[sbml],
SBMLPlot[sbml, Sequence[plotopt]]
],
Print[boldRed["Warning:  "], boldBlack["SBMLRead: "],
boldBlue["PlotOptions\[Rule]"<>ToString[plotopt]],
boldBlack["\nignored because numerical solution is inhibited by "],"return\[Rule]{SBMLNumericalSolution\[Rule]0}"//boldBlue];
]; 
];

cpuReport["getSBML"]; 

If[Global`printSessionStats/.{opt}/.Options[SBMLRead],
Print["Aggregate Statistics: ",
$SBML$modelcount," models; ",
$SBML$SessionWarnings," warnings; ",
TimeUsed[]-$SBML$SessionStartTime," CPU."
];
]; 

sbml = Sort[sbml]; (* put options in alphabetical order *)

Return[sbml];
];


textODES[model_]:=Module[{eqs},
eqs=Global`SBMLODES/.model;
eqs=InputForm/@eqs;
eqs=ToString/@eqs;
eqs = (#<>"\n")&/@eqs;
eqs=StringJoin@@eqs;
Return[eqs]
];
textODES[model_, filename_]:= Module[{eqs,f},
eqs= textODES[model];
f=validateOutputFileName[filename];
f=Export[f,eqs,"text"];
Return[f];
];


SBMLNDSolve[{}, x___]:= Module[{}, Print["Error: "//boldRed, "Expecting "//boldBlack,"SBMLNDSolve[model, duration, options]"//boldBlue, " and not "//boldBlack,
"SBMLNDSolve[{}, ...]"//boldBlue ];
 Return[$Failed]
]; 
SBMLNDSolve[$Failed, x___]:= Module[{}, Print["Error: "//boldRed, "Expecting "//boldBlack,"SBMLNDSolve[model, duration, options]"//boldBlue, " and not "//boldBlack,
"SBMLNDSolve[$Failed, ...]"//boldBlue ];
 Return[$Failed]
]; 

SBMLNDSolve[x_,tmax_,opt___?OptionQ]:= Module[{n, ev,cr},


$ReportMissingIC=True;
(*$ReportMissingODE = False; *) 
$FirstIteration = True;
ev = Global`SBMLEvents/.x;

cr=Global`SBMLConstraints/.x/.{Global`SBMLConstraints-> {}};

$InitialRun=True;

If[Length[ev]>0 \[Or] Length[cr]>0, 

n=NDSolveSBMLWithEvents[x, tmax,ev,cr,opt];
,
n=NDSolveSBMLModel[x,0, tmax, opt];
]; 
Return[n];

];

SBMLNDSolve[x___]:= Module[{}, Print["Error: "//boldRed, "Expecting "//boldBlack,"SBMLNDSolve[model, duration, options]"//boldBlue];
 Return[$Failed]
]


DEBUGGridPlot=False; 

SBMLGridPlot[q_?InterpolationSetListQ,opt___?OptionQ]:=Module[{v},
If[DEBUGGridPlot, Print["SBMLGridPlot (1):"]]; 
(* v=Head/@decontextify/@First/@q[[1,3]]; *)

v=ToString/@(Head/@First/@q[[1,3]]);

(* v=StringReplace[decontextify/@ToString/@First/@q[[1,3]], "[t]"-> ""]; *)

If[DEBUGGridPlot, Print["SBMLGridPlot (1): v: ", v]]; 

Return[SBMLGridPlot[q,v,opt]];
];
SBMLGridPlot[q_?InterpolationSetListQ,{vars__},opt___?OptionQ]:=Module[{tstart,tend},
If[DEBUGGridPlot, Print["SBMLGridPlot (2): {vars}: ", {vars}]]; 
tstart=q[[1,1]];
tend=q[[Length[q],2]];
Return[SBMLGridPlot[q,{vars},{tstart,tend},opt]];
];
SBMLGridPlot[q_?InterpolationSetListQ,{vars__},{tstart_,tend_},opt___?OptionQ]:=Module[{p,n,colors,nc,g,np},
If[DEBUGGridPlot, Print["SBMLGridPlot (3): {vars}: ", {vars}]]; 
n=Length[Flatten[{vars}]];
colors=Hue/@(Range[n]/(1.` n));p=MapThread[SBMLPlot[q,{#1},PlotLabel->stringer[#1],PlotStyles->#2,Global`holdLegend->True,DisplayFunction->Identity,opt]&,{{vars},colors}];
nc=Global`columns/. {opt}/. {Global`columns->3};g=Partition[p,nc];
ng=Length[Flatten[g]];
np=Length[Flatten[p]];
If[np>ng,
g=Append[g,Take[p,ng-np]];
];
g=Show[GraphicsGrid[g]];
Return[g];
];
SBMLGridPlot[sol_,var_?ListQ,{tbegin_?NumberQ,tend_?NumberQ},opt___?OptionQ]:=Module[{n,colors,p,popt,nc,g,ng,np},
If[DEBUGGridPlot, Print["SBMLGridPlot (4):"]]; 
n=Length[Flatten[var]];
colors=Hue/@(Range[n]/(1.` n));
With[{popt=MyFilterOptions[Plot,System`DisplayFunction->Identity,opt ]},p=MapThread[SBMLPlot[sol,#1,{tbegin, tend}, PlotStyle->#2,PlotLabel->stringer[#1],Global`holdLegend-> True, popt]&,{var,colors}];
];
nc=Global`columns/. {opt}/. {Global`columns->3};
g=Partition[p,nc];
ng=Length[Flatten[g]];
np=Length[Flatten[p]];
If[np>ng,g=Append[g,Take[p,ng-np]];];
g=Show[GraphicsGrid[g]];
Return[g];
];
SBMLGridPlot[sol_,var_?ListQ,opt___?OptionQ]:=Module[{soln,g,tbegin,tend,debug=False},
If[DEBUGGridPlot, Print["SBMLGridPlot (5):"]]; 
soln=selectSolution[sol];
If[debug,Print["soln=",soln];];
{tbegin,tend}=getPlotTimes[soln];
g=SBMLGridPlot[soln,var,{tbegin,tend},opt];
Return[g];];
SBMLGridPlot[sol_,opt___?OptionQ]:=Module[{soln,g,vars},
If[DEBUGGridPlot, Print["SBMLGridPlot (6):"]]; 
vars=decontextify[Head/@First/@Flatten[sol]];
g=SBMLGridPlot[sol,vars,opt];Return[g];];


InterpolationSetListQ[x_]:= Module[{},
If[!ListQ[x], Return[False]]; 
Return[Length[Complement[Head/@x,{InterpolationSet}]]<1];
];


startAndEndValues[InterpolationSet[start_, end_, f_]]:= Module[{vars,startValues, endvalues},
vars = First/@f;
startValues = vars/.f/.{Global`t-> start};
endValues=vars/.f/.{Global`t-> end};
vars = decontextify[vars];

startValues = MapThread[{#1,start,#2}&, {vars,startValues}];
endValues = MapThread[{#1,end,#2}&,{ vars,endValues}];
Return[{startValues, endValues}]
];
startAndEndValues[f_?InterpolationSetListQ]:= Join@@(startAndEndValues/@f);


DEBUGPLOT=False;


SBML$LogPlotZero=0;
SBML$MultiPlot=False;
SBMLPlot[$Failed]:= Module[{}, Print["Error: "//boldRed, "SBMLPlot: unable to plot: "//boldBlack, $Failed//boldBlue]];
SBMLPlot[{}]:= Module[{}, Print["Error: "//boldRed, "SBMLPlot: unable to plot: "//boldBlack, {}//boldBlue]]

SBMLPlot[q_?InterpolationSetListQ, {}]:= Module[{},
Print["Error: "//boldRed, "SBMLPlot: Invalid input."//boldBlack];
Abort[];
];

SBMLPlot[q_?InterpolationSetListQ,z___?OptionQ]:=Module[{p,s,opts,legend,savs,vars,datasets,createLines,connectingLines,debug=True, dbg,zbad,logplot,zerovalue,hold,colors,df},

SBML$MultiPlot=True;
dbg=DEBUGPLOT;
If[dbg,Print["SBMLPlot: InterpolationSetListQ (0): "//boldRed, "SBMLPlot: plotting interpolation set"]];


opts=Select[{z},OptionQ];
hold=holdLegend/. opts/. {holdLegend->False};
colors=SBMLPlotColors/. opts/. {SBMLPlotColors->{}};

If[dbg,Print["SBMLPlot: InterpolationSetListQ: "//boldRed, "\ncolors:"//boldRed,colors//boldBlue, "\nhold:"//boldRed, hold//boldBlue]];

zbad=Complement[{z},{opts}];
logplot=stringer[type/. {z}/. {type->""}]=="Log";
zbad=Complement[zbad,{type->"Log"}];
zbad=Select[zbad,stringer[First[#1]]!="zero"&];
zbad=Select[zbad,!First[#1]===holdLegend];
zbad=Select[zbad,!First[#1]===SBMLPlotColors];
zbad=Select[zbad,!First[#1]===PlotStyles];
 
If[dbg, Print["SBMLPlot: InterpolationSetListQ: q:"//boldRed, q//boldBlue]];

If[Length[zbad]>0,(Print[boldOrange[">>Warning: "],boldBlack[" The option "],boldRed[#1],boldBlack[" is not allowed (or has not yet been implemented) for models that contain events."]]&)/@zbad;];

If[logplot,
If[dbg,Print["SBMLPlot: InterpolationSetListQ: "//boldRed, "About to call SBMLPlot[interpolatingFunction] - LogPlot"]];
zerovalue={zero/. {z}/. {zero->0}};
SBML$LogPlotZero=Max[zerovalue,0];
p=SBMLLogPlot[q,Sequence@@opts,PlotRange->All];,

If[dbg,Print["SBMLPlot: InterpolationSetListQ: "//boldRed, "About to call SBMLPlot[interpolatingFunction]"]];
p=(SBMLPlot[#1,Sequence@@opts,
Global`holdLegend->hold,
Global`SBMLPlotColors->colors,
PlotRange->All
]&)/@q
];


If[dbg,Print["SBMLPlot: InterpolationSetListQ: "//boldRed, "dbg: SBMLPlot: plotting interpolation sets: p: ",Show[p,DisplayFunction->$DisplayFunction]]];

SBML$MultiPlot=False;legend={MapThread[{Graphics[{Sequence@@#1,Line[{{0,0},{1,0}}]}],ToString[#2]}&,{MultiPlot$Styles,MultiPlot$Legends}]};


If[$VersionNumber<6, legend=Join[legend,{LegendSize->{1,1},LegendPosition->{1,-0.5`},TextStyle->{FontFamily->Times}}], 
legend=Join[legend,{LegendSize->{1,1},LegendPosition->{1,-0.5`},BaseStyle->{FontFamily->Times}}];
]; 

If[Length[p]>1&&!logplot,
sav=startAndEndValues[q];

vars=(#1[Global`t]&)/@ToExpression/@MultiPlot$Legends;

If[dbg, Print["SBMLPlot: InterpolationSetListQ: "//boldRed, "sav: "//boldRed, sav//boldBlue, "\nvars:"//boldRed, vars//boldBlue]]; 

datasets=(Cases[sav,{#1,___},\[Infinity]]&)/@vars;

If[dbg,Print["SBMLPlot: InterpolationSetListQ: "//boldRed, "dbg: SBMLPlot: plotting interpolation set: datasets(1): ",datasets//boldBlue]];

datasets=(Drop[Drop[#1,1],-1]&)/@datasets;

If[dbg,Print["SBMLPlot: InterpolationSetListQ: "//boldRed, "dbg: SBMLPlot: plotting interpolation set: datasets(2): ",datasets//boldBlue]];datasets=Transpose/@(Drop[#1,1]&)/@Transpose/@datasets;datasets=(Partition[#1,2]&)/@datasets;createLines[dataset_,style_]:=Module[{},If[dbg,Print["createLines: style:",style]];(Graphics[{Sequence@@style,Line[{#1[[1]],#1[[2]]}]}]&)/@dataset];datasets=MapThread[createLines,{datasets,MultiPlot$Styles}];If[dbg,Print["SBMLPlot: InterpolationSetListQ: "//boldRed, "datasets:",datasets]];connectingLines=Show[Flatten[datasets],DisplayFunction->Identity];p=Show[p,connectingLines];If[dbg,Print["SBMLPlot: InterpolationSetListQ: "//boldRed, "p with connectingLines:",Show[p,DisplayFunction->$DisplayFunction]]];,Off[Graphics::"gptn"];p=Show[p,DisplayFunction->Identity];On[Graphics::"gptn"];];If[AllowMultiPlot$Legends,s=ShowLegend[p,legend],df=DisplayFunction/. opts/. {DisplayFunction->$DisplayFunction};If[dbg,Print["SBMLPlot: InterpolationSetListQ: "//boldRed, "df:",df]];
Return[Show[p,DisplayFunction->df]]]
];
SBMLPlot[q_?InterpolationSetListQ,{var__},z___?OptionQ]:=Module[{tstart,tend},
If[DEBUGPLOT, Print["SBMLPlot: InterpolationSetListQ: (1): {var}: ", {var} ]];
tstart=q[[1,1]];
tend=q[[Length[q],2]];
Return[SBMLPlot[q,{var},{tstart,tend},z]];];

SBMLPlot[q_?InterpolationSetListQ,{var__},{tstart_,tend_},z___?OptionQ]:=Module[{convars,devars,r,n,selvars},

If[DEBUGPLOT, Print["SBMLPlot: InterpolationSetListQ: (2): {var}: ", {var}]];

selvars[InterpolationSet[t1_,t2_,set_],vin_]:=Module[{newset,v,  notfound, varsInSolution},


v= If[StringQ[#], ToExpression[#], #]&/@vin;


newset=Select[set,MemberQ[v,First[#1]]&];

varsInSolution=First/@set;
debugPrint[DEBUGPLOT, "SBMLPlot: selvars: varsInSolution:", varsInSolution];
debugPrint[DEBUGPLOT, "SBMLPlot: selvars:  v:", v]; 
debugPrint[DEBUGPLOT, "SBMLPlot: selvars:  defunctionate/@v:", defunctionate/@v]; 


notFound=Complement[decontextify/@defunctionate/@v, decontextify/@defunctionate/@varsInSolution];
Print["Warning:"//boldRed, "SBMLPlot: The requested variable "//boldBlack,defunctionate[#]//boldBlue, " was not found in the solution set for the time period "//boldBlack , {t1, t2}//boldBlack]&/@notFound;


If[DEBUGPLOT, 
Print["v:", v]; 
Print["set: ", set, "\nnewset:", newset];
];

If[Length[newset]==0, 
Print["Error: "//boldRed, "SBMLPlot: requested variables: "//boldBlack,(defunctionate/@ v)//boldBlue, " not found in solution set. There is nothing to plot. " //boldBlack];
Abort[];
];
Return[InterpolationSet[t1,t2,newset]];
];

 
devars=decontextify/@{var};
convars=contextify/@devars;
(* devars=(#1[Global`t]&)/@devars;
convars=(#1[Global`t]&)/@convars;*)
devars = functionate/@devars;
convars= functionate/@convars; 


r=MapThread[#1->#2&,{convars,devars}];
(* n=(selvars[#1,Union[Join[devars,convars]]]&)/@q; *) 

n=(selvars[#1,convars]&)/@q;


If[DEBUGPLOT, Print["SBMLPlot: InterpolationSetListQ: (2): n: ", n]];

Return[
SBMLPlot[n,PlotRange->{{tstart,tend},All},z]
];
];

SBMLPlot[InterpolationSet[t1_,t2_,sol_],{var__?nonOptionQ},{tbegin_?NumberQ,tend_?NumberQ},opt___?OptionQ]:=Module[{},
If[DEBUGPLOT, Print["SBMLPlot:InterpolationSet: (1)"//boldRed]]; 

SBMLPlot[sol,{var},{Max[tbegin,t1],Min[tend,t2]},opt]
];

SBMLPlot[InterpolationSet[t1_,t2_,sol_],var_?nonOptionQ,{tbegin_?NumberQ,tend_?NumberQ},opt___?OptionQ]:=Module[{},
If[DEBUGPLOT, Print["SBMLPlot:InterpolationSet: (2)"//boldRed]]; 
SBMLPlot[sol,var,{Max[tbegin,t1],Min[tend,t2]},opt]
];

SBMLPlot[InterpolationSet[t1_,t2_,sol_],{tbegin_?NumberQ,tend_?NumberQ},opt___?OptionQ]:=Module[{},
If[DEBUGPLOT, Print["SBMLPlot:InterpolationSet: (3)"//boldRed]]; 
SBMLPlot[sol,{Max[tbegin,t1],Min[tend,t2]},opt]
];

SBMLPlot[InterpolationSet[t1_,t2_,sol_],var_?nonOptionQ,opt___?OptionQ]:=Module[{},
If[DEBUGPLOT, Print["SBMLPlot:InterpolationSet: (4), var="//boldRed, var//boldBlue]]; 

SBMLPlot[sol,var,{t1,t2},opt]
];

SBMLPlot[InterpolationSet[t1_,t2_,sol_],opt___?OptionQ]:=Module[{},
If[DEBUGPLOT, Print["SBMLPlot:InterpolationSet: (5)"//boldRed]]; 
If[DEBUGPLOT, Print["SBMLPlot: InterpolationSet: (5): sol:"//boldRed, sol//boldBlue]];
SBMLPlot[sol,{t1,t2},opt]
];


SBMLPlot[sol_, {var__?nonOptionQ},{tbegin_?NumberQ, tend_?NumberQ},opt___?OptionQ]:= Module[{legends, variables,n,colors,defaultColors,plotType, soln,p,legend,allowLegend,popt,styles,trace, dbg=False,tt, vars, plot, gopt},
trace=DEBUGPLOT;
dbg=DEBUGPLOT; 
If[dbg \[Or] trace, Print["==== SBMLPlot Trace ON ====\nSBMLPlot: {var}="//boldRed,{var}//boldBlue,"\nSBMLPlot: {tbegin, tend}="//boldRed,{tbegin,tend}//boldBlue, "\nSBMLPlot: {opt}="//boldRed, {opt}//boldBlue]]; 

soln = selectSolution[sol]; 

If[dbg, Print["decontextify/@{var}: ", decontextify/@stringer/@{var}]]; 
If[dbg, Print["contextify/@decontextify/@{var}: ",contextify/@ decontextify/@stringer/@{var}]]; 

variables=contextify/@decontextify/@stringer/@{var}; 
variables = Map[If[StringQ[#], ToExpression[#], #]&, variables];

vars = variables;

variables = Map[#[Global`t]&,variables];
legends = decontextify[Map[ToString,{var}]];
n=Length[legends];

(* get styles and make sure it is a list of lists *)
styles=Global`PlotStyles/.{opt}/.{Global`PlotStyles-> {}};
(* if PlotSTyles is not used, maybe PlotStyle was used globally *) 
If[Length[styles]<1, styles=PlotStyle/.{opt}/.{PlotStyle-> {}}]; 

If[dbg, Print["styles (1):",styles]]; 

(* If there is just one style, apply it to each variable*)
If[\[Not]ListQ[styles], styles=Table[{styles},{n}]];
If[dbg, Print["styles (2):",styles]]; 

(* If there is more than one style, but only a one level list, apply them to all variables *)

If[Length[styles]>0,
If[\[Not]ListQ[First[styles]],styles={styles}];
];
If[dbg, Print["styles (3):",styles]]; 

While[Length[styles]<n, styles=Append[styles,{}]]; 
If[Length[styles]>n, Print["Warning: "//boldRed," SBMLPlot: "//boldBlack, Length[styles]//boldBlue, " PlotStyles supplied only "//boldBlack,n//boldBlue," expected. Extra styles ignored. "//boldBlack];
styles=Take[styles,n];
];
If[dbg, Print["styles (4):",styles]]; 


(* add in colors if not supplied in PlotStyles *)

colors =Flatten[ Global`SBMLPlotColors/.{opt}/.{Global`SBMLPlotColors-> {}}]; 
(* If[SameQ[colors,None], 
colors = Map[Hue,Range[n]/(1.0*n)]]; *)
If[Length[colors]>0,
If[Length[colors]>n, Print["Warning: "//boldRed,"SBMLPlot: "//boldBlack, "\nSBMLPlotColors\[Rule]"<>ToString[colors]//boldBlue," contains "//boldBlack, Length[colors]//boldBlue, " colors; only "//boldBlack,
n//boldBlue,
boldBlack["\nare expected. The input will be interpreted as"],
boldBlue["\nSBMLPlotColors\[Rule]"<>ToString[Take[colors,n]]]
];
colors=Take[colors,n];
];
];

If[dbg,Print["n=",n," Length[colors]:",Length[colors]]];
If[Length[colors]<n,
defaultColors = Map[Hue,Range[n]/(1.0*n)];
defaultColors=Drop[defaultColors,Length[colors]];
colors=Join[colors, defaultColors];
];
If[dbg, Print["colors:",colors]]; 
If[dbg, Print["original styles:",styles]]; 

(* Seems that Mathematica choose the LAST style to use, not the FIRST, like Options *)
styles=MapThread[Prepend[#1,#2]&, {styles, colors}];

If[dbg, Print["revised styles:",styles]]; 

plotType = stringer[(Global`type/.{opt})]; 
If[plotType=="Log", 
p=SBMLLogPlot[soln,{var}, {tbegin, tend},opt];
Return[p];
];
allowLegend = \[Not](Global`holdLegend/.{opt}/.{Global`holdLegend-> False});
AllowMultiPlot$Legends=allowLegend;



If[trace, 
 Print["SBMLPlot: "//boldRed, "variables: "//boldRed, variables//boldBlue];
Print["SBMLPlot: "//boldRed, "styles: "//boldRed, styles//boldBlue]; 
Print["SBMLPlot: "//boldRed, "legends: "//boldRed, legends//boldBlue]; 
]; 

With[{popt=MyFilterOptions[Plot,opt]}, 

If[trace, Print["SBMLPlot: "//boldRed, "{popt}:"//boldRed, {popt}//boldBlue]]; 

If[SBML$MultiPlot,
If[trace, Print["SBMLPlot: SBML$MultiPlot"//boldRed]]; 

If[$VersionNumber<6,
p=Plot[Evaluate[variables/.soln], {Global`t,tbegin,tend},
PlotStyle->styles,  
Sequence[popt], 
DisplayFunction-> Identity
],

plot[x_, directives_]:= Plot[x/.soln, {Global`t, tbegin, tend}, PlotStyle->directives, popt]; 
(*
p=Plot[variables/.soln, {Global`t,tbegin,tend},
PlotStyle->((Directive@@#)&/@styles), 
Sequence[popt]
]*)

p=MapThread[plot, {variables, Directive/@styles}]
]; 

MultiPlot$Colors=colors;
MultiPlot$Legends = legends;
MultiPlot$Styles = styles;
,
If[trace, Print["SBMLPlot: "//boldRed, "Not SBML$MultiPlot: allowLegend: "//boldRed, allowLegend//boldBlue]]; 

If[$VersionNumber<6, 

If[allowLegend,
p=Plot[Evaluate[variables/.soln], {Global`t,tbegin,tend},
Sequence[popt],
Graphics`Legend`PlotLegend-> legends,
PlotStyle->styles, 
Graphics`Legend`LegendPosition-> {1,-0.5},
Graphics`Legend`LegendSize-> {.5,1}],
p=Plot[Evaluate[variables/.soln], {Global`t,tbegin,tend},
Sequence[popt],
PlotStyle->styles]
], 
If[trace, Print["SBMLPlot: variables:"//boldRed, variables//boldBlue]]; 

plot[x_, directives_]:= Plot[x/.soln, {Global`t, tbegin, tend}, PlotStyle->directives, popt, PlotRange-> All]; 

If[allowLegend,

p=
{ 
Show[MyLegend[legends, colors],AspectRatio-> 1/GoldenRatio],
MapThread[plot, {variables, Directive/@styles}]
}; 
If[trace, Print["SBMLPlot: p "//boldRed, p//boldBlue]];

With[{gopt=MyFilterOptions[Graphics,opt]}, 
p=Show[p, gopt,  Axes-> True]
]
,
p=Show[MapThread[plot, {variables, Directive/@styles}]]
]

]; 

]


];

If[trace, Print["SBMLPlot: Plot: "//boldRed, p, "\n=== SBMLPlot Trace: EXIT ==="//boldRed]]; 

Return[p]
];

MyLegend[names_?ListQ, colors_?ListQ]:= Module[{p, n, nc, x, y, xy},
n=Length[names];
nc=Length[colors]; 
If[n != nc,
Print["Error:"//boldRed, "MyLegend:"//boldBlue, " number of names = "//boldBlack, n//boldBlack, " is different from the number of colors = "//boldBlack, nc//boldBlack];
 Return[$Failed]
]; 

x=1.1;
xy=Table[Scaled[{x, 1-1.0*y/(n+1)}], {y, 1, n}]; 
p=MapThread[Text, {stringer/@names, xy}];
p=Transpose[{colors, p}];
p=Graphics/@p
]; 



SBMLPlot[sol_, variable_?nonOptionQ, {tbegin_?NumberQ, tend_?NumberQ}, opt___?OptionQ]:= Module[{vars,lvars,r,n,pvar,p, dbg},
dbg=DEBUGPLOT; 
If[dbg, Print["SBMLPlot 2: variable: "//boldRed, variable//boldBlue, " {begin, end}:"//boldRed, {tbegin, tend}//boldBlue, " {options}:"//boldRed, {opt}//boldBlue]; ]; 

(*rev 2.6.2 to check for "ALL" here *)
If[ToUpperCase[ToString[variable]]=="ALL", 
Return[SBMLPlot[sol, {tbegin, tend}, opt]]
];


SBMLPlot[sol, {variable}, {tbegin, tend}, opt]
];



SBMLPlot[sol_,{tbegin_?NumberQ, tend_?NumberQ}, opt___?OptionQ]:= Module[{soln,vars, dbg},
dbg=DEBUGPLOT;
If[dbg, Print["SBMLPlot 3: {tbegin, tend}: "//boldRed, {tbegin, tend}//boldBlue, " {opt}:"//boldRed, {opt}//boldBlue];];

soln = selectSolution[sol]; 

(* added the following check 2.7.3 in responsed to bug 1892076 *)
vars = Global`variables/.{opt}/.{Global`variables-> All}; 
If[SameQ[vars, All], vars  =Map[Head,Map[First,Flatten[soln]]]];

If[dbg, Print["SBMLPlot 3: vars: ", vars]]; 
Return[SBMLPlot[soln, vars,{tbegin,tend},opt]]
];


SBMLPlot[sol_, variable_?nonOptionQ, opt___?OptionQ]:= Module[{p, tbegin, tend, soln, dbg},
dbg=DEBUGPLOT;
(**) If[dbg, Print["SBMLPlot 4: variable: "//boldRed, variable//boldBlue, " {options}:"//boldRed, {opt}//boldRed]] ;(* *)

(* allow plotting of either solutions or solutions incorporated within a model *)
soln = selectSolution[sol]; 
{tbegin, tend} = getPlotTimes[soln]; 


p = SBMLPlot[soln,variable, {tbegin, tend},opt];
Return[p];
];

SBMLPlot[sol_, opt___?OptionQ]:= Module[{vars,svars, tbegin, tend, soln, dbg},
dbg=DEBUGPLOT;
If[dbg, Print["SBMLPlot 5: opt: "//boldRed, {opt}//boldBlue];]; 

(* allow plotting of either solutions or solutions incorporated within a model *)
soln = selectSolution[sol]; 

{tbegin, tend} = getPlotTimes[soln]; 

vars = Flatten[{Global`variables/.{opt}/.Global`variables-> {"All"}}]; 
If[dbg, Print["SBMLPlot 5: variables: ", vars]]; 

svars = ToUpperCase/@ToString/@vars;
If[MemberQ[svars, "ALL"], 
Return[SBMLPlot[soln, {tbegin,tend},opt]]
]; 

Return[SBMLPlot[soln,vars,  {tbegin,tend},opt]];
];


getPlotTimes[soln_]:= Module[{solTimes, n1, tbegin, tend, pos,part},
solTimes[System`InterpolatingFunction[deltat_, ___][t_]]:= Flatten[{deltat}];
part[x_,{i__}]:= Part[x,i];
(* replace the following 2.4.4 because may have things like expression * interpolatingFUnction, etc, rather than just pure interpolating funcitons*)
(* n1=Map[Last,Flatten[soln]]; *)
pos=Position[soln, InterpolatingFunction[___][Global`t]];
n1 = part[soln,#]&/@pos;

n1=Map[solTimes,n1];
(* numerical error could make the solution times slightly different: some may be real and some may be integer, for example! 
corrected 2.4.15 - 9 May 2005 - Tokyo Hackathon *)
(* {tbegin, tend} = (n1//Union)//Flatten;
*)
tbegin = Max[First/@n1];
tend = Min[Last/@n1];

Return[{tbegin, tend}]; 
]; 

selectSolution[sol_]:= Module[{},
If[MemberQ[ToString/@First/@sol, "SBMLNumericalSolution"], 
Return[Global`SBMLNumericalSolution/.sol];
, 
Return[sol//Flatten]; 
];
Print[boldOrange["Error:"], boldRed["selectSolution: law of excluded middles violation. Catastrophic failure of nature."];];
Abort[]; 
]; 


SBMLListPlot[vars_,{t_,tmin_,tmax_, dt_}, sol_,opt___?OptionQ]:= Module[{data,x,variableNames,xname,xdata,plts,colors,nvars,style},
data=dataTable[vars,{t,tmin,tmax,dt},sol];
variableNames = First[data];
xname=First[variableNames];
variableNames=Rest[variableNames];

data = Transpose[Rest[data]];
xdata = First[data];
data = Rest[data];
nvars = Length[data];
colors = Range[nvars]*1.0/nvars;

style = {PlotStyle/.{opt}/.{PlotStyle-> {}}}//Flatten;
plots = MapThread[ListPlot[Transpose[{xdata,#1}],PlotStyle-> Flatten[{Hue[#2],style}],MyFilterOptions[ListPlot,opt],DisplayFunction-> Identity]&,{data,colors}];
Return[Show[plots,MyFilterOptions[Show,opt],DisplayFunction-> $DisplayFunction]];


]


Options[SBMLWrite]={
Global`format->"",
Global`inputfile-> "",
Global`outputfile-> ""
};


SBMLWrite[opt___?OptionQ]:= Module[{model, format, inputfile,outputfile,msg,tofile, dbg=False},
inputfile = (Global`inputfile/.{opt});
inputfile=stringer[inputfile]; 
If[!fileExists[inputfile], Print["Error: "//boldOrange,"The file "//boldBlack,
ToFileName[Directory[],inputfile]//boldRed, " does not exist."//boldBlack]; Return[$Failed];];

If[dbg, Print["SBMLWrite: inputfile:",inputfile]];

format=(Global`format/.{opt}/.Options[SBMLWrite])//ToString//ToUpperCase;
$SBML$OutputFormat=format;
$SBML$OutputFormatIsHTML=(format=="HTML");
Switch[format,
"BERKELEYMADONNA",
model = SBMLRead[inputfile,MathSBMLSaveVerboseData-> True,
 opt,Global`context-> "$",Global`LoadModelBuilder-> False]
,
_,
model = SBMLRead[inputfile,MathSBMLSaveVerboseData-> True,
 opt,Global`LoadModelBuilder-> False]; 
];

$SBML$OutputFormatIsHTML=False;

$SBML$Inputfile=inputfile;
outputfile = (Global`outputfile/.{opt}/.Options[SBMLWrite])//ToString;
tofile = outputfile!= ""; 

If[dbg, Print["SBMLWrite: inputfile,outputfile,format:",inputfile,",",outputfile,",",format]];

If[tofile,
outputfile=validateOutputFileName[outputfile];
];
If[outputfile=="$Failed",
tofile=False;
];

Switch[format,

"BERKELEYMADONNA",
msg = If[tofile, 
toBerkeleyMadonnaForm[model,outputfile, opt], 
toBerkeleyMadonnaForm[model,opt]
]; 
,

"XPP",
msg = If[tofile, 
toXPPForm[model,outputfile], 
toXPPForm[model]
]; 

,
"FORTRAN",

Print[boldRed["Warning: SBMLWrite: FORTRAN format is Developemental and subject to both error. Please report any errors to the developers."]
];
msg = fortranize[model, opt];
If[tofile, msg = Export[outputfile,msg,"Text"]]; 
,

"HTML",
msg = htmlPrint[model,opt]; 
If[dbg, Print["SBMLWrite: msg (1): ", msg]]; 

(* The character \[CenterEllipsis] is \ [ CenterEllipsis ] and is not three dots!*)

msg = StringReplace[msg, {"\[CenterEllipsis];"-> "", "\[CenterEllipsis]"-> "", "\[EmptySet]"-> "","\[Rule]"-> "&rarr;" (*"&#x2192;"*) , "\[RightArrowLeftArrow]"-> "&larr;<span style=\"margin-left:-12;\">&rarr;</span>" (* "&#x21CC;"*) }];

If[dbg, Print["SBMLWrite: msg (2): ", msg]]; 
If[tofile, msg=Export[outputfile,msg,"Text"]];
,

_, 
printWarning["SBMLWrite: invalid format = '"<>format<>"'. No file written. Valid formats are: XPP, HTML"];
msg = model; 
]; 
Return[msg];
];


If[$$LoadBug, Print["Loading: model builder funtions"]];


fixMathematicaENotation[x_?StringQ]:= StringReplace[x, "*^"-> "e"];


checkMathMLSubset[math_, type_, id_]:=Module[{dbg=False,XML2Sym,m, commands, attributes,
oksubset={"math", "lambda","cn","ci","csymbol","sep","apply", "piecewise", "piece", "otherwise", "eq","neq", "gt", "lt", "geq", "leq", "plus", "minus", "times", "divide", "power", "root", "abs", "exp", "ln", "log", "floor", "ceiling", "factorial", "and", "or", "xor", "not", "degree", "bvar","logbase", "sin", "cos", "tan", "sec", "csc", "cot", "sinh", "cosh", "Tanh", "sech", "csch", "coth", "arcsin", "arccos", "arctan", "arcsec", "arccsc", "arccot", "arcsinh", "arccosh", "arctanh", "arcsech", "arccsch", "arccoth", "true", "false", "notanumber", "pi", "infinity", "exponentiale", "semantics", "annotation", "annotation-xml"},
okattributes={"style", "class", "id", "encoding","definitionURL", "type","xmlns"},
oktypes={"real", "integer", "rational", "e-notation"},
types, xmlns, isanumber, notanumber
}, 

isanumber[x_]:= numberFormQ[x] \[Or] eFormQ[x]; 
notanumber[x_]:= !isanumber[x]; 

If[type!= "function", oksubset=Complement[oksubset, {"bvar","lambda"}]]; 

If[dbg, Print["checkMathMLSubset: math:", math]];
XML2Sym["ci",___]:= {};
XML2Sym["csymbol",___]:= {}; 
XML2Sym[x___]:= XMLElement[x];

m=math/.{XMLElement-> XML2Sym};
m=Flatten[m/.{XMLElement-> List}];
If[dbg, Print["checkMathMLSubset: m:", m]]; 
attributes = Select[m, SameQ[Head[#], Rule]&];
types=Select[attributes, First[#]=="type"&]; 
commands=Complement[m, attributes];
commands=Select[commands,notanumber];
If[dbg, Print["checkMathMLSubset: attributes:", attributes]]; 
If[dbg, Print["checkMathMLSubset: commands:", commands]]; 
If[dbg, Print["checkMathMLSubset: types:", types]]; 

commands = Complement[commands, oksubset];
attributes=Complement[First/@attributes, okattributes];
xmlns=Cases[attributes,{_,"xmlns"},Infinity];
attributes=Complement[attributes,xmlns];

types = Select[types, !MemberQ[oktypes, Last[#]]&]; 

Print["Error:"//boldRed," Invalid MathML element "//boldBlack,#//boldBlue, " used in "//boldBlack, type//boldBlue, " definition for "//boldBlack, id//boldBlue]&/@commands;
Print["Error:"//boldRed," Invalid MathML attribute "//boldBlack, #//boldBlue, " used in "//boldBlack, type//boldBlue, " definition for "//boldBlack, id//boldBlue]&/@attributes;
Print["Error:"//boldRed," Invalid MathML type "//boldBlack, #//boldBlue,  " used in "//boldBlack, type//boldBlue, " definition for "//boldBlack, id//boldBlue]&/@types;

Return[]
];



If[$$LoadBug, Print["Loading:newModel"]];


setEcho[value_]:= (MB$Echo=value);
setEcho[]:= setEcho[True];
hideEcho[]:= setEcho[False];
setEcho[];

setArray[value_]:= (MB$Arrays=value);
setArray[]:= setArray[True];
setArray[False];

ifArrays[]:= MB$Arrays;

setArraysAreAnnotations[value_]:= (MB$ArraysAreAnnotations=value);
setArraysAreAnnotations[]:= setArraysAreAnnotations[True];
setArraysAreAnnotations[];

ifArraysAreAnnotations[]:= MB$ArraysAreAnnotations;
$SBML$Rationals=False;



popCompartment[]:= Module[{n},
If[!ListQ[MB$CurrentCompartment], MB$CurrentCompartment={MB$CurrentCompartment}]; 

If[Length[MB$CurrentCompartment]>0, 
n=First[MB$CurrentCompartment];
MB$CurrentCompartment=Rest[MB$CurrentCompartment];
,
n=Null;
]; 
Return[n];
];
If[$$LoadBug, Print["Loading:newModel:pushCompartment"]];
pushCompartment[n_]:= Module[{},
If[n==Null,MB$CurrentCompartment={}; Return[];]; 
If[(ListQ[MB$CurrentCompartment]&&Length[MB$CurrentCompartment]>0),
If[stringer[n]!= stringer[First[MB$CurrentCompartment]], 
MB$CurrentCompartment=
Prepend[MB$CurrentCompartment,stringer[n]]];
,
MB$CurrentCompartment={n}];
];

forgetCompartment[n_]:= Module[{},
MB$CurrentCompartment=
Flatten[MB$CurrentCompartment/.{n-> {},stringer[n]-> {}}];
];
If[$$LoadBug, Print["Loading:newModel:setCompartment"]];
setCompartment[n_]:= Module[{},

If[compartmentExists[stringer[n]],
pushCompartment[n];
If[MB$Echo,Print["Current compartment set to "//boldGreen,n//boldBlue]];
,
If[n==Null,
pushCompartment[Null],
Print["Warning:"//boldOrange,"pushCompartment: Requested compartment "//boldBlack,n//boldRed," does not exist."//boldBlack];
]; 
];
]


If[$$LoadBug, Print["Loading:newModel:newModel"]];
newModel[opt___?OptionQ]:= Module[{stringer,val,c, defaultNotes, family, given,email,org, creator, domain}, 


SBML$CheckModelContext = Global`checkModelContext/.{opt}/.{Global`checkModelContext-> False};

Off[General::"spell"];
Off[General::"spell1"];
Off[Part::"pspec"]; 

stringer[x_?StringQ]:= x;
stringer[x_]:= ToString[InputForm[x]]; 
stringer[x_-> y_]:= (stringer[x]-> stringer[y]);

val = (Global`Arrays)/.{opt}/.{Global`Arrays-> ifArrays[]}; 
setArray[val]; 

val = (Global`ArraysAreAnnotations)/.{opt}/.{Global`ArraysAreAnnotations-> ifArraysAreAnnotations[]}; 
setArraysAreAnnotations[val]; 

$SBML$Rationals=(Global`rationals)/.{opt}/.{Global`rationals-> False};

family=stringer/@(MIRIAM`Family/.{opt}/.{MIRIAM`Family-> $MachineName<>" at "<>$MachineDomain<>" (automatically generated)"});
given=stringer/@(MIRIAM`Given/.{opt}/.{MIRIAM`Given->$UserName<>" (automatically generated)"});
domain=$MachineDomain;
If[domain=="", domain="not.specified"]; 
email=stringer/@(MIRIAM`EMAIL/.{opt}/.{MIRIAM`EMAIL-> "anonymous@"<>domain});
org=stringer/@(MIRIAM`Orgname/.{opt}/.{MIRIAM`Orgname-> "MathSBML User Community"}); 
creator=Global`CreatedBy/.{opt}/.{Global`CreatedBy-> {family,given,email,org}}; 
creator=Flatten[{creator}];
Switch[Length[creator],
0, creator={family, given, email, org};,
1, creator=Join[creator,{given,email, org}];,
2, creator=Join[creator, {email, org}];,
3, creator=Join[creator, {org}];,
_, creator=Take[creator,4]
];


MB$Modify=False;

MB$Species={};
MB$SpeciesTypes={};
MB$CompartmentTypes={};
MB$Compartments={}; 
MB$Functions={};
MB$Events={}; 
MB$Reactions={};
MB$Parameters={}; 
MB$InitialAssignments={};
MB$Units={};
MB$Rules={};
MB$Constraints={};
MB$UnitsOfTheSpecies={};
MB$CurrentCompartment=Null;
previouslyDefinedNamesInTheMathematicaEnvirnoment=Names["*"];
previouslyDefinedContextsInTheMathematicaEnvironment=Contexts[];

resetDefaultUnits[];

MB$ID=(Global`id)/.{opt}/.{Global`id-> "SBMLModel"};
MB$ID=stringer[MB$ID];
MB$MetaID=(Global`metaid)/.{opt}/.{Global`metaid-> ""};
MB$MetaID=stringer[MB$MetaID];


If[!SIDQ[MB$ID] , 
c=fixSID[MB$ID];
Print["Error: "//boldRed, "\""<>MB$ID<>"\""//boldBlue, "is not a valid SID, replaced with "//boldBlack, "\""<>c<>"\""//boldBlue];
MB$ID=c;
];
If[MB$MetaID== "",
MB$MetaID="\[UnderBracket]"<>MB$ID;
,
If[!SIDQ[MB$MetaID] , 
c=fixSID[MB$MetaID];
Print["Error: "//boldRed, "\""<>MB$MetaID<>"\""//boldBlue, "is not a valid SID, replaced with "//boldBlack, "\""<>c<>"\""//boldBlue];
MB$MetaID=c;
];
]; 

$SBML$IDTable={};
$SBML$MetaIDTable={};
$SBML$function$bvars={}; 
$SBML$MetaIDAssociations={};

addID[MB$ID,"model",False];
addMetaID[MB$MetaID,MB$ID, "model", True];

MB$ModelAnnotation={};
MB$SBMLAnnotation={}; 
MB$Name= (Global`name)/.{opt}/.{Global`name->MB$ID}; 
$SBML$Underscorecharacter=Global`underscore/.{opt}/.Options[SBMLRead];
$SBML$IndeterminateValue=Global`indeterminateValueString/.{opt}/.Options[SBMLRead];

setAnnotationNamespace["http://sbml.org/software/mathsbml/ns"]; 
setAnnotationPackage["mathsbml"]; 

setSBMLAnnotation["AuthorConfiguration"->
 {"SoftwareVersion"-> {$MathSBML$Version},
"MathematicaVersion"-> {$Version},
"ProcessorType"-> {$ProcessorType},
"MachineType"-> {$MachineType},
"System"-> {$SystemID},
"OperatingSystem"-> {$OperatingSystem},
"date"-> {W3CDTF[]},
"MachineName"-> {$MachineName},
"MachineID"-> {$MachineID},
"MachineDomain"-> {$MachineDomain},
"UserName"-> {$UserName},
"ProductInformation"-> stringer/@$ProductInformation
},
"mathsbml","http://sbml.org/software/mathsbml/ns"];



MB$reactioncounter=1; 
MB$speciescounter=1;
MB$speciestypecounter=1;
MB$functioncounter=1;
MB$unitcounter=1;
MB$compartmentcounter=1;
MB$parametercounter=1;
MB$variablecounter=1;
MB$eventcounter = 1;
MB$rulecounter=1;
MB$dimensionCounter=1;
MB$CurrentDimension={};
MB$indexCounter=1; 

MB$SBMLNotes={};
MB$AssignmentRuleVariables={};
MB$RateRuleVariables={};
MB$ReactionVariables={};
MB$BoundaryConditionSpecies={}; 

defaultNotes ="<p style='font-size:x-small;'>This is a Systems Biology Markup Language (SBML) file, generated by MathSBML "<>$MathSBML$Version<>" "<>now[]<>".  SBML is a form of XML, and most XML files will not display properly in an internet browser. To view the contents of an XML file use the \"Page Source\" or equivalent button on you browser. </p>";
MB$ModelNotes = (Global`notes/.{opt}/.Global`notes-> "")//stringer;
MB$ModelNotes=MB$ModelNotes<>defaultNotes;

MB$Comments = (Global`comments/.{opt}/.Global`comments-> "")//stringer;



MB$Echo = (Global`echo)/.{opt}/.{Global`echo-> False};

MB$Index[x_]:= {};
MB$Dimensions= {};

MB$Level=stringer[(Global`level)/.{opt}/.{Global`level-> 2}]; 
MB$Version=stringer[(Global`version)/.{opt}/.{Global`version-> 3}];
MB$LevelVersion=MB$Level<>"."<>MB$Version;

Switch[MB$Level,
"2",
Switch[MB$Version,
"1",
MB$xmlns="http://www.sbml.org/sbml/level2",
"2",
MB$xmlns="http://www.sbml.org/sbml/level2/version2",
"3",
MB$xmlns="http://www.sbml.org/sbml/level2/version3",
"4",
MB$xmlns="http://www.sbml.org/sbml/level2/version4",


_,
Print["Error: newModel: "//boldRed," SBML Level "//boldBlack, MB$Level//boldBlue," Version "//boldBlack,MB$Version//boldBlue," is not supported."//boldBlack];
Abort[];
]; ,
_,
Print["Error:"//boldRed," SBML Level "//boldBlack, MB$Level//boldBlue," is not currently supported by the model builder."//boldBlack];
Abort[];
]; 
setModelAnnotation[MIRIAMcreatorToSymbolicXML@@creator];

If[MB$Echo,Print["Model "//boldGreen,MB$ID//boldBlue," initialized: SBML Level "//boldGreen, MB$Level//boldBlue," Version "//boldGreen, MB$Version//boldBlue]];

];

If[$$LoadBug, Print["Loading:newModel: newModel: default "]];
newModel[x_?nonOptionQ, opt___?OptionQ]:= newModel[Global`id-> x,opt];

If[$$LoadBug, Print["Loading:newModel: modifyModel"]];
modifyModel[opt___?OptionQ]:= Module[{id, name, val},
id=stringer[(Global`id)/.{opt}/.{Global`id-> ""}]; 
name= stringer[(Global`name)/.{opt}/.{Global`name->""}]; 
If[id!= "", MB$ID=id];
If[name!= "", MB$Name=name];

val = (Global`Arrays)/.{opt}/.{Global`Arrays-> ifArrays[]}; 
setArray[val]; 

val = (Global`ArraysAreAnnotations)/.{opt}/.{Global`ArraysAreAnnotations-> ifArraysAreAnnotations[]}; 
setArraysAreAnnotations[val]; 

];

If[$$LoadBug, Print["Loading:newModel:showModel"]];
showModel[opt___?OptionQ]:=Module[{m,saveEcho},
saveEcho=MB$Echo;
m=SBMLRead[createSymbolicModel[], opt, Global`evaluateParameters-> False, Global`verbose-> True, Global`return->"None", Global`LoadModelBuilder-> False, Global`warnings-> False]; 
MB$Echo=saveEcho;
Return[m]; 
]; 

If[$$LoadBug, Print["Loading:newModel:loadSimulator"]];
loadSimulator[opt___?OptionQ]:=Module[{echo,m,dbg=False},
echo=MB$Echo;
m=createSymbolicModel[];
dbg = (Global`debug/.{opt}/.{Global`debug-> False}); 
If[dbg,Print["loadSimulator: m(1)="//boldRed,m//boldBlue]];
If[dbg, Print["loadSimulator: {opt}="//boldRed,{opt}//boldBlue]];

m= SBMLRead[m,opt, Global`verbose-> False];
If[dbg, Print["loadSimulator: m(2)="//boldRed,m//boldBlue]];
MB$Echo=echo;
Return[m]; 
];

If[$$LoadBug, Print["Loading:newModel: loadModelBuilder"]];
loadModelBuilder[file_,opt___?OptionQ] := Module[{echo,m},
echo = MB$Echo;
m=SBMLRead[file,  opt,Global`LoadModel-> True,Global`EchoLoad-> True]; 
MB$Echo=echo;
Return[m];
]




If[$$LoadBug, Print["setting Annotation"]];
setModelAnnotation[MIRIAMcreatorToSymbolicXML["None Given","No Name Given","no@email.address","Unspecified"]];

If[$$LoadBug, Print["executing newModel"]];
newModel["temporary"];

If[$$LoadBug, Print["resetting MIRIAM"]];
resetMIRIAMcreator[];
 


If[$$LoadBug, Print["Loading:dumpModel"]];


dumpModel[]:= Module[{},
Print["MB$Functions="//boldRed,MB$Functions//boldBlack];
Print["MB$Units="//boldRed,MB$Units//boldBlack];
Print["MB$CompartmentTypes="//boldRed,MB$CompartmentTypes//boldBlack]; 
Print["MB$SpeciesTypes="//boldRed,MB$SpeciesTypes//boldBlack];

Print["MB$Compartments="//boldRed,MB$Compartments//boldBlack]; 
Print["MB$Species="//boldRed,MB$Species//boldBlack];
Print["MB$UnitsOfTheSpecies="//boldRed,MB$UnitsOfTheSpecies//boldBlack];

Print["MB$Parameters="//boldRed,MB$Parameters//boldBlack]; 
Print["MB$InitialAssignments="//boldRed, MB$InitialAssignments//boldBlack];
Print["MB$Rules="//boldRed,MB$Rules//boldBlack];
Print["MB$Reactions="//boldRed,MB$Reactions//boldBlack];
Print["MB$Events="//boldRed,MB$Events//boldBlack]; 

Print["MB$ID="//boldRed,MB$ID//boldBlack]; 
Print["MB$MetaID="//boldRed,MB$MetaID//boldBlack]; 

Print["MB$Name="//boldRed,MB$Name//boldBlack]; 

Print["MB$ModelNotes="//boldRed, MB$ModelNotes//boldBlack];
Print["MB$SBMLNotes="//boldRed,MB$SBMLNotes//boldBlack];

Print["MB$ModelAnnotation="//boldRed, MB$ModelAnnotation//boldBlack];
Print["MB$SBMLAnnotation="//boldRed, MB$SBMLAnnotation//boldBlack]; 


Print["MB$functioncounter="//boldRed,MB$functioncounter//boldBlack];
Print["MB$unitcounter="//boldRed,MB$unitcounter//boldBlack];
Print["MB$compartmentcounter="//boldRed,MB$compartmentcounter//boldBlack];
Print["MB$speciescounter="//boldRed,MB$speciescounter//boldBlack];
Print["MB$variablecounter="//boldRed,MB$variablecounter//boldBlack];
Print["MB$parametercounter="//boldRed,MB$parametercounter//boldBlack];
Print["MB$rulecounter="//boldRed,MB$rulecounter//boldBlack];
Print["MB$reactioncounter="//boldRed,MB$reactioncounter//boldBlack]; 
Print["MB$eventcounter="//boldRed,MB$eventcounter//boldBlack];

]; 


removeEmptyStandardElements[s_]:= Module[{sbmlStandardElements={"listOfFunctionDefinitions","listOfUnitDefinitions","listOfCompartments","listOfCompartmentTypes", "listOfSpeciesTypes","listOfSpecies","listOfParameters","listOfInitialAssignments","listOfReactions","listOfRules","listOfConstraints","listOfEvents","listOfReactants","listOfProducts","listOfModifiers", "notes"},sr,r},
sr[x_]:= ToString[XMLOut[XMLElement[x,{},{}]]];
r=Rule[sr[#],"<!-- "<>sr[#]<> " -->"]&/@sbmlStandardElements;
Return[StringReplace[s,r]];
]


createModel[opt___?OptionQ]:= Module[{SBML, dbg=False},
SBML = createSymbolicModel[opt];
If[dbg, Print["createModel:"//boldRed, "SBML: "//boldBlue, SBML//boldBlack]]; 

SBML = postprocess[SBML]; 
If[dbg, Print["createModel:"//boldRed, "SBML (postprocessed): "//boldBlue, SBML//boldBlack]]; 

SBML=ExportXMLString[SBML];
If[dbg, Print["createModel:"//boldRed, "SBML (Exported): "//boldBlue, SBML//boldBlack]]; 


If["RemoveEmptySBML"/.{opt}/.{"RemoveEmptySBML"-> True},
SBML=removeEmptyStandardElements[SBML];
];
SBML = sunderscore[SBML];
SBML = fixMathematicaENotation[SBML];
Return[SBML];
];
createModel[fileName_?StringQ,opt___?OptionQ]:= Module[{s,f},
f=validateOutputFileName[fileName];
If[f!= "$Failed",
s = createModel[opt]; 
s=Export[f,s,"text"];
Return[s];
];
];
getSBMLModel[x___]:= createModel[x];

createSymbolicModel[opt___?OptionQ]:= Module[{functions,units, compartments, species, parameters, rules, reactions, events, SBML,notes,preface,comments,speciesTypes,compartmentTypes,dbg=False,sub,inline, initialAssignments, includeAnnotations, includeNotes, includeComments, stuff},

includeAnnotations = "annotations"/.{opt}/.{"annotations"-> True}; 
includeNotes="notes"/.{opt}/.{"notes"-> True};
includeComments="comments"/.{opt}/.{"comments"-> True}; 

functions = XMLElement["listOfFunctionDefinitions",{},Last/@MB$Functions];
units =XMLElement["listOfUnitDefinitions",{}, Last/@MB$Units];
compartments=XMLElement["listOfCompartments",{},Last/@MB$Compartments];
speciesTypes = XMLElement["listOfSpeciesTypes",{},Last/@MB$SpeciesTypes];
compartmentTypes = XMLElement["listOfCompartmentTypes",{},Last/@MB$CompartmentTypes];

species = XMLElement["listOfSpecies",{},Last/@MB$Species];
parameters = XMLElement["listOfParameters",{},Last/@MB$Parameters];
initialAssignments=XMLElement["listOfInitialAssignments", {}, Last/@MB$InitialAssignments];
rules = XMLElement["listOfRules",{},Last/@MB$Rules];
constraints=XMLElement["listOfConstraints",{},MB$Constraints];
reactions = XMLElement["listOfReactions",{},Last/@MB$Reactions];
events =XMLElement["listOfEvents",{}, Last/@MB$Events];
If[dbg,
Print["createSymbolicModel:MB$ModelNotes:",MB$ModelNotes];
Print[MB$ModelNotes!= ""];
];

(* following line fixed 2.3.22*)
notes=stringToNotes[{MB$ModelNotes}//Flatten];

If[dbg, 
Print["createSymbolicModel:MB$ModelNotes:",MB$ModelNotes];
Print["createSymbolicModel:notes:",notes];
]; 
sub={functions,units};
If[ToExpression[MB$LevelVersion ]>2.15, 
sub=Append[sub,compartmentTypes];
];
If[ToExpression[MB$LevelVersion ]>2.15, 
sub=Append[sub,speciesTypes];
];

sub = Join[sub, {compartments, species,parameters }]; 
If[ToExpression[MB$LevelVersion ]>2.15, 
sub=Append[sub,initialAssignments];
];
sub = Join[sub, {rules }]; 
If[ToExpression[MB$LevelVersion ]>2.15, 
sub=Append[sub,constraints];
];

sub = Join[sub, {reactions, events }]; 

inline={"id"->stringer[MB$ID], "name"-> stringer[MB$Name]};
If[MB$MetaID!= "", AppendTo[inline,"metaid"-> stringer[MB$MetaID]]]; 

If[includeAnnotations, sub=Join[ MB$ModelAnnotation, sub]]; 
If[includeNotes, sub = Join[notes, sub]]; 

SBML = XMLElement["model",inline, sub];

SBML = {SBML}; 
 If[includeAnnotations, SBML=Join[ MB$SBMLAnnotation, SBML]]; 
 If[includeNotes, SBML=Join[ MB$SBMLNotes, SBML]]; 


SBML = XMLElement["sbml", {"xmlns"-> MB$xmlns, "level"-> MB$Level, "version"-> MB$Version},SBML];

If[includeComments, 
preface = {
XMLObject["Declaration"]["Version"->"1.0","Encoding"->"UTF-8"],
XMLObject["Comment"][" Generated "<>now[]<>" "],
XMLObject["Comment"][" Generated by MathSBML "<>$MathSBML$Version<>" "],
XMLObject["Comment"][" Generated using Mathematica Version "<>$Version<>" " ]
};
If[MB$Comments=="",comments={},
comments=XMLObject["Comment"][MB$Comments];
preface=Append[preface,comments];
]; 

,
preface = {
XMLObject["Declaration"]["Version"->"1.0","Encoding"->"UTF-8"]};
];


SBML = XMLObject["Document"][preface,SBML,{}];
If[dbg, Print["createSymbolicModel: SBML: ", SBML]]; 
Return[SBML];
];
getModel[x___]:= createSymbolicModel[x];



retrieveSBMLObject[type_?StringQ,id_?StringQ]:= Module[{data, c,p,x},

data =
Switch[type,
"function", MB$Functions,
"unit",MB$Units,
"compartment",MB$Compartments,
"compartmentType",MB$CompartmentTypes,
"species",MB$Species,
"speciesType",MB$SpeciesTypes,
"parameter",MB$Parameters,
"initialAssignment", MB$InitialAssignments,
"rule",MB$Rules,
"reaction",MB$Reactions,
"event",MB$Events,
_, 
Print["Error: "//boldRed,"retrieveSBMLObject "//boldBlack," type = "//boldBlack, type//boldBlue," unknown."//boldBlack];
Abort[];
]; 
c = Map[First,data]; 
If[MemberQ[c,id],
p=Position[c,id];
While[ListQ[p], p=First[p]]; 
x=Last[data[[p]]];
Return[x];
];
Return[{}];
]; 


globalize[Rule[a_,b_]]:= Rule[contextify[a,"Global"]//ToExpression,b];
globalize[{x_}]:= globalize/@{x};
globalize[x_]:= contextify[decontextify[x],Global];


extractAndUpdateXMLOptions[XMLElement[x___],opt___?OptionQ]:= Module[{y},
y=extractXMLOptions[XMLElement[x]];
y = stringrule/@(Join[{opt},y]//Flatten);
Return[y];
];



getReaction[n_?IntegerQ]:= Module[{m},
m=Length[MB$Reactions];
If[n>m \[Or] n<1, Print["Error: getReaction: "//boldOrange," Reaction: "//boldBlack,n//boldRed," does not exist. There are "//boldBlack,m//boldRed," reaction definitions."//boldBlack];Return[{}];];
Return[MB$Reactions[[n]]//Last];
]; 
getReactionNumber[id_?SIDQ]:=Module[{m,n},
m = First/@MB$Reactions;
n=Position[m, stringer[id]];
If[Length[n]<1, Print["Error: getReactionNumber: "//boldOrange,"Reaction: "//boldBlack,id//boldRed," does not exist. Valid reactions are "//boldBlack, m//boldRed];Return[0];]; 
While[ListQ[n], n=First[n]];
Return[n];
]; 

getReaction[id_?SIDQ]:=Module[{m,n},
n=getReactionNumber[id];
If[n>0,
Return[MB$Reactions[[n]]//Last],
Return[{}]
]; 
]; 

getReaction[x_?ListQ]:= getReaction/@Flatten[x];
getReaction[x___]:= Module[{},
Print["Error: getReaction: "//boldOrange, "Correct format is "//boldBlack,"getReaction[id]"//boldRed, " where id is an integer or an SID "//boldBlack,"getReaction[Integer]"//boldRed, " or "//boldBlack,
"getReaction[{x1,x2,...}]"//boldRed," where x1,x2,... are integers or SIDs."//boldBlack];
Return[{}];
];

getNumberOfReactions[]:= Length[MB$Reactions];
getReactions[]:= getReaction[Range[getNumberOfReactions[]]];



replaceReaction[i_?IntegerQ, XMLElement["reaction",x___]]:= Module[{n,j},
n=Length[MB$Reactions];
If[n>0 \[And] i>0 \[And] i<=n, 

j=getSBMLfield["id",XMLElement["reaction",x]]; 
If[j=="", j=MB$Reactions[[i,1]]];


MB$Reactions=ReplacePart[MB$Reactions,j-> XMLElement["reaction",x],i];
If[MB$Echo, Print["Reaction ",i, " replaced."]];
Return[];
]; 
Print["Error: replaceReaction: "//boldOrange," unable to replace reaction "//boldBlack,i//boldRed];
Return[];
]; 

replaceReaction[id_?SIDQ, XMLElement["reaction",x___]]:= Module[{n},
n=getReactionNumber[id];
If[n>0, 
replaceReaction[n, XMLElement["reaction",x]]; 
Return[];
]; 
Print["Error: replaceReaction: "//boldOrange," unable to replace reaction "//boldBlack,id//boldRed];
Return[];
]; 

replaceReaction[x___]:= Print["Error: "//boldOrange,"replaceReaction: "//boldRed, "Invalid arguments. Correct format is:"//boldBlack,"replaceReaction["//boldBlack," Integer|SID "//boldBlack,","//boldBlack, " XMLElement[\"reaction\",...]"//boldBlack," ]"//boldBlack];




 reactionToSBML[{x__?ListQ}]:=Module[{SBML}, 
SBML =Flatten[ reactionToSymbolicSBML/@{x}];
SBML = XMLElement["listOfReactions",{},SBML]; 
SBML=ExportXMLString[SBML];
SBML = sunderscore[SBML];
SBML=fixMathematicaENotation[SBML];
Return[SBML];
];

reactionToSBML[opt___?OptionQ]:= Module[{r},
r = reactionToSymbolicSBML[opt]; 
r=ExportXMLString[r];
r=sunderscore[r];
r=fixMathematicaENotation[r]; 
Return[r];
];

reactionToSBML[reaction_, opt___?OptionQ]:= reactionToSBML[Global`reaction-> reaction, opt];

reactionToSBML[x___]:=
Print[boldRed["Error:"], boldBlack["The argument to reactionToSBML must be a sequence of options."]]; 



deleteReaction[opt___?OptionQ]:= Module[{n,c,p},
n =( Global`id/.{opt}/.{id-> ""})//stringer;
If[id=="", 
Print["Error: deleteReaction"//boldRed," No "//boldBlack,"id"//boldBlue," was specified."//boldBlack]]; 
removeID[n, "reaction"]; 
MB$Currentid=n;
c = Map[First,MB$Reactions]; 
If[MemberQ[c,n],
p=Position[c,n];
MB$Reactions= Drop[MB$Reactions,First[p]]; 
Return[True];
];
Return[False];
];
deleteReaction[x_, opt___?OptionQ]:= deleteReaction[Global`id-> x,opt];
removeReaction[x___]:=Module[{flag},
flag = deleteReaction[x];
If[flag, 
If[MB$Echo,Print["Reaction "//boldGreen,MB$Currentid//boldBlue," removed."//boldGreen]],
Print["Error: "//boldRed,"removeReaction:Requested reaction "//boldBlack,MB$Currentid//boldRed," does not exist. No removal peformed."//boldBlack]];
];


checkKineticLaw[opt___?OptionQ]:=Module[{dbg,klaw,parameters, reaction,modifiers, reactants,products,species,compartments,GlobalParameters,functions, missingSpecies,xml,myXMLElement,syms,undefinedSymbols,undefinedSpecies,definedSymbols, undefinedModifiers,id, caller, allSpeciesReferenced , csymbols,math, csymbolsInFormula},




caller=invokedBy/.{opt}/.{invokedBy-> "Unknown"};

dbg=Global`debug/.{opt}/.{dbg-> False};

csymbolsInFormula = csymbolsused/.{opt}/.{csymbolsused-> {}}; 

(* get parameters and then convert to just parameter ids, not values *)
id=stringer[Global`id/.{opt}/.{Global`id-> "ID_unassigned"}];

debugPrint[dbg, "checkKineticLaw: id",id]; 

parameters=Global`parameters/.{opt}/.{Global`parameters-> {}};
parameters=Flatten[List[#]]&/@(parameters/.{Rule-> List});
parameters =stringer/@( First/@parameters);

klaw = Global`kineticLaw/.{opt}/.{Global`kineticLaw-> {}};
If[OptionQ[klaw],klaw=Global`math/.klaw/.{Global`math-> {}}]; 
reaction=Global`reaction/.{opt}/.{Global`reaction-> {}};
modifiers=Global`modifiers/.{opt}/.{Global`modifiers-> {}};

debugPrint[dbg, "checkKineticLaw: reaction ",reaction]; 
debugPrint[dbg, "checkKineticLaw: caller ",caller]; 

If[ListQ[reaction]\[And] Length[reaction]==0,
reactants=List[Global`reactants/.{opt}/.{Global`reactants-> {}}]//Flatten;
products=List[Global`products/.{opt}/.{Global`products-> {}}]//Flatten;
debugPrint[dbg,"checkKineticLaw: products(1)",products];

If[reactants=={} \[And]products=={},
reaction=First[{opt}];
If[!SameQ[Head[reaction],Rule], Print["Error: unknown form for reaction."]];
debugPrint[dbg,"checkKineticLaw: reaction",reaction];
{reactants, products}=(reaction/.{Rule-> List, Plus-> List, Times-> List});
{reactants, products}=Flatten/@List/@{reactants, products};
reactants=Select[reactants, !NumberQ[#]&];
products=Select[products, !NumberQ[#]&];

(* reactants=First[reaction];
products=Last[reaction]; *)
debugPrint[dbg,"checkKineticLaw: products(2a)",products];
debugPrint[dbg,"checkKineticLaw: reactants(2a)",reactants];

];
debugPrint[dbg,"checkKineticLaw: products(2b)",products];
debugPrint[dbg,"checkKineticLaw: reactants(2b)",reactants];

,
If[SameQ[Head[reaction], Rule],
{reactants, products}=(reaction/.{Rule-> List, Plus-> List, Times-> List});
{reactants, products}=Flatten/@List/@{reactants, products};
reactants=Select[reactants, !NumberQ[#]&];
products=Select[products, !NumberQ[#]&];
debugPrint[dbg,"checkKineticLaw: products(2c)",products];
debugPrint[dbg,"checkKineticLaw: reactants(2c)",reactants];

]; 
debugPrint[dbg,"checkKineticLaw: products(2d)",products];
debugPrint[dbg,"checkKineticLaw: reactants(2d)",reactants];

];

debugPrint[dbg,"checkKineticLaw: products(3)",products];


debugPrint[dbg, "checkKineticLaw: caller: ", caller];
debugPrint[dbg, "checkKineticLaw: First/@MB$Species: ", First/@MB$Species];

If[caller=="getReaction",
species=decontextify/@stringer/@$SBML$Species$IDs;
compartments=decontextify/@stringer/@$SBML$Compartmentids;
GlobalParameters=decontextify/@stringer/@SBMLGlobalParameters;
functions=decontextify/@stringer/@First/@$SBML2$Functions
,
species=First/@MB$Species;
compartments=First/@MB$Compartments;
GlobalParameters=First/@MB$Parameters;
functions=First/@MB$Functions;
];

debugPrint[dbg,"checkKineticLaw: products",products];

reactants=stringer/@Flatten[List[reactants]];
products=stringer/@Flatten[List[products]];
modifiers=stringer/@Flatten[List[modifiers]];
allSpeciesReferenced=Join[reactants, products , modifiers];

debugPrint[dbg,"checkKineticLaw: opt",{opt}];
debugPrint[dbg,"checkKineticLaw: klaw(1)",klaw];
debugPrint[dbg,"checkKineticLaw: parameters",parameters];
debugPrint[dbg,"checkKineticLaw: reactants",reactants];
debugPrint[dbg,"checkKineticLaw: products",products];
debugPrint[dbg,"checkKineticLaw: modifiers",modifiers];
debugPrint[dbg,"checkKineticLaw: species",species];
debugPrint[dbg,"checkKineticLaw: allSpeciesReferenced",allSpeciesReferenced];
debugPrint[dbg,"checkKineticLaw: compartments",compartments];
debugPrint[dbg,"checkKineticLaw: GlobalParameters",GlobalParameters];
debugPrint[dbg,"checkKineticLaw: functions",functions];

reaction=Rule[Plus@@reactants,Plus@@products];
If[Length[modifiers]>0, 
reaction=System`Overscript[reaction,modifiers];
];

debugPrint[dbg,"checkKineticLaw: reaction(2)",reaction];

Print["Warning: "//boldRed, " the global parameter "//boldBlack,#//boldBlue," has been referenced in the reaction "//boldBlack,id//boldBlue," = "//boldBlack, reaction//boldBlue , " as a species."//boldBlack]&/@Intersection[allSpeciesReferenced, GlobalParameters];

missingSpecies=Complement[allSpeciesReferenced,species];

(* this line checks for species that are declared in the reaction but not in the model *)

Print["Warning: checkKineticLaw: "//boldRed," the species "//boldBlack,#//boldBlue," is referenced in the reaction "//boldBlack,id//boldBlue," = "//boldBlack,reaction//boldBlue," but has not been previously defined."//boldBlack]&/@missingSpecies;

If[caller=="addReaction",
Map[addSpecies[Global`id-> #]&,  missingSpecies];
(* need to redefined species because it may have changed *)
 species=First/@MB$Species;  
]; 

(* now check for species that are referenced in the kinetic law but are not declared as modifiers *)

debugPrint[dbg,"checkKineticLaw: klaw(2)",klaw];
debugPrint[dbg, "checkKineticLaw: csymbolsInFormula: ", csymbolsInFormula]; 

csymbols=Join[Cases[FullForm[klaw],MyAngleBracket[_,"time"],Infinity],
Cases[FullForm[klaw],MyAngleBracket[_,"delay"][_,_],Infinity]
];
Block[{ANG}, 
ANG[x_,"time"]:= x;
ANG[x_, "delay"][_, _]:= x;
csymbols=csymbols/.{MyAngleBracket-> ANG};
];
AppendTo[csymbols, MyAngleBracket];

(* csymbols=Append[First/@(csymbols/.{Global`AngleBracket-> List}),Global`AngleBracket]; *)

csymbols = Join[stringer/@csymbols,stringer/@Flatten[{csymbolsInFormula}] ];
debugPrint[dbg,"checkKineticLaw: csymbols",csymbols];


xml=Xpression2SymbolicMathML[klaw];
math=xml;
xml=Cases[xml, XMLElement["ci",{},{_}],Infinity];
debugPrint[dbg,"checkKineticLaw: xml",xml];

myXMLElement["ci",{},{"t"}]:= {};
myXMLElement["ci",{}, {x_}]:= x;
myXMLElement[x___]:= "XMLFormatError";
syms=Flatten[xml/.{XMLElement-> myXMLElement}];
debugPrint[dbg,"checkKineticLaw: syms",syms];

definedSymbols=defunctionate/@Join[parameters,  species, compartments, functions, GlobalParameters, csymbols];
debugPrint[dbg, "checkKineticLaw: definedSymbols", definedSymbols]; 
(* this gives all symbols that are not declared *)
undefinedSymbols=Complement[syms, definedSymbols];

debugPrint[dbg,"checkKineticLaw: undefinedSymbols",undefinedSymbols];

Print["Warning: checkKineticLaw: "//boldRed," the symbol "//boldBlack,#//boldBlue," is referenced in the kinetic law "//boldBlack, klaw//boldBlue," for reaction "//boldBlack,id//boldBlue," = ",reaction//boldBlue," but has not been defined in the model."//boldBlack]&/@undefinedSymbols;

(* this gives all objects that are used as species but are not defined *)
undefinedSpecies=Complement[Join[modifiers,reactants, products],species];
debugPrint[dbg,"checkKineticLaw: undefinedSpecies",undefinedSpecies];



(* Print["Warning: "//boldRed," the species "//boldBlack,#//boldBlue," is referenced in reaction "//boldBlack,id//boldBlue," but has not been previously defined as a species in the model."//boldBlack]&/@undefinedSpecies; *) 

(* this gives all the species that are referenced in the kinetic law that are not declared as modifiers *)
undefinedModifiers=Complement[Complement[Intersection[syms, species],reactants, products],modifiers];
debugPrint[dbg,"checkKineticLaw: undefinedModifiers",undefinedModifiers];

Print["Error: "//boldRed," the species "//boldBlack,#//boldBlue," is referenced in the kinetic law "//boldBlack, klaw//boldBlue," for reaction "//boldBlack,id//boldBlue," = "//boldBlack, reaction//boldBlue," but is not defined as a modifier in the reaction."//boldBlack]&/@undefinedModifiers;

checkFunctionCalls[math,"reaction",stringer[id], opt];

modifiers=Join[modifiers,undefinedModifiers];

If[caller=="addReaction",
Return[
Flatten[Join[{
Global`reactants-> reactants,
Global`products-> products, 
Global`modifiers-> modifiers},
{opt}
]]
];
];
Return[{}];
];


addReaction[XMLElement[x___]]:=Module[{r,n, reacts, prods, mods,sp, compartment,rstring,reactListString, 
meta, rmetas, pmetas, mmetas,addmeta, dbg=False, reactionparameters
},


addmeta[metau_,idu_, object_]:= Module[{id, cn, cio},
If[dbg, Print["addmeta: metau=", metau, " idu=", idu, " object=", object]]; 
cio=contextify[idu, object]; 
If[dbg, Print["addmeta: cio: ", cio]]; 
cn=contextify[n, MB$ID]; 
If[dbg, Print["addmeta: n, cn: ",n, ",", cn]]; 

id=contextify[cio, cn];

If[dbg, Print["addmeta: id: ", id]]; 

If[metau!= "", addMetaID[metau,id, object, True]]; 
]; 


reactListString[{}]:= "";
reactListString[{q__}]:= ToString[Plus[q]];
r =XMLElement[x];
n=getSBMLid[r];

If[dbg, Print["addReaction[XML]: r: ", r]]; 
If[dbg, Print["addReaction[XML]: n: ", n]]; 



If[deleteReaction[Global`id-> n],If[MB$Echo,Print["Previous occurance of reaction "//boldGreen,n//boldBlue," removed."//boldGreen]]];
addID[n, "reaction",True];

meta = getSBMLfield["metaid", r]; 
If[meta!= "", addMetaID[meta,contextify[n], "reaction", True]]; 
If[dbg, Print["addReaction[XML]: meta: ", meta]]; 


MB$Reactions=Append[MB$Reactions,n->r];

(* add code here to verify that reactants, products, modifiers are in model *)

reacts = Cases[r,XMLElement["listOfReactants",_,_],2 ];
reacts = Cases[reacts,XMLElement["speciesReference",_,_],3]; 
rmetas=Map[getSBMLfield["metaid",#]&, reacts];
reacts = Map[getSBMLfield["species",#]&, reacts];

If[dbg, Print["addReaction[XML]: addmeta: ", {rmetas, reacts}]];
MapThread[addmeta[#1, #2, "reactant"]&, {rmetas, reacts}];
If[dbg, Print["addReaction[XML]: addmeta: done "]];



prods = Cases[r,XMLElement["listOfProducts",_,_],2];
prods = Cases[prods,XMLElement["speciesReference",_,_],3]; 
pmetas=Map[getSBMLfield["metaid",#]&, prods];
prods = Map[getSBMLfield["species",#]&, prods];

If[dbg, Print["addReaction[XML]: addmeta: ", {pmetas, prods}]];
MapThread[addmeta[#1, #2, "product"]&, {pmetas, prods}];
If[dbg, Print["addReaction[XML]: addmeta: done "]];


(* check to see if any reactant or product is already referenced in an assignment rule *)


Block[{prior, check},

prior[variable_]:= Module[{},

If[MemberQ[MB$AssignmentRuleVariables, variable], 
Return["assignmentRule"];
];
If[MemberQ[MB$RateRuleVariables, variable], 
Return["rateRule"];
];
Return[""]; 
]; 

check[variable_]:= (StringLength[prior[variable]]>0) \[And] !MemberQ[MB$BoundaryConditionSpecies, variable]; 

Map[If[check[#], Print["Error: "//boldRed, "addReaction: "//boldBlack,
prior[#]//boldBlue, " already defined for the variable "//boldBlack, #//boldBlue , " which is not a boundaryCondition\n"//boldBlack, Sequence@@XMLHighlightForm[r, Purple, "species="<>quote[#]]

]]&, Union[prods, reacts]];


MB$ReactionVariables=Flatten[AppendTo[MB$ReactionVariables, Union[prods, reacts]]]//Union; 


]; 


mods = Cases[r,XMLElement["listOfModifiers",_,_] ,2];
mods = Cases[mods,XMLElement["modifierSpeciesReference",_,_],3]; 
mmetas=Map[getSBMLfield["metaid",#]&, mods];
mods = Map[getSBMLfield["species",#]&, mods];
MapThread[addmeta[#1, #2, "modifier"]&, {mmetas, mods}];


(*rstring=Rule[(reacts/.{List-> Plus}),prods/.{List-> Plus}];*) 
rstring=reactListString[reacts]<>"\[Rule]"<>reactListString[prods];
rstring=StringReplace[rstring," "-> ""]; 

If[Length[mods]>0,rstring=Overscript[rstring,mods]];

reacts =Union[ Flatten[{reacts,prods,mods}]]; 
reacts = Complement[reacts,Map[First,MB$Species]];
If[Length[reacts]>0,
Map[addSpecies[Global`id-> #]&, reacts]
];

reactionparameters=getSBMLfield["id", #]&/@Cases[r, XMLElement["parameter",___], Infinity]; 
addID[#, "reaction-parameter ("<>n<>")", False]&/@reactionparameters;

If[MB$Echo, Print["Reaction "//boldGreen,rstring//boldBlue, " added as "//boldGreen,n//boldBlue]];
Return[n];
];

addReaction[opt___?OptionQ]:=Module[{r,n,id, opts,optss, rs, ps, reaction, info, dbg=False},
(* MB$Echo = Global`echo/.{opt}/.{Global`echo-> True}; *) 


opts=Flatten[{opt}];

If[dbg, Print["addReaction[options]: opts: ", opts]]; 

rs=(Global`reactants)/.opts/.{Global`reactants-> {}};
ps=(Global`products)/.opts/.{Global`products-> {}};
reaction=(Global`reaction)/.opts/.{Global`reaction-> {}};

info = Flatten[Join[rs, ps, {reaction}]]; 
If[info=={}, 
reaction=First[opts]; 
opts=Rest[opts];
AppendTo[opts, Global`reaction-> reaction];
]; 

id=(Global`id)/.{opt}/.{Global`id-> ""};
If[id=="",id = "reaction"<>ToString[MB$reactioncounter++]; ]; 

opts={opts,Global`id-> id, invokedBy-> "addReaction"}//Flatten;

optss=checkKineticLaw@@opts;
optss= Select[optss, !SameQ[First[#], invokedBy]&];

r =reactionToSymbolicSBML@@optss;
If[dbg, Print["addReaction[options]: r: ", r]]; 

n = addReaction[r]; 
If[dbg, Print["addReaction[options]: n: ", n]]; 

Return[n]; 
];

addReaction[r_, opt___?OptionQ]:= Module[{},
Return[addReaction[Global`reaction-> r, opt]];
];


modifyReaction[opt___?OptionQ]:= Module[{n,x,y, m,dbg=False,dummyvariable,
r, p,rn, pn,rs, ps,  k,kopt,kann,knotes,rann,pann,mann,reactionAnnotation,reactionNotes,rmetaids,pmetaids,mmetaids, getFirst, getSpecies, speciesName, stoic, infix, parameter, getspeciesReferenceInfo, getModifierSpecies, speciesMetaid
},

getFirst[a_]:= Module[{b}, 
b=a; 
While [ListQ[b] \[And] Length[b]>0, b = First[b]];
Return[b]; 
]; 

getSpecies[a_]:= 
 Cases[a, XMLElement["speciesReference",___],Infinity];
getModifierSpecies[a_]:= 
 Cases[a, XMLElement["modifierSpeciesReference",___],Infinity];

getSpecies[a_, tag_]:= Module[{},
Switch[tag,
"listOfReactants",getSpecies[a],
"listOfProducts",getSpecies[a],
"listOfModifiers",getModifierSpecies[a],
_,"Error"
]//Return;
]; 

speciesName[a_]:= getSBMLfield["species",a]; 
speciesMetaid[a_]:= getSBMLfield["metaid",a];

getspeciesReferenceInfo[tag_, input_]:= Module[{r,names, stoichiometries,dbg=False, ann, metaids, notes},

r=Cases[input, XMLElement[tag, ___],Infinity];

r=getSpecies[r//getFirst,tag]; 
debugPrint[dbg,"\!\(\*
StyleBox[\"getspeciesReferenceInfo\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\":\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\" \",\nFontColor->RGBColor[0, 0, 1]]\)"<>tag,r];

ann = getAnnotations/@r;
debugPrint[dbg,"\!\(\*
StyleBox[\"getspeciesReferenceInfo\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\":\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\" \",\nFontColor->RGBColor[0, 0, 1]]\)"<>tag<>": annotations",ann];

names =speciesName/@r;
debugPrint[dbg,"\!\(\*
StyleBox[\"getspeciesReferenceInfo\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\":\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\" \",\nFontColor->RGBColor[0, 0, 1]]\)"<>tag<>": names ",names];

notes = getNotes/@r; 

metaids=speciesMetaid/@r;


If[tag== "listOfReactants" \[Or] tag=="listOfProducts",
stoichiometries= stoic/@r;
debugPrint[dbg,"getspeciesReferenceInfo: "<>tag<>": stoichiometries ",stoichiometries];,
stoichiometries={};
];

Return[{names,stoichiometries,ann,notes, metaids }];
];

infix[XMLElement["math",x___]]:= SymbolicSBMLMathMLToExpression[XMLElement["math",x]];
infix[x___]:= 1; 
stoic[a_]:= s = Cases[a, XMLElement["math",___], Infinity]//getFirst//infix;

parameter[p_]:=Module[{s,ann,notes,r},
s= extractXMLOptions[p];
ann = getAnnotations[p]; 
notes=getNotes[p]//stringToNotes; 
r=Rule[ getSBMLfield["id",p],Join[s,{"annotation"-> ann,"notes"-> notes}]
];
Return[r]
];

debugPrint[dbg,"modifyReaction,opt",{opt}]; 
n =( Global`id/.{opt}/.{Global`id-> ""})//stringer;
If[n=="", Print["Error: "//boldRed,"modifyReaction: No reaction id specified."//boldBlack];Return[{}]; ]; 

MB$Currentid=n;
debugPrint[dbg,"modifyReaction,n",n]; 
x=retrieveSBMLObject["reaction",n];

debugPrint[dbg,"modifyReaction,x",x];
reactionAnnotation = updateAnnotations[x,opt]; 
debugPrint[dbg,"modifyReaction: annotations ",reactionAnnotation];

reactionNotes=updateNotes[x,opt];
debugPrint[dbg,"modifyReaction: notes ",reactionNotes];


If[ToString[Head[x]]=="XMLElement",

y=extractXMLOptions[x];
y = Join[{opt},y]//Flatten;

debugPrint[dbg,"modifyReaction,y",y];

{rn,rs,rann,rnotes, rmetaids}=getspeciesReferenceInfo["listOfReactants", x];
{pn,ps,pann,pnotes,pmetaids}=getspeciesReferenceInfo["listOfProducts", x];
{m,dummyvariable, mann,mnotes, mmetaids}=getspeciesReferenceInfo["listOfModifiers", x];

y = Join[y,
{"reactants"-> rn, "products"-> pn, "reactantStoichiometry"-> rs, "productStoichiometry"-> ps, "modifiers"-> m,
"reactantannotations"-> rann,"productannotations"-> pann,"modifierannotations"-> mann,
"reactantmetaids"-> rmetaids,"productmetaids"-> pmetaids,
"modifiermetaids"-> mmetaids,
"reactantnotes"-> rnotes, "productnotes"-> pnotes,"modifiernotes"-> mnotes
}
];
debugPrint[dbg,"modifyReaction,y",y];

k = Cases[x,XMLElement["kineticLaw",___],Infinity]//getFirst; 
kopt = extractXMLOptions[k]; 
debugPrint[dbg,"modifyReaction,k",k];
debugPrint[dbg,"modifyReaction,kopt",kopt];

p = Cases[k, XMLElement["parameter",___],Infinity]; 
debugPrint[dbg,"modifyReaction, parameters",p];
p = parameter/@p;
debugPrint[dbg,"modifyReaction, parameters",p];

kann = getAnnotations[k];
knotes = getNotes[k]//stringToNotes; 
k = Cases[k, XMLElement["math",___],Infinity]//getFirst//infix; 
debugPrint[dbg,"modifyReaction,kinetic law",k];
y = Join[y,kopt/.{"metaid"-> "kineticlawmetaid"}]; 
y = Append[y, 
"kineticLaw"->{ "math"-> k, "annotation"-> kann, "notes"-> knotes}]; 

y = Append[y, "parameters"-> p]; 
y = Prepend[y,"annotation"-> reactionAnnotation]; 
y = Prepend[y,"notes"-> reactionNotes]; 

y = globalize/@y; 
debugPrint[dbg,"modifyReaction,y",y];

n=Apply[addReaction,y];  
,
Print["Warning: "//boldOrange, "The reaction "//boldBlack,n//boldRed, " was not found."//boldBlack]; 
n={};
];
Return[n]; 
];
modifyReaction[id_, opt___?OptionQ]:= modifyReaction[Global`id-> id, opt];


getSpecies[n_?IntegerQ]:= Module[{m},
m=Length[MB$Species];
If[n>m \[Or] n<1, Print["Error: getSpecies: "//boldRed," Species: "//boldBlack,n//boldRed," does not exist. There are "//boldBlack,m//boldRed," species."//boldBlack];Return[{}];];
Return[MB$Species[[n]]//Last];
]; 
getSpeciesNumber[id_?SIDQ]:=Module[{m,n},
m = First/@MB$Species;
n=Position[m, stringer[id]];
If[Length[n]<1, Print["Error: getSpeciesNumber: "//boldRed,"Species: "//boldBlack,id//boldRed," does not exist. Valid species are "//boldBlack, m//boldRed];Return[0];]; 
While[ListQ[n], n=First[n]];
Return[n];
]; 
getSpecies[id_?SIDQ]:=Module[{m,n},
n=getSpeciesNumber[id];
If[n>0,Return[MB$Species[[n]]//Last]];
Return[{}];
]; 
getSpecies[x_?ListQ]:= getSpecies/@Flatten[x];
getNumberOfSpecies[]:= Length[MB$Species];
getSpecies[]:= getSpecies[Range[getNumberOfSpecies[]]]; 

getSpecies[x___]:= Module[{},
Print["Error: getSpecies: "//boldRed, "Correct format is: "//boldBlack,"getSpecies[id]"//boldRed, " where id is an integer or an SID, "//boldBlack,"getSpecies[Integer]"//boldRed, " or "//boldBlack,"getSpecies[{x1,x2,...}]"//boldRed," where x1,x2,... are integers or SIDs."//boldBlack];
Return[{}];
];




replaceSpecies[i_?IntegerQ, XMLElement["species",x___]]:= Module[{n,j},
n=Length[MB$Species];
If[n>0 \[And] i>0 \[And] i<=n, 
j=getSBMLfield["id",XMLElement["species",x]]; 
If[j=="", j=MB$Species[[i,1]]];
MB$Species=ReplacePart[MB$Species,j-> XMLElement["species",x],i];
If[MB$Echo, Print["Species ",i, " replaced."]];
Return[];
]; 
Print["Error: replaceSpecies: "//boldOrange," unable to replace species "//boldBlack,i//boldRed];
Return[];
]; 

replaceSpecies[id_?SIDQ, XMLElement["species",x___]]:= Module[{n},
n=getSpeciesNumber[id];
If[n>0, 
replaceSpecies[n, XMLElement["species",x]]; 
Return[];
]; 
Print["Error: replaceSpecies: "//boldOrange," unable to replace species "//boldBlack,id//boldRed];
Return[];
]; 
replaceSpecies[x___]:= Print["Error: "//boldOrange,"replaceSpecies: "//boldRed, "Invalid arguments. Correct format is:"//boldBlack,"replaceSpecies["//boldBlack," Integer|SID "//boldBlack,","//boldBlack, " XMLElement[\"species\",...]"//boldBlack," ]"//boldBlack]



speciesToSBML[{x__?ListQ}]:=Module[{SBML}, 
SBML =Flatten[ speciesToSymbolicSBML/@{x}];
SBML = XMLElement["listOfSpecies",{},SBML]; 
SBML=ExportXMLString[SBML];
SBML = sunderscore[SBML];
Return[SBML];
];

speciesToSBML[opt___?OptionQ]:= Module[{r},
r =speciesToSymbolicSBML[opt]; 
r=ExportXMLString[r];
r = sunderscore[r];
Return[r];
];

speciesToSBML[x_, opt___?OptionQ]:= speciesToSBML[Global`id-> x, opt]; 


speciesToSBML[x___]:= Print[
boldRed["Error:"], 
boldBlack["speciesToSBML:  invalid syntax: "], boldBlue[ToString[{x}]]
]; 




deleteSpecies[opt___?OptionQ]:= Module[{n,c,p},
n =( Global`id/.{opt}/.{id-> ""})//stringer;
If[id=="", 
Print["Error: deleteSpecies"//boldRed," No "//boldBlack,"id"//boldRed," was specified."//boldBlack]]; 
removeID[n,"species"]; 

MB$Currentid=n;
c = Map[First,MB$Species]; 
If[MemberQ[c,n],
p=Position[c,n];
MB$Species= Drop[MB$Species,First[p]]; 
Return[True];
];
Return[False];
];
deleteSpecies[x_, opt___?OptionQ]:= deleteSpecies[Global`id-> x,opt];
removeSpecies[x___]:=Module[{flag},
flag = deleteSpecies[x];
If[flag, 
If[MB$Echo,Print["Species "//boldGreen,MB$Currentid//boldBlue," removed."//boldGreen]],
Print["Error: "//boldRed,"removeSpecies: Requested species "//boldBlack,MB$Currentid//boldBlue," does not exist."//boldBlack]];
];



addSpecies[XMLElement[x___]]:=Module[{r,n, comp,comps, units, cdata, dbg=False,
substanceUnits, spatialSizeUnits, defSpatialSizeUnits,dim,hasOnlySubstanceUnits,logicate, opts,sub,unitsofthespecies,stype,stypes, meta, bc},
r =XMLElement[x];
n=getSBMLid[r];


(* check for previous occurance of this species *)

If[deleteSpecies[Global`id-> n],If[MB$Echo,Print["Previous occurance of species "//boldGreen,n//boldBlue," removed."//boldGreen]]
];


addID[n, "species",True];
meta = getSBMLfield["metaid", r]; 
If[meta!= "", addMetaID[meta,contextify[n], "species", True]]; 




opts={x}[[2]];
sub={x}[[3]];

logicate["true"]:= True;
logicate["false"]:= False;
logicate[___]:=False;

bc= getSBMLfield["boundaryCondition", r]; 
If[logicate[bc], AppendTo[MB$BoundaryConditionSpecies, n]]; 

(* check to make sure assigned compartment exists *) 

comp = getSBMLfield["compartment",r];
comps = First/@MB$Compartments;

If[!MemberQ[comps,comp],addCompartment[comp];];

cdata = comp/.MB$Compartments;
If[dbg, Print["addSpecies: cdata: ",cdata]]; 

stype=getSBMLfield["speciesType",r];
If[stype!= "",

stypes=First/@MB$SpeciesTypes;
If[!MemberQ[stypes,stype], addSpeciesType[stype]]; 

]; 

(* check for substanceUnits and insert default if not present *)
substanceUnits=getSBMLfield["substanceUnits",r,default-> "substance"];
opts=Select[opts,(First[#]!= "substanceUnits")&];
opts = Append[opts,"substanceUnits"-> substanceUnits];
If[!unitExists[substanceUnits], addUnit[substanceUnits]];
If[dbg, Print["addSpecies: opts (1):",opts]]; 

(* check for hasOnlySubstanceUntis and insert default value if not present *)
hasOnlySubstanceUnits=getSBMLfield["hasOnlySubstanceUnits",r,default-> "false"]; 
opts=Select[opts,(First[#]!= "hasOnlySubstanceUnits")&];
opts = Append[opts,"hasOnlySubstanceUnits"-> hasOnlySubstanceUnits];
If[dbg, Print["addSpecies: opts (2):",opts]]; 



If[logicate[hasOnlySubstanceUnits],
unitsofthespecies=Rule[n,substanceUnits];

,
	
(*check spatial size units; compare with compartment units; insert default if not there *)
dim = getSBMLfield["spatialDimensions",cdata,default-> "3"]; 

defSpatialSizeUnits=Switch[dim,
"0","dimensionless",
"1","length",
"2","area",
"3","volume",
_,"Indeterminate"
]; 
defSpatialSizeUnits=getSBMLfield["units",cdata,default-> defSpatialSizeUnits];

If[ToExpression[MB$LevelVersion]<2.3,
spatialSizeUnits=getSBMLfield["spatialSizeUnits",r,default-> defSpatialSizeUnits];
opts = Select[opts, (First[#]!= "spatialSizeUnits")&]; 
If[spatialSizeUnits!= "Indeterminate",
opts = Append[opts,"spatialSizeUnits"-> spatialSizeUnits]
];
unitsofthespecies=Rule[n,substanceUnits<>"/"<>spatialSizeUnits];
, 
(* spatialSizeUnits were removed in L2V3 *)

unitsofthespecies=Rule[n,substanceUnits<>"/"<>defSpatialSizeUnits];
spatialSizeUnits=getSBMLfield["spatialSizeUnits",r,default-> ""];
If[spatialSizeUnits!= "", 
Print["Error: addSpecies: "//boldRed, "spatialSizeUnits is not a valid option in SMBL Level.Version "//boldBlack, MB$LevelVersion//boldBlack]
];
]; 

If[spatialSizeUnits=="Indeterminate" , unitsofthespecies="Indeterminate"];
];
If[dim=="0" , unitsofthespecies=substanceUnits];


MB$UnitsOfTheSpecies=Append[MB$UnitsOfTheSpecies,unitsofthespecies];


If[dbg, 
Print["addSpecies: substanceUnits: ", n,":",substanceUnits]; 
Print["addSpecies: spatialSizeUnits: ",n,":",spatialSizeUnits];
Print["addSpecies: hasOnlySubstanceUnits: ", n,":",hasOnlySubstanceUnits];
]; 


r=XMLElement["species",opts,sub];
If[dbg, Print["addSpecies: opts (3):",opts]]; 
If[dbg, Print["addSpecies: r:",r];];
MB$Species=Append[MB$Species,n->r];

(* check to make sure assigned units exits *) 
units = getSBMLfield["units",r];
If[units!= "", 
If[!unitExists[units], addUnit[units]]];

If[MB$Echo, Print["Species "//boldGreen,n//boldBlue," added to compartment "//boldGreen, comp//boldBlue]];
Return[n];
];


addSpecies[s_?ListQ, opt___?OptionQ]:= Map[addSpecies[#,opt]&,s];    

addSpecies[opt___?OptionQ]:=Module[{r,n, c,comps,opts, allowedOpts, dbg=False},
opts ={opt}; 

Switch[MB$LevelVersion, 
"2.1",
allowedOpts={Global`annotation, Global`boundaryCondition, Global`charge, Global`compartment,Global`constant,  Global`id, Global`metaid,  Global`name,Global`notes,Global`initialAmount, Global`initialConcentration, Global`substanceUnits,Global`spatialSizeUnits, Global`ArrayDimensions, Global`hasOnlySubstanceUnits};
,
"2.2", 
allowedOpts={Global`annotation, Global`boundaryCondition, Global`charge, Global`compartment,Global`constant,  Global`id, Global`metaid,  Global`name,Global`notes,Global`initialAmount, Global`initialConcentration, Global`substanceUnits,Global`spatialSizeUnits, Global`ArrayDimensions, Global`hasOnlySubstanceUnits, Global`speciesType};
,
"2.3",
allowedOpts={Global`annotation, Global`boundaryCondition, Global`charge, Global`compartment,Global`constant,  Global`id, Global`metaid,  Global`name,Global`notes,Global`initialAmount, Global`initialConcentration, Global`substanceUnits, Global`ArrayDimensions, Global`hasOnlySubstanceUnits, Global`speciesType}; 
,
_,
Print["addSpecies: ", "unable to process MB$LevelVersion: ", MB$LevelVersion];
Return[$Failed];
];
 
checkOptions[addSpecies, opts, allowedOpts];
If[dbg, Print["addSpecies: opts: ", opts]]; 

c = stringer[Global`compartment/.{opt}/.{Global`compartment-> ""}]; 

(* If no compartment, automatically add it! *) 
If[c=="",

(* if there is at least one compartment already, use the first one *) 
(* otherwise add a new compartment *) 

If[Length[MB$Compartments]>0, 
(* check for possible invalid reassignment of MB$CurrentCompartment by another program or possible deletion of compartment *)
c=popCompartment[];
While[
(!MemberQ[First/@MB$Compartments,c] )&&(c!= Null),
c=popCompartment[];
];
If[c==Null, c = MB$Compartments//First//First]; 
,
c = "Compartment"<>ToString[MB$compartmentcounter]; 
];
opts = Prepend[opts, Global`compartment-> c]; 
]; 

(* reset current compartment *)

pushCompartment[c];

r =Apply[speciesToSymbolicSBML,opts]; 
If[dbg, Print["addSpecies:r ", r]];

n=addSpecies[r];
Return[n];
];

addSpecies[id_, opt___?OptionQ]:= addSpecies[Global`id-> id, opt];


 modifySpecies[opt___?OptionQ]:= Module[{n,x,y,ann, notes},
n =( Global`id/.{opt}/.{Global`id-> ""})//stringer;
MB$Currentid=n;

x=retrieveSBMLObject["species",n];

If[ToString[Head[x]]=="XMLElement",
y=globalize/@extractAndUpdateXMLOptions[x,opt];



ann = updateAnnotations[x, opt];
notes = updateNotes[x, opt]; 

y = Prepend[y, globalize["annotation"-> ann]]; 
y = Prepend[y, globalize["notes"-> notes]]; 

n=Apply[addSpecies,y];
,
n=addSpecies[opt]; 
];
Return[n]; 
];
modifySpecies[id_, opt___?OptionQ]:= modifySpecies[Global`id-> id, opt];



getSpeciesType[n_?IntegerQ]:= Module[{m},
m=getNumberOfSpeciesTypes[];
If[n>m \[Or] n<1, Print["Error: getSpeciesType: "//boldRed," speciesType: "//boldBlack,n//boldRed," does not exist. There are "//boldBlack,m//boldRed," speciesTypes."//boldBlack];Return[{}];];
Return[MB$SpeciesTypes[[n]]//Last];
]; 
getSpeciesTypeNumber[id_?SIDQ]:=Module[{m,n},
m = First/@MB$SpeciesTypes;
n=Position[m, stringer[id]];
If[Length[n]<1, Print["Error: getSpeciesTypeNumber: "//boldRed,"speciesType: "//boldBlack,id//boldRed," does not exist. Valid speciesType are "//boldBlack, m//boldRed];Return[0];]; 
While[ListQ[n], n=First[n]];
Return[n];
]; 
getSpeciesType[id_?SIDQ]:=Module[{m,n},
m = First/@MB$SpeciesTypes;
n=Position[m, stringer[id]];
If[Length[n]<1, Print["Error: getSpeciesType: "//boldRed,"speciesType: "//boldBlack,id//boldRed," does not exist. Valid speciesType are "//boldBlack, m//boldRed];Return[{}];]; 
While[ListQ[n], n=First[n]];
Return[MB$SpeciesTypes[[n]]//Last];
]; 
getSpeciesType[x_?ListQ]:= getSpeciesType/@Flatten[x];
getNumberOfSpeciesTypes[]:= Length[MB$SpeciesTypes];
getSpeciesType[]:= getSpeciesType[Range[getNumberOfSpeciesTypes[]]]; 

getSpeciesType[x___]:= Module[{},
Print["Error: getSpeciesType: "//boldRed, "Correct format is: "//boldBlack,"getSpeciesType[id]"//boldRed, " where id is an integer or an SID, "//boldBlack,"getSpeciesType[Integer]"//boldRed, " or "//boldBlack,"getSpeciesType[{x1,x2,...}]"//boldRed," where x1,x2,... are integers or SIDs."//boldBlack];
Return[{}];
];




speciesTypeToSBML[{x__?ListQ}]:=Module[{SBML}, 
SBML =Flatten[ speciesTypeToSymbolicSBML/@{x}];
SBML = XMLElement["listOfSpeciesTypes",{},SBML]; 
SBML=ExportXMLString[SBML];
SBML = sunderscore[SBML];
Return[SBML];
];

speciesTypeToSBML[opt___?OptionQ]:= Module[{r},
r =speciesTypeToSymbolicSBML[opt]; 
r=ExportXMLString[r];
r = sunderscore[r];
Return[r];
];

speciesTypeToSBML[x_, opt___?OptionQ]:= speciesTypeToSBML[Global`id-> x, opt]; 


speciesTypeToSBML[x___]:= Print[
boldRed["Error:"], 
boldBlack["speciesTypeToSBML:  invalid syntax: "], boldBlue[ToString[{x}]]
]; 




deleteSpeciesType[opt___?OptionQ]:= Module[{n,c,p},
n =( Global`id/.{opt}/.{Global`id-> ""})//stringer;
If[n=="", 
Print["Error: "//boldRed," deleteSpeciesType: id not specified."//boldBlack]]; 
removeID[n,"speciesType"]; 
MB$Currentid=n;
c = Map[First,MB$SpeciesTypes]; 
If[MemberQ[c,n],
p=Position[c,n];
MB$SpeciesTypes= Drop[MB$SpeciesTypes,First[p]]; 
Return[True];
];
Return[False];
];
deleteSpeciesType[x_, opt___?OptionQ]:= deleteSpeciesType[Global`id-> x,opt];
removeSpeciesType[x___]:=Module[{flag},
flag = deleteSpeciesType[x];
If[flag, 
If[MB$Echo,Print["Species Type "//boldGreen,MB$Currentid//boldBlue," removed."//boldGreen]],
Print["Error: "//boldRed,"removeSpeciesType:"//boldBlack,MB$Currentid//boldBlue," not found."//boldBlack]];
];



addSpeciesType[XMLElement[x___]]:=Module[
{r,n, opts,sub, meta},
If[ToExpression[MB$LevelVersion]<2.2, Print["Error:"//boldOrange," Cannot add a speciesType in SBML Level "//boldBlack,MB$LevelVersion//boldBlack];Abort[]];
r =XMLElement[x];
n=getSBMLid[r];

opts={x}[[2]];
sub={x}[[3]];

(* check for previous occurance of this species type *)

If[deleteSpeciesType[Global`id-> n],If[MB$Echo,Print["Previous occurance of speciesType "//boldGreen,n//boldBlue," removed."//boldGreen]]
];

addID[n, "speciesType",True];
meta = getSBMLfield["metaid", r]; 
If[meta!= "", addMetaID[meta,contextify[n], "speciesType", True]]; 


r=XMLElement["speciesType",opts,sub];
MB$SpeciesTypes=Append[MB$SpeciesTypes,n->r];
If[MB$Echo, Print["SpeciesType "//boldGreen,n//boldBlue," added."//boldGreen]];

Return[n];
];


addSpeciesType[s_?ListQ, opt___?OptionQ]:= Map[addSpeciesType[#,opt]&,s];    

addSpeciesType[opt___?OptionQ]:=Module[{r,n},
checkOptions[addSpeciesType, opt, 
{Global`annotation,  Global`id, Global`metaid,  Global`name,Global`notes}];
r =speciesTypeToSymbolicSBML@@{opt};
n=addSpeciesType[r];
Return[n];
];

addSpeciesType[id_, opt___?OptionQ]:= addSpeciesType[Global`id-> id, opt];


 modifySpeciesType[opt___?OptionQ]:= Module[{n,x,y,ann, notes},
n =( Global`id/.{opt}/.{Global`id-> ""})//stringer;
MB$Currentid=n;

x=retrieveSBMLObject["speciesType",n];

If[ToString[Head[x]]=="XMLElement",
y=globalize/@extractAndUpdateXMLOptions[x,opt];

ann = updateAnnotations[x, opt];
notes = updateNotes[x, opt]; 

y = Prepend[y, globalize["annotation"-> ann]]; 
y = Prepend[y, globalize["notes"-> notes]]; 

n=Apply[addSpeciesType,y];
,
n=addSpeciesType[opt]; 
];
Return[n]; 
];
modifySpeciesType[id_, opt___?OptionQ]:= modifySpeciesType[Global`id-> id, opt];



getFunction[n_?IntegerQ]:= Module[{m},
m=Length[MB$Functions];
If[n>m \[Or] n<1, Print["Error: getFunction: "//boldOrange," Function: "//boldBlack,n//boldRed," does not exist. There are "//boldBlack,m//boldRed," functions."//boldBlack];Return[{}];];
Return[MB$Functions[[n]]//Last];
];
getFunctionNumber[id_?SIDQ]:=Module[{m,n},
m = First/@MB$Functions;
n=Position[m, stringer[id]];
If[Length[n]<1, Print["Error: getFunctionNumber: "//boldOrange,"Function: "//boldBlack,id//boldRed," does not exist. Valid functions are "//boldBlack, m//boldRed];Return[0];]; 
While[ListQ[n], n=First[n]];
Return[n];
];  
getFunction[id_?SIDQ]:=Module[{m,n},
n=getFunctionNumber[id];
If[n>0, Return[MB$Functions[[n]]//Last]]; 
Return[{}]; 
]; 
getFunction[x_?ListQ]:= getFunction/@Flatten[x];
getNumberOfFunctions[]:= Length[MB$Functions];
getFunctions[]:= getFunction[Range[getNumberOfFunctions[]]]; 

getFunction[x___]:= Module[{},
Print["Error: getFunction: "//boldOrange, "Correct format is: "//boldBlack,"getFunction[id]"//boldRed, " where id is an integer or an SID, "//boldBlack,"getFunction[Integer]"//boldRed, " or "//boldBlack,"getFunction[{x1,x2,...}]"//boldRed," where x1,x2,... are integers or SIDs."//boldBlack];
Return[{}];
];




replaceFunction[i_?IntegerQ, XMLElement["functionDefinition",x___]]:= Module[{n,j},
n=Length[MB$Functions];
If[n>0 \[And] i>0 \[And] i<=n, 
j=getSBMLfield["id",XMLElement["functionDefinition",x]]; 
If[j=="", j=MB$Functions[[i,1]]];
MB$Functions=ReplacePart[MB$Functions,j-> XMLElement["functionDefinition",x],i];
If[MB$Echo, Print["Function ",i, " replaced."]];
Return[];
]; 
Print["Error: replaceFunction: "//boldOrange," unable to replace function "//boldBlack,i//boldRed];
Return[];
]; 

replaceFunction[id_?SIDQ, XMLElement["functionDefinition",x___]]:= Module[{n},
n=getFunctionNumber[id];
If[n>0, 
replaceFunction[n, XMLElement["functionDefinition",x]]; 
Return[];
]; 
Print["Error: replaceFunction: "//boldOrange," unable to replace function "//boldBlack,id//boldRed];
Return[];
]; 

replaceFunction[x___]:= Print["Error: "//boldOrange,"replaceFunction: "//boldRed, "Invalid arguments. Correct format is:"//boldBlack,"replaceFunction["//boldBlack," Integer|SID "//boldBlack,","//boldBlack, " XMLElement[\"functionDefinition\",...]"//boldBlack," ]"//boldBlack];


 functionToSBML[{x__?ListQ}]:=Module[{SBML}, 
SBML =Flatten[ functionToSymbolicSBML/@{x}];
SBML = XMLElement["listOfFunctionDefinitions",{},SBML]; 
SBML=ExportXMLString[SBML];
SBML = sunderscore[SBML];
Return[SBML];
];

functionToSBML[opt___?OptionQ]:= Module[{r},
r=functionToSymbolicSBML[opt];
r=ExportXMLString[r];
r=sunderscore[r];
Return[r];
];

functionToSBML[x_, opt___?OptionQ]:= functionToSBML[Global`id-> x, opt]; 

functionToSBML[x___]:=
Print[boldRed["Error:"],
 boldBlack[" functionToSBML: invalid argument syntax: "],
boldBlue[ToString[{x}]]]; 


deleteFunction[opt___?OptionQ]:= Module[{n,c,p},
n =( Global`id/.{opt}/.{id-> ""})//stringer;
If[id=="", 
Print["Error: deleteFunction"//boldOrange," No "//boldBlack,"id"/boldRed," was specified."]]; 
removeID[n,"function"]; 
MB$Currentid=n;
c = Map[First,MB$Functions]; 
If[MemberQ[c,n],
p=Position[c,n];
MB$Functions= Drop[MB$Functions,First[p]]; 
Return[True];
];
Return[False];
];
deleteFunction[x_, opt___?OptionQ]:= deleteFunction[Global`id-> x,opt];
removeFunction[x___]:=Module[{flag},
flag = deleteFunction[x];
If[flag, 
If[MB$Echo,Print["Function "//boldGreen,MB$Currentid//boldBlue," removed."//boldGreen]],
Print["Warning: "//boldOrange,"Requested function "//boldBlack,MB$Currentid//boldRed," can not be removed."//boldBlack]];
];



addFunction[XMLElement[x___]]:=Module[{n,meta, syms,XML2Sym, bvars,hf, math, csymbols, mycsymbol, lambda,checkIfLambda,  dbg=False},

checkIfLambda[XMLElement["math",v_, XMLElement[w___]]]:=True;
checkIfLambda[XMLElement["math",v_, {XMLElement[w___]}]]:=True;
checkIfLambda[w___]:=False;


XML2Sym["ci",{},{u_}]:=u;
XML2Sym[u___]:= "??--Unknown--??";

n=getSBMLid[XMLElement[x]];
If[dbg, Print["addFunction: id: ",n]]; 

If[deleteFunction[Global`id-> n] , If[MB$Echo,Print["Previous occurance of function "//boldGreen,n//boldBlue," removed."//boldGreen]]
];

addID[n,"function",True];
meta = getSBMLfield["metaid", XMLElement[x]]; 
If[meta!= "", addMetaID[meta,contextify[n], "function", True]]; 

MB$Functions=Append[MB$Functions,n->XMLElement[x]];

(* check for undefined symbols *)

math=Cases[{XMLElement[x]}, XMLElement["math",___], Infinity];
checkMathMLSubset[math, "function", n];

If[!checkIfLambda[#], 
Print["Error: "//boldRed, " The "//boldBlack,"<math ...>"//boldBlue," object in "//boldBlack,"<functionDefinition id=\""//boldBlue,n//boldBlue,"\" ..>"//boldBlue, " contains the wrong number of "//boldBlack,"<lambda ..>"//boldBlue," elements. It should begin with a "//boldBlack,"<lambda ..>"//boldBlue," element and contain precisely one "//boldBlack,"<lambda ..>"//boldBlue," element:\n"//boldBlack,
Sequence@@XMLHighlightForm[XMLElement[x],Purple, "math"]
]
]&/@math;


syms=Cases[{XMLElement[x]}, XMLElement["ci",___], Infinity];
syms=Union[syms/.{XMLElement-> XML2Sym}];

bvars=Cases[{XMLElement[x]}, XMLElement["bvar",___], Infinity];
bvars=Cases[bvars, XMLElement["ci",___], Infinity];
bvars=bvars/.{XMLElement-> XML2Sym};
bvars=Union[bvars];

addID[#, "function-argument", False]&/@bvars;

If[dbg, Print["addFunction:bvars:",bvars]];
AppendTo[$SBML$function$bvars, {n, Length[bvars]}]; 
If[dbg, Print["$SBML$function$bvars: ", $SBML$function$bvars]];


csymbols = Cases[XMLElement[x], XMLElement["csymbol",___],Infinity];
If[Length[csymbols]>0,
mycsymbol["csymbol",{___},xx_]:= xx;
mycsymbol[xx___]:= XMLElement[xx];
csymbols=Flatten[(csymbols/.{XMLElement-> mycsymbol})/.{XMLElement-> List}];
csymbols=Complement[csymbols,{"ci"}];
];

syms=Complement[syms, bvars,csymbols,  First/@$SBML$IDTable];

hf[var_]:= XMLHighlightForm[XMLElement[x],Purple,"<ci>"<>stringer[var]<>"</ci>"];

Print["Error: "//boldRed, "addFunction: undefined symbol "//boldBlack, #//boldBlue, " referenced in the definition of the function "//boldBlack,n//boldBlue,"\n",
Sequence@@hf[#]


]&/@syms;

lambda = Cases[XMLElement[x], XMLElement["lambda",___], Infinity];
If[Length[lambda]>1, 
Print["Error: "//boldRed, "Multiple lambda elements in function "//boldBlack, n//boldBlue, Sequence@@XMLHighlightForm[XMLElement[x], Purple, "<lambda>"]]; 
];
checkFunctionCalls[lambda, "function",n];

If[MB$Echo, Print["Function "//boldGreen,n//boldBlue," added."//boldGreen]];
Return[n];
];

addFunction[opt___?OptionQ]:=Module[{r,n},
(* MB$Echo = Global`echo/.{opt}/.{Global`echo-> True}; *) 
r =functionToSymbolicSBML[opt]; 
n=addFunction[r]; 
Return[n];
];

addFunction[id_, opt___?OptionQ]:= addFunction[Global`id-> id, opt];


modifyFunction[opt___?OptionQ]:= Module[{n,x,y, m, arguments, math,ann,notes},

arguments[_[args_, formula_]]:= args;
math[_[args_, formula_]]:= formula;

n =( Global`id/.{opt}/.{Global`id-> ""})//stringer;
MB$Currentid=n;
x=retrieveSBMLObject["function",n];

If[ToString[Head[x]]=="XMLElement",
y=extractAndUpdateXMLOptions[x,opt];

ann = updateAnnotations[x, opt]; 
notes = updateNotes[x, opt];

y = Prepend[y, globalize["annotation"-> ann]]; 
y  =Prepend[y, globalize["notes"-> notes]]; 

m = Cases[x, XMLElement["math",___], Infinity];
While [ListQ[m] \[And] Length[m]>0, m = First[m]]; 

m = SymbolicSBMLMathMLToExpression[m];

y = Append[y, "arguments"-> arguments[m]//Flatten]; 
y = Append[y,"math"-> math[m]]; 
y = globalize/@y; 

n=Apply[addFunction,y];  
,
n=addFunction[opt]; 
];
Return[n]; 
];
modifyFunction[id_, opt___?OptionQ]:= modifyFunction[Global`id-> id, opt];


getUnit[n_?IntegerQ]:= Module[{m},
m=Length[MB$Units];
If[n>m \[Or] n<1, Print["Error: getUnit: "//boldOrange," Unit definition: "//boldBlack,n//boldRed," does not exist. There are "//boldBlack,m//boldRed," unit definitions."//boldBlack];Return[{}];];
Return[MB$Units[[n]]//Last];
]; 
getUnitNumber[id_?SIDQ]:=Module[{m,n},
m = First/@MB$Units;
n=Position[m, stringer[id]];
If[Length[n]<1, Print["Error: getUnitNumber: "//boldOrange,"Unit: "//boldBlack,id//boldRed," does not exist. Valid units are "//boldBlack, m//boldRed];Return[0];]; 
While[ListQ[n], n=First[n]];
Return[n];
]; 
getUnit[id_?SIDQ]:=Module[{n},
n=getUnitNumber[id];
If[n>0, Return[MB$Units[[n]]//Last]];
Return[{}]; 
]; 
getUnit[x_?ListQ]:= getUnit/@Flatten[x];
getUnit[x___]:= Module[{},
Print["Error: getUnit: "//boldOrange, "Correct format is "//boldBlack,"getUnit[id]"//boldRed, " where id is an integer or an SID "//boldBlack,"getUnit[Integer]"//boldRed, " or "//boldBlack,
"getUnit[{x1,x2,...}]"//boldRed," where x1,x2,... are integers or SIDs."//boldBlack];
Return[{}];
];
getNumberOfUnits[]:=Length[MB$Units];
getUnits[]:= getUnit[Range[getNumberOfUnits[]]];



replaceUnit[i_?IntegerQ, XMLElement["unitDefinition",x___]]:= Module[{n,j},
n=Length[MB$Units];
If[n>0 \[And] i>0 \[And] i<=n, 

j=getSBMLfield["id",XMLElement["unitDefinition",x]]; 
If[j=="", j=MB$Units[[i,1]]];
MB$Units=ReplacePart[MB$Units,j-> XMLElement["unitDefinition",x],i];
If[MB$Echo, Print["Unit ",i, " replaced."]];
Return[];
]; 
Print["Error: replaceUnit: "//boldOrange," unable to replace unitDefinition "//boldBlack,i//boldRed];
Return[];
]; 

replaceUnit[id_?SIDQ, XMLElement["unitDefinition",x___]]:= Module[{n},
n=getUnitNumber[id];
If[n>0, 
replaceUnit[n, XMLElement["unitDefinition",x]]; 
Return[];
]; 
Print["Error: replaceUnit: "//boldOrange," unable to replace unitDefinition "//boldBlack,id//boldRed];
Return[];
]; 

replaceUnit[x___]:= Print["Error: "//boldOrange,"replaceUnit: "//boldRed, "Invalid arguments. Correct format is:"//boldBlack,"replaceUnit["//boldBlack," Integer|SID "//boldBlack,","//boldBlack, " XMLElement[\"unitDefinition\",...]"//boldBlack," ]"//boldBlack];


 unitToSBML[{x__?ListQ}]:=Module[{r}, 
r =Flatten[ unitToSymbolicSBML/@{x}];
r = XMLElement["listOfUnitDefinitions",{},r]; 
r=ExportXMLString[r];
r=sunderscore[r];
Return[r];
];


unitToSBML[opt___?OptionQ]:= Module[{r},
r=unitToSymbolicSBML[opt];
r=ExportXMLString[r];
r=sunderscore[r];
Return[r];
];

unitToSBML[x_, opt___?OptionQ]:= unitToSBML[Global`id-> x, opt];


deleteUnit[opt___?OptionQ]:= Module[{n,c,p,sp},
n =( Global`id/.{opt}/.{id-> ""})//stringer;
If[id=="", 
Print["Error: deleteUnit"//boldOrange," No "//boldBlack,"id"/boldRed," was specified."]]; 
MB$Currentid=n;
removeID[n,"unit"]; 

c = Map[First,MB$Units]; 
(* Print["deleteUnit: c=",c]; *)
If[MemberQ[c,n],
If[\[Not]MB$Modify,
(* check to see if any species or parameters reference this unit *) 
sp = Position[MB$Species, "units"-> n];
If[Length[sp]>0,
sp = First/@sp;
sp=Map[Part[First/@MB$Species,#]&,sp];
Print["Warning: "//boldOrange, "The species "//boldBlack,list2CommaSeparatedString[sp]//boldRed, " refer to units "//boldBlack,n//boldRed ];
Return[False];
];
sp = Position[MB$Parameters,"units"-> n]; 
If[Length[sp]>0,
sp = First/@sp;
sp=Map[Part[First/@MB$Parameters,#]&,sp];
Print["Warning: "//boldOrange, "The parameters "//boldBlack,list2CommaSeparatedString[sp]//boldRed, " refer to units "//boldBlack,n//boldRed ];
Return[False];
];
]; 

p=Position[c,n];
MB$Units= Drop[MB$Units,First[p]]; 
Return[True];
];
Return[False];
];
deleteUnit[x_, opt___?OptionQ]:= deleteUnit[Global`id-> x,opt];
removeUnit[x___]:=Module[{flag},
flag = deleteUnit[x];
If[flag, 
If[MB$Echo,Print["Unit "//boldGreen,MB$Currentid//boldBlue," removed."//boldGreen]],
Print["Warning: "//boldOrange,"Requested unit "//boldBlack,MB$Currentid//boldRed," can not be removed."//boldBlack]];
];


Global`$DEBUG$ADDUNIT=False; 

addUnit[XMLElement[x___]]:= Module[{n, meta},
debugPrint[Global`$DEBUG$ADDUNIT,"addUnit[XMLElement]: ", XMLElement[x]];


n=getSBMLid[XMLElement[x]];

If[defaultUnit[n],
If[\[Not]removeDefaultUnit[n],
Print["Warning: Unable to redefine default unit"//boldOrange," Unit "//boldBlack,n//boldRed];
Return[{}]
];
,
If[unitExists[n], 
If[deleteUnit[Global`id-> n] ,
If[MB$Echo,
Print["Previous occurance of unit "//boldBlack,n//boldRed," removed."//boldBlack];
];
,
Print["Warning: "//boldOrange," Unit "//boldBlack,n//boldRed," can not be added."//boldBlack];
Return[{}];
];
]; 
]; 

addID[n,"unit",True];
meta = getSBMLfield["metaid", XMLElement[x]]; 
If[meta!= "", addMetaID[meta,contextify[n], "unit", True]]; 

MB$Units=Append[MB$Units,n->XMLElement[x]];
If[MB$Echo, Print["Unit "//boldGreen,n//boldBlue," added."//boldGreen]];
Return[n];
]; 

addUnit[opt___?OptionQ]:=Module[{r,n},
debugPrint[Global`$DEBUG$ADDUNIT,"addUnit[options]: ", {opt}];

(* MB$Echo = Global`echo/.{opt}/.{Global`echo-> True}; *)
r =unitToSymbolicSBML[opt]; 

n=addUnit[r];
Return[n];
];

addUnit[id_, opt___?OptionQ]:= addUnit[Global`id-> id, opt];



 modifyUnit[opt___?OptionQ]:= Module[{n,x,y,k,dbg=True, u,name, ann, newann,unitann, metaid},
n =( Global`id/.{opt}/.{Global`id-> ""})//stringer;
metaid = Global`metaid/.{opt}/.{Global`metaid->1}; 

MB$Currentid=n;
x=retrieveSBMLObject["unit",n];

If[ToString[Head[x]]=="XMLElement",
y=extractXMLOptions[x];
If[metaid== 1, metaid="metaid"/.y/.{"metaid"->""}]; 
y = stringrule/@(Join[{opt},y]//Flatten);
u =Cases[x, XMLElement["listOfUnits",___],Infinity]; 
If[Length[u]>0,
While[ListQ[u] \[And] Length[u]>0, u=First[u]]; 
u = Cases[u, XMLElement["unit",___], Infinity];
unitann = getAnnotations/@u;

u = expressionate/@(extractXMLOptions/@u);
u = MapThread[Append[#1,Global`annotation-> #2]&,{u,unitann}];
k = Map[Global`kind/.#&, u]; 
u = MapThread[Rule[#1, #2]&, {k,u}]; 

u = "unit"/.y/.{"unit"-> u}//expressionate; 

name ="name"/.y/.{"name"-> ""}; 

ann = getAnnotations[x];
newann = (Global`annotation/.{opt}/.{Global`annotation-> {}});
ann = Join[ann, newann]; 


y  = {Global`id-> n, Global`unit-> u,Global`annotation-> ann, Global`metaid->metaid}; 
If[name!= "", y = Append[y, Global`name-> name]]; 

]; 
 
MB$Modify=True;
n=Apply[addUnit,y];
MB$Modify=False;
,
n=addUnit[opt]; 
];
Return[n]; 
];
modifyUnit[id_, opt___?OptionQ]:= modifyUnit[Global`id-> id, opt];



getCompartmentType[n_?IntegerQ]:= Module[{m},
m=getNumberOfCompartmentTypes[];
If[n>m \[Or] n<1, Print["Error: getCompartmentType: "//boldOrange," compartmentType: "//boldBlack,n//boldRed," does not exist. There are "//boldBlack,m//boldRed," compartmentTypes."//boldBlack];Return[{}];];
Return[MB$CompartmentTypes[[n]]//Last];
]; 
getCompartmentTypeNumber[id_?SIDQ]:=Module[{m,n},
m = First/@MB$CompartmentTypes;
n=Position[m, stringer[id]];
If[Length[n]<1, Print["Error: getCompartmentTypeNumber: "//boldOrange,"compartmentType: "//boldBlack,id//boldRed," does not exist. Valid compartmentType are "//boldBlack, m//boldRed];Return[0];]; 
While[ListQ[n], n=First[n]];
Return[n];
];
getCompartmentType[id_?SIDQ]:=Module[{m,n},
m = First/@MB$CompartmentTypes;
n=Position[m, stringer[id]];
If[Length[m]>0, m =list2CommaSeparatedString[m], m="No compartmentTypes have been defined."]; 
If[Length[n]<1, Print["Error: "//boldRed, " getCompartmentType: "//boldBlack,"compartmentType: "//boldBlack,id//boldBlue," does not exist. Valid compartmentTypes are: "//boldBlack, m//boldBlue];Return[{}];]; 
While[ListQ[n], n=First[n]];
Return[MB$CompartmentTypes[[n]]//Last];
]; 
getCompartmentType[x_?ListQ]:= getCompartmentType/@Flatten[x];
getNumberOfCompartmentTypes[]:= Length[MB$CompartmentTypes];
getCompartmentTypes[]:= getCompartmentType[Range[getNumberOfCompartmentTypes[]]]; 

getCompartmentType[x___]:= Module[{},
Print["Error: getCompartmentType: "//boldOrange, "Correct format is: "//boldBlack,"getCompartmentType[id]"//boldRed, " where id is an integer or an SID, "//boldBlack,"getCompartmentType[Integer]"//boldRed, " or "//boldBlack,"getCompartmentType[{x1,x2,...}]"//boldRed," where x1,x2,... are integers or SIDs."//boldBlack];
Return[{}];
];




compartmentTypeToSBML[{x__?ListQ}]:=Module[{SBML}, 
SBML =Flatten[ compartmentTypeToSymbolicSBML/@{x}];
SBML = XMLElement["listOfCompartmentTypes",{},SBML]; 
SBML=ExportXMLString[SBML];
SBML = sunderscore[SBML];
Return[SBML];
];

compartmentTypeToSBML[opt___?OptionQ]:= Module[{r},
r =compartmentTypeToSymbolicSBML[opt]; 
r=ExportXMLString[r];
r = sunderscore[r];
Return[r];
];

compartmentTypeToSBML[x_, opt___?OptionQ]:= compartmentTypeToSBML[Global`id-> x, opt]; 


compartmentTypeToSBML[x___]:= Print[
boldOrange["Warning:"], 
boldBlack["The argument to compartmentTypeToSBML must be either a sequence of options or a list of option lists"]
]; 




deleteCompartmentType[opt___?OptionQ]:= Module[{n,c,p},
n =( Global`id/.{opt}/.{id-> ""})//stringer;
If[id=="", 
Print["Error: deleteCompartmentType"//boldRed," No "//boldBlack,"id"/boldRed," was specified."]]; 
removeID[n,"compartmentType"]; 
MB$Currentid=n;
c = Map[First,MB$CompartmentTypes]; 
If[MemberQ[c,n],
p=Position[c,n];
MB$CompartmentTypes= Drop[MB$CompartmentTypes,First[p]]; 
Return[True];
];
Return[False];
];
deleteCompartmentType[x_, opt___?OptionQ]:= deleteCompartmentType[Global`id-> x,opt];
removeCompartmentType[x___]:=Module[{flag},
flag = deleteCompartmentType[x];
If[flag, 
If[MB$Echo,Print["Compartment Type "//boldGreen,MB$Currentid//boldBlue," removed."//boldGreen]],
Print["Error: "//boldRed,"Requested compartmentType "//boldBlack,MB$Currentid//boldBlue," does not exist. No removal peformed."//boldBlack]];
];



addCompartmentType[XMLElement[x___]]:=Module[
{r,n, opts,sub, meta},
If[ToExpression[MB$LevelVersion]<2.15, Print["Error:"//boldRed," Cannot add a compartmentType in SBML Level "//boldBlack,MB$LevelVersion//boldBlack];Abort[]];
r =XMLElement[x];
n=getSBMLid[r];

opts={x}[[2]];
sub={x}[[3]];

(* check for previous occurance of this Compartment type *)

If[deleteCompartmentType[Global`id-> n],If[MB$Echo,Print["Previous occurance of compartmentType "//boldGreen,n//boldBlue," removed."//boldGreen]]
];

addID[n, "compartmentType",True];

meta = getSBMLfield["metaid", XMLElement[x]]; 
If[meta!= "", addMetaID[meta,contextify[n], "compartmentType", True]]; 


r=XMLElement["compartmentType",opts,sub];
MB$CompartmentTypes=Append[MB$CompartmentTypes,n->r];
If[MB$Echo, Print["CompartmentType "//boldGreen,n//boldBlue," added."//boldGreen]];

Return[n];
];


addCompartmentType[s_?ListQ, opt___?OptionQ]:= Map[addCompartmentType[#,opt]&,s];    

addCompartmentType[opt___?OptionQ]:=Module[{r,n, dbg=False},
checkOptions[addCompartmentType, opt, 
{Global`annotation,  Global`id, Global`metaid,  Global`name,Global`notes}];
If[dbg, Print["addCompartmentType[opt]:{opt}:", {opt}]]; 
r =compartmentTypeToSymbolicSBML@@{opt};
If[dbg, Print["addCompartmentType[opt]:r:",r]];
n=addCompartmentType[r];
If[dbg,Print["addCompartmentType[opt]:n:",n]];

Return[n];
];

addCompartmentType[id_, opt___?OptionQ]:= addCompartmentType[Global`id-> id, opt];


 modifyCompartmentType[opt___?OptionQ]:= Module[{n,x,y,ann, notes},
n =( Global`id/.{opt}/.{Global`id-> ""})//stringer;
MB$Currentid=n;

x=retrieveSBMLObject["compartmentType",n];

If[ToString[Head[x]]=="XMLElement",
y=globalize/@extractAndUpdateXMLOptions[x,opt];

ann = updateAnnotations[x, opt];
notes = updateNotes[x, opt]; 

y = Prepend[y, globalize["annotation"-> ann]]; 
y = Prepend[y, globalize["notes"-> notes]]; 

n=Apply[addCompartmentType,y];
,
n=addCompartmentType[opt]; 
];
Return[n]; 
];
modifyCompartmentType[id_, opt___?OptionQ]:= modifyCompartmentType[Global`id-> id, opt];



getCompartment[n_?IntegerQ]:= Module[{m},
m=Length[MB$Compartments];
If[n>m \[Or] n<1, Print["Error: getCompartment: "//boldOrange," Compartment: "//boldBlack,n//boldRed," does not exist. There are "//boldBlack,m//boldRed," compartments."//boldBlack];Return[{}];];
Return[MB$Compartments[[n]]//Last];
]; 
getCompartmentNumber[id_?SIDQ]:=Module[{m,n},
m = First/@MB$Compartments;
n=Position[m, stringer[id]];
If[Length[n]<1, Print["Error: getCompartmentNumber: "//boldOrange,"Compartment: "//boldBlack,id//boldRed," does not exist. Valid compartments are "//boldBlack, m//boldRed];Return[0];]; 
While[ListQ[n], n=First[n]];
Return[n];
]; 
getCompartment[id_?SIDQ]:=Module[{n},
n = getCompartmentNumber[id];
If[n>0, Return[MB$Compartments[[n]]//Last]];
Return[{}];
]; 
getCompartment[x_?ListQ]:= getCompartment/@Flatten[x];
getCompartment[x___]:= Module[{},
Print["Error: getCompartment: "//boldOrange, "Correct format is: "//boldBlack,"getCompartment[id]"//boldRed, " where id is an integer or an SID, "//boldBlack,"getCompartment[Integer]"//boldRed, " or "//boldBlack,"getCompartment[{x1,x2,...}]"//boldRed," where x1,x2,... are integers or SIDs."//boldBlack];
Return[{}];
];
getNumberOfCompartments[]:=Length[MB$Compartments];
getCompartments[]:= getCompartment[Range[getNumberOfCompartments[]]];




replaceCompartment[i_?IntegerQ, XMLElement["compartment",x___]]:= Module[{n,j},
n=Length[MB$Compartments];
If[n>0 \[And] i>0 \[And] i<=n, 

j=getSBMLfield["id",XMLElement["compartment",x]]; 
If[j=="", j=MB$Compartments[[i,1]]];


MB$Compartments=ReplacePart[MB$Compartments,j-> XMLElement["compartment",x],i];
If[MB$Echo, Print["Compartment ",i, " replaced."]];
Return[];
]; 
Print["Error: replaceCompartment: "//boldOrange," unable to replace compartment "//boldBlack,i//boldRed];
Return[];
]; 

replaceCompartment[id_?SIDQ, XMLElement["compartment",x___]]:= Module[{n},
n=getCompartmentNumber[id];
If[n>0, 
replaceCompartment[n, XMLElement["compartment",x]]; 
Return[];
]; 
Print["Error: replaceCompartment: "//boldOrange," unable to replace compartment "//boldBlack,id//boldRed];
Return[];
]; 

replaceCompartment[x___]:= Print["Error: "//boldOrange,"replaceCompartment: "//boldRed, "Invalid arguments. Correct format is:"//boldBlack,"replaceCompartment["//boldBlack," Integer|SID "//boldBlack,","//boldBlack, " XMLElement[\"compartment\",...]"//boldBlack," ]"//boldBlack];


compartmentExists[n_]:= MemberQ[First/@MB$Compartments,n];


 compartmentToSBML[{x__?ListQ}]:=Module[{r}, 
r =Flatten[ compartmentToSymbolicSBML/@{x}];
r = XMLElement["listOfCompartments",{},r]; 
r=ExportXMLString[r];
r=sunderscore[r];
Return[r];
];


compartmentToSBML[opt___?OptionQ]:= Module[{r},
r=compartmentToSymbolicSBML[opt]; 
r=ExportXMLString[r];
r=sunderscore[r];
Return[r];
];

compartmentToSBML[x_, opt___?OptionQ]:= compartmentToSBML[Global`id->x, opt];


deleteCompartment[opt___?OptionQ]:= Module[{n,c,p, sp, mod},
n =( Global`id/.{opt}/.{id-> ""})//stringer;

If[id=="", 
Print["Error: deleteCompartment"//boldOrange," No "//boldBlack,"id"/boldRed," was specified."]]; 
MB$Currentid=n;
removeID[n,"compartment"]; 

c = Map[First,MB$Compartments]; 
If[MemberQ[c,n],

If[\[Not]MB$Modify,
(* check to see if there are any species references to this compartment *) 
sp = Position[MB$Species, "compartment"-> n];
If[Length[sp]>0,
sp = First/@sp;
sp=Map[Part[First/@MB$Species,#]&,sp];
Print["Warning: "//boldOrange, "The species "//boldBlack,list2CommaSeparatedString[sp]//boldRed, " refers to compartment "//boldBlack,n//boldRed ];
Return[False];
];
(* check for other compartments referring to this *)
sp = Position[MB$Compartments, "outside"-> n];
If[Length[sp]>0,
sp = First/@sp;
sp=Map[Part[First/@MB$Compartments,#]&,sp];
Print["Warning: "//boldRed, "The compartment "//boldBlack,list2CommaSeparatedString[sp]//boldRed, " refers to compartment "//boldBlack,n//boldRed," in its outside field. This message usually occurs when compartments are not defined in the proper order. "//boldBlack];
Return[False];
];
]; 
(* delete the compartment *) 

p=Position[c,n];
MB$Compartments= Drop[MB$Compartments,First[p]]; 

forgetCompartment[n];

Return[True];
];
Return[False];
];
deleteCompartment[x_, opt___?OptionQ]:= deleteCompartment[Global`id-> x,opt];
removeCompartment[x___]:=Module[{flag},
flag = deleteCompartment[x];
If[flag, 
Print["Compartment "//boldGreen,MB$Currentid//boldBlue," removed."//boldGreen],
Print["Warning: "//boldOrange,"Requested compartment "//boldBlack,MB$Currentid//boldRed," can not be removed."//boldBlack]];
];



addCompartment[XMLElement[x___]]:= Module[{n,r,outside, comps, meta},
r = XMLElement[x];
n=getSBMLid[r];



If[compartmentExists[n],
If[deleteCompartment[Global`id-> n] ,If[MB$Echo,Print["Previous occurance of "//boldGreen,n//boldBlue," removed."//boldGreen]];
,
Print["Warning: "//boldRed," Compartment "//boldBlack,n//boldRed," cannot be added because it already exists. This message usually occurs when compartments are defined out of order in the SBML model and added automatically by SBMLRead during the prior (invalid) reference. "//boldBlack];
Return[{}];
]; 
]; 
addID[n, "compartment",True];
meta = getSBMLfield["metaid", XMLElement[x]]; 
If[meta!= "", addMetaID[meta,contextify[n], "compartment", True]]; 



MB$Compartments=Append[MB$Compartments,n->r];
pushCompartment[n];

outside = getSBMLfield["outside",r];
If[outside!= "",
comps = First/@MB$Compartments;
If[!MemberQ[comps,outside],
addCompartment[outside];
];
];
If[MB$Echo, Print["Compartment "//boldGreen,n//boldBlue," added."//boldGreen]];

Return[n];
]; 

addCompartment[opt___?OptionQ]:=Module[{r,n},
(* MB$Echo = Global`echo/.{opt}/.{Global`echo-> True}; *)

r =compartmentToSymbolicSBML[opt]; 
n=addCompartment[r];
Return[n];
];


addCompartment[id_, opt___?OptionQ]:= addCompartment[Global`id-> id, opt];



 modifyCompartment[opt___?OptionQ]:= Module[{n,x,y,ann,notes},
n =( Global`id/.{opt}/.{Global`id-> ""})//stringer;
MB$Currentid=n;
x=retrieveSBMLObject["compartment",n];
If[ToString[Head[x]]=="XMLElement",
y=globalize/@extractAndUpdateXMLOptions[x,opt];

ann = updateAnnotations[x, opt]; 
notes = updateNotes[x, opt];

y = Prepend[y, globalize["annotation"-> ann]]; 
y  =Prepend[y, globalize["notes"-> notes]]; 

MB$Modify=True;
n=Apply[addCompartment,y];
MB$Modify=False;
,
n=addCompartment[opt]; 
];
Return[n]; 
];
modifyCompartment[id_, opt___?OptionQ]:= modifyCompartment[Global`id-> id, opt];



getParameter[n_?IntegerQ]:= Module[{m},
m=Length[MB$Parameters];
If[n>m \[Or] n<1, Print["Error: getParameter: "//boldOrange," Parameter: "//boldBlack,n//boldRed," does not exist. There are "//boldBlack,m//boldRed," parameters"//boldBlack];Return[{}];];
Return[MB$Parameters[[n]]//Last];
]; 
getParameterNumber[id_?SIDQ]:=Module[{m,n, sid},
sid=stringer[id];
m=First/@MB$Parameters;
n=Position[m, sid];
If[Length[n]<1, Print["Error: getParameterNumber: "//boldOrange,
"Parameters: "//boldBlack,id//boldRed," does not exist. Valid parameters are "//boldBlack, m//boldRed];
Return[0];
]; 
While[ListQ[n], n=First[n]];
Return[n];
]; 
getParameter[id_?SIDQ]:=Module[{n,p},
n = getParameterNumber[id]; 
If[n>0, 
p=Last[MB$Parameters[[n]]]; 
Return[p]];
Return[{}]; 
]; 
getParameter[x_?ListQ]:= getParameter/@Flatten[x];
getParameter[x___]:= Module[{},
Print["Error: getParameter: "//boldOrange, "Correct format is: "//boldBlack,"getParameter[id]"//boldRed, " where id is an integer or an SID, "//boldBlack,"getParameter[Integer]"//boldRed, " or "//boldBlack,
"getParameter[{x1,x2,...}]"//boldRed," where x1,x2,... are integers or SIDs."//boldBlack];
Return[{}];
];
getNumberOfParameters[]:=Length[MB$Parameters];
getParameters[]:= getParameter[Range[getNumberOfParameters[]]];


replaceParameter[i_?IntegerQ, XMLElement["parameter",x___]]:= Module[{n,j},
n=Length[MB$Parameters];
If[n>0 \[And] i>0 \[And] i<=n, 

j=getSBMLfield["id",XMLElement["parameter",x]]; 
If[j=="", j=MB$Parameters[[i,1]]];

MB$Parameters=ReplacePart[MB$Parameters,j-> XMLElement["parameter",x],i];
If[MB$Echo, Print["Parameter ",i, " replaced."]];
Return[];
]; 
Print["Error: replaceParameter: "//boldOrange," unable to replace parameter "//boldBlack,i//boldRed];
Return[];
]; 

replaceParameter[id_?SIDQ, XMLElement["parameter",x___]]:= Module[{n},
n=getParameterNumber[id];
If[n>0, 
replaceParameter[n, XMLElement["parameter",x]]; 
Return[];
]; 
Print["Error: replaceParameter: "//boldOrange," unable to replace parameter "//boldBlack,id//boldRed];
Return[];
]; 

replaceParameter[x___]:= Print["Error: "//boldOrange,"replaceParameter: "//boldRed, "Invalid arguments. Correct format is:"//boldBlack,"replaceParameter["//boldBlack," Integer|SID "//boldBlack,","//boldBlack, " XMLElement[\"parameter\",...]"//boldBlack," ]"//boldBlack];


 parameterToSBML[{x__?ListQ}]:=Module[{r}, 
r =Flatten[ parameterToSymbolicSBML/@{x}];
r = XMLElement["listOfParameters",{},r]; 
r=ExportXMLString[r];
r=sunderscore[r];
Return[r];
];


parameterToSBML[opt___?OptionQ]:= Module[{r},
r=parameterToSymbolicSBML[opt]; 
r=ExportXMLString[r];
r=sunderscore[r];
Return[r];
];

parameterToSBML[x_, opt___?OptionQ]:= parameterToSBML[Global`id-> x, opt];



deleteParameter[opt___?OptionQ]:= Module[{n,c,p},
n =( Global`id/.{opt}/.{Global`id-> ""})//stringer;
If[id=="", 
Print["Error: deleteParameter"//boldOrange," No "//boldBlack,"id"/boldRed," was specified."]]; 
removeID[n,"parameter"];
MB$Currentid=n;
c = Map[First,MB$Parameters]; 
If[MemberQ[c,n],
p=Position[c,n];
MB$Parameters= Drop[MB$Parameters,First[p]]; 
Return[True];
];
Return[False];
];
deleteParameter[x_, opt___?OptionQ]:= deleteParameter[Global`id-> x,opt];
removeParameter[x___]:=Module[{flag},
flag = deleteParameter[x];
If[flag, 
If[MB$Echo,Print["Parameter "//boldGreen,MB$Currentid//boldBlue," removed."//boldGreen]],
Print["Warning: "//boldOrange,"Requested Parameter "//boldBlack,MB$Currentid//boldRed," can not be removed."//boldBlack]];
];


addParameter[XMLElement[x___]]:=Module[{r,n, units,dbg=False, val, meta},
r =XMLElement[x]; 
n=getSBMLid[r];

If[deleteParameter[Global`id-> n] ,If[MB$Echo,Print["Previous occurance of parameter "//boldGreen,n//boldBlue," removed."//boldGreen]]
];

addID[n,"parameter",True];
meta = getSBMLfield["metaid", XMLElement[x]]; 
If[meta!= "", addMetaID[meta,contextify[n], "parameter", True]]; 


MB$Parameters=Append[MB$Parameters,n->r];

(* check to make sure assigned units exits *) 
units = getSBMLfield["units",r];
If[units!= "", 
If[!unitExists[units], addUnit[units]]];

If[dbg, Print["addParameter: r=",r]];

val = getSBMLfield["value",r];
If[val!= "", val="="<>stringer[val]];
If[MB$Echo, Print["Parameter "//boldGreen,n//boldBlue,val//boldBlue," added."//boldGreen]];
Return[n];
];

addParameter[opt___?OptionQ]:=Module[{r,n, dbg=False},
If[dbg, Print["addParameter: {opt}: ", {opt}]]; 
r =parameterToSymbolicSBML[opt]; 
n=addParameter[r]; 
Return[n];
];

addParameter[id_, opt___?OptionQ]:= Module[{dbg=False}, 
If[dbg, Print["addParameter: id = ", id, " {opt}=", {opt}]]; 
Return[addParameter[Global`id-> id, opt]]
];


 modifyParameter[opt___?OptionQ]:= Module[{n,x,y,ann, notes, bug=False},
n =( Global`id/.{opt}/.{Global`id-> ""})//stringer;
MB$Currentid=n;
x=retrieveSBMLObject["parameter",n];
If[ToString[Head[x]]=="XMLElement",
If[bug, Print["x=", x]]; 

y=globalize/@extractAndUpdateXMLOptions[x,opt];
If[bug, Print["y(1)=", y]]; 

ann = updateAnnotations[x, opt];
notes = updateNotes[x,opt]; 

y = Prepend[y, globalize["annotation"-> ann]]; 
If[bug, Print["y(2)=", y]]; 
y = Prepend[y,globalize["notes"->notes]]; 
If[bug, Print["y(3)=", y]]; 


MB$Modify=True;
n=Apply[addParameter,y];
If[bug, Print["n=", n]]; 

MB$Modify=False;
,
n=addParameter[opt]; 
];
Return[n]; 
];
modifyParameter[id_, opt___?OptionQ]:= modifyParameter[Global`id-> id, opt];



getInitialAssignment[n_?IntegerQ]:= Module[{m},
m=Length[MB$InitialAssignments];
If[n>m \[Or] n<1, Print["Error: "//boldRed,"getInitialAssignment: "//boldBlack," initialAssignment: "//boldBlack,n//boldBlue," does not exist. There are "//boldBlack,m//boldBlue," initialAssignments"//boldBlack];Return[{}];];
Return[MB$InitialAssignments[[n]]//Last];
]; 
getInitialAssignmentNumber[id_?SIDQ]:=Module[{m,n, sid},
sid=stringer[id];
m=First/@MB$InitialAssignments;
n=Position[m, sid];
If[Length[n]<1, Print["Error: "//boldRed,"getInitialAssignmentNumber: "//boldBlack,
"initialAssignment for "//boldBlack,id//boldBlue," does not exist."//boldBlack];
Return[0];
]; 
While[ListQ[n], n=First[n]];
Return[n];
]; 
getInitialAssignment[id_?SIDQ]:=Module[{n,p},
n = getInitialAssignmentNumber[id]; 
If[n>0, 
p=Last[MB$InitialAssignments[[n]]]; 
Return[p]];
Return[{}]; 
]; 
getInitialAssignment[x_?ListQ]:= getInitialAssignment/@Flatten[x];
getInitialAssignment[x___]:= Module[{},
Print["Error: "//boldRed,"getInitialAssignment: "//boldBlack, "Correct format is: "//boldBlack,"getInitialAssignment[id]"//boldBlue, " where id is an integer or an SID, "//boldBlack,"getInitialAssignment[Integer]"//boldBlue, " or "//boldBlack,
"getInitialAssignment[{x1,x2,...}]"//boldBlue," where x1,x2,... are integers or SIDs."//boldBlack];
Return[{}];
];
getNumberOfInitialAssignments[]:=Length[MB$InitialAssignments];
getInitialAssignments[]:= getInitialAssignment[Range[getNumberOfInitialAssignments[]]];


 initialAssignmentToSBML[{x__?ListQ}]:=Module[{r}, 
r =Flatten[ initialAssignmentToSymbolicSBML/@{x}];
r = XMLElement["listOfInitialAssignments",{},r]; 
r=ExportXMLString[r];
r=sunderscore[r];
Return[r];
];


initialAssignmentToSBML[opt___?OptionQ]:= Module[{r},
r=initialAssignmentToSymbolicSBML[opt]; 
r=ExportXMLString[r];
r=sunderscore[r];
Return[r];
];

initialAssignmentToSBML[x_, opt___?OptionQ]:= initialAssignmentToSBML[Global`symbol-> x, opt];



deleteInitialAssignment[opt___?OptionQ]:= Module[{n,c,p, meta, dbg=False},
n =( Global`symbol/.{opt}/.{Global`symbol-> ""})//stringer;
If[n=="", 
Print["Error: "//boldRed, " deleteInitialAssignment"//boldBlack," No "//boldBlack,"symbol"//boldBlue," was specified."//boldBlack]];
MB$Currentid=n; 
c = Map[First,MB$InitialAssignments]; 
If[MemberQ[c,n],
p=Position[c,n];
MB$InitialAssignments= Drop[MB$InitialAssignments,First[p]]; 

(* remove metaids pointing to n *)
meta =functionate["initialAssignment", n]/.(Reverse/@$SBML$MetaIDAssociations);
If[dbg==True, 
Print["deleteInitialAssignment: meta, n: ", {meta, n}];
];
removeMetaID[meta, "initialAssignment"];
Return[True];


];
Return[False];
];
deleteInitialAssignment[x_, opt___?OptionQ]:= deleteInitialAssignment[Global`symbol-> x,opt];
removeInitialAssignment[x___]:=Module[{flag},
flag = deleteInitialAssignment[x];
If[flag, 
If[MB$Echo,Print["InitialAssignment for "//boldGreen,MB$Currentid//boldBlue," removed."//boldGreen]],
Print["Error: "//boldRed,"Requested initialAssignment for "//boldBlack,MB$Currentid//boldBlue," could not be removed."//boldBlack]];
];


addInitialAssignment[XMLElement[x___]]:=Module[
{r,n, meta},

If[ToExpression[MB$LevelVersion]<2.2, 
Print["Error: "//boldRed, "addInitialAssignment: initialAssignment is not permitted in SBML level.version "//boldBlack, MB$LevelVersion//boldBlue]
];

n=getSBMLfield["symbol", r];
r =XMLElement[x]; 

If[deleteInitialAssignment[Global`symbol-> n] ,If[MB$Echo,Print["Previous occurance of initialAssignment for "//boldGreen,n//boldBlue," removed."//boldGreen]]
];


 meta = getSBMLfield["metaid", r]; 
If[meta!= "", 
addMetaID[meta,"initialAssignment["<>n<>"]", "initialAssignment", True];
]; 


MB$InitialAssignments=Append[MB$InitialAssignments,n->r];

checkInitialAssignment[r, "addInitialAssignment"];

If[MB$Echo, Print["InitialAssignment for "//boldGreen,n//boldBlue," added."//boldGreen]];
Return[n];
];

addInitialAssignment[opt___?OptionQ]:=Module[{r,n},
r =initialAssignmentToSymbolicSBML[opt]; 
n=addInitialAssignment[r]; 
Return[n];
];

addInitialAssignment[id_, opt___?OptionQ]:= addInitialAssignment[Global`symbol-> id, opt];


replaceInitialAssignment[i_?IntegerQ, XMLElement["initialAssignment",x___]]:= Module[{n,j},
n=Length[MB$InitialAssignments];
If[n>0 \[And] i>0 \[And] i<=n, 

j=getSBMLfield["symbol",XMLElement["initialAssignment",x]]; 
If[j=="", j=MB$InitialAssignments[[i,1]]];

MB$InitialAssignments=ReplacePart[MB$InitialAssignments,j-> XMLElement["initialAssignment",x],i];
If[MB$Echo, Print["InitialAssignment ",i, " replaced."]];
Return[];
]; 
Print["Error: "//boldRed," replaceParameter: "//boldBlack," unable to replace initialAssignment "//boldBlack,i//boldBlue];
Return[];
]; 

replaceInitialAssignment[id_?SIDQ, XMLElement["initialAssignment",x___]]:= Module[{n},
n=getInitialAssignmentNumber[id];
If[n>0, 
replaceInitialAssignment[n, XMLElement["initialAssignment",x]]; 
Return[];
]; 
Print["Error: "//boldRed," replaceInitialAssignment: "//boldBlack," unable to replace initialAssignment for "//boldBlack,id//boldBlue];
Return[];
]; 

replaceInitialAssignment[x___]:= Print["Error: "//boldRed,"replaceInitialAssignment: "//boldBlack, "Invalid arguments. Correct format is:"//boldBlack,"replaceInitialAssignment["//boldBlack," Integer|SID,"//boldBlack, " XMLElement[\"initialAssignment\",...]"//boldBlack," ]"//boldBlack];


 modifyInitialAssignment[opt___?OptionQ]:= Module[{n,x,y,ann, notes, oldmath,xmlsub, dbg=False},
n =( Global`symbol/.{opt}/.{Global`symbol-> ""})//stringer;
MB$Currentid=n;
x=retrieveSBMLObject["initialAssignment",n];
If[ToString[Head[x]]=="XMLElement",
y=globalize/@extractAndUpdateXMLOptions[x,opt];

ann = updateAnnotations[x, opt];


notes=updateNotes[stringToNotes[x,opt]];

y = Prepend[y, globalize["annotation"-> ann]]; 
y = Prepend[y,globalize["notes"->notes]];

xmlsub=extractXMLSubElements[x];
If[dbg, Print["modifyInitialAssignment: xmlsub: ", xmlsub]]; 


oldmath = Cases[xmlsub, XMLElement["math",___]]; 
If[Length[oldmath]>1, Print["Error: "//boldRed,
"modifyInitialAssignment: previous value of initialAssignment for "//boldblack,
n//boldBlue, " has multiple math fields. Only the first will be retrieved. "//boldBlack
]];
If[Length[oldmath]<1, 
Print["Error: "//boldRed,
"modifyInitialAssignment: previous value of initialAssignment for "//boldblack,
n//boldBlue, " has no math field.  "//boldBlack
];
,
While[ListQ[oldmath] \[And] Length[oldmath]>0, oldmath=First[oldmath]];
If[dbg, Print["modifyInitialAssignment: oldmath: ", oldmath]]; 
oldmath = MathMLToInfix[XMLOut[oldmath]];
If[dbg, Print["modifyInitialAssignment: oldmath: ", oldmath]]; 
y = Append[y, Global`math-> oldmath]; 

];


If[dbg, Print["modifyInitialAssignment: y:", y]]; 

MB$Modify=True;
n=Apply[addInitialAssignment,y];
MB$Modify=False;
,
n=addInitialAssignment[opt]; 
];
Return[n]; 
];
modifyInitialAssignment[id_, opt___?OptionQ]:= modifyInitialAssignment[Global`symbol-> id, opt];



checkInitialAssignment[r_,calledby_, opt___?OptionQ]:=Module[{dbg=False,
symbolsReferenced,math,options,subXML, XML2Symbol,knownSymbols,
unknownSymbols,variable,ruleType,hf, csymbols, mycsymbol, mathexpression,symbol,
calledbySBMLRead},

calledbySBMLRead=(calledby=="calledbySBMLRead");

XML2Symbol["ci",{},{x_}]:= x;
XML2Symbol[x___]:= {};

options=extractXMLOptions[r];
subXML=extractXMLSubElements[r];

symbol= ("symbol"/.options)/.{"symbol"-> "??-symbol-not-specified-??"};

If[MemberQ[First/@$SBML$IDTable, symbol], 
Block[{p,s},
p=Position[$SBML$IDTable, symbol];
While[ListQ[p], p=First[p]];
s=$SBML$IDTable[[p,2]];
If[!MemberQ[{"compartment","parameter", "species"}, s], 

Print["Error: "//boldRed, "checkInitialAssignment: an initial assignment cannot be made to a "//boldBlack,s//boldBlue," only to a compartment, parameter, or species:\n"//boldBlack,
Sequence@@XMLHighlightForm[r, Purple,"symbol="<>quote[symbol]]
];

];
];
,
Print["Error: "//boldRed, "checkInitialAssignment: undefined or invalid symbol "//boldBlack,
symbol//boldBlue, " in "//boldBlack, "initialAssignment:\n"//boldBlue,
Sequence@@XMLHighlightForm[r,Purple, "symbol="<>quote[symbol]]
]
];



(* Prevent duplicate messaging - catch this in addInitialAssignment*)

If[!calledbySBMLRead,
If[MemberQ[MB$AssignmentRuleVariables, symbol], 
Print["Error: "//boldRed, " An "//boldBlack,
"initialAssignment "//boldBlue, 
"may not refer to a symbol for which an "//boldBlack, "assignmentRule"//boldBlue," has been previously defined. Symbol: "//boldBlack, symbol//boldBlue];
]; 
];

(* The following test will never pass when called by addInitialAssignment because of the deleteInitialAssignment *)

If[calledbySBMLRead,
If[MemberQ[First/@MB$InitialAssignments, symbol], 
Print["Error: "//boldRed, " Multiple initialAssignments may not be made to the same symbol. Symbol: "//boldBlack, symbol//boldBlue];
]; 
]; 

math=Cases[subXML, XMLElement["math",___],1];
If[Length[math]<1,
Return[];
,
If[Length[math]>1,
Print["Error: "//boldRed, "Multiple math objects in initialAssignment:\n"//boldBlack,
Sequence@@XMLHighlightForm[r,Purple,"math"]
];
];
While[ListQ[math],math=First[math]];
]; 

symbolsReferenced=Cases[math,XMLElement["ci",___],Infinity];
symbolsReferenced=symbolsReferenced/.{XMLElement-> XML2Symbol};
symbolsReferenced=Union[symbolsReferenced]; 

csymbols = Cases[math, XMLElement["csymbol",___],Infinity];
If[Length[csymbols]>0,
mycsymbol["csymbol",{___},x_]:= x;
mycsymbol[x___]:= XMLElement[x];
csymbols=Flatten[(csymbols/.{XMLElement-> mycsymbol})/.{XMLElement-> List}];
csymbols=Complement[csymbols,{"ci"}];
];




knownSymbols=Join[First/@$SBML$IDTable, csymbols];
unknownSymbols=Complement[symbolsReferenced,knownSymbols];

mathexpression=Cases[subXML, XMLElement["math",___],1];
mathexpression=First[mathexpression];
mathexpression=XMLOut[mathexpression];

hf[var_]:= XMLHighlightForm[#,Purple,"<ci>"<>stringer[var]<>"</ci>"]&@@ Cases[subXML, XMLElement["math",___],1];


Print["Error: "//boldRed,"addInitialAssignment: Unknown symbol "//boldBlack,#//boldBlue," is referenced in the initialAssignment "//boldBlack,
MathMLToInfix[mathexpression]//boldBlue,"\n",
Sequence@@hf[#]

]&/@unknownSymbols;

checkFunctionCalls[math,"initialAssignment", "(addInitialAssignment)"];

Return[];
];


 constraintToSBML[{x__?ListQ}]:=Module[{r}, 
r =Flatten[ constraintToSymbolicSBML/@{x}];
r = XMLElement["listOfConstraints",{},r]; 
r=ExportXMLString[r];
r=sunderscore[r];
Return[r];
];


constraintToSBML[opt___?OptionQ]:= Module[{r},
r=constraintToSymbolicSBML[opt]; 
r=ExportXMLString[r];
r=sunderscore[r];
Return[r];
];


getConstraint[n_?IntegerQ]:= Module[{m},
m=Length[MB$Constraints];
If[n>m \[Or] n<1, Print["Error: "//boldRed,"getConstraint: "//boldBlack," Constraint: "//boldBlack,n//boldBlue," does not exist. There are "//boldBlack,m//boldBlue," Constraints"//boldBlack];Return[{}];];
Return[MB$Constraints[[n]]];
]; 

getConstraint[x_?ListQ]:= getConstraint/@Flatten[x];
getConstraint[x___]:= Module[{},
Print["Error: "//boldRed,"getConstraint: "//boldBlack, "Correct format is: "//boldBlack,"getConstraint[Integer]"//boldBlue, " or "//boldBlack,
"getConstraint[{x1,x2,...}]"//boldBlue," where x1,x2,... are integers"//boldBlack];
Return[{}];
];
getNumberOfConstraints[]:=Length[MB$Constraints];
getConstraints[]:= getConstraint[Range[getNumberOfConstraints[]]];


deleteConstraint[n_?IntegerQ]:= Module[{x,meta},
If[n> Length[MB$Constraints],
Print["Error: "//boldRed, "deleteConstraint: "//boldBlack, " requested constraint number: "//boldBlack, n//boldBlue," exceeds number of constraints: "//boldBlack, Length[MB$Constraints]//boldBlue];
Return[False];
];
If[n<= 0, 
Print["Error: "//boldRed, "deleteConstraint: "//boldBlack, "argument must be a postive integer. Requested value: "//boldBlack, n//boldBlue];
Return[False];
]; 
x=getConstraint[n];
MB$Constraints= Drop[MB$Constraints,{n}]; 

meta = getSBMLfield["metaid",x]; 
removeMetaID[meta, "constraint"]; 

Return[True];
];
removeConstraint[x___]:=Module[{flag},
flag = deleteConstraint[x];
If[flag, 
If[MB$Echo,Print["Constraint "//boldGreen,x//boldBlue," removed."//boldGreen]],
Print["Error: "//boldRed,"Requested Constraint "//boldBlack,x//boldBlue," could not be removed."//boldBlack]];
];


addConstraint[XMLElement[x___]]:=Module[
{r, meta,n, math},

If[ToExpression[MB$LevelVersion]<2.2, 
Print["Error: "//boldRed, "addConstraint: Constraint is not permitted in SBML level.version "//boldBlack, MB$LevelVersion//boldBlue]
];

r =XMLElement[x]; 
checkConstraintExpression[r];
MB$Constraints=Append[MB$Constraints,r];

math = Cases[r, XMLElement["math",___], Infinity]; 
math=Flatten[math];
If[Length[math]<1, Print["Error: "//boldRed, "addConstraint: no Math"//boldBlack, 
XMLHighlightForm[r,Purple,"constraint"]
]
]; 

math=MathMLToInfix[XMLOut[math[[1]]]]; 
math=stringer[math];

n="constraint["<>math<>"]";
meta = getSBMLfield["metaid", r]; 
If[meta!= "", addMetaID[meta,n, "constraint", True]]; 


If[MB$Echo, Print["Constraint "//boldGreen, math//boldBlue, " added."//boldGreen]];
Return[];
];

addConstraint[opt___?OptionQ]:=Module[{r,n},
r =constraintToSymbolicSBML[opt]; 
n=addConstraint[r]; 
Return[n];
];

addConstraint[x___]:= Print["Error: "//boldRed, "The argument to addConstraint should be either an option list or an XMLElement[...] object"//boldBlack];


replaceConstraint[i_?IntegerQ, XMLElement["constraint",x___]]:= Module[{n,r},
n=Length[MB$Constraints];
r=XMLElement["constraint",x];
If[n>0 \[And] i>0 \[And] i<=n, 
MB$Constraints=ReplacePart[MB$Constraints, r,i];
If[MB$Echo, Print["Constraint ",i, " replaced."]];
Return[];
]; 
Print["Error: "//boldRed," replaceConstraint: "//boldBlack," unable to replace Constraint "//boldBlack,i//boldBlue];
Return[];
]; 

replaceConstraint[x___]:= Print["Error: "//boldRed,"replaceConstraint: "//boldBlack, "Invalid arguments. "//boldBlack, {x}//boldBlue, " \nCorrect format is:"//boldBlack,"replaceConstraint["//boldBlack," Integer,"//boldBlack, " XMLElement[\"constraint\",...]"//boldBlack," ]"//boldBlack];


 modifyConstraint[i_?IntegerQ, opt___?OptionQ]:= Module[{n,x,y,ann, notes, dbg=False, oldmat},

x={getConstraint[i]}//Flatten;
If[dbg,Print["modifyConstraint: x:", x]];

If[Length[x]>0, 
x=First[x];
y=globalize/@extractAndUpdateXMLOptions[x,opt];


ann = updateAnnotations[x, opt];
notes = updateNotes[x,opt]; 

y = Prepend[y, globalize["annotation"-> ann]]; 
y = Prepend[y,globalize["notes"->notes]]; 
If[dbg, Print["modifyConstraint: y:",y]];


xmlsub=extractXMLSubElements[x];
If[dbg, Print["modifyInitialAssignment: xmlsub: ", xmlsub]]; 


oldmath = Cases[xmlsub, XMLElement["math",___]]; 
If[Length[oldmath]>1, Print["Error: "//boldRed,
"modifyConstraint: previous value of constraint for "//boldblack,
n//boldBlue, " has multiple math fields. Only the first will be retrieved. "//boldBlack
]];
If[Length[oldmath]<1, 
Print["Error: "//boldRed,
"modifyConstraint: previous value of constraint for "//boldblack,
n//boldBlue, " has no math field.  "//boldBlack
];
,
While[ListQ[oldmath] \[And] Length[oldmath]>0, oldmath=First[oldmath]];
If[dbg, Print["modifyConstraint: oldmath: ", oldmath]]; 
oldmath = MathMLToInfix[XMLOut[oldmath]];
If[dbg, Print["modifyConstraint: oldmath: ", oldmath]]; 
y = Append[y, Global`math-> oldmath]; 
]; 

deleteConstraint[i];
addConstraint@@y;
,
addConstraint[opt]; 
];
Return[]; 
];



checkConstraintExpression[r_, opt___?OptionQ]:=Module[{dbg=False,
symbolsReferenced,math,options,subXML, XML2Symbol,knownSymbols,
unknownSymbols,variable,ruleType,hf, csymbols, mycsymbol, mathexpression},

XML2Symbol["ci",{},{x_}]:= x;
XML2Symbol[x___]:= {};

options=extractXMLOptions[r];
subXML=extractXMLSubElements[r];


math=Cases[subXML, XMLElement["math",___],1];
If[Length[math]<1,
Return[];
,
If[Length[math]>1,
Print["Error: "//boldRed, "Multiple math objects in constraint:\n"//boldBlack,
Sequence@@XMLHighlightForm[r,Purple,"math"]
];
];
While[ListQ[math],math=First[math]];
]; 

symbolsReferenced=Cases[math,XMLElement["ci",___],Infinity];
symbolsReferenced=symbolsReferenced/.{XMLElement-> XML2Symbol};
symbolsReferenced=Union[symbolsReferenced]; 

csymbols = Cases[math, XMLElement["csymbol",___],Infinity];
If[Length[csymbols]>0,
mycsymbol["csymbol",{___},x_]:= x;
mycsymbol[x___]:= XMLElement[x];
csymbols=Flatten[(csymbols/.{XMLElement-> mycsymbol})/.{XMLElement-> List}];
csymbols=Complement[csymbols,{"ci"}];
];


knownSymbols=Join[First/@$SBML$IDTable, csymbols];
unknownSymbols=Complement[symbolsReferenced,knownSymbols];

mathexpression=Cases[subXML, XMLElement["math",___],1];
mathexpression=First[mathexpression];
mathexpression=XMLOut[mathexpression];

hf[var_]:= XMLHighlightForm[#,Purple,"<ci>"<>stringer[var]<>"</ci>"]&@@ Cases[subXML, XMLElement["math",___],1];


Print["Error: "//boldRed,"addConstraint: Unknown symbol "//boldBlack,#//boldBlue," is referenced in the constraint "//boldBlack,
MathMLToInfix[mathexpression]//boldBlue,"\n",
Sequence@@hf[#]

]&/@unknownSymbols;

checkFunctionCalls[math,"constraint", "(addConstraint)"];

Return[];
];


getRule[n_?IntegerQ]:= Module[{m},
m=getNumberOfRules[];
If[n>m \[Or] n<1, 
Print["Error: "//boldRed,"getRule:  Rule: "//boldBlack,n//boldBlue," does not exist. There are "//boldBlack,m//boldBlue," rule definitions."//boldBlack];Return[{}];];
Return[MB$Rules[[n]]//Last];
]; 
getRuleNumber[id_?SIDQ]:=Module[{m,n},
m=Map[First,MB$Rules];
n=Position[m, stringer[id]];
If[Length[n]<1,Return[0]]; 
While[ListQ[n], n=First[n]];
Return[n];
]; 

getRule[id_?SIDQ]:=Module[{m,n},
n=getRuleNumber[id];
If[n>0, 
m=Last[MB$Rules[[n]]];
Return[m];
];
Return[{}];
]; 

getRule[x_?ListQ]:= getRule/@Flatten[x];
getRule[x___]:= Module[{},
Print["Error: "//boldRed,"getRule: Correct format is getRule[metaid],  getRule[Integer],  or getRule[{x1,x2,...}], where x1,x2,... are integers."//boldBlack];
Return[{}];
];
getRules[]:= getRule[Range[Length[MB$Rules]]];
getNumberOfRules[]:= Length[MB$Rules];


ruleStringQ["assignmentRule"]=True;
ruleStringQ["rateRule"]=True;
ruleStringQ["algebraicRule"]=True;
ruleStringQ["constraintRule"]=True;
ruleStringQ["connectionRule"]=True;
ruleStringQ[x___]:= False;

replaceRule[i_?IntegerQ, XMLElement[u_?ruleStringQ,x___]]:= Module[{n,j},
n=Length[MB$Rules];
If[n>0 \[And] i>0 \[And] i<=n, 

j=getSBMLfield["metaid",XMLElement[u,x]]; 
If[j=="", j=MB$Rules[[i,1]]];

MB$Rules=ReplacePart[MB$Rules,j-> XMLElement[u,x],i];
If[MB$Echo, Print["rule ",i, " replaced."]];
Return[];
]; 
Print["Error: replaceRule: "//boldOrange," unable to replace rule "//boldBlack,i//boldRed];
Return[];
]; 

replaceRule[id_?SIDQ, XMLElement[r_?ruleStringQ,x___]]:= Module[{n},
n=getRuleNumber[id];
If[n>0, 
replaceRule[n, XMLElement[r,x]]; 
Return[];
]; 
Print["Error: replaceRule: "//boldOrange," unable to replace rule "//boldBlack,id//boldRed];
Return[];
]; 

replaceRule[x___]:= Print["Error: "//boldOrange,"replaceRule: "//boldRed, "Invalid arguments. Correct format is:"//boldBlack,"replaceRule["//boldBlack," Integer|SID "//boldBlack,","//boldBlack, " XMLElement[r,...]"//boldBlack," ] where r=\"assignmentRule\",\"rateRule\",\"algebraicRule\",\"constraintRule\"(experimental:L2V2draft1), \"connectionRule\"(experimental:L3,arrays),\"initialAssignmentRule\"(experimental:L3,arrays)"//boldBlack];


 ruleToSBML[{x__?ListQ}]:=Module[{r}, 
r =Flatten[ ruleToSymbolicSBML/@{x}];
r = XMLElement["listOfRules",{},r]; 
r=ExportXMLString[r];
r =sunderscore[r];
Return[r];
];


ruleToSBML[opt___?OptionQ]:= Module[{r},
r=ruleToSymbolicSBML[opt]; 
r=ExportXMLString[r];
r =sunderscore[r];
Return[r];
];



 deleteRule[opt___?OptionQ]:= Module[{n,c,p, number,opts, dbg=False},
opts = Flatten[{opt}]; 
If[dbg, Print["deleteRule: opts(1):"//boldRed, opts//boldBlue]]; 

opts=checkOptions[deleteRule, opts, { "metaid"}];
If[dbg, Print["deleteRule: opts(2):"//boldRed, opts//boldBlue]]; 

n =( Global`metaid/.{opt}/.{metaid-> ""})//stringer;
If[n=="",  Return[False];]; 

number = getRuleNumber[n];
If[number>0, deleteRule[number] ];

Return[True];

]; 


deleteRule[x_?!IntegerQ[#]&, opt__?OptionQ]:= Block[{dbg=False},
If[dbg, Print["deleteRule[x, opt]: x:"//boldRed, x//boldBlue, " {opt}:"//boldRed, {opt}//boldBlue]]; 
 
deleteRule[Global`metaid-> x,opt]
];

deleteRule[n_?IntegerQ]:= Module[{p, meta, dbg=False},

If[dbg, Print["deleteRule:n:"//boldRed, n//boldBlue]]; 

If[n>0 \[And] n<= getNumberOfRules[], 


p=getRule[n];
meta=getSBMLfield["metaid",p];
removeMetaID[meta,"rule"];  


MB$Rules = Drop[MB$Rules, {n}]; 
Return[True];
];
Return[False];
]; 

removeRule[x___]:=Module[{flag},
flag = deleteRule[x];
If[flag, 
If[MB$Echo,Print["Rule "//boldGreen,MB$Currentid//boldBlue," removed."//boldGreen]],
Print["Warning: "//boldOrange,"Requested Rule "//boldBlack,MB$Currentid//boldRed," cannot be removed."//boldBlack]];
];



addRule[XMLElement[x___]]:=Module[{r,n, type, var,sp,par, a, b, c, chk,ichk,ertype, ermetaid,rhsrule,lhsrule,rhsvars,ruleContent, ruleType, functions,indices, debug=False, connection,ijk,comp, definedVariables, ruleexpr, csymbols, dbg=False},

If[dbg, Print["*************\naddRule: XMLElement "//boldRed]]; 
r = XMLElement[x]; 
checkRuleExpression[r]; 

If[dbg, Print["addRule: XMLElement: r: "//boldRed,r//boldBlue]]; 

ruleType[XMLElement[u_,___]]:= u; 

type=First[{x}]; 
type=ruleType[XMLElement[x]];
If[debug, Print["addRule: rule type: "//boldRed, type]//boldBlue]; 

If[type=="annotation",
ruleContent=Cases[XMLElement[x], XMLElement[___],2];
type = ruleType/@ruleContent;
If[Length[type]<1, 
Print["Error: Unable to decode rule within annotation: "//boldOrange, XMLElement[x]//boldBlue];
Abort[];
];
If[Length[type]>1,Print["Warning: Too many XMLElements within the annotation - only the first one is used: "//boldOrange, XMLElement[x]//boldBlue]
];
type=First[type];
If[debug, Print["addrule: rule type: "//boldRed, type//boldBlue]]; 

];

sp = First/@MB$Species;
par = First/@MB$Parameters;
comp=First/@MB$Compartments; (* added 2.5.2 *) 
definedVariables = Union[sp, par, comp];

connection= getSBMLfield["connection",r]; 




If[debug, Print["addRule:{type,sp,par,comp, definedVariables}:"//boldRed, {type,sp,par,comp,definedVariables}//boldBlue]];


n = getSBMLfield["metaid",r]; 
If[n=="",

n="rule"<>ToString[MB$rulecounter++];
{a, b, c} = {x}; 
b = Append[b, "metaid"-> n]; 
r = XMLElement[a, b, c]; 
n = getSBMLfield["metaid",r];
];
If[debug, Print["addRule:n:"//boldRed, n//boldBlue]];



var =getSBMLfield["variable",r]; 
If[debug, Print["addRule:var:"//boldRed, var//boldBlue]];

If[type=="assignmentRule", 
Block[{iavars},
iavars = First/@MB$InitialAssignments;
If [MemberQ[iavars, var], Print["Error: "//boldRed, "addRule: cannot have an "//boldBlack,"assignmentRule"//boldBlue, " and an "//boldBlack, "initialAssignment"//boldBlue, " for the same variable: "//boldBlack, var//boldBlue]];
];

];


If[var!= "" \[And] (type=="assignmentRule" \[Or] type== "rateRule"),
(* make sure that no rule has been previously defined for this variable *)
If[debug, Print["addRule:type==assignment or type==rateRule"//boldRed]];

chk = MathSBML`Private`getXMLElement/@(Last/@MB$Rules); 
(*allow earlier initialAssignmentRule*)
chk = Select[chk, First[#]!= "initialAssignmentRule"&]; 

ichk=Position[chk,var];
If[Length[ichk]>0,
(* ichk has form {{i,j,k,..},{i,j,k,..},...}; if this error correction is implemented correctly it will actually only be {{i,j,k,...}} for a single prior occurance at most: so convert to first index of first occurrence  *) 
ichk = First/@ichk;
ichk = First[ichk];

(* create a rule ruletype->{options} for the earlier reference *) 

chk = chk[[ichk]];
(* ertype, ermetaid*)
ertype = chk[[1]]; 
ermetaid = "metaid"/.Last[chk];

If[!(ifArrays[]\[And]stringer[connection]!= ""),
Print["Error: "//boldRed,"addRule: "//boldBlack,
type//boldBlue," for variable "//boldBlack, var//boldBlue, " is not allowed because a "//boldBlack,
ertype//boldBlue,
" has already been defined for this variable: \"No more than one assignment or rate rule can be defined for a given identifier.\""//boldBlack
];
Return[{}];
];
];


];
If[var!= "" \[And] type=="assignmentRule",

(* make sure that the variable is not referenced in an earlier rule *)
If[debug, Print["addRule:type==assignmentRule"//boldRed]];

chk=Cases[MB$Rules, XMLElement["ci",{},{var}], Infinity]; 
If[Length[chk]>0,
Print["Error: "//boldRed, " A rule with "//boldBlack, var//boldBlue," on its right hand side has been previously defined and therefore this rule can not be added. This is because a rule is not allowed to refer to a variable for which there is a subsequent assignment rule, and this would be the subsequent assignment rule."//boldBlack];
Return[{}]; 
]; 

(* make sure the rule does not self-refer *)
chk=Cases[XMLElement[x], XMLElement["ci",{},{var}], Infinity]; 
If[Length[chk]>0,
Print["Error: "//boldRed,type//boldBlue,  " refers to "//boldBlack, var//boldBlue," on both sides of the equation.\n"//boldBlack,

Sequence@@XMLHighlightForm[XMLElement[x],Purple,stringer[var]]

];
Return[{}]; 
]; 


]; 

(* if connection field check for previous connection def *)

If[stringer[connection]!= "", 
If[!ifArrays[],
Print["Error: "//boldOrange, " connection filed "//boldBlack, stringer[connection]//boldRed," not allowed because Arrays are off"];
,
chk = MathSBML`Private`getXMLElement/@(Last/@MB$Rules);
chk = Select[chk,( First[#]=="connectionRule")&];
chk = Last/@chk; 
chk = (("metaid"/.#)&)/@chk;
If[!MemberQ[chk,stringer[connection]], 
Print["Warning: "//boldOrange,
"Specified connectionRule: "//boldBlack,
connection//boldRed," is undefined."//boldBlack]
];
];
]; 

(* make sure the variable is previously defined either as a species or a parameter *) 
(* changed to "definedVariables" 2.5.2 *)
(* error message added 2.5.25 *)

If[var!= "" \[And] (type=="assignmentRule" \[Or] type== "rateRule"),
If[!MemberQ[definedVariables,var], 
Print["Error: "//boldRed, " addRule: "//boldBlack, type//boldBlue, " variable=\""<>var<>"\""//boldBlue, " not previously defined. Offending SBML:\n" //boldBlack,
Sequence@@XMLHighlightForm[r,Purple,"variable=\""<>stringer[var]<>"\""]
]; 
addParameter[var,Global`constant-> "false"];

];
]; 


If[debug, Print["addRule:thyme to save the Rule"//boldRed]];

Switch[type,
"assignmentRule", AppendTo[MB$AssignmentRuleVariables, stringer[var]],
"rateRule", AppendTo[MB$RateRuleVariables, stringer[var]]
]; 


(* SAVE THE RULE *) 


Block[{num, flag, debg=False},
num=getRuleNumber[n]; 
If[debg, Print["addRule: num:"//boldRed,num//boldBlue]]; 

If[flag=deleteRule[num] , If[MB$Echo,Print["Previous occurance of rule "//boldGreen,num//boldBlue," removed."//boldGreen]]
];

If[debg, Print["addRule: flag:"//boldRed, flag//boldBlue]]; 
]; 

MB$Rules=Append[MB$Rules,n->r];

(* add check for indices 2.3.26 *)
indices =Cases[r, XMLElement["index",___],Infinity]//Flatten;
If[debug, Print["addRule: indices (1): "//boldRed, indices//boldBlue]]; 
indices =getSBMLfield["id",#]&/@indices; 
If[debug, Print["addRule: indices: (2)"//boldRed, indices//boldBlue]]; 


(* Check symbols on Right hand side *) 
(* extract the xml for the rule *)
rhsrule=r;
(* get the sub-XML elements *)
If[debug, Print["addRule:rhsrule(-2):"//boldRed, rhsrule//boldBlue]];rhsrule=extractXMLSubElements[rhsrule];
(* extract the mathml - there may also be annotations, notes here *)
If[debug, Print["addRule:rhsrule(-1):"//boldRed, rhsrule//boldBlue]];rhsrule=Cases[rhsrule, XMLElement["math",___],Infinity];
If[debug, Print["addRule:rhsrule(0):"//boldRed, rhsrule//boldBlue]];While[ListQ[rhsrule] \[And] Length[rhsrule]>0, rhsrule=First[rhsrule]]; 

If[rhsrule=={}, rhsrule=Xpression2SymbolicMathML[{}]];

If[debug, Print["addRule:rhsrule(1):"//boldRed, rhsrule//boldBlue]];
csymbols = Cases[rhsrule, XMLElement["csymbol",___], Infinity]; 
Block[{XML2C}, 
XML2C["csymbol", {u__}, {y_}]:= y; 
XML2C[u___]:= {}; 
csymbols = Flatten[csymbols/.{XMLElement-> XML2C}]; 
]; 

If[debug, Print["addRule: csymbols in rule: ", csymbols]]; 
If[debug, Print["addRule:rhsrule(1.5):"//boldRed, rhsrule//boldBlue]];


rhsrule =InputForm[ SymbolicSBMLMathMLToExpression[rhsrule]];
If[debug, Print["addRule:rhsrule(2):"//boldRed, rhsrule//boldBlue]];

rhsvars=getSymbols[rhsrule];
If[debug, Print["addRule:missing vars(rhsvars)(1):"//boldRed, rhsvars//boldBlue]];

rhsvars=ToString/@InputForm/@rhsvars;
functions = stringer/@(First/@MB$Functions);
(* determine and add the undefined variables as parameters; add functions 5-19-04 *)
rhsvars = Complement[rhsvars,definedVariables, (* sp,par,*) indices, functions, $SubsetMathML, $ArrayMathML, csymbols];




If[debug, Print["addRule:missing vars(rhsvars)(2):"//boldRed, rhsvars//boldBlue]];
addParameter[#,Global`constant-> "false"]&/@rhsvars;
 

(* get info for "pretty" echo message *)

rhsrule =ToString[rhsrule];
lhsrule=Switch[type,
"assignmentRule",stringer[var]<>"="<>rhsrule,
"rateRule",stringer[var]<>"'[t]"<>"="<>rhsrule,
"algebraicRule","0"<>"="<>rhsrule,

"initialAssignmentRule",
ijk = Cases[r,XMLElement["index",___],Infinity];
ijk =getSBMLfield["id",#]&/@ijk; 
ijk = list2CommaSeparatedString[ijk];
If[StringLength[ijk]>0, ijk = "["<>ijk<>"]",ijk=""]; 
stringer[var]<>ijk<>"="<>rhsrule,

"constraintRule",rhsrule,
"connectionRule", rhsrule,
_, 
Print[">>> Program Error (addRule): notify developer: type= "//boldRed,type//boldBlue] ;
"ERROR"
];
If[MB$Echo,
 Print[type//boldGreen," ",n//boldBlue," added: "//boldGreen, lhsrule//boldBlue];
]; 

If[n!= "", 
ruleexpr=stringer[type]<>"["<>lhsrule<>"]";
addMetaID[n,ruleexpr, "rule", True];
]; 



If[(type== "rateRule" \[Or] type== "assignmentRule") \[And] MemberQ[MB$ReactionVariables, stringer[var]], 
If[!MemberQ[MB$BoundaryConditionSpecies, var], 
Print["Error: "//boldRed, "addRule: "//boldBlack, type//boldBlue, " for "//boldBlack, var//boldBlue," - the variable has been previously referenced in a reaction, even though the species is not a boundaryCondition;\n"//boldBlack, 
Sequence@@XMLHighlightForm[r, Purple,"variable="<>quote[var]]
];
]; 
]; 
Return[n];
];




addRule[opt___?OptionQ]:=Module[{r,n,c,p,echo, type, var,sp,par, metaid, dbg=False},
(* MB$Echo = Global`echo/.{opt}/.{Global`echo-> True}; *) 

If[dbg, Print["addRule:{opt}:"//boldRed, {opt}//boldBlue]]; 

metaid = stringer[Global`id/.{opt}/.{Global`id-> ""}]; 
If[metaid=="",
metaid = stringer[Global`metaid/.{opt}/.{Global`metaid-> ""}]; 
]; 
If[metaid=="",
n="rule"<>ToString[MB$rulecounter++];,
n=metaid;
];
r =ruleToSymbolicSBML[Global`id-> n, opt]; 
n = addRule[r];
Return[n];
];

addRule[id_, opt___?OptionQ]:= addRule[Global`id-> id, opt];


 modifyRule[i_?IntegerQ, opt___?OptionQ]:= Module[{r,dbg=False, n,x,y,ruletype,infix, getFirst, type,math,p,ann, notes},

ruletype[XMLElement[a_,___]]:= a;
ruletype[a___]:= "ERROR";
infix[XMLElement["math",a___]]:= SymbolicSBMLMathMLToExpression[XMLElement["math",a]];
infix[a___]:= 1; 
getFirst[a_]:= Module[{b}, 
b=a; 
While [ListQ[b] \[And] Length[b]>0, b = First[b]];
Return[b]; 
]; 

r= getRule[i]; 
If[r=={}, Return[$Failed]]; 
n=getSBMLfield["metaid", r]; 

If[dbg, 
Print["modifyRule: r: ", r];
Print["modifyRule: n: ", n];
]; 

MB$Currentid=n;


type = ruletype[r]; 
y=expressionate[globalize/@extractAndUpdateXMLOptions[r,opt]];
y = Prepend[y,Global`type-> type]; 

If[dbg, Print["modifyRule: y: ", y]]; 

math = Cases[r, XMLElement["math",___],Infinity]//getFirst//infix; 
y = Append[y, Global`math-> math]; 
If[dbg, Print["modifyRule: y: ", y]]; 



ann = updateAnnotations[r, opt];
notes = updateNotes[r, opt]; 

y = Prepend[y, globalize["annotation"-> ann]]; 
y = Prepend[y, globalize["notes"-> notes]]; 

If[deleteRule[i] \[And] MB$Echo,
Print["Previous occurance of rule "//boldGreen, i//boldBlue, " removed."//boldGreen]
]; 


addRule@@y;

If[MB$Echo, Print["Rule "//boldGreen,i//boldBlue," modified."//boldGreen]];



Return[n]; 
];

(* modifyRule[id_, opt___?OptionQ]:= modifyRule[Global`id-> id, opt]; *)
modifyRule[x___]:=Print["Error: "//boldRed, "modifyRule: as of version 2.6.0, the correct format is: "//boldBlack, "modifyRule[integer, options]"//boldBlue, "\nTo find the integer corresponding to a particular metaid value use: "//boldBlack, "getRuleNumber[metaid]"//boldBlue];


checkRuleExpression[r_, opt___?OptionQ]:=Module[{dbg=False,
symbolsReferenced,math,ruleOptions,subXML, XML2Symbol,knownSymbols,
unknownSymbols,variable,ruleType,hf, csymbols, mycsymbol},

XML2Symbol["ci",{},{x_}]:= x;
XML2Symbol[x___]:= {};

ruleType[XMLElement[type_,x___]]:= type;
ruleType[x___]:="??--Unknown rule type--??";

debugPrint[dbg, "checkRuleExpression: r",r];
ruleOptions=extractXMLOptions[r];
subXML=extractXMLSubElements[r];
debugPrint[dbg, "checkRuleExpression: ruleOptions",ruleOptions];
debugPrint[dbg, "checkRuleExpression: subXML",subXML];

variable="variable"/.ruleOptions/.{"variable"-> "??--UNKNOWN Variable--??"};

math=Cases[subXML, XMLElement["math",___],1];
If[Length[math]<1,
debugPrint[dbg,"checkRuleExpression ", "no Math"];
Return[];
,
While[ListQ[math],math=First[math]];
]; 
debugPrint[dbg, "checkRuleExpression: math", math];

symbolsReferenced=Cases[math,XMLElement["ci",___],Infinity];
symbolsReferenced=symbolsReferenced/.{XMLElement-> XML2Symbol};
symbolsReferenced=Union[symbolsReferenced]; 
debugPrint[dbg, "checkRuleExpression: symbolsReferenced", symbolsReferenced];

csymbols = Cases[math, XMLElement["csymbol",___],Infinity];
debugPrint[dbg, "checkRuleExpression: csymbols", csymbols];
If[Length[csymbols]>0,
mycsymbol["csymbol",{___},x_]:= x;
mycsymbol[x___]:= XMLElement[x];
csymbols=Flatten[(csymbols/.{XMLElement-> mycsymbol})/.{XMLElement-> List}];
csymbols=Complement[csymbols,{"ci"}];
debugPrint[dbg, "checkRuleExpression: csymbols", csymbols];
];


knownSymbols=Join[First/@$SBML$IDTable, csymbols];
debugPrint[dbg, "checkRuleExpression: knownSymbols", knownSymbols];unknownSymbols=Complement[symbolsReferenced,knownSymbols];

hf[var_]:= XMLHighlightForm[#,Purple,"<ci>"<>stringer[var]<>"</ci>"]&@@ Cases[subXML, XMLElement["math",___],1];


Print["Error: "//boldRed,"addRule: Unknown symbol "//boldBlack,#//boldBlue," is referenced in the MathML for rule (type = "//boldBlack ,ruleType[r]//boldBlue,") for "//boldBlack,variable//boldBlue,"; "//boldBlack, "\nMathML expression:\n"//boldBlack,
Sequence@@hf[#]

]&/@unknownSymbols;

checkFunctionCalls[math,ruleType[r], variable];

Return[];
];


checkFunctionCalls[symXML_, type_, id_, opt___?OptionQ]:= Module[{dbg=False, functionRefs,functions, fref, badFunctionCalls,correctType,r, knownFunctions, usedFunctionIDs, positions,pup,pup4,fcomp,functionsCalledAsNonFunctions,errMsg, getBadCall, badCallXML,hf, countArguments, argumentsUsed, checkArguments, knownCsymbols},

knownCsymbols=csymbolsused/.{opt}/.{csymbolsused-> {}}; 
If[dbg, Print["--->checkFunctionCalls: knownCsymbols: ", knownCsymbols]]; 

correctType[x_]:= Module[{c}, 
c=Cases[$SBML$IDTable,{x,_}];
If[Length[c]<1, Return["undefined"]]; 
c=c[[1,2]];
Return[c];
];

(* check for non-functions that are used as functions *)

functions=Cases[symXML, XMLElement["apply",{}, {XMLElement["ci",___ ],___}], Infinity];
fref[XMLElement["apply",{}, {XMLElement["ci",_, u_ ],___}]]:=u;
fref[u___]:= {};
functionRefs=Flatten[fref/@functions];
functionRefs = Complement[functionRefs, {"AngleBracket"}]; 

knownFunctions=First/@Select[$SBML$IDTable, Last[#]=="function"&];
badFunctionCalls=Complement[functionRefs,knownFunctions];
badFunctionCalls=Complement[badFunctionCalls, {"AngleBracket"}]; 
badFunctionCalls=Complement[badFunctionCalls, knownCsymbols]; 

getBadCall[f_]:= Cases[functions, XMLElement["apply",{},{XMLElement["ci",{},{f}],___}]];

If[dbg,
Print["debug: checkFunctionCalls: symXML:",symXML];
Print["debug: checkFunctionCalls: functions:",functions];
Print["debug: checkFunctionCalls: functionRefs:", functionRefs];
Print["debug: checkFunctionCalls: badFunctionCalls:", badFunctionCalls];
Print["debug: checkFunctionCalls: knownFunctions:",knownFunctions];
]; 

hf[f_]:= Sequence@@Flatten[{XMLHighlightForm[#,Purple,"<ci>"<>stringer[f]<>"</ci>"]&/@getBadCall[f]}];

MapThread[Print["Error: "//boldRed, stringer[type]<>":"<>stringer[id]<>":"<>#2<>":"<>#1//boldBlue," used as a function.\n"//boldBlack,
hf[#1]
]&, {badFunctionCalls, correctType/@badFunctionCalls}]; 

(* 
 check for functions that are used as non-functions 
*)

usedFunctionIDs = Cases[symXML,XMLElement["ci",_,{#}], Infinity]&/@knownFunctions;
usedFunctionIDs=Cases[symXML,#,Infinity]&/@knownFunctions;
If[dbg, Print["debug: checkFunctionCalls: usedFunctionIDs:",usedFunctionIDs];]; 
positions={#, Position[symXML,#]}&/@Union[Flatten[usedFunctionIDs]];
If[dbg, Print["debug: checkFunctionCalls: positions:",positions]];

pup[{f_,g_}]:= Module[{},
If[Length[g]<1, Return[{}]];
Return[{f, symXML[[Sequence@@Drop[#,-4]]]&/@g}];
];
pup4=pup/@positions;
If[dbg, Print["debug: checkFunctionCalls: pup4:",pup4]]; 

fcomp[{f_, g_}]:= Module[{gkeep,gdrop},
If[Length[g]<1, Return[{}]];
gdrop = Cases[g, XMLElement["apply",{},{XMLElement["ci",{},{f}],___}],Infinity];
gkeep=Complement[g,gdrop];
Return[{f,gkeep}]; 
]; 

functionsCalledAsNonFunctions=fcomp/@pup4;
If[dbg, Print["debug: checkFunctionCalls: functionsCalledAsNonFunctions:", functionsCalledAsNonFunctions]]; 

errMsg[{f_,g_}]:= Module[{},
If[Length[g]<1, Return[]];
Print["Error: "//boldRed,
stringer[type]<>":"<>stringer[id]<>": function: "<>stringer[f]//boldBlue,
" referenced as a variable:\n"//boldBlack,
Sequence@@XMLHighlightForm[#,Purple,"<ci>"<>stringer[f]<>"</ci>"]
]&/@g
];

errMsg/@functionsCalledAsNonFunctions;

(* check for functions that are called with the wrong number of arguments *)

countArguments[XMLElement["apply",{},{XMLElement["ci",{},{f_}], args___}]]:= Module[{},
{f, Length[{args}]}
];
countArguments[___]:= {};

argumentsUsed=countArguments/@functions;
If[dbg, Print["debug: checkFunctionCalls: argumentsUsed:", argumentsUsed]];

checkArguments[{f_, num_}, fdef_]:= Module[{numExpected},

If[f=="AngleBracket", Return[]]; 
If[MemberQ[knownCsymbols, f], Return[]]; 

numExpected=Cases[$SBML$function$bvars, {f, _}]; 
If[Length[numExpected]<1, numExpected=0, numExpected=numExpected[[1,2]]];
If[num!= numExpected, 
Print["Error: "//boldRed, stringer[type]<>":"<>stringer[id]<>": function: "<>stringer[f]//boldBlue,
" called with "//boldBlack, num//boldBlue, " arguments (bvars), but "//boldBlack, numExpected//boldBlue, " arguments were expected:\n"//boldBlack, 
XMLPrintForm[fdef,Purple]
];
];

];

If[dbg, Print["debug: checkFunctionCalls: functions: ", functions]]; 

MapThread[checkArguments, {argumentsUsed, functions}];
];


getEvent[n_?IntegerQ]:= Module[{m},
m=Length[MB$Events];
If[n>m \[Or] n<1, Print["Error: getEvent: "//boldOrange," Event: "//boldBlack,n//boldRed," does not exist. There are "//boldBlack,m//boldRed," events."//boldBlack];Return[{}];];
Return[MB$Events[[n]]//Last];
]; 
getEventNumber[id_?SIDQ]:=Module[{m,n},
m = First/@MB$Events;
n=Position[m, stringer[id]];
If[Length[n]<1, Print["Error: getEventNumber: "//boldOrange,"Event: "//boldBlack,id//boldRed," does not exist. Valid events are "//boldBlack, m//boldRed];Return[0];]; 
While[ListQ[n], n=First[n]];
Return[n];
];
getEvent[id_?SIDQ]:=Module[{m,n},
n=getEventNumber[id];
If[n>0,
m=Last[MB$Events[[n]]];
Return[m]
];
Return[{}]
]; 
getEvent[x_?ListQ]:= getEvent/@Flatten[x];
getNumberOfEvents[]:= Length[MB$Events];
getEvents[]:= getEvent[Range[getNumberOfEvents[]]]; 

getEvent[x___]:= Module[{},
Print["Error: getEvent: "//boldOrange, "Correct format is: "//boldBlack,"getEvent[id]"//boldRed, " where id is an integer or an SID, "//boldBlack,"getEvent[Integer]"//boldRed, " or "//boldBlack,"getEvent[{x1,x2,...}]"//boldRed," where x1,x2,... are integers or SIDs."//boldBlack];
Return[{}];
];




replaceEvent[i_?IntegerQ, XMLElement["event",x___]]:= Module[{n,j},
n=Length[MB$Events];
If[n>0 \[And] i>0 \[And] i<=n, 

j=getSBMLfield["id",XMLElement["event",x]]; 
If[j=="", j=MB$Events[[i,1]]];

MB$Events=ReplacePart[MB$Events,j-> XMLElement["event",x],i];
If[MB$Echo, Print["event ",i, " replaced."]];
Return[];
]; 
Print["Error: replaceEvent: "//boldOrange," unable to replace event "//boldBlack,i//boldRed];
Return[];
]; 

replaceEvent[id_?SIDQ, XMLElement["event",x___]]:= Module[{n},
n=getEventNumber[id];
If[n>0, 
replaceEvent[n, XMLElement["event",x]]; 
Return[];
]; 
Print["Error: replaceEvent: "//boldOrange," unable to replace event "//boldBlack,id//boldRed];
Return[];
]; 

replaceEvent[x___]:= Print["Error: "//boldOrange,"replaceEvent: "//boldRed, "Invalid arguments. Correct format is:"//boldBlack,"replaceEvent["//boldBlack," Integer|SID "//boldBlack,","//boldBlack, " XMLElement[\"event\",...]"//boldBlack," ]"//boldBlack];


 eventToSBML[{x__?ListQ}]:=Module[{r}, 
r =Flatten[ eventToSymbolicSBML/@{x}];
r = XMLElement["listOfEvents",{},r]; 
r=ExportXMLString[r];
r=sunderscore[r];
Return[r];
];


eventToSBML[opt___?OptionQ]:= Module[{r},
r=eventToSymbolicSBML[opt]; 
r=ExportXMLString[r];
r=sunderscore[r];
Return[r];
];

eventToSBML[x_, opt___?OptionQ]:= eventToSBML[Global`id-> x, opt];



deleteEvent[opt___?OptionQ]:= Module[{n,c,p},
n =( Global`id/.{opt}/.{id-> ""})//stringer;
If[id=="", 
Print["Error: deleteEvent"//boldOrange," No "//boldBlack,"id"/boldRed," was specified."]]; 
removeID[n,"event"]; 
MB$Currentid=n;
c = Map[First,MB$Events]; 
If[MemberQ[c,n],
p=Position[c,n];
MB$Events= Drop[MB$Events,First[p]]; 
Return[True];
];
Return[False];
];
deleteEvent[x_, opt___?OptionQ]:= deleteEvent[Global`id-> x,opt];
removeEvent[x___]:=Module[{flag},
flag = deleteEvent[x];
If[flag, 
If[MB$Echo,Print["Event "//boldGreen,MB$Currentid//boldBlue," removed."//boldGreen]],
Print["Warning: "//boldOrange,"Requested Event "//boldBlack,MB$Currentid//boldRed," can not be removed."//boldBlack]];
];



addEvent[XMLElement[x___]]:=Module[{r,n, a, b, c,dbg=False,ea,eamath,vars,modelSpecies,modelParameters,modelCompartments,isConstant,constants,constVal,constantParameters,trueVariables, invalidVariables, constantVariables,undefinedVariables,allowedVariables,XML2Symbol,et, etmath, hf,csymbols,mycsymbol,math, meta},

constVal["false"]:= False;
constVal["true"]:= True;
constVal[z_]:= Indeterminate;

XML2Symbol["ci",{},{u_}]:= u;
XML2Symbol[u___]:= {};

r =XMLElement[x];
n=getSBMLfield["id",r];
If[n== "", 
n = "event"<>ToString[MB$eventcounter++];
{a, b, c} = {x};
b = Append[b, "id"-> n];
r = XMLElement[a, b, c];
n  = getSBMLfield["id",r]; 
];

If[deleteEvent[Global`id-> n] ,
If[MB$Echo,Print["Previous occurance of event "//boldGreen,n//boldBlue," removed."//boldGreen]]
];

addID[n,"event",True];
meta = getSBMLfield["metaid", r]; 
If[meta!= "", addMetaID[meta,n, "event", True]]; 

MB$Events=Append[MB$Events,n->r];
(* test to see if valid variable *)
If[dbg,Print["addEvent:"//boldBlack," r "//boldRed,"="//boldBlack,r//boldBlack];];

(* check for any csymbols *)

math=XMLElement[x];
csymbols = Cases[math, XMLElement["csymbol",___],Infinity];
If[Length[csymbols]>0,
mycsymbol["csymbol",{___},xx_]:= xx;
mycsymbol[xx___]:= XMLElement[xx];
csymbols=Flatten[(csymbols/.{XMLElement-> mycsymbol})/.{XMLElement-> List}];
csymbols=Complement[csymbols,{"ci"}];
debugPrint[dbg, "checkRuleExpression: csymbols", csymbols];
];

debugPrint[dbg, "addEvent: csymbols",csymbols];

(* check event trigger *)

et = Cases[r, XMLElement["trigger",___], Infinity]; 
checkFunctionCalls[et,"event-trigger",stringer[n]];
etmath = Cases[et, XMLElement["ci",___], Infinity];
etmath=etmath/.{XMLElement-> XML2Symbol};
invalidVariables=Complement[etmath,Join[First/@$SBML$IDTable,csymbols]];


hf[var_]:= XMLHighlightForm[#,Purple,"<ci>"<>stringer[var]<>"</ci>"]&@@ et;

Print["Error: "//boldRed, "addEvent: undefined variable "//boldBlack,#//boldBlue, " referenced in trigger for event "//boldBlack, n//boldBlue,"\nInvalid trigger = \n"//boldBlack,
Sequence@@hf[#]
]&/@invalidVariables;

(* check event assignments *)

ea = Cases[r,XMLElement["eventAssignment",___], Infinity];
checkFunctionCalls[ea,"event-assignment",stringer[n]];

vars = Map[getSBMLfield["variable",#]&,ea];

Block[{metas, ids},
metas = Map[getSBMLfield["metaid",#]&, ea];
ids = Map[contextify[contextify[#,"eventAssignment"],n]&, vars];
MapThread[If[#1!= "", addMetaID[#1,#2, "eventAssignment", True]]&,{metas,ids}];
];

(* check assignment variable *)
 
modelSpecies=First/@MB$Species;
modelParameters = First/@MB$Parameters;
modelCompartments=First/@MB$Compartments;
allowedVariables=Join[modelSpecies, modelParameters,modelCompartments];
undefinedVariables=Complement[vars,allowedVariables];

hf[var_]:= XMLHighlightForm[#,Purple,"variable=\""<>stringer[var]<>"\""]&@@ Cases[r,XMLElement["listOfEventAssignments",___], Infinity];
Print["Error: "//boldRed," unknown eventAssignment variable: "//boldBlack,
#//boldBlue," in event: "//boldBlack, 
n//boldBlue,"\nInvalid listOfEventAssignments:\n"//boldBlack,
Sequence@@hf[#]
]&/@undefinedVariables;

isConstant[p_]:= constVal[getSBMLfield["constant",Last[p]]];
(* Species default to non-constant, parameters & compartments to constant! *)
constants = Join[
(isConstant/@MB$Species)/.{Indeterminate-> False},(isConstant/@MB$Parameters)/.{Indeterminate-> True},
(isConstant/@MB$Compartments)/.{Indeterminate-> True}];
constants={allowedVariables,constants}//Transpose;
constants=Select[constants,Last[#]&];
constants=First/@constants;
constants=Intersection[vars,constants];

(* check event assignment expression *)
eamath = Cases[ea,XMLElement["ci",___],Infinity]; 
eamath=(eamath/.{XMLElement-> XML2Symbol}); 
invalidVariables=Complement[eamath,Join[First/@$SBML$IDTable,csymbols]];

ea = Cases[r,XMLElement["listOfEventAssignments",___], Infinity];

hf[var_]:= XMLHighlightForm[#,Purple,"variable=\""<>stringer[var]<>"\""]&@@ea;
Print[
"Error: "//boldRed,
"the eventAssignment variable: "//boldBlack,
#//boldBlue," in event "//boldBlack,
n//boldBlue," has constant=\"true\" and may not be assigned a value as a result of an event."//boldBlack, " Invalid listOfEventAssignments:\n"//boldBlack, 
Sequence@@hf[#]
]&/@constants;

hf[var_]:= XMLHighlightForm[#,Purple,"<ci>"<>stringer[var]<>"</ci>"]&@@ Cases[r,XMLElement["listOfEventAssignments",___], Infinity];
Print["Error: "//boldRed, "addEvent: undefined variable "//boldBlack,#//boldBlue, " referenced in eventAssignment for event "//boldBlack, n//boldBlue, " Invalid listOfEventAssignments:\n"//boldBlack, 
Sequence@@hf[#]
]&/@invalidVariables;

If[MB$Echo, Print["Event "//boldGreen,n//boldBlue," added."//boldGreen]];
Return[n];
];

addEvent[opt___?OptionQ]:=Module[{r,n},
(* MB$Echo = Global`echo/.{opt}/.{Global`echo-> True}; *)
r =eventToSymbolicSBML[opt]; 
n = addEvent[r];

Return[n];
];

addEvent[id_, opt___?OptionQ]:= addEvent[Global`id-> id, opt];


 modifyEvent[opt___?OptionQ]:= Module[{n,x,y,trigger,delay, infix, getFirst, getElement,getMath, asg, vars,maths,name,ann, notes,asgann,asgnotes,asgmetids},

infix[XMLElement["math",x___]]:= SymbolicSBMLMathMLToExpression[XMLElement["math",x]];
infix[x___]:= 1; 
getFirst[a_]:= Module[{b}, 
b=a; 
While [ListQ[b] \[And] Length[b]>0, b = First[b]];
Return[b]; 
]; 
getElement[element_, xml_,level_:Infinity]:= Cases[xml, XMLElement[element, ___], level];
getMath[element_, xml_]:=infix[getFirst[getElement["math",getFirst[getElement[element,xml]]]]];

n =( Global`id/.{opt}/.{Global`id-> ""})//stringer;
MB$Currentid=n;
x=retrieveSBMLObject["event",n];

If[ToString[Head[x]]=="XMLElement",
y=globalize/@extractAndUpdateXMLOptions[x,opt];

trigger = getMath["trigger",x]; 
delay = getMath["delay",x]; 
y = Join[y, {Global`trigger-> trigger, Global`delay-> delay}]; 

asg = getElement["listOfEventAssignments", x];
asg = getElement["eventAssignment",asg//getFirst];

asgmetids = Map[getSBMLfield["metaid",#]&,asg];
asgnotes = getNotes/@asg;
asgann=getAnnotations/@asg;

vars = Map[getSBMLfield["variable",#]&, asg];
maths = infix/@getFirst/@Map[Cases[#, XMLElement["math",___],Infinity]&, asg];
asg = MapThread[Rule[#1, #2]&, {vars, maths}]; 

y =Append[y, Global`eventAssignment-> asg]; 
y =Append[y,Global`eventAssignmentMetaids-> asgmetids];
y=Append[y, Global`eventAssignmentNotes-> asgnotes];
y =Append[y, Global`eventAssignmentAnnotations-> asgann];


ann = updateAnnotations[x, opt];
notes = updateNotes[x, opt]; 
y = Prepend[y, globalize["annotation"-> ann]];
y = Prepend[y, globalize["notes"-> notes]];

MB$Modify=True;
n=Apply[addEvent,y];
MB$Modify=False;
,
n=addEvent[opt]; 
];
Return[n]; 
];
modifyEvent[id_, opt___?OptionQ]:= modifyEvent[Global`id-> id, opt];



replaceObject["compartment",x_, y_]:= replaceCompartment[x,y];
replaceObject["event",x_,y_]:= replaceEvent[x,y];
replaceObject["function",x_,y_]:= replaceFunction[x,y];
replaceObject["parameter",x_,y_]:= replaceParameter[x,y];
replaceObject["reaction",x_,y_]:= replaceReaction[x,y];
replaceObject["rule",x_,y_]:= replaceRule[x,y];
replaceObject["species",x_,y_]:= replaceSpecies[x,y];
replaceObject["unit", x_, y_]:= replaceUnit[x,y];
replaceObject["initialAssignment", x_, y_]:= replaceInitialAssignment[x,y];
replaceObject[x___]:= Print["Error: "//boldRed," replaceObject:"//boldBlack," invalid argument: "//boldBlack, {x}//boldBlue]; 


getObject["compartment",x___]:= getCompartment[x];
getObject["compartmentType", x___]:= getCompartmentType[x]; 
getObject["event",x___]:= getEvent[x];
getObject["function",x___]:= getFunction[x];
getObject["parameter",x___]:= getParameter[x];
getObject["reaction",x___]:= getReaction[x];
getObject["rule",x___]:= getRule[x];
getObject["species",x___]:= getSpecies[x];
getObject["speciesType", x___]:= getSpeciesType[x]; 
getObject["unit",x___]:= getUnit[x];
getObject["constraint", x___]:= getConstraint[x]; 
getObject["initialAssignment", x___]:= getInitialAssignment[x]; 

(* getObject[s_?StringQ,x___]:= getObject[ToLowerCase[s],x]; *)

getObject[x?StringQ_, y___]:= Module[{}, Print["Error: "//boldRed, "getObject: "//boldBlack, "unknown object: "//boldBlack, x//boldBlue]; 
Return[$Failed];
]; 

getObject[x__]:= Module[{}, Print["Error: "//boldRed, "getObject: "//boldBlack, "object must be a string, not: "//boldBlack,{ x}[[1]]//boldBlue]; 
Return[$Failed];
]; 




getNumberOfObjects["compartment"]:= getNumberOfCompartments[];
getNumberOfObjects["compartmentType"]:= getNumberOfCompartmentTypes[]; 
getNumberOfObjects["event"]:= getNumberOfEvents[];
getNumberOfObjects["function"]:= getNumberOfFunctions[];
getNumberOfObjects["parameter"]:= getNumberOfParameters[];
getNumberOfObjects["reaction"]:= getNumberOfReactions[];
getNumberOfObjects["rule"]:= getNumberOfRules[];
getNumberOfObjects["species"]:= getNumberOfSpecies[];
getNumberOfObjects["speciesType"]:= getNumberOfSpeciesTypes[]; 
getNumberOfObjects["unit"]:= getNumberOfUnits[];
getNumberOfObjects["constraint"]:= getNumberOfConstraints[]; 
getNumberOfObjects["initialAssignment"]:= getNumberOfInitialAssignments[]; 
getNumberOfObjects[x_?StringQ]:= Module[{}, Print["Error: "//boldRed, "getNumberOfObjects: unknown Object: "//boldBlack, x//boldBlue]; Return[$Failed]]; 
getNumberOfObjects[x_]:= Module[{}, Print["Error: "//boldRed, "getNumberOfObjects: Object: "//boldBlack, x//boldBlue, " is not a string."//boldBlack]; Return[$Failed]]; 



getObjectID[object_?StringQ, x_]:= Module[{id}, 
id=getObjectAttribute[object, "id" , x];
Return[id]; 
]; 

getObjectID[object_, x___]:= Module[{id}, 
Print["Error: "//boldRed, "getObjectID: "//boldBlack, " object must be a string, not "//boldBlack, object//boldBlue]; 
Return[$Failed]; 
]; 

getObjectIDs[object_?StringQ]:= Module[{id, n}, 
n=getNumberOfObjects[object]; 
If[ToString[n]=="$Failed", 
Print["Error: "//boldRed, "getObjectIDs: "//boldBlack, object//boldBlue]; 
Return[$Failed]]; 

ids=getObjectID[object, #]&/@Range[n];
Return[ids]; 
];
getObjectIDs[x___]:= Module[{}, 
Print["Error: "//boldRed, "getObjectIDs: object must be a single string, not: "//boldBlack, x//boldBlue]; 
Return[$Failed]; 
];

getObjectName[object_?StringQ, x_]:= Module[{id}, 
id=getObjectAttribute[object, "name", x];
Return[id]; 
]; 

getObjectName[object_, x___]:= Module[{id}, 
Print["Error: "//boldRed, "getObjectName: "//boldBlack, " object must be a string, not "//boldBlack, object//boldBlue]; 
Return[$Failed]; 
]; 

getObjectNames[object_?StringQ]:= Module[{names, n}, 
n=getNumberOfObjects[object]; 
If[ToString[n]=="$Failed", 
Print["Error: "//boldRed, "getObjectNames: "//boldBlack, object//boldBlue]; 
Return[$Failed]]; 

names=getObjectName[object, #]&/@Range[n];
Return[names]; 
];
getObjectNames[x___]:= Module[{}, 
Print["Error: "//boldRed, "getObjectNames: object must be a single string, not: "//boldBlack, x//boldBlue]; 
Return[$Failed]; 
];


getCompartmentID[x_]:= getObjectID["compartment", x]; 
getEventID[x_]:= getObjectID["event", x]; 
getFunctionID[x_]:= getObjectID["function", x]; 
getParameterID[x_]:= getObjectID["parameter", x]; 
getRuleID[x_]:= getObjectID["rule", x]; 
getSpeciesID[x_]:= getObjectID["species", x]; 
getUnitID[x_]:= getObjectID["unit", x]; 
getSpeciesTypeID[x_]:= getObjectID["speciesType", x]; 
getCompartmentTypeID[x_]:= getObjectID["compartmentType", x]; 
getConstraintID[x_]:= getObjectID["constraint", x]; 
getInitialAssignmentID[x_]:= getObjectID["initialAssignment", x]; 

getCompartmentIDs[]:= getObjectIDs["compartment"]; 
getEventIDs[]:= getObjectIDs["event"]; 
getFunctionIDs[]:= getObjectIDs["function"]; 
getParameterIDs[]:= getObjectIDs["parameter"]; 
getRuleIDs[]:= getObjectIDs["rule"]; 
getSpeciesIDs[]:= getObjectIDs["species"]; 
getUnitIDs[]:= getObjectIDs["unit"]; 
getSpeciesTypeIDs[]:= getObjectIDs["speciesType"]; 
getCompartmentTypeIDs[]:= getObjectIDs["compartmentType"]; 
getConstraintIDs[]:= getObjectIDs["constraint"]; 
getInitialAssignmentIDs[]:= getObjectIDs["initialAssignment"]; 

getCompartmentName[x_]:= getObjectName["compartment", x]; 
getEventName[x_]:= getObjectName["event", x]; 
getFunctionName[x_]:= getObjectName["function", x]; 
getParameterName[x_]:= getObjectName["parameter", x]; 
getRuleName[x_]:= getObjectName["rule", x]; 
getSpeciesName[x_]:= getObjectName["species", x]; 
getUnitName[x_]:= getObjectName["unit", x]; 
getSpeciesTypeName[x_]:= getObjectName["speciesType", x]; 
getCompartmentTypeName[x_]:= getObjectName["compartmentType", x]; 
getConstraintName[x_]:= getObjectName["constraint", x]; 
getInitialAssignmentName[x_]:= getObjectName["initialAssignment", x]; 

getCompartmentNames[]:= getObjectNames["compartment"]; 
getEventNames[]:= getObjectNames["event"]; 
getFunctionNames[]:= getObjectNames["function"]; 
getParameterNames[]:= getObjectNames["parameter"]; 
getRuleNames[]:= getObjectNames["rule"]; 
getSpeciesNames[]:= getObjectNames["species"]; 
getUnitNames[]:= getObjectNames["unit"]; 
getSpeciesTypeNames[]:= getObjectNames["speciesType"]; 
getCompartmentTypeNames[]:= getObjectNames["compartmentType"]; 
getConstraintNames[]:= getObjectNames["constraint"]; 
getInitialAssignmentNames[]:= getObjectNames["initialAssignment"]; 


getObjectNumber["compartment",x___]:= getCompartmentNumber[x];
getObjectNumber["event",x___]:= getEventNumber[x];
getObjectNumber["function",x___]:= getCompartmentNumber[x];
getObjectNumber["parameter",x___]:= getParameterNumber[x];
getObjectNumber["reaction",x___]:= getReactionNumber[x];
getObjectNumber["rule",x___]:= getRuleNumber[x];
getObjectNumber["species",x___]:= getSpeciesNumber[x];
getObjectNumber["unit",x___]:= getUnitNumber[x];
getObjectNumber[s_?StringQ,x___]:= getObjectNumber[ToLowerCase[s],x];
getObjectNumber[x___]:= Module[{s,xx},
Print["Error:"//boldOrange,
("getObjectNumber["<>StringDrop[StringDrop[ExportString[x//List,"Text"],1],-1]<>"]")//boldRed,
" Invalid call to getObjectNumber;  the first argument must be one of the following strings: \"compartment\",\"event\",\"function\",\"parameter\",\"reaction\",\"rule\",\"species\",\"unit\""//boldBlack
];
Return[{}]];


getObjects[]:= {};
getObjects[x_?StringQ]:= Module[{n, objs},
n = getNumberOfObjects[x]; 
If[ToString[n]== "$Failed", Print["Error: "//boldRed, "getObjects: "//boldBlack, x//boldBlue]; Return[$Failed]; 
]; 
objs=getObject[x, #]&/@Range[n]; 
Return[objs]; 

];



getObjects[opt___?OptionQ]:= Module[{x,opts,y},
x={opt}/.{Rule-> List};
opts=First/@x;
x=Join@@x;
y=getObjects@@x;
opts=Take[opts,Length[y]];
opts=ToLowerCase/@opts;
y=MapThread[Rule[#1,#2]&, {opts,y}];
Return[y];
];

getObjects[x___]:= Module[{n,p},
n=Length[{x}];
If[OddQ[n],
Print["Error:"//boldRed,n//boldBlue," arguments supplied to getObjects; an even number of arguments is required, or a single string argument."//boldBlack ];
];
p = Partition[{x},2];
Return[getObject@@#&/@p];
];




Options[SBMLCopy]={ImportOptions-> {}, ExportOptions-> {}};
SBMLCopy[in_?StringQ, out_?StringQ, opt___?OptionQ]:= Module[{f,s,msg, iopt,eopt},

iopt = ImportOptions/.{opt}/.Options[SBMLCopy];
iopt=MyFilterOptions[Import,iopt];

eopt =ExportOptions/.{opt}/.Options[SBMLCopy];
eopt=MyFilterOptions[Export,eopt];

If[!validInputFile[in],Return[]];
s = ExportXMLString[Import[in, iopt]] ;

If[availableOutputFile[out], 
msg=Export[out,s,"text", eopt];,
msg = s
];
Return[msg];
];


SBMLCopy[in_?StringQ, opt___?OptionQ]:= Module[{f,s,msg, iopt, eopt},
If[!validInputFile[in],Return[]];

iopt = ImportOptions/.{opt}/.Options[SBMLCopy];
iopt=MyFilterOptions[Import,iopt];

eopt =ExportOptions/.{opt}/.Options[SBMLCopy];
eopt=MyFilterOptions[Export,eopt];

s = ExportXMLString[Import[in,iopt]] ;
Return[s];
];

SBMLCopy[x___]:= Print[
boldOrange["Error: "],
boldRed["SBMLCopy must have two string arguments, SBMLCopy[input-file-name, output-file-name]."]
];


sameReaction[Plus[r1__]-> Plus[p1__], Plus[r2__]-> Plus[p2__]]:= Module[{plus, R1,R2, P1, P2,z},
plus[x__]:={x}/.{Plus-> List}//Flatten;
{R1,P1,R2, P2} =Map[Flatten[List[#]]&, {r1, p1, r2, p2}/.{Plus-> plus}];

z=Join[Complement[R1,R2], Complement[R2,R1],Complement[P1,P2], Complement[P2, P1]]//Flatten;

Return[Length[z]==0]; 
];
sameReaction[
MyRightArrowLeftArrow[Plus[r1__], Plus[p1__]], MyRightArrowLeftArrow[ Plus[r2__],Plus[p2__]]]:=sameReaction[Plus[r1]-> Plus[p1], Plus[r2]-> Plus[p2]];



compareReactions[fileList_,opt___?OptionQ]:= Module[{getReactions, countOccurances, rlist,rlisted, allReactions,comparison,getSame,simplifyReaction,sur,fCount, rCount,verbose,rmod,fmod,rlast,tstart,tlast,tmod,tc},
tstart = TimeUsed[];
verbose = Global`verbose/.{opt}/.{Global`verbose-> False};
fmod = Global`fmod/.{opt}/.{Global`fmod-> 1};
rmod = Global`rmod/.{opt}/.{Global`rmod-> 1};
tmod = Global`tmod/.{opt}/.{Global`tmod-> 1};


fCount=0;
rCount=0; 
log={};

rlast=0;
tlast=tstart;

getReactions[file_]:= Module[{returnVal,r, nreactions},
fCount++;

r=Global`SBMLReactions/.SBMLRead[file,Global`context-> "$$$`",Global`evaluateParameters-> False, Global`return-> {SBMLReactions-> True, SBMLODES->False,SBMLIC->False,SBMLConstants->False,SBMLModelVariables->False,SBMLAlgebraicRules->False,SBMLUnitDefinitions->False,SBMLUnitAssociations->False,SBMLModelName->False,SBMLFunctions->False,SBMLEvents->False,SBMLNameIDAssociations->False,SBMLNumericalSolution->False}];
nreactions = Length[r]; 
rCount+=nreactions; 
tc = TimeUsed[];
If[verbose &&( Mod[fCount,fmod]==0   \[Or]tc>tlast+tmod),tlast=tc; Print[fCount, " files; (at ",  file,"); ", rCount," reactions; ",tc-tstart," cpu."]];
returnVal=r;
Return[returnVal]; 
];


rlist = Map[getReactions,fileList]; 

If[verbose, Print[fCount," files; ",rCount," reactions ", TimeUsed[]-tstart," seconds CPU."]];

rlisted=rlist;

allReactions=Apply[Join,rlisted];
uniqueReactions=Union[allReactions];

If[Length[uniqueReactions]==Length[allReactions], Print["No Repeated Reactions."]; Return[{}]; ]; 

If[verbose, Print[Length[uniqueReactions], " unique Reactions."]]; 

getSame[r_]:= Select[allReactions,sameReaction[r, #]&];
rCount=0; 
countOccurances[r_]:= Module[{val},
rCount++;
val=Length[getSame[r]]; 
tc = TimeUsed[]; 
If[rCount>= rlast+rmod \[Or] tc >= tlast + tmod, 
If[verbose,rlast=rCount;tlast=tc;  Print[rCount," reactions; (current=",decontextify[r,"$$$`"],"); ",TimeUsed[]-tstart," cpu."]];
]; 
Return[val];];

simplifyReaction[x_]:= MathSBML`Private`decontextify[ToString[InputForm[x]],"$$$`"]; 

comparison=countOccurances/@ uniqueReactions; 
(* sur = simplifyReaction/@uniqueReactions; *) 
comparison={comparison,uniqueReactions};
comparison=comparison//Transpose;
comparison=Select[comparison, First[#]>1&];
comparison = Map[{#//First, simplifyReaction[#//Last]}&,comparison];


comparison = comparison//Sort//Reverse; 
Print["Total CPU:", TimeUsed[]-tstart]; 
Return[comparison];

]; 


dataTable[var_,{t_, t0_, tend_, tdelta_}, r_, opt___?OptionQ]:= Module[{v,vnames, results, is, getSet,ta,tb,file,vfile, format, vforms = {"CSV","HDF","LIST", "MAT", "MTX","NB","TSV", "TABLE"}},
v={var}//Flatten;
vnames = MathSBML`Private`stringer/@v;
v=(#[t]&)/@v;

is = Position[r, InterpolationSet];

(* Not an interpolation table *)
If[Length[is]<1, 
{ta, tb} = MathSBML`Private`getPlotTimes[r];
ta =Max[t0, ta];
tb=Min[tend, tb]; 
If[tb<ta, 
results={},
results=Table[Flatten[{t,N/@(v/.r)}],{t,ta, tb, tdelta}];
]; 
, 
(* handle interpolation sets *) 

getSet[InterpolationSet[start_, finish_, data_]]:= Module[{tbeginset, tendset, setresults},
tbeginset = Ceiling[(start-t0)/tdelta]*tdelta+t0;
tendset = Floor[(finish-t0)/tdelta]*tdelta+t0;

If[t0>tendset, Return[{}];];  
If[tend<tbeginset, Return[{}];]; 

tbeginset = Max[t0, tbeginset];
tendset = Min[tend, tendset]; 

setresults=Table[Flatten[{t,N/@(v/.{data})}],{t,tbeginset, tendset, tdelta}];
Return[setresults];
];
results = Join@@(getSet/@r);

]; 
results = Prepend[results,Flatten[{"time", vnames}]]; 

file =Global`file/.{opt}/.{Global`file-> ""}; 
file=stringer[file]; 
If[StringLength[file]>0, 

vfile=validateOutputFileName[file];
If[vfile=="$Failed",
Print["Unable to create file ",file]; 
Return[results];
];

format = Global`format/.{opt}/.{Global`format-> "CSV"};
format=stringer[format];
If[!MemberQ[vforms,format], 
Print["Error: dataTable: "//boldOrange, "invalid format\[Rule]"//boldBlack,format//boldRed," allowed values are "//boldBlack, list2CommaSeparatedString[vforms]<>"; "//boldBlack,"CSV assumed."//boldBlack];
format="CSV"]; 
If[format=="HDF" \[Or] format=="MAT" \[Or] format== "MTX", results=Rest[results]]; 

Export[ vfile,results, format];
Return[vfile];

]; 


Return[results];
]


resetIC[m_?ListQ, var_, value_]:= Module[{name,model,pos,ic,cases,time,ctxt,argument},
argument[x_[y_]]:= y;
If[!SameQ[Union[Head/@m], {Rule}], 
Print["Error: resetIC: first argument must be the output of SBMLRead."];
 Abort[];
];

ctxt=Global`SBMLContext/.m/.{Global`SBMLContext-> "None"};
name =contextify[ decontextify[var],ctxt];

ic=Global`SBMLIC/.m/.{Global`SBMLIC-> {}};

pos = Position[m,Global`SBMLIC-> ic]; 

If[Length[ic]<1,
(* if there are no initial conditions assume time is zero *)
 ic={name[0]==value},

(* otherwise there are some ic already present *)

cases=Cases[ic,Equal[name[_],_]];
If[Length[cases]>1,
Print["Warning:resetIC:multiple initial conditions found for ",name,":",cases];
];


If[Length[cases]<1,
(* in this case name has no previous initial condition *)
(* use time of other initial conditions *) 
time=argument[ic[[1,1]]];
ic = Append[ic,name[time]==value];
,

(* in this case a previous initial condition for name was found *)
ic=Complement[ic,cases];
cases=cases[[1,1]];
cases=Equal[cases,value];
ic = Append[ic,cases];
];
]; 
While[ListQ[pos] \[And] Length[pos]>0,
pos=First[pos];
];
If[AtomQ[pos],
model=ReplacePart[m,Global`SBMLIC-> ic,pos];,
model=Append[m,Global`SBMLIC-> ic]//Sort;
];
Return[model];
];
resetIC[a_,Rule[b_,c_]]:= resetIC[a,b,c];
resetIC[a_,r_?ListQ]:= Fold[resetIC,a,r];
resetIC[a___]:= Print["Error: resetIC: invalid argument sequence."];



resetParameter[m_?ListQ, var_, value_]:= Module[{name,model,pos,v,cases,time,ctxt,argument,vars, voriginal, dbg=False},
argument[x_[y_]]:= y;
If[!SameQ[Union[Head/@m], {Rule}], 
Print["Error: resetParameter: first argument must be the output of SBMLRead."];
 Abort[];
];

ctxt=Global`SBMLContext/.m/.{Global`SBMLContext-> "None"};
debugPrint[dbg, "resetParameter: ctxt", ctxt]; 

name =contextify[ var,ctxt];
debugPrint[dbg, "resetParameter: name", name]; 

(* there was an extra semicolon after this statement that caused a break-down in version *)

voriginal=Global`SBMLConstants/.m/.{Global`SBMLConstants-> {}};
vars=First/@voriginal;
debugPrint[dbg, "resetParameter: voriginal", voriginal]; 
debugPrint[dbg, "resetParameter: vars(1)", vars]; 
vars=Union[Append[vars,name]];
debugPrint[dbg, "resetParameter: vars(2)", vars]; 
v=MapThread[Rule,{vars, vars/.{name-> value}/.voriginal}];
debugPrint[dbg, "resetParameter: v", v];

pos = Position[First/@m,Global`SBMLConstants]; 
debugPrint[dbg, "resetParameter: pos", pos];


While[ListQ[pos] \[And] Length[pos]>0,
pos=First[pos];
];
If[AtomQ[pos],
model=ReplacePart[m,Global`SBMLConstants-> v,pos];,
model=Append[m,Global`SBMLConstants-> v]//Sort;
];
Return[model];
];
resetParameter[a_,Rule[b_,c_]]:= resetParameter[a,b,c];
resetParameter[a_,r_?ListQ]:= Fold[resetParameter,a,r];
resetParameter[a___]:= Print["Error: resetParameter: invalid argument sequence."];



LTPrint["Public Functions Leaded."]
