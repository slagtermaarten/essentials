(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



If[$$LoadBug, Print["Loading:SBMLWrite output file formats"]];


htmlPrint[model_, opt___?OptionQ]:= Module[{html,pagetitle, headerOnly, prtable, t, v,name, citation,notes, vd, vdheader,ss,id,inlinestylesheet, writenotes, dbg=False},


inlinestylesheet="\n<style type=\"text/css\">\n<!--\n"<>"body{\nfont-family:verdana,arial,helvetica,sans-serif;\nfont-size:small;\nbackground-color:#c0c0c0;\n}\n\n"<>"td.sbml-tag-title{\ntext-align:center;\nbackground-color:white;\nfont-size:medium;\nfont-variant:small-caps;\nfont-weight:bold;\nfont-style:normal;\ncolor:black;\n}\n\n"<>"td.sbml-model-notes{\ncolor:purple;\nfont-size:small;\nbackground-color:#c0c0c0;\nborder:thin solid black;\npadding:3;\n}\n\n"<>"td.sbml-column-data{\ntext-align:left;\nfont-size:small;\nbackground-color:white;\ncolor:black;\npadding-left:3;\npadding-right:3;\nvertical-align:top;\nborder:thin solid black;}\n\n"<>"td.sbml-column-head{\nfont-size:small;\nfont-weight:bold;\nfont-variant:small-caps;\nfont-style:normal;\ncolor:purple;\nbackground-color:#c0c0c0;\ntext-align:left;\nvertical-align:top;\nborder-top:thin solid black;\nborder-bottom:thin solid black;\npadding-left:5;\npadding-right:5;\n}\n\n\n"<>"table.sbml-table{\nmargin:0 auto;\nbackground-color:white;\nborder:thin solid black;\nborder-collapse:collapse;\n}\n\n"<>"p.file-information{\nfont-size:large;\nfont-variant:small-caps;\ncolor:purple;\ntext-align:center;\nfont-style:normal;\nfont-weight:bold;\n\n}\n\n\n"<>"span.file-information-label{\ncolor:black;\nfont-style:normal;\nfont-weight:bold;\n}\n\n"<>"div{\nbackground-color:#c0c0c0;\n}\n.main{\nbackground-color:#c0c0c0;\n}\n-->\n</style>";

ss = (Global`stylesheet/.{opt}/.{Global`stylesheet-> "inline"})//stringer;

headerOnly[{x_, y_, z_}]:= (Length[y]<1) \[And] (Length[z]<1);
prtable[{x_, y_, z_}]:= If[headerOnly[{x,y,z}],
htmlHeader[x],
htmlTable[z,columnHeaders-> y, title-> x]
];
prtable[x_]:= prtable[{x[[1]], x[[2]], x[[3]]}];

vdheader = Take[SBML$VerboseData,2]; (* first two lines have model file name and model name *) 
vd = Drop[SBML$VerboseData, 2];

If[dbg, Print["htmlPrint: vdheader: ", vdheader]]; 
If[dbg, Print["htmlPrint: vd: ", vd]]; 


html="<!doctype html public \"-//w3c//dtd html 4.0 Transitional//en\">\n<html>\n<head>\n";

html=html<>"<meta http-equiv=\"Content-Type\" content=\"text/html; charset=iso-8859-1\">\n";

t=ToString[MathSBML`Private`now[]];
v=ToString[$MathSBML$Version];
name =  Global`SBMLModelName/.model/.{Global`SBMLModelName-> ""};
id= Global`SBMLModelid/.model/.{Global`SBMLModelid-> ""}; 
id = StringReplace[id,{"\[UnderBracket]"-> "_"}];
(* If[StringLength[name]==0,name = "Unnamed Model"]; *) 
name = StringReplace[name,{"\[UnderBracket]"-> "_"}]; 

html = html 
<>"<!-- SBML Model Name: "<>name<>"\n"
<>"     Generated by MathSBML "<>v<>"\n"
<>"     Creation Time: "<>t<>"\n"
<>"     Mathematica Version: "<>$Version<>"\n"
<>"     User:          "<>$UserName<>"\n"
<>"     Machine:       "<>$MachineName<>"\n"
<>"     Processor:     "<>$ProcessorType<>"\n"
<>"     Machine type:  "<>$MachineType<>"\n"
<>"     Oper. System:  "<>$OperatingSystem
<>"\n-->\n";


citation = "Generated at "<>t<>" by "<>$UserName<>" on "<>$MachineName<>" using MathSBML "<>v<>" [Mathematica Version "<>$Version<>"]"
<>" Processor/Type/OS="<>$ProcessorType<>"/"<>$MachineType<>"/"<>$OperatingSystem ;

(* determine model notes *) 

writenotes=Global`notes/.{opt}/.{Global`notes-> False};
If[writenotes,

If[ToString[Head[$SBML$Notes]]=="XMLElement", 
notes = ExportXMLString[$SBML$Notes];
(* the following requires 5.1 *)
(* notes=StringReplace[notes,"<body"~~Except[">"]..~~">"->""];
*) 
If[$VersionNumber>5,
notes=StringReplace[notes,\!\(\*
TagBox[
StyleBox[
RowBox[{"StringExpression", "[", 
RowBox[{"\"\<<body\>\"", ",", 
RowBox[{"Repeated", "[", 
RowBox[{"Except", "[", "\"\<>\>\"", "]"}], "]"}], ",", "\"\<>\>\""}], "]"}],
ShowSpecialCharacters->False,
ShowStringCharacters->True,
NumberMarks->True],
FullForm]\)->""];
notes = StringReplace[notes, "</body>"-> ""];
];
notes ="\n<table class=\"sbml-table\" width='75%'>"<>"\n\t<tr>\n\t\t<td class=\"sbml-tag-title\">\n\t\tModel Notes Contained in the XML\n\t\t</td>\n\t</tr>\n"<>
"\t<tr>\n\t\t<td class=\"sbml-model-notes\">\n"<>notes<>"\n\t\t</td>\n\t</tr>\n</table>\n\n";,

If[StringQ[$SBML$Notes],
notes=$SBML$Notes;
(* notes=StringReplace[notes,"<body"~~Except[">"]..~~">"->""];
*) 
If[$VersionNumber>5,
notes=StringReplace[notes,\!\(\*
TagBox[
StyleBox[
RowBox[{"StringExpression", "[", 
RowBox[{"\"\<<body\>\"", ",", 
RowBox[{"Repeated", "[", 
RowBox[{"Except", "[", "\"\<>\>\"", "]"}], "]"}], ",", "\"\<>\>\""}], "]"}],
ShowSpecialCharacters->False,
ShowStringCharacters->True,
NumberMarks->True],
FullForm]\)->""];
notes = StringReplace[notes, "</body>"-> ""];
]; 
notes ="\n<table class=\"sbml-table\" width='75%'>"<>"\n\t<tr>\n\t\t<td class=\"sbml-tag-title\">\n\t\tModel Notes\n\t\t</td>\n\t</tr>\n"<>
"\t<tr>\n\t\t<td class=\"sbml-model-notes\">\n"<>notes<>"\n\t\t</td>\n\t</tr>\n</table>\n";
,
notes=""
];

];
,
notes="";
];

(* generate the body of the web page *) 

pagetitle =name; 
html = html<>"<title>"<>pagetitle<>"</title>\n";

Switch[ToUpperCase[ss],
"INLINE", ss=inlinestylesheet,
"NONE", ss="",
_, ss="<link rel=\"stylesheet\" href=\""<>ss<>"\" type=\"text/css\">\n"
];

html = html<>ss;

html = html<>"</head>\n<body>\n";

html = html<>"<div class=\"main\">";

html = html<>"\n<p class=\"file-information\"><span class=\"file-information-label\">File name:</span> "<>stringer[$SBML$Inputfile]<>"<br>";
html = html<>"\n<span class=\"file-information-label\">SBML Level</span> "<>stringer[$SBML$Level]<>" <span class=\"file-information-label\">Version </span>"<>stringer[$SBML$Version]<>"<br>";
If[StringLength[name]>0,
html = html<>"\n<span class=\"file-information-label\">Model name:</span> "<>stringer[name]<>"<br>";
]; 
html = html<>"\n<span class=\"file-information-label\">Model id:</span> "<>stringer[id]<>"</p>";

html = html <>notes;
html = html<>Map[prtable, vd];





html = html<>"<br/><br/>\n<hr>\n<div style=\"font-style:italic;text-align:left; font-size:8pt;\">"<>citation;
html = html<>"</td></tr></table>\n";
html = html<>"</div>";
html = html<>"\n</div>";


html = html<>"</body>\n</html>";

If[dbg, Print["htmlprint: html: ", html]]; 
Return[html];


];


htmlHeader[str_]:= Module[{r,s},

r =
"<br/>\n<table border=1 cellpadding=\"5\">\n\t<tr>\n\t\t<td style=\"font-weight: bold; font-size:medium; color:black; background-color:#A0FFA0;text-align:center;\">\n\t\t\t<div style=\"font-size:larger;\">\n";

s = StringReplace[str,{"\n"-> "<br/>","\[UnderBracket]"-> "_" }]; 
r= r<>"\t\t\t"<>s<>"\n\t\t\t<div>\n\t\t</td>\n\t</tr>\n</table>\n"; 


Return[r];

];


htmlTable[data_, opt___?OptionQ]:= Module[{t,h,ncol,html, tableRowForm,tableData, blankline, processValue, dbg=False},

If[dbg, Print["htmlTable: data: ", data]]; 

t=title/.{opt}/.{title-> "Table Header"};

(* If[dbg, Print["htmlTable: data: ",data]]; *) 

processValue[xin_?StringQ, class_]:= Module[{x},

(* It is possible that xin = "symbol=value" and this will evaluate to a number!!! *)

x=StringReplace[xin, {":="-> ":equal"}];
x=StringReplace[x, "="-> " equals "];
x = StringReplace[x, ":equal"-> ":="];
If[isanumber[x], 
(* NumberQ[ToExpression[x]], *)
x=ToExpression[x];
x=processValue[x,class];
x=stringer[x];
Return[x];
];
x=StringReplace[xin, {"\n"-> "<br>"}];
Return[x];
];


processValue[x_?ListQ, class_]:= Module[{y,z},
If[Length[x]==1 \[And] ListQ[First[x]],
y=First[x],
y=x
];


y=processValue[#,class]&/@y;
z=Map[stringer[#]<>"; "&, y];
z=(StringJoin@@z)<>",";
z=StringReplace[z, ",; "-> ","];
Return[z];
];

processValue[x_, class_]:= Module[{y,sp},
y=ToString[InputForm[x]]; 
sp = StringPosition[y,"*^"];

(* this will work only if the input is really a number with a single exponent in it; an expression with multiple exponents will cause a failure.*)
If[Length[sp]==1, 
y=StringReplace[y,{"*^"-> "&times;10<sup>"}]<>"</sup>";
]; 
Return[y];
]; 

tableRowForm[x_, tdclass_:""]:= Module[{y,z, class},

class=stringer[tdclass];


If[class!= "", 
  class= " class='"<>class<>"'";
];

y =processValue[#, class]&/@x;  


z= "\t<tr>\n"<>Apply[StringJoin,Map["\t\t<td"<>class<>">"<>#<>"</td>\n"&, y]]<>"\t</tr>\n";

z = StringReplace[z, { "[t]"-> "","=="-> "=","\""-> "", "\[UnderBracket]"-> "_","{"-> "", "}"-> "", ","-> "<br/>"}];


z = StringReplace[z, "@COMMA"-> ","]; 


Return[z];

If[dbg, Print["tableRowForm: z:", z]]; 

];

If[Length[data]<1,
html = "";
 Return[html]
];

ncol = Length[data[[1]]];

h = columnHeaders/.{opt}/.{columnHeaders-> {}};
h = PadRight[h,ncol,"column header"];

(* style=\" text-align:center;background-color:# a0ffa0;font-size:larger;\" *)

blankline="\n\t<tr><td colspan=\""<>ToString[ncol]<>"\" class=\"sbml-column-head-space\"></td></tr>";

blankline="";


If[dbg, Print["htmlTable: calling tableRowForm:"]]; 

h = "\t<tr>\n\t\t<td class='sbml-tag-title' colspan=\""<>ToString[ncol]<>"\">\n\t\t"<>t<>"\n\t\t</td>\n\t</tr>\n"<>blankline<>
tableRowForm[h, "sbml-column-head"]<>blankline;

If[dbg, Print["htmlTable: returning from tableRowForm: h:", h]]; 



html = "<br/><br/>\n<table class=\"sbml-table\" >\n";
html = html<>"<thead>\n";
html = html<>h<>"</thead>\n";
html = html<>"<tbody>\n";

tableData = Map[tableRowForm[#, "sbml-column-data"]&, data];

If[dbg, Print["htmlTable: tableData:", tableData]]; 

tableData = Apply[StringJoin,tableData];

html = html<>tableData;
 
html = html<>"</tbody>\n</table>\n";

If[dbg, Print["htmlTable: html:", html]]; 


Return[html]; 
];


toXPPForm[model_, file_?StringQ,opt___?OptionQ]:= Module[{m,f},
m = toXPPForm[model,opt];
Export[file,m,"text"];
Return[file];
];

toXPPForm[model_,opt___?OptionQ]:= Module[{odes, ic, par,lhs, rhs,xpp,name,t,v,fcns,odelhs,oderhs},

printWarning[!OptionQ[model],"toXPPForm: argument does not appear to be a MathSBML model."];

xpp = ""; 

(* extract odes from the MathSBML model *)
odes = Global`SBMLODES/.model;
ic = Global`SBMLIC/.model;
par = Global`SBMLConstants/.model;
name = Global`SBMLModelName/.model/.{Global`SBMLModelName-> ""};
fcns = Global`SBMLFunctions/.model/.{Global`SBMLFunctions-> {}};  

(* apply functions *) 

oderhs = Map[Last,odes]//.fcns;
odelhs = Map[First,odes];

(* evaluate parameters *) 
If[evaluateParameters/.{opt}/.{evaluateParameters-> False},
 oderhs = oderhs//.par;
];

odes = MapThread[#1==#2&, {odelhs,oderhs}]; 

t=ToString[MathSBML`Private`now[]];
v=ToString[$MathSBML$Version];
xpp=             "# Model Name:    "<>name<>"\n#\n";
xpp=xpp<>"# Creation Time: "<>t<>"\n";
xpp=xpp<>"# User:          "<>$UserName<>"\n";
xpp=xpp<>"# Machine:       "<>$MachineName<>"\n";
xpp=xpp<>"# System:        "<>$ProcessorType<>" "<>$MachineType<>" "<>$OperatingSystem<>"\n";
xpp=xpp<>"# Generated by MathSBML "<>v<>"\n";


(* convert the "Derivative[1][variable][t]" to "variable'" for each variable *) 
lhs = Map[ToString[InputForm[First[#]]]&, odes];
lhs = Map[StringReplace[#,{"Derivative[1]["-> "", "][t]"-> ""}]&,lhs];
lhs = Map[StringReplace[#,{" "-> "","`"-> "_"}]&, lhs];

(* convert the right hand side of each ode into xpp-compatible string form *) 
rhs = Map[ToString[InputForm[Last[#]]]&, odes];
rhs = Map[StringReplace[#,"[t]"-> ""]&, rhs];
rhs = Map[StringReplace[#,{" "-> "","`"-> "_"}]&, rhs];

(* combine the lhs and rhs's of the odes together and join into a single file-writeable string, including embedded newline characters *) 
odes ={lhs,rhs}//Transpose;
odes = Map[#[[1]]<>"'="<>#[[2]]<>"\n"&, odes];
odes = Apply[StringJoin,odes];
odes = "# \n# Differential Equations\n# \n"<>odes<>"# ";
xpp = xpp<>odes;

If[Length[par]>0,
par = Map["par "<>ToString[First[#]]<>"="<>ToString[Last[#]]<>"\n"&, par];
par = Apply[StringJoin,par]; 
par = StringReplace[par, {"`"-> "_"}];
par = "\n# \n# Parameters\n# \n"<>par<>"# ";
xpp = xpp<>par;
]; 
If[Length[ic]>0, 
ic = Map[ToString,ic];
ic = Map[StringReplace[#,{"[0]"-> "", " "-> "", "=="-> "="}]&, ic];
ic = Map["init "<>#<>"\n"&,ic];
ic = Apply[StringJoin, ic];
ic = StringReplace[ic, {"`"-> "_"}];
ic = "\n# \n# Initial Conditions\n# \n"<>ic<>"# ";
xpp = xpp<>ic;
];
xpp = xpp<>"\ndone";


Return[xpp];
]


toBerkeleyMadonnaForm[model_, file_?StringQ,opt___?OptionQ]:= Module[{m,f},
m = toBerkeleyMadonnaForm[model,opt];
Export[file,m,"text"];
Return[file];
];

toBerkeleyMadonnaForm[model_,opt___?OptionQ]:= Module[{odes, ic, par,lhs, rhs,bmdata,name,t,v,fcns,odelhs,oderhs, startimevalue, stoptimevalue, dtvalue,method,debug=False,srules,srulereplace},

printWarning[!OptionQ[model],"toBerkeleyMadonnaForm: argument does not appear to be a MathSBML model."];

srules= {
RegularExpression["Abs\\[(.*)\\]"]:>  "ABS[$1]",
RegularExpression["ArcCos\\[(.*)\\]"]:>  "ARCCOS[$1]",
RegularExpression["ArcCosh\\[(.*)\\]"]:>  "ARCCOSH[$1]",
RegularExpression["ArcSin\\[(.*)\\]"]:>  "ARCSINH[$1]",
RegularExpression["ArcTan\\[(.*)\\]"]:>  "ARCTAN[$1]",
RegularExpression["ArcTanh\\[(.*)\\]"]:>  "ARCTANH[$1]",
RegularExpression["Cos\\[(.*)\\]"]:>  "COS[$1]",
RegularExpression["Cosh\\[(.*)\\]"]:>  "COSH[$1]",
RegularExpression["Erf\\[(.*)\\]"]:>  "ERF[$1]",
RegularExpression["Erfc\\[(.*)\\]"]:>  "ERFC[$1]",
RegularExpression["Floor\\[(.*)\\]"]:>  "INTEGER[$1]",
RegularExpression["Log\\[10,(.*)\\]"]:>  "LOG10[$1]",
RegularExpression["Log\\[(.*)\\]"]:>  "LOGN[$1]",
RegularExpression["Max\\[(.*)\\]"]:>  "MAX[$1]",
RegularExpression["Mean\\[(.*)\\]"]:>  "MEAN[$1]",
RegularExpression["Sin\\[(.*)\\]"]:>  "SIN[$1]",
RegularExpression["Sinh\\[(.*)\\]"]:>  "SINH[$1]",
RegularExpression["Sqrt\\[(.*)\\]"]:>  "SQRT[$1]",
RegularExpression["Tan\\[(.*)\\]"]:>  "TAN[$1]",
RegularExpression["Tanh\\[(.*)\\]"]:>  "TANH[$1]"};
srulereplace[x_]:= FixedPoint[StringReplace[#,srules]&, x];

bmdata = ""; 
(* extract odes from the MathSBML model *)
odes = Global`SBMLODES/.model;
ic = Global`SBMLIC/.model;
par = Global`SBMLConstants/.model;
name = Global`SBMLModelName/.model/.{Global`SBMLModelName-> ""};
fcns = Global`SBMLFunctions/.model/.{Global`SBMLFunctions-> {}};  

starttimevalue =stringer[ Global`STARTTIME/.{opt}/.{Global`STARTTIME-> 0}];
stoptimevalue = stringer[Global`STOPTIME/.{opt}/.{Global`STOPTIME-> 10}];
dtvalue =stringer[ Global`DT/.{opt}/.{Global`DT-> 0.02}];
method = stringer[Global`METHOD/.{opt}/.{Global`METHOD-> "RK4"}]; 

(* apply functions *) 

oderhs = Map[Last,odes]//.fcns;
odelhs = Map[First,odes];

If[debug, Print["toBerkeleyMadonnaFormat: oderhs:",oderhs]];

(* evaluate parameters *) 
(* If[evaluateParameters/.{opt}/.{evaluateParameters-> False},
 oderhs = oderhs//.par;
];
*) 


odes = MapThread[#1==#2&, {odelhs,oderhs}]; 

t=ToString[MathSBML`Private`now[]];
v=ToString[$MathSBML$Version];
bmdata=             "{ Model Name:    "<>name<>" }\n";
bmdata=bmdata<>"{ Creation Time: "<>t<>" }\n";
bmdata=bmdata<>"{ User:          "<>$UserName<>" }\n";
bmdata=bmdata<>"{ Machine:       "<>$MachineName<>" }\n";
bmdata=bmdata<>"{ System:        "<>$ProcessorType<>" "<>$MachineType<>" "<>$OperatingSystem<>"    }\n";
bmdata=bmdata<>"{ Generated by MathSBML "<>v<>" }\n";

bmdata = bmdata<>"METHOD "<>method<>"\nSTARTTIME = "<>starttimevalue<>"\nSTOPTIME = "<>stoptimevalue<>"\nDT = "<>dtvalue<>"\n";
(* convert the "Derivative[1][variable][t]" to "variable'" for each variable *) 
lhs = Map[ToString[InputForm[First[#]]]&, odes];
lhs = Map[StringReplace[#,{"Derivative[1]["-> "", "][t]"-> ""}]&,lhs];
lhs = Map[StringReplace[#,{" "-> "","`"-> "_"}]&, lhs];
lhs = Map[StringReplace[#,{"$_"-> ""}]&, lhs];

(* convert the right hand side of each ode into bmdata-compatible string form *) 



rhs=Last/@odes;
rhs = Map[ToString[InputForm[#]]&, rhs];
rhs=srulereplace/@rhs;
rhs = Map[StringReplace[#,"[t]"-> ""]&, rhs];
rhs = Map[StringReplace[#,{" "-> "","`"-> "_"}]&, rhs];
rhs = Map[StringReplace[#,{"$_"-> ""}]&, rhs];
rhs = Map[StringReplace[#, {"*^"-> "*10^"}]&, rhs]; 
rhs = Map[StringReplace[#, {"["-> "(", "]"-> ")"}]&, rhs]; 


(* combine the lhs and rhs's of the odes together and join into a single file-writeable string, including embedded newline characters *) 
odes ={lhs,rhs}//Transpose;
odes = Map[
"d/dt ("<>#[[1]]<>") = "<>#[[2]]<>"\n"&, 
odes];
odes = Apply[StringJoin,odes];
odes = "{ Differential Equations }\n"<>odes;
bmdata = bmdata<>odes;

If[Length[par]>0,
par = Map[ToString[First[#]]<>" = "<>ToString[Last[#]]<>"\n"&, par];
par = Apply[StringJoin,par]; 
par = StringReplace[par, {"`"-> "_"}];
par=StringReplace[par,{"$_"-> ""}]; 
par = "{ Parameters }\n"<>par;
par = StringReplace[par, {"Indeterminate"-> "0"}]; 
bmdata = bmdata<>par;
]; 
If[Length[ic]>0, 
ic = Map[ToString,ic];
ic = Map[StringReplace[#,{"[0]"-> "", " "-> "", "=="-> " = "}]&, ic];
ic = Map["init "<>#<>"\n"&,ic];
ic = Apply[StringJoin, ic];
ic = StringReplace[ic, {"`"-> "_"}];
ic = StringReplace[ic, {"$_"-> ""}];

ic = "{ Initial Conditions }\n"<>ic;
ic = StringReplace[ic, {"Indeterminate"-> "0"}]; 
bmdata = bmdata<>ic;
];


Return[bmdata];
]


fortranize[model_,opt___?OptionQ]:= Module[{vars,varules,odes,oderhs,odevars,orderedVars, varsWithoutODES,algRules,nodes, nalg, nvars, var2NumberedVar, resids,nresids, parameters, Fortran,name,  key,dbg=False,neq, adda,jac,allfunctions,allvars,jacobian,y,s,p,i,j,tab , evts,nevts,eventFortran,eventNames, eventDelays,yrule,FortranEventSubroutine,FortranEventActivateFunction,FortranEventTestFunction, activities, eventControl,flagNames,timeNames, header, subroutinesGenerated, generateIndex, icvals, icfor, srule},

subroutinesGenerated = {{"res (subroutine)", "Calculate Residuals - required by lsodi"},{"addp (subroutine)", "Add A to any matrix - required by lsodi"}, {"jac (subroutine)", "Compute Jacobian - required by lsodi"},
{"init (subroutine)", "Set initial conditions"}}; 

yrule = ToString[FortranForm[y]]->"y";
srule = ToString[FortranForm[s]]-> "s";

debugPrint[dbg,"fortranize: {yrule, srule}:", {yrule,srule}]; 

name =  Global`SBMLModelName/.model/.{Global`SBMLModelName-> ""};
If[StringLength[name]==0,
name = Global`SBMLModelid/.model/.{Global`SBMLModelid-> "Unnamed SBML Model"};
]; 
name = StringReplace[name,{"\[UnderBracket]"-> "_"}]; 

Fortran ="C\nC --------------------------------------------------------\nC\n"<>"      subroutine res(neq,t,y,s,r,ires)\n"<>"      double precision r,s,t,y\n"<>"C\n"<>"C This is subroutine res for lsodi\n"<>"C This function computes the residuals r(i)=g(t,y)- A(t,y)(dy/dt)\n"<>"C for the linear-implicit system system (A)*(dy/dt)=g(t,y)\n"<>"C where A is a constant, possibly singular, matrix.\n"<>"C\n"<>"C Here A is diagonal with (restriction imposed by SBML, not lsodi)\n"<>"C       A(i,i)=1, i=1,...,m, where m=# of odes in the SBML Model\n"<>"C       A(i,i)=0, i=m+1,...,m+nrules, where nrules =# of algebraic rules\n"<>"C       A(i,i)=0, i=nrules+1,...,nvars, where nvars is the total number\n"<>"C                 of variables in the system and nvars-nrules-m>0 is the\n"<>"C                 number of variables controlled purely by events\n";

Fortran = Fortran<>"C\nC If the system is purely differential"<>
"\nC the right-hand side of the system dydt = g(y,t) will "<>
"\nC be returned if s is zero-filled.\nC\n";


 debugPrint[dbg,"Fortran:",model];  

(* put model parts into local variables *) 
vars = Global`SBMLModelVariables/.model;
nvars = Length[vars]; 

odes = Global`SBMLODES/.model;
nodes = Length[odes]; 

algRules = Global`SBMLAlgebraicRules/.model; 
nalg = Length[algRules]; 


parameters = Global`SBMLConstants/.model;

(* create rules to remove the [t] from the variable names *) 
varules = MapThread[#1-> #2&, {vars,(Head/@vars)}]; 

(* oderhs gives the rhs of the odes, w/o the [t], and evaluate any parameters *) 
oderhs = (Last/@odes)/.varules;
oderhs = (oderhs//.parameters); 

(* vars gives the variable symbols, w/o the [t], that are in the model *) 
vars = Head/@vars;

(* odevars gives the variable symbols, w/o the [t] in order of ode, of the variables that have odes; the ode for odevar[k] is in oderhs[k] *) 
odevars = ToString/@(First/@odes);
odevars = ToExpression/@Map[StringReplace[#,{"'[t]"-> ""}]&, odevars];

(* varsWithoutODES gives the variables that do not have odes *) 
varsWithoutODES = Complement[vars, odevars]; 

(* orderedVars has the ode-based vars first, followed by the non-ode-based vars *) 
orderedVars = Join[odevars, varsWithoutODES];
var2NumberedVar = MapThread[#1-> y[#2]&, {orderedVars,Range[nvars]}];

(* determine initial conditions for variables *)
icvals =ToString/@ FortranForm/@ToExpression/@SBMLIC/@ToString/@orderedVars; 

(* define variables in comments  *)
key = MapThread["C y("<>#1<>") = "<>#2<>"\n"&,
{ToString/@Range[nvars],ToString/@decontextify[orderedVars]}];
key = Apply[StringJoin,key];
Fortran = Fortran<>"C Representation of Model Variables by the array y\n";
Fortran = Fortran<>"C ------------------------------------------------\n";
Fortran = Fortran<>key;
Fortran = Fortran<>"C\n";

(* algebraic rules are always of the form 0 = expression; get rhs without the [t], and evaluate any parameters *)
algRules = (Last/@algRules)/.varules; 
algRules = (algRules//.parameters); 

debugPrint[dbg,"Fortran: vars:",vars];
debugPrint[dbg,"Fortran: odevars:",odevars];
debugPrint[dbg,"Fortran: varsWithoutODES:",varsWithoutODES];
debugPrint[dbg,"Fortran: orderedVars:", orderedVars]; 
debugPrint[dbg,"Fortran: var2NumberedVar:", var2NumberedVar]; 

debugPrint[dbg,"Fortran: varrules:", varules]; 
debugPrint[dbg,"Fortran: odes:",odes];
debugPrint[dbg,"Fortran: oderhs:",oderhs]; 
debugPrint[dbg,"Fortran: algRules:", algRules];
If[dbg,Print[">>>debug: Fortran: nvars = ", nvars,"; nodes = ", nodes,"; nalg = ", nalg]]; 


oderhs = (oderhs/.var2NumberedVar); 
algRules = (algRules/.var2NumberedVar);
resids = Join[oderhs, algRules]; 

resids = PadRight[resids,nvars]; (* additional vars may be set by events *) 

allfunctions = resids ; (* save for later *)
nresids = Length[resids];
resids = resids-(s/@Range[nresids]); 

debugPrint[dbg,"Fortran: oderhs (numbered):",oderhs]; 
debugPrint[dbg,"Fortran: algRules (numbered):", algRules];
debugPrint[dbg,"Fortran: residuals:", resids];

(* convert to Fortran Form *) 
resids = FortranForm/@resids;
resids = ToString/@resids;


(* resids = Map[StringReplace[#,
{ToString[FortranForm[s]]->"s", 
yrule}]&, resids];
*) 
resids = Map[StringReplace[#,
{srule, 
yrule}]&, resids];



(* turn into equations like r(n) = g(t,y)-A(t,y)*(dy/dt)  *) 
resids = MapThread["r("<>#2<>")="<>#1&,{resids,ToString/@Range[nresids]}]; 
resids = FortranWrap/@resids;
resids = Map[#<>"\n"&,resids]; 
resids = Apply[StringJoin,resids];
debugPrint[dbg,"Fortran: residuals:", resids];

neq = ToString[nresids]; 

Fortran=Fortran<>"      dimension "<>list2CommaSeparatedString[Map[#<>"("<>neq<>")"&, {"r","s","y"}]]<>"\n";

Fortran = Fortran<>resids;
Fortran = Fortran<>"      return\n      end\nC\n";

(* end of res *)
(* beginning of adda *)

adda = "C\nC --------------------------------------------------------\nC\n"<>"      subroutine addp(neq, t, y, ml, mu, p, nrowp)\n"<>
"C\nC Subroutine addp required by lsodi\nC\n"<>
"      double precision p, t, y\n"<>
"      dimension y("<>neq<>"), p(nrowp,"<>neq<>")\n"<>"      integer i\n"<>
"      Do i = 1,"<>ToString[nodes]<>"\n"<>
"         p(i,i) = p(i,i)+1\n"<>
"      End Do\n"<>
"      return\n"<>
"      end\n";

Fortran = Fortran<>adda;

(* end of adda *)
(* beginning of jac *)

jac = "C\nC --------------------------------------------------------\nC"<>"\n      subroutine jac (neq,t,y,s,ml,mu,p,nrowp)\n"<>
"C\nC Subroutine jac required by lsodi, computes jacobian\nC\n"<>
"      dimension y("<>neq<>"), s("<>neq<>"),p(nrowp,"<>neq<>")\n\n";

(* calculate jacobian matrix *)
jacobian = Jacob[allfunctions, y/@Range[nresids]];
jacobian = Flatten[jacobian]; 
tab=list2CommaSeparatedString/@Partition[Table[{i,j},{i,1,nresids}, {j,1,nresids}]//Flatten,2];
jacobian = MapThread["p("<>#1<>")="<>StringReplace[ToString[FortranForm[#2]],{yrule}]&,{tab,jacobian}];
jacobian = Map["      "<>#<>"\n"&,jacobian];
jacobian = Apply[StringJoin,jacobian];
jac = jac<>jacobian; 

jac = jac<>"\n      return\n      end\n";

Fortran = Fortran<>jac;
(* Determine initial conditions *)

icfor="C\nC --------------------------------------------------------\nC\n"<>"      Subroutine init(neq,y)"<>"\n      double precision y\n"<>"      dimension y("<>ToString[nvars]<>")\n";
icfor = icfor<>Apply[StringJoin,MapThread["      y("<>ToString[#1]<>")="<>#2<>"\n"&, {Range[nvars], icvals}]]<>"      return\n      end\n";
Fortran = Fortran<>icfor;

(* process events *) 

evts = Global`SBMLEvents/.model;
nevts = Length[evts]; 
debugPrint[dbg,"Fortran: evts = ", evts];

eventFortran=""; 

FortranEventSubroutine[evname_->evopt_]:= Module[{f="", trigger, evdelay, eventName, triggername, activatename},
eventName=StringReplace[decontextify[evname],"\[UnderBracket]"-> "_"]; 
triggername = "trigger_"<>eventName;
activatename="activate_"<>eventName;
subroutinesGenerated = Join[subroutinesGenerated, {
{triggername<>" (function)", "Trigger event "<>eventName},{activatename<>" (subroutine)", "Perform activity required by event "<>eventName}}
];

debugPrint[dbg, "FortranEventSubroutine: eventName",eventName];
debugPrint[dbg, "FortranEventSubroutine: evopt",evopt];
f="C\nC --------------------------------------------------------\n"<>"C\nC ***** Test to see if event "<>eventName<>" has been triggered\nC\n";
f=f<>FortranWrap[
 "logical function "<>triggername<>"(neq, y)\n"]<>"      double precision y\n"<>
"      integer neq\n"<>
"      dimension y("<>ToString[nvars]<>")\n"<>
"      logical triggered\n";

trigger = "trigger"/.evopt/.{"trigger"->""};
printWarning[trigger =="", "No event trigger supplied for event "<>evname];
trigger= StringReplace[trigger,{"[t]"-> ""}];
trigger = ToExpression[trigger]/.var2NumberedVar; 
trigger = ToString[trigger];
trigger = decontextify[trigger,$SBML$Context];
trigger = ToString[FortranForm[ToExpression[trigger]]]; 
trigger=StringReplace[trigger,yrule];
f = f<>FortranWrap["triggered="<>trigger<>"\n"];
f = f<>"      return(triggered)\n      end\n"; 
f=f<>"C\nC ***** Activate event: "<>eventName<>" *****\nC\n";
f=f<>FortranWrap[
 "subroutine "<>activatename<>"(neq, y)\n"]<>"      double precision y\n"<>
"      integer neq\n"<>
"      dimension y("<>ToString[nvars]<>")\n";


activities = "events"/.evopt/.{"events"-> {}};
printWarning[activities =="", "No event activities supplied for event "<>evname];
activities= Map[StringReplace[#,{"[t]"-> ""}]&, activities];
activities =ToExpression/@activities; 
activities = Map[#/.var2NumberedVar&, activities]; 
activities = ToString/@activities;
activities = Map[decontextify[#, $SBML$Context]&, activities]; 
activities = ToExpression/@activities; 
activities = Map[
ToString[FortranForm[First[#]]]<>"="<>ToString[FortranForm[Last[#]]]&,
activities]; 
activities=Map[StringReplace[#,yrule]&, activities];
activities = Map[#<>"\n"&, activities];
activities = Apply[StringJoin,FortranWrap/@activities];


debugPrint[dbg, "Fortran: activities:", activities]; 

f = f<>activities<>"      return\n      end\n"; 

f = StringReplace[f,{"\[UnderBracket]"->"_"}]; 

evdelay =  "delay"/.evopt/.{"delay"->"0"};
evdelay = StringReplace[evdelay,{"[t]"-> "", "\[UnderBracket]"->"_"}]; 

Return[{f, eventName, evdelay}]; 

];
FortranEventSubroutine[x___]:= printWarning["FortranEventSubroutine: invalid event format: "<>ToString[InputForm[x]]]; 
(* end of FortranEventSubroutine *)  

If[nevts>0,
eventFortran = FortranEventSubroutine/@evts;

{eventFortran, eventNames, eventDelays} = Transpose[eventFortran]; 

eventFortran = Apply[StringJoin,eventFortran]; 
 debugPrint[dbg,"eventFortran",eventFortran]; 
debugPrint[dbg,"eventNames",eventNames];
debugPrint[dbg,"eventDelays",eventDelays];


Fortran = Fortran<>eventFortran;
];



generateIndex[]:= Module[{lmax ,l2max, stringpad},
subroutinesGenerated = Sort[subroutinesGenerated]; 
stringpad[s_?StringQ, n_?IntegerQ, char_]:= Module[{s1}, 
s1 = s;
While[StringLength[s1]<n,s1=s1<>char];
Return[s1];
];
stringpad[s_?StringQ, n_?IntegerQ]:= stringpad[s, n, " "]; 

lmax = Map[StringLength[First[#]]&, subroutinesGenerated]//Max; 
l2max = Map[StringLength[Last[#]]&, subroutinesGenerated]//Max; 

subroutinesGenerated = Map[{stringpad[#[[1]], 1+lmax], #[[2]]}&, subroutinesGenerated];
subroutinesGenerated=
StringJoin@@
Map["C "<>Apply[StringJoin,#]<>"\n"&, subroutinesGenerated];


subroutinesGenerated = "C SBML Model Name:  "<>name<>"\nC\n"<>"C Generated by MathSBML "<>$MathSBML$Version<>"\n"
<>"C Creation Time: "<>now[]<>"\n"
<>"C User:          "<>$UserName<>"\n"
<>"C Machine:       "<>$MachineName<>"\n"
<>"C Processor:     "<>$ProcessorType<>"\n"
<>"C Machine type:  "<>$MachineType<>"\n"
<>"C Oper. System:  "<>$OperatingSystem<>"\n"
<>"C --------------------------------------------------------\n"
<>"C\nC lsodi compliant SBML model\n"
<>"C Reference: http://netlib.org/alliant/ode/prog/lsodi.f\n"
<>"C\nC --------------------------------------------------------\n"<>"C\nC This file contains the following modules:\nC\nC "<>stringpad["Module Name",lmax+1]<>stringpad["Description",l2max]<>"\nC "<>stringpad["",lmax,"-"]<>" "<>stringpad["",l2max,"-"]<>"\n"<>subroutinesGenerated;




Return[subroutinesGenerated]; 
]; 

header = generateIndex[];
Fortran = header<>Fortran; 

Return[Fortran];
];


FortranWrap[inputString_?StringQ]:= Module[{outputString, wrk,nextchunk, width=66,
sixBlanks="      ", continuation = "     &",first=True},
wrk = inputString;
outputString="       ";
While[StringLength[wrk]>width,
nextchunk = StringTake[wrk, width];
wrk = StringDrop[wrk, width];
If[first, 
outputString=sixBlanks<>nextchunk;
first=False;,
outputString=outputString<>"\n"<>continuation<>nextchunk;
];
];
If[StringLength[wrk]>0,
If[first,
outputString=sixBlanks<>wrk;
,
outputString=outputString<>"\n"<>continuation<>wrk;
];
];
Return[outputString];
];
FortranWrap[x_]:= FortranWrap[ToString[FortranForm[x]]];


LTPrint["Loaded SBMLWrite Special Output Formats."]; 
