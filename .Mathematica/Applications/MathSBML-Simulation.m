(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



variableToParameter[filename_?StringQ, var_, options___?OptionQ]:= Module[{model,m},
model=SBMLRead[filename, options];
m=variableToParameter[model, var];
Return[m];
];

variableToParameter[model_, var_]:= Module[{c, nc, uc, nuc, id, m, opts, odes, nxprime, dbg=False, ic, ics,icvars, icvals, constants, modelvals, parameters, assrule,assignmentrules, algrules,algrule,event, events, trigger, delay,eventid, eventAssignment, evnew, newevent, modelvariables, modelvars, species, speciescomps},
id  = Global`SBMLModelid/.model/.{Global`SBMLModelid-> ""};
If [id=="", Print["Error: "//boldRed, "This does not appear to be a valid SBML model. The model should be the output of SBMLRead."//boldBlue]; Return[$Failed]]; 
c = Cases[model, var[_], \[Infinity]];
nc = Length[c];
uc = Union[c];
nuc = Length[uc];

opts=First/@model;
If[dbg,
Print["variableToParameter: "//boldBlue, "Model: ",id," - the variable ", var, " occurs ", nc, " times, ",nuc, " times uniquely."]; 
Print["variableToParameter: "//boldBlue, " options: ", opts]; 
];


modelvariables = Global`SBMLModelVariables/.model;

If[!MemberQ[modelvariables, var[Global`t]],
Print["Error:"//boldRed, " variableToParameter: requested variable "//boldBlack, var//boldBlue, " is not speicified as a variable in the model. "//boldBlack];
];
modelvars = Complement[modelvariables, {var[Global`t], var}] // Sort;

odes = Global`SBMLODES/.model;
nxprime = Position[odes, var'[Global`t]];
If[dbg, Print["variableToParameter: "//boldBlue, " odes: ", odes]]; 

If[Length[nxprime]>0, 
(* remove ode if necessary *)
(* the following will only work if there is precisely one reference to x'[t] *)
nxprime = nxprime[[1, 1]];
odes = Delete[odes, nxprime];
odes =  odes/.{var[Global`t]-> var};
]; 

If[dbg, Print["variableToParameter: "//boldBlue, " odes: ", odes]]; 

(* Remove initial condition  *)
ics =( Global`SBMLIC/.model/.{Global`SBMLIC-> {}})/.{Equal-> Rule};
ic = var[0]/.ics;  

icvars = First/@ics;
icvars =Complement[icvars, {var[0]}];

icvals = icvars/.ics;
ics = MapThread[Equal, {icvars, icvals}]; 
If[dbg, Print["variableToParameter: "//boldBlue, " ics: ", ics]]; 



(* Add to lists of constants and parameters *)

constants = Global`SBMLConstants/.model;
constants = Append[constants, var-> ic];
parameters = Global`SBMLParameters/.model;
parameters = Append[parameters, var]; 

If[dbg, Print["variableToParameter: "//boldBlue, " parameters: ", parameters]]; 
If[dbg, Print["variableToParameter: "//boldBlue, " constants: ", constants]]; 

(* check to see if it is in an assignment rule *)

assignmentrules=Global`SBMLAssignmentRules/.model;
algrules = Global`SBMLAlgebraicRules/.model;

assrule = Cases[assignmentrules, Equal[var[Global`t], ___], Infinity];

If[Length[assrule]>0,
While[ListQ[assrule], assrule=First[assrule]];
algrule =Equal[0, Last[assrule]-var];
Print["Warning: "//boldRed, "variableToParameter: "//boldBlue," The variable "//boldBlack, var//boldBlue," was found in an assignment rule "//boldBlack, assrule//boldBlue,"\nThis will be replaced by the following algebraic rule, which could make the system over-determined and non-simulatable: "//boldBlack, algrule//boldBlue];
AppendTo[algrules, algrule];
assignmentrules = Complement[assignmentrules, {assrule}];
];
(* events are stored as text rather then expressions so it becomes more complicated *)

evnew = {};
events = Global`SBMLEvents/.model;
If[Length[events]>0, 
If[dbg, Print["variableToParameter: "//boldBlue, "events; ", events];
];

While[Length[events]>0,
event=First[events]; 
events=Rest[events];

eventid= First[event]; 
event=Last[event];

trigger = "trigger"/.event;
trigger = ToExpression[trigger]/.{var[Global`t]-> var};

delay = "delay"/.event;
delay = ToExpression[delay]/.{var[Global`t]-> var};

eventAssignment="events"/.event;
eventAssignment = ToExpression/@eventAssignment;
eventAssignment = (#/.{var[Global`t]-> var})&/@eventAssignment;

If[dbg, 
Print["variableToParameter:"//boldBlue,
"event: id: ", eventid, " trigger: ", trigger, " delay: ", delay, " assignment: ", eventAssignment];
];

(*determine if var is reset by eventAssignment *)

eventAssignment = eventAssignment/.{Rule-> List};
c = Cases[eventAssignment,{var, _}, Infinity];
eventAssignment = Rule@@#&/@eventAssignment;


If[Length[c]>0,
c = Rule@@#&/@c;

Print["Warning:"//boldRed, " variableToParameter: "//boldBlack, " requested variable "//boldBlack, var//boldBlue," is reset by the event assignment "//boldBlack,#//boldBlue ," in event "//boldBlack, eventid//boldBlue, " Removing this eventAssignment could change the intent of the model."//boldBlack]&/@c;

eventAssignment = Complement[eventAssignment, c]; 

If[dbg, Print["variableToParameter: "//boldBlue, " revised eventAssignments: ", eventAssignment];
];

]; (*End if length[c] > 0 *)

(* save the modified event *)

newevent = eventid-> {
"trigger"-> stringer[trigger], 
"delay"-> stringer[delay],
"events"-> (stringer/@eventAssignment)
};
AppendTo[evnew, newevent];

]; (* end while length events > 0 *)

If[dbg, 
Print["variableToParameter:"//boldBlue, " modified events: ", evnew];
]; 

]; (* end if length events > 0 *) 

(* if X is a species remove it from list of species *)

species = Global`SBMLSpecies/.model;
speciescomp = Global`SBMLSpeciesCompartmentAssociations/.model;
speciescomp=speciescomp/.{Rule-> List};

species = Complement[species, {var[Global`t], var}]; 
speciescomp = Select[speciescomp, stringer[First[#]]!= stringer[var]&];
speciescomp = Rule@@#&/@speciescomp;

(* replace X[t] with X throughout the model *)


modelvals =opts/. {Global`SBMLODES-> odes, 
Global`SBMLAlgebraicRules-> algrules, 
Global`SBMLAssignmentRules-> assignmentrules,
Global`SBMLConstants-> constants, 
Global`SBMLEvents-> evnew,Global`SBMLParameters-> parameters, Global`SBMLIC-> ics,
Global`SBMLModelVariables-> modelvars,
Global`SBMLSpecies -> species,
Global`SBMLSpeciesCompartmentAssociations-> speciescomp
}/.model;

m = MapThread[Rule, {opts, modelvals}];
m = m/.{var[Global`t]-> var}; 
m = Sort[m];

Return[m];
];

variableToParameter[x___]:= Print["Error: "//boldRed, "variableToParameter: invalid argument list\nValid syntax is either:\n\tvariableToParameter[filename, variable, options] or \n\tvariableToParameter[model,variable]\nwhere model is the output of SBMLRead."//boldBlack];


parametricScan[filename_?StringQ,  X_, XMIN_, XMAX_, DX_,Y_,  time_,
opt___?OptionQ]:= Module[{model},
model = SBMLRead[filename,evaluateParameters-> False,  opt];
Return[parametricScan[model, X, XMIN, XMAX, DX,Y,  time]];
];
parametricScan[model_, X_, XMIN_, XMAX_, DX_,Y_,  time_]:= Module[{x, results,num, m, value},
results={};
For[
x=XMIN,
x<= XMAX,
x=x+DX,

m=resetParameter[model, X, x];
num = SBMLNDSolve[m, time]; 
num = Flatten[num];
value = Y[Global`t]/.num/.{Global`t-> time};
AppendTo[results, {x, value}];
];
Return[results];
];
parametricScan[x___]:= Print["Error: "//boldRed, "parametricScan: incorrect arguments: correct formats are "//boldBlack,"\n\tparametricScan[filname, p, pmin, pmax, deltap, V, time] or\n\tparametricScan[model, p, pmin, pmax, deltap, V, time]\n"//boldBlack]; 


icScan[filename_?StringQ,  X_, XMIN_, XMAX_, DX_,Y_,  time_,
opt___?OptionQ]:= Module[{model},
model = SBMLRead[filename,evaluateParameters-> False,  opt];
Return[icScan[model, X, XMIN, XMAX, DX,Y,  time]];
];
icScan[model_, X_, XMIN_, XMAX_, DX_,Y_,  time_]:= Module[{x, results,num, m, value},
results={};
For[
x=XMIN,
x<= XMAX,
x=x+DX,

m=resetIC[model, X, x];
num = SBMLNDSolve[m, time]; 
num = Flatten[num];
value = Y[Global`t]/.num/.{Global`t-> time};
AppendTo[results, {x, value}];
];
Return[results];
];
icScan[x___]:= Print["Error: "//boldRed, "icScan: incorrect arguments: correct formats are "//boldBlack,"\n\ticScan[filname, p, pmin, pmax, deltap, V, time] or\n\ticScan[model, p, pmin, pmax, deltap, V, time]\n"//boldBlack]; 


LTPrint["Simulation and Analysis Extensions loaded"]
