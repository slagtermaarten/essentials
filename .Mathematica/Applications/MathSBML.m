(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



BeginPackage["MathSBML`"];

If[$VersionNumer<6, 
Off[DiscreteMath`Combinatorica`Star]; 
]; 

If[$VersionNumber<6, 
Needs["Graphics`"];
Needs["Graphics`Legend`"];
Needs["LinearAlgebra`MatrixManipulation`"];
Needs["Utilities`"];
,
Needs["PlotLegends`"]; 
]; 

Needs["JLink`"];
If[$VersionNumber>= 6, Needs["XML`"]];  (* XML` is loaded automatically in versions 4 & 5 *)

If[$VersionNumber>5,
Needs["DifferentialEquations`NDSolveProblems`"];
Needs["DifferentialEquations`NDSolveUtilities`"]; 
Needs["DifferentialEquations`InterpolatingFunctionAnatomy`"];
If[$VersionNumber<6, Needs["DiscreteMath`GraphPlot`"]]
];
If[$VersionNumber>5.3, Needs["GraphUtilities`"]]; 

If[$VersionNumber<6, 
On[DiscreteMath`Combinatorica`Star];
]; 

versions=Names["$MathSBML$Version"];
If[Length[versions]>0,
TEMP$OLDVERSION=$MathSBML$Version; 
TEMP$FIRST=False;,
TEMP$FIRST=True];
Remove[versions];


$MathSBML$Version = "2.9.0 [8-Oct-2008]";


bulletize[mystring$$$_?StringQ,bullet$$$_?StringQ]:="\n\n"<>bullet$$$<>" "<>mystring$$$; 
numerize[mystring$$$_?StringQ, number$$$_?IntegerQ]:= bulletize[mystring$$$, "("<>ToString[number$$$]<>")"];
numerizedList[myzstring$$$_?ListQ]:=Apply[StringJoin, MapThread[numerize[#1, #2]&, {myzstring$$$, Range[Length[myzstring$$$]]}]];



sbmlReadLimitations = numerizedList[{
"\!\(\*
StyleBox[\"SBMLRead\",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\" \",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\)does not perform XML or SBML validation.  If invalid SBML or XML is supplied, unexpected results can occur.  In general, incorrectly formatted XML will cause \!\(\*
StyleBox[\"Mathematica\",\nFontSlant->\"Italic\"]\)'s \!\(\*
StyleBox[\"Import\",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\"[\",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\"..\",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\"]\",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\" \",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\)function to print an error message indicating the line number for the first error and then \!\(\*
StyleBox[\"Mathematica\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)will terminate.",
"\!\(\*
StyleBox[\"SBMLRead\",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\" \",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\)is currently only compatible with SBML Level 1 (versions 1 and 2) and Level 2 (version 1). Subsequent releases will support higher levels.",
"In SBML Level 1, all of the mathematical functions (e.g., \!\(\*
StyleBox[\"abs\",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\), \!\(\*
StyleBox[\"acos\",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\), etc.) are fully supported.  Thus \!\(\*
StyleBox[\"cos\",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\"(\",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\"x\",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\")\",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\)becomes\!\(\*
StyleBox[\" \",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\"Cos\",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\"[\",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\"x\",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\"]\",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\), etc.  Predefined rate law functions are recognized as functions but are not implemented. Thus,if the function \!\(\*
StyleBox[\"umr\",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\"(\",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\"argument\",\nFontSlant->\"Italic\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\"list\",\nFontSlant->\"Italic\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\")\",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\" \",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\)is specified in the SBML,it will be recognized as a predefined function and will be expanded in the \!\(\*
StyleBox[\"Mathematica\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)model as \!\(\*
StyleBox[\"umr\",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\"[\",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\"argument\",\nFontSlant->\"Italic\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\"list\",\nFontSlant->\"Italic\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\"]\",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\).  However, unlike the mathematical functions,no implementation is provided.Thus if the model contains ths functions,the user must supply a \!\(\*
StyleBox[\"Mathematica\",\nFontSlant->\"Italic\"]\)i mplementation for \!\(\*
StyleBox[\"umr\",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\),etc.",
"By default, all parameters are replaced with their numerical values as specified in the model. This can be switched off using the option \!\(\*
StyleBox[\"evaluateParameters\",\nFontColor->RGBColor[0, 0, 1]]\), in which case \!\(\*
StyleBox[\"SBMLRead\",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\" \",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\)will return a list of \!\(\*
StyleBox[\"Mathematica\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)replacement rules of the form \!\(\*
StyleBox[\"name\",\nFontSlant->\"Italic\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\"\[Rule]\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\" \",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\"value\",\nFontSlant->\"Italic\",\nFontColor->RGBColor[0, 0, 1]]\).",
"The topological relationship specified by the \!\(\*
StyleBox[\"outside\",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\" \",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\)attribute in a compartment definition is ignored, although \!\(\*
StyleBox[\"SBMLRead\",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\" \",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\)will display the relationship in the verbose listing.  If no outside component exists, the \!\(\*
StyleBox[\"Mathematica\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)variable \!\(\*
StyleBox[\"Indeterminate\",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\" \",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\)is displayed.",
"The \!\(\*
StyleBox[\"reversible\",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\" \",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\)parameter of the \!\(\*
StyleBox[\"reaction\",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\" \",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\)type is ignored with the following exception: reversible reactions in the list of reactions returned (SBMLReactions) will use the double arrow (\[RightArrowLeftArrow]) instead of the single forward arrow (\[Rule] or ->, same arrow used for rules).", 
"In SBML Level 1, Unspecified initial conditions and parameter values will be labeled as \!\(\*
StyleBox[\"Indeterminate\",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\" \",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\)if they are not specified,and a warning message will be printed. Models with \!\(\*
StyleBox[\"Indeterminate\",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\" \",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\)parameters and initial conditions will cause an error in\!\(\*
StyleBox[\" \",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\"NDSolve\",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\).  To prevent this from happening,the user can optionally specify the options \!\(\*
StyleBox[\"defaultParameterValue\",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\" \",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\)and \!\(\*
StyleBox[\"defaultIC\",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\" \",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\)to set all \!\(\*
StyleBox[\"Indeterminate\",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\" \",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\)parameter values and initial conditions.For example, \!\(\*
StyleBox[\"defaultParameterValue\",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\"->\",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\" \",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\"1\",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\" \",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\)will set all \!\(\*
StyleBox[\"Indeterminate\",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\" \",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\)parameters equal to 1. Unspecified units will be labeled as \!\(\*
StyleBox[\"Indeterminate\",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\" \",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\)in the verbose listing,but no association will be returned for indeterminate units.","Annotations and notes are ignored."
}]; 

sbmlReadOptions = "\n\nOptions for SBMLRead are:\n"<>
"\n\!\(\*
StyleBox[\"align\",\nFontColor->RGBColor[0, 0, 1]]\)\[Rule]\"Left\", alignment of verbose output on screen. Any valid values of TextAlignment may be used; since the value is passed directly to TextAlignment without error checking invalid values will result in the default value of TextAlignment (\"Left\"). This option is ignored unless verbose\[Rule]True."<>
"\n\!\(\*
StyleBox[\"concise\",\nFontColor->RGBColor[0, 0, 1]]\)\[Rule]False. When  True, overrides whatever values are set to verbose, warnings, and stats to set all of them to False. This option minimizes the written output."<>
"\n\!\(\*
StyleBox[\"context\",\nFontColor->RGBColor[0, 0, 1]]\)\[Rule]\"Automatic\" (default), assign all global model variables to a context given by the model name; thus variables x,y,z in them SBML become modelname`x, modelname`y, modelname`z in the Mathematica representation.  Local parameters in reactions will be assigned a context modelname`reactionname, i.e., if reaction20 in model foo has a parameter k it will be called foo`reaction20`k. "<>
"\n\!\(\*
StyleBox[\"context\",\nFontColor->RGBColor[0, 0, 1]]\)\[Rule]str, where str is any string.  All variables will be assigned to the context str` (reaction parameters to context str`reactioname`)  instead of modelname`. The terminating \"`\" character is optional."<>
"\n\!\(\*
StyleBox[\"context\",\nFontColor->RGBColor[0, 0, 1]]\)\[Rule]\"None\", all model variables are placed in the Global` context. Be aware that this could be dangerous, as symbols in the model could collide with other variables previously defined in the Mathematica environment and lead to unexpected results. "<>
"\n\!\(\*
StyleBox[\"defaultIC\",\nFontColor->RGBColor[0, 0, 1]]\)\[Rule]Indeterminate, if reassigned, then all unspecified initial conditions will be set to the value of defaultIC.  Otherwise they will remain Indeterminate."<>
"\n\!\(\*
StyleBox[\"defaultParameterValue\",\nFontColor->RGBColor[0, 0, 1]]\)\[Rule]Indeterminate, if reassigned, then all unspecified parameter values will be set to the value of defaultIC.  Otherwise they will remain Indeterminate."<>
"\n\!\(\*
StyleBox[\"EchoLoad\",\nFontColor->RGBColor[0, 0, 1]]\)\[Rule]False, if True, a message will be printed as each SBML object is loaded into the Model Builder. Ignored unlese LoadModelBuilder\[Rule]True"<>
"\n\!\(\*
StyleBox[\"evaluateParameters\",\nFontColor->RGBColor[0, 0, 1]]\)\[Rule]True, immediately evaluate parameters in reactions, otherwise return reactions with symbolic parameters.  "<>
"\nL\!\(\*
StyleBox[\"oadModelBuilder\",\nFontColor->RGBColor[0, 0, 1]]\)\[Rule]True, loads model into the Model Builder."<>
"\n\!\(\*
StyleBox[\"NDSolveOptions\",\nFontColor->RGBColor[0, 0, 1]]\)\[Rule]{}, options to be passed to NDSolve; ignored unless SBMLNumericalSolution\[Rule]n, withing return, as in return\[Rule]{SBMLNumericalSolution\[Rule] 25, ...}, where n>0 is a number."<>
"\n\!\(\*
StyleBox[\"PlotOptions\",\nFontColor->RGBColor[0, 0, 1]]\)\[Rule]{} contains a list of options to be passed to SBMLPlot, including any options to be passed to Plot.  If this option is omitted or a null list, no plot is generated. A warning message will be generated if the user does not also request a numerical solution by setting SBMLNumericalSolution to a positive value as part of the return options."<>
"\n\!\(\*
StyleBox[\"return\",\nFontColor->RGBColor[0, 0, 1]]\)\[Rule]{SBMLODES\[Rule]True, SBMLIC\[Rule]True, SBMLConstants\[Rule]True, SBMLModelVariables\[Rule]True, SBMLAlgebraicRules\[Rule]True, SBMLUnitDefinitions\[Rule]True, SBMLUnitAssociations\[Rule]True, SBMLReactions\[Rule]True, SBMLFunctions\[Rule]True,  SBMLEvents\[Rule]True, SBMLNameIDAssociations\[Rule]True, SBMLModelName\[Rule]True, SBMLNumericalSolution\[Rule]0}; this option allows the user to control the return value of SBMLRead.  All boolean items are returned except for those set to False. A numerical solution is only returned if SBMLNumericalSolution evaluates to a positive number. Setting return\[Rule]None is equivalent to setting everything to False."<>
"\n\!\(\*
StyleBox[\"shortenODES\",\nFontColor->RGBColor[0, 0, 1]]\)\[Rule]False, ignored unless verbose\[Rule]True and showKineticlaw\[Rule]True. If shortenODES\[Rule]False (default), then the entire differential equation will be displayed in the verbose listing; if shortenODES\[Rule]True then the Mathematica Short[..] version will be used."<>
"\n\!\(\*
StyleBox[\"showKineticLaw\",\nFontColor->RGBColor[0, 0, 1]]\)\[Rule]True, ignored unless verbose\[Rule]True; if showKineticLaw\[Rule]True(default), the SBML kinetic law is shown in the reaction-listing of the verbose display; otherwise  the kinetic laws are not displayed in the reactions table"<>
"\n\!\(\*
StyleBox[\"showReactionParameters\",\nFontColor->RGBColor[0, 0, 1]]\)\[Rule]True,  ignored unless verbose\[Rule]True; if showReactionParameters\[Rule]True(default), the local parameters in each reaction are  shown in the reaction-listing of the verbose display; otherwise  the local parameters are not displayed in the reactions table"<>
"\n\!\(\*
StyleBox[\"stats\",\nFontColor->RGBColor[0, 0, 1]]\)\[Rule]False, print a statistical summary of the file"<>
"\n\!\(\*
StyleBox[\"underscore\",\nFontColor->RGBColor[0, 0, 1]]\)\[Rule]\"\[UnderBracket]\", character (or string) that is used to replace the underscore (\"_\") charcter in SBML indentifiers."<>
"\n\!\(\*
StyleBox[\"verbose\",\nFontColor->RGBColor[0, 0, 1]]\)\[Rule]False, if True, print an interpretive table of the SBML"<>
"\n\!\(\*
StyleBox[\"verbosecontext\",\nFontColor->RGBColor[0, 0, 1]]\)\[Rule]False, if True, the context (scope) of all variables will be indicated in the verbose display. If False, only the pure model variable will be indicated. This option will be ignored unless verbose\[Rule]True."<>
"\n\!\(\*
StyleBox[\"warnings\",\nFontColor->RGBColor[0, 0, 1]]\)\[Rule] True, if False, warning messages will be suppressed."; 


SBMLRead::usage="SBMLRead[filename, options]"<>
" returns an option list of the form:\n\n{\nSBMLODES\[Rule]{v1'[t]==expression, v2'[t]==expression,...},\nSBMLConstants\[Rule]{k1\[Rule]value,k2\[Rule]value,...},\nSBMLIC\[Rule]{v1[0]==value,v2[0]==value,...},\nSBMLModelVariables\[Rule]{v1[t],v2[2],..},\nSBMLAlgebraicRules\[Rule]{expression1==0, expression2==0, ...},\nSBMLUnitDefinitions\[Rule]{unitName1\[Rule]unitDefinition1, unitName2\[Rule]unitDefinition2,...},\nSBMLUnitAssociations\[Rule]{var1\[Rule]units1,var2\[Rule]units2,...},\nSBMLReactions\[Rule]{reaction1, reaction2,...},\nSBMLModelName\[Rule]name,\nSBMLNameIDAssociations\[Rule]{id1\[Rule]name1,id2\[Rule]name2},\nSBMLFunctions\[Rule]{function1\[Rule]def, function2\[Rule]def,...},\nSBMLEvents\[Rule]{event1def1, eventdef2,,..},\nSBMLNumericalSolution\[Rule]numerical solution,\nSBMLCompartments\[Rule]{c1,c2,...}\n}\n\nwhere v1,v2,... give all of the species in the SBML file; c1,c2,... are the compartments in the model; the expression gives the derived differential equation for that species; value (following SBMLConstants or SBMLIC) is the SBML value of the associated parameter or initial condition; unitName1,... are user-defined units; unitDefinition1,... are expressions that give the unit definitions in terms of pre-defined units; units1,... are the units that correspond to variable var1,..., which can be either species, parameter, or compartment; reaction1,reaction2,... are the reactions in standard biochemical form \!\(\*SubscriptBox[\"\[CapitalSigma]\", \"i\"]\)\!\(\*SubscriptBox[\"R\", \"i\"]\)\[Rule]\!\(\*SubscriptBox[\"\[CapitalSigma]\", \"j\"]\)\!\(\*SubscriptBox[\"P\", \"j\"]\), where R and P are the reactants and products in each reaction.\nSBMLFunctions, SBMLEvents, and SBMLNameIDAssociations only apply for Level 2.\nEvent definitions have the form id\[Rule]{\"trigger\"\[Rule]expression,\"delay\"\[Rule]expression,\"events\"\[Rule]{var1\[Rule]exp1,var2\[Rule]exp2,...}} where id is the event id (assigned to Event\[UnderBracket]n if not provided); and expression, etc., are Mathematica expressions.\nSBMLFunctions have the form {id\[Rule]Function[...], id\[Rule]Function[...],..} where Function[...] gives a pure Mathematica Function definition and id is the corresponding SBML id for the function. \nAny portion of the returned option list may be turned off with the option return.\nSBMLNumericalSolution is the output of SBMLNDsolve, if a numerical solution is requested.\n\nThe intention is that this format contains all information necessary to pass the model to NDSolve in the following manner:\n\n"<>"r=SBMLRead[filename,options]\n"<>
"Apply[NDSolve,{Join[SBMLODES/.r, SBMLIC/.r]/.(SBMLConstants/.r), SBMLModelVariables/.r,{t,0,tmax},NDSolveOptions}]"<>
"\n\nwhere NDSolveOptions are any valid options for NDSolve and tmax is the duration of the NDSolve Rule."<>sbmlReadOptions<>
"\n\nAdditional Notes and Limitations of SBMLRead"<>sbmlReadLimitations


textODES::usage="textODES[model] returns the differential equations in a model as a list of strings that can be copied to a text file.\ntextODES[model,filename] writes the result to filename.\nmodel Should be the output of SBMLRead or loadSimulator."


SBMLNDSolve::usage="SBMLNDSolve[model, tmax,options]"<>
" evaluates NDSolve on an SBML model, where model is the ouptput of SBMLRead, tmax is the duration of the NDSolve run, and options are any valid options for NDSolve.\n\nAdditional Notes and Limitations:"<>numerizedList[{ "units are ignored by \!\(\*
StyleBox[\"SBMLNDSolve\",\nFontColor->RGBColor[0, 0, 1]]\)",
"The inclusion of algebraic constraints (rules) along with differential equations to produce a system of Differential-Algebraic Equations requires Mathematica Version \[GreaterEqual] 5.0; version checking is performed dynamically.",
"If the model does not contain any events then the return value of SBMLNDSolve is identical to the corresponding return value from NDSolve, notably, a list of InterpolatingFunctions's",
"If the model does contain events, a list of InterpolationSet's is returned",
"At the present time delay and timeUnits fields in events are not supported by SBMLNDSolve. It is anticipated that this functionality will be added in a later version."
}];


dataTable::usage="dataTable[variable,{t, t1, t2, dt}, solution, options] returns a table of data values for a given variable or set of variables from a solution set at times t=t1, t1+dt, t1+2dt,...,[t2]; a point at t2 will only be in the data if (t2-t1)/dt is an integer.\nsolution is the output of SBMLNDSolve\nvariable is the name of the variable, or a list of variables to be tabulated\nExample:\ncvsTable[{A,B,C},{t,0,1, 0.2}, r]\nwill list the variables A, B and C from the solution r\n\nOptions:\nfile\[Rule]output file name; write the output to the specified file instead of the screen. If the file already exists, an similar file name is used.\nformat\[Rule]output format to use. Allowed values are:\n\"CSV\", comma separated values\n\"HDF\",heirarchical data format (column headers deleted)\n\"LIST\",a text file containing Mathematica lists\n \"MAT\", MAT matrix file format (column headers deleted)\n\"NB\",as a Mathematica Notebook\n\"TSV\",tab separated values\n\"TABLE\",white-space separated values.\n";


conservationMatrix::usage="conservationMatrix[s] returns the conservation matrix, given the stoichiometry matrix s.";


SBMLPlot::usage="SBMLPlot[solution, {var1, var2,...}, {tbegin, tend}, options] plots the results of a simulation.\nsolution is either the output of SBMLNDSolve or the output of an SBMLRead run with numerical solution enabled.\nThe variables named var1, var2,.. are plotted from t=tbegin to t=tend on a single plot. The context of the variable name must be specified, i.e., if the model identifier is foo, to plot variables A and C only but not any other variable, one would invoke SBMLPlot[solution, {foo`A,foo`C}, {tbegin,tend}].\n"<>
"SBMLPlot[solution,{tbegin,tend}, options] plots all variables in the solution set for the specified time range.\n"<>
"SBMLPlot[solution,variable,options] and \nSBMLPlot[solution,variable,{tbegin,tend},options], where the context of the variable is omitted, will Plot a single variable in the solution.\n"<>
"SBMLPlot[solution,options] plots all variables for the entire duration of the run.\n"<>
"SBMLPLot[InterpolationSet[..], arguments] where any of the above formats for the arguments following solution is valid\n"<>"SBMLPlot[{InterpolationSet[..],InterpolationSet[...],...}] plots the solution of all variables across a set of sequential InterpolationSet's produced by SBMLNDSolve\n "<>"\nAny valid option for Plot may be used.\n\n\!\(\*
StyleBox[\"Additional\",\nFontVariations->{\"Underline\"->True}]\)\!\(\*
StyleBox[\" \",\nFontVariations->{\"Underline\"->True}]\)\!\(\*
StyleBox[\"options\",\nFontVariations->{\"Underline\"->True}]\)\!\(\*
StyleBox[\":\",\nFontVariations->{\"Underline\"->True}]\)\n"<>
"variables\[Rule] var or {var1, var2, ...} or \"All\"; gives the names of the variables to be plotted. If this option is omitted all variables are plotted. The context of the variable name must be specified, i.e., if the model identifier is foo, to plot variables A and C only but not any other variable, one would specify variables\[Rule]{foo`A,foo`C}. If any of the variable names is All then all variables will be plotted. Note: This option is only available in SBMLPlot[solution,options] form. \n"<>"holdLegend->False, if True, don't print the legend.\n"<>"PlotStyles->{styles1,styles2,...} where each of styles1,styles2,... is a list of styles (values for PlotStyle) for variable1, variable2,...,e.g., SBMLPlot[...,PlotStyles-> {{Green},{Blue,Dashing[{.02}]}},...] will plot the first variable as a solid green line, and the second variable as a dashed blue line. The length of the list given to PlotStyles must be the same as the number of variables being plotted."<>
"\ntype\[Rule]\"Log\", if specified, the y-axis is logarithmic. " ;
SBMLGridPlot::usage="SBMLGridPlot[solution,options]\nSBMLGridPlot[Solution,{var1,var2,...},options]\nSBMLGridPlot[solution,variable,{tbegin,tend},options]\nThese functions will plot each specified variable (or the entire solution set) for the specified times (or the entire time span) on a separate graph, with the top of the graph labeled with the variable name. The plots will be arranged on a grid with three plots per line. The context of the variables should not be included in the list of variable names. \nOptions include:\ncolumns->3, number of plots per line\nAny valid option for Plot may also be used.";
SBMLListPlot::usage="
SBMLListPlot[vars,{t,tmin,tmax, dt}, sol, opt] interpolates the output of SBMLNDSolve (with or without events) and generates a plot using Mathematica's ListPlot function rather than Plot.\nvars is a list of variables.\nt is the time variable\ntmin is the lower plot limit\ntmax is the upper plot limit\ndt is the interpolation interval\nsol is the the output of SBMLNDSolve\nopt is a sequence of options that may contain any valid options for ListPlot or Graphics. Since the default option of ListPlot is PlotJoined->False, the points will not be connected with a line unless PlotJoined->True.\nEach variable will be plotted a different color.\nIn the present version no legend is printed."


SBMLWrite::usage="SBMLWrite[optons] will write a model in a specified format as determined by the options. \n\nOptions are:\n"<>
"\n\!\(\*
StyleBox[\"inputfile\",\nFontColor->RGBColor[0, 0, 1]]\)\[Rule]\!\(\*
StyleBox[\"string\",\nFontSlant->\"Italic\"]\), name of SBML file that is to be converted (read).An inputfile is required. "<>
"\n\!\(\*
StyleBox[\"output\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\"file\",\nFontColor->RGBColor[0, 0, 1]]\)\[Rule]\!\(\*
StyleBox[\"string\",\nFontSlant->\"Italic\"]\), name of file that output is written to. If not specified, the output is written to the screen"<>
"\n\!\(\*
StyleBox[\"format\",\nFontColor->RGBColor[0, 0, 1]]\)\[Rule]\!\(\*
StyleBox[\"string\",\nFontSlant->\"Italic\"]\), type of output to produce. If no format is specified or an invalid format is specified the original model will be returned. Valid formats are:\"BerkeleyMadonna\", \"Fortran\", \"HTML\", \"XPP\" (the value of format is case-insensitve). It is anticipated that other formats will be added in future releases."<>
"\nThere are additional options for some formats.\n"<>
"\n\!\(\*
StyleBox[\"Notes\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\" \",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\"for\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\" \",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\"BerkeleyMadonma\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\" \",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\"format\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\":\",\nFontColor->RGBColor[0, 0, 1]]\)"<>
numerizedList[{"The following additional options are available:DT, METHOD,STARTIME, STOPTIME. These correspond to the values of the Berkeley Madonna control variables by the same name.",
"The output is a text file that contains text that can be pasted into a Berkeley Madonna Equation window. It is not a \"clickable\" Berkeley Madonna input file, which does not have text format.",
"All reactions are translated into differential equations and combined with rules, in the same manner that this is normally performed by SBMLRead. Only the resulting differential equations are written to the output file, and not the reactions.",
"Events and units are not processed in the current version.","Parameters or initial conditions that are not set in the model will be assigned a value of zero in the Berkeley Madonna file."}]<>
"\n\n\!\(\*
StyleBox[\"Notes\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\" \",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\"for\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\" \",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\"XPP\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\" \",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\"format\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\":\",\nFontColor->RGBColor[0, 0, 1]]\)"<>numerizedList[{"XPP implmentation is limited to ODEs, parameters, and intial condtions. It is anticipated that more complex forms will be allowed in future release of MathSBML.",
"SBML functions are not implemented in XPP files. Instead, they are instantiated in place.","By default, assignment rules are not instantiated before evaluation. To force evaluate of assignment rules, use the option evaluateParameters\[Rule]True. This will also force evaluation of all parameters.","SBML events are not implemented in XPP files.","Parameters or initial conditions that are not set in the model will be assigned a value of Indeterminate in the XPP file, which is not a valid XPP value."}]<>"\n\n\!\(\*
StyleBox[\"Notes\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\" \",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\"for\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\" \",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\"Fortran\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\" \",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\"Format\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\":\",\nFontColor->RGBColor[0, 0, 1]]\)"<>numerizedList[{"Fortran format is developmental", 
"The output file will contain the three subroutines res, addp, and jac required by lsodi", "Documentation of lsodi can be found at http://netlib.org/alliant/ode/prog/lsodi.f","The output file will also contain a subroutine init that sets the initial condition.",
"The output file also contains two modules for each event in the file, a logical function trigger_\!\(\*
StyleBox[\"<\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"event\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\">\",\nFontSlant->\"Italic\"]\) that returns the boolean value of the event's trigger given the values of all the system's state variables, and a subroutine activate_\!\(\*
StyleBox[\"<\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"event\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\">\",\nFontSlant->\"Italic\"]\) that modifies the system's state variables as per the event.","The user is expected implement his/her own driver software that utilizes the event files and calls lsodi or some other solver as required. An example (without events) is provided in the lsodi documentation.","Because lsodi does not directly support events, if the model contains events the user will need to write wrappers for the subroutines provided that make them compatible with his/her chosen solver.",
"Parameters in the model such as foo`k and foo`r1`k will become fooxk and fooxr1xk"}]<>"\n\n\!\(\*
StyleBox[\"Notes\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\" \",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\"on\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\" \",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\"HTML\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\" \",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\"Format\",\nFontColor->RGBColor[0, 0, 1]]\)"<>
"\nThe following addtional options is available:"<>"\n\!\(\*
StyleBox[\"stylesheet\",\nFontColor->RGBColor[0, 0, 1]]\)\[Rule]\!\(\*
StyleBox[\"string\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"(\",\nFontSlant->\"Plain\"]\)\!\(\*
StyleBox[\"only\",\nFontSlant->\"Plain\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Plain\"]\)\!\(\*
StyleBox[\"when\",\nFontSlant->\"Plain\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Plain\"]\)\!\(\*
StyleBox[\"format\",\nFontSlant->\"Plain\"]\)\[Rule]\"HTML\"),Name of style sheet to reference for HTML output.\nstylesheet\[Rule]\"none\" do not include styles and do not refer to a style sheet\nstylesheet\[Rule]\"inline\" (default) means include the contents of a default style sheet within the file itself rather than referring to an external style sheet.\n"<>"The following styles are used and may be defined by the user in the user-defined style sheet: "<>"body,div,td.sbml-tag-title, td.sbml-model-notes,td.sbml-column-data,td.sbml-column-head, table.sbml-table,p.file-information, span.file-information-label. See the examples on the mathsbml web page for more details.";


SBMLCopy::usage="SBMLCopy[input, output, options] makes a copy of an SBML file to another SBML file, filtering the file through Mathematica's XML support to pretty-print the output in a more readable form.  The content of the XML is unchanged, but the formatting/indentation is standardized. The names of the file must be specified as strings.\nIf the output file already exists the output will be displayed on the screen. When checking for a pre-existing output file, the comparison is case-insensitive.\nSBMLCopy[input] will write the output to the screen instead of to a file.\n\n\!\(\*
StyleBox[\"Options\",\nFontVariations->{\"Underline\"->True}]\):\nExportOptions\[Rule]option list\nImportOptions\[Rule]option list\n\n\!\(\*
StyleBox[\"Example\",\nFontVariations->{\"Underline\"->True}]\):SBMLCopy[\"myfile.xml\", \"yourfile.xml\", ImportOptions\[Rule]{CharacterEncoding\[Rule] \"UTF8\", ExportOptions\[Rule]{CharacterEncoding-> \"PrintableASCII\"}]";

ImportOptions::usage="ImportOptions is an option for SBMLCopy, specifying a list of options that should be passed to Import";
ExportOptions::usage="ExportOptions is an option for SBMLCopy, specifying a list of options that should be passed to Export";


mass::usage="mass[\!\(\*SubscriptBox[\"S\", \"1\"]\),\!\(\*SubscriptBox[\"S\", \"2\"]\),...,\!\(\*SubscriptBox[\"S\", \"n\"]\),k] is a predefined rate law for Irreversible Mass Action Kinetics that returns a velocity v=k*\!\(\*SubscriptBox[\"S\", \"1\"]\)*\!\(\*SubscriptBox[\"S\", \"2\"]\)*\!\(\*SubscriptBox[\"S\", \"3\"]\)\!\(\*SubscriptBox[\"\[CenterEllipsis]S\", \"n\"]\);\nmass[k] returns v=k; \nmass[] returns v=1.";



uui::usage="uui[S,\!\(\*SubscriptBox[\"V\", \"m\"]\),\!\(\*SubscriptBox[\"K\", \"m\"]\)] is  is a predefined rate law for Irreversible Simple Michaelis-Mentin Kinetics that returns a velocity v=\!\(\*FractionBox[
RowBox[{SubscriptBox[\"V\", \"m\"], \"*\", \"S\"}], 
RowBox[{SubscriptBox[\"K\", \"m\"], \"+\", \"S\"}]]\).";
uur::usage="uur[S,P,\!\(\*SubscriptBox[\"V\", \"f\"]\),\!\(\*SubscriptBox[\"V\", \"r\"]\),\!\(\*SubscriptBox[\"K\", \"ms\"]\),\!\(\*SubscriptBox[\"K\", \"mp\"]\)] is a predefined rate law for Uni-Uni Reversible Simple Michaelis-Menten Kinetics that returns a velocity v=\!\(\*FractionBox[
RowBox[{
RowBox[{
RowBox[{\"SubscriptBox\", \"[\", 
RowBox[{\"V\", \",\", \"f\"}], \"]\"}], 
RowBox[{\"(\", 
RowBox[{\"S\", \"/\", SubscriptBox[\"K\", \"ms\"]}], \")\"}]}], \"-\", 
RowBox[{
RowBox[{\"SubscriptBox\", \"[\", 
RowBox[{\"V\", \",\", \"r\"}], \"]\"}], 
RowBox[{\"(\", 
RowBox[{\"P\", \"/\", SubscriptBox[\"K\", \"mp\"]}], \")\"}]}]}], 
RowBox[{\"1\", \"+\", 
RowBox[{\"(\", 
RowBox[{\"P\", \"/\", SubscriptBox[\"K\", \"mp\"]}], \")\"}], \"+\", 
RowBox[{\"(\", 
RowBox[{\"S\", \"/\", SubscriptBox[\"K\", \"ms\"]}], \")\"}]}]]\)."


uuhr::usage="uuhr[S,P,\!\(\*SubscriptBox[\"V\", \"f\"]\),\!\(\*SubscriptBox[\"K\", \"m1\"]\),\!\(\*SubscriptBox[\"K\", \"m2\"]\),\!\(\*SubscriptBox[\"K\", \"eq\"]\)] is a predefined rate law for Uni-Uni Reversible Simple Michaelis-Menten Kinetics with Haldane Adjustment. The rate law returned is v=\!\(\*FractionBox[
RowBox[{
RowBox[{\"(\", 
RowBox[{SubscriptBox[\"V\", \"f\"], \"/\", \"m1\"}], \")\"}], 
RowBox[{\"(\", 
RowBox[{\"S\", \"-\", 
RowBox[{\"P\", \"/\", SubscriptBox[\"K\", \"eq\"]}]}], \")\"}]}], 
RowBox[{\"1\", \"+\", 
RowBox[{\"S\", \"/\", \"m1\"}], \"+\", 
RowBox[{\"P\", \"/\", SubscriptBox[\"K\", \"m2\"]}]}]]\)."


isouur::usage="isouur[S, P, \!\(\*SubscriptBox[\"V\", \"f\"]\), \!\(\*SubscriptBox[\"K\", \"ms\"]\), \!\(\*SubscriptBox[\"K\", \"mp\"]\), \!\(\*SubscriptBox[\"K\", \"ii\"]\), \!\(\*SubscriptBox[\"K\", \"eq\"]\)]is a predefined rate law for Iso Uni-Uni kinetics. The rate law returned is  \!\(\*FractionBox[
RowBox[{
RowBox[{\"SubscriptBox\", \"[\", 
RowBox[{\"V\", \",\", \"f\"}], \"]\"}], 
RowBox[{\"(\", 
RowBox[{\"S\", \"-\", 
RowBox[{\"P\", \"/\", SubscriptBox[\"K\", \"eq\"]}]}], \")\"}]}], 
RowBox[{\"(\", 
RowBox[{
RowBox[{\"S\", 
RowBox[{\"(\", 
RowBox[{\"1\", \"+\", 
RowBox[{\"P\", \"/\", SubscriptBox[\"K\", \"ii\"]}]}], \")\"}]}], \"+\", 
RowBox[{
RowBox[{\"SubscriptBox\", \"[\", 
RowBox[{\"K\", \",\", \"ms\"}], \"]\"}], 
RowBox[{\"(\", 
RowBox[{\"1\", \"+\", 
RowBox[{\"P\", \"/\", SubscriptBox[\"K\", \"mp\"]}]}], \")\"}]}]}], \")\"}]]\)."


hilli::usage="hilli[S, V, K,h] is a predefined rate law for Hill Kinetics. The rate law returned is v= \!\(\*FractionBox[
RowBox[{\"V\", \"*\", SuperscriptBox[\"S\", \"h\"]}], 
RowBox[{SuperscriptBox[\"K\", \"h\"], \"+\", SuperscriptBox[\"S\", \"h\"]}]]\)."


hillr::usage="hillr[S, P,\!\(\*SubscriptBox[\"V\", \"f\"]\), \!\(\*SubscriptBox[\"S\", \"half\"]\),\!\(\*SubscriptBox[\"P\", \"half\"]\),h, \!\(\*SubscriptBox[\"K\", \"eq\"]\)] is a predefined rate law for reversible Hill kinetics.  The rate law is \!\(\*FractionBox[
RowBox[{\"S\", \" \", 
RowBox[{\"(\", 
RowBox[{\"1\", \"-\", FractionBox[\"P\", 
RowBox[{\"S\", \" \", SubscriptBox[\"K\", \"eq\"]}]]}], \")\"}], \" \", SuperscriptBox[
RowBox[{\"(\", 
RowBox[{FractionBox[\"P\", SubscriptBox[\"P\", \"half\"]], \"+\", FractionBox[\"S\", SubscriptBox[\"S\", \"half\"]]}], \")\"}], 
RowBox[{
RowBox[{\"-\", \"1\"}], \"+\", \"h\"}]], \" \", SubscriptBox[\"V\", \"f\"]}], 
RowBox[{
RowBox[{\"(\", 
RowBox[{\"1\", \"+\", SuperscriptBox[
RowBox[{\"(\", 
RowBox[{FractionBox[\"P\", SubscriptBox[\"P\", \"half\"]], \"+\", FractionBox[\"S\", SubscriptBox[\"S\", \"half\"]]}], \")\"}], \"h\"]}], \")\"}], \" \", SubscriptBox[\"S\", \"half\"]}]]\)."


hillmr::usage="hillmr[S, P, M, \!\(\*SubscriptBox[\"S\", \"0.5\"]\), \!\(\*SubscriptBox[\"P\", \"0.5\"]\), \!\(\*SubscriptBox[\"M\", \"0.5\"]\), Vf, Keq, h, \[Alpha]] is a predefined rate law for reversible Hill kinetics with one modifier. The rate law is \!\(\*FractionBox[
RowBox[{\"S\", \" \", 
RowBox[{\"(\", 
RowBox[{\"1\", \"-\", FractionBox[\"P\", 
RowBox[{\"S\", \" \", SubscriptBox[\"K\", \"eq\"]}]]}], \")\"}], \" \", SuperscriptBox[
RowBox[{\"(\", 
RowBox[{FractionBox[\"P\", SubscriptBox[\"P\", \"0.5\"]], \"+\", FractionBox[\"S\", SubscriptBox[\"S\", \"0.5\"]]}], \")\"}], 
RowBox[{
RowBox[{\"-\", \"1\"}], \"+\", \"h\"}]], \" \", SubscriptBox[\"V\", \"f\"]}], 
RowBox[{
RowBox[{\"(\", 
RowBox[{SubscriptBox[\"K\", \"1\"], \"+\", SubscriptBox[\"K\", \"2\"]}], \")\"}], \" \", SubscriptBox[\"S\", \"0.5`\"]}]]\) where \!\(\*SubscriptBox[\"K\", \"1\"]\)=(\!\(\*FractionBox[\"P\", SubscriptBox[\"P\", \"0.5\"]]\)+\!\(\*FractionBox[\"S\", SubscriptBox[\"S\", \"0.5\"]]\)\!\(\*SuperscriptBox[\")\", \"h\"]\)  and \!\(\*SubscriptBox[\"K\", \"2\"]\)=\!\(\*FractionBox[
RowBox[{\"1\", \"+\", SuperscriptBox[
RowBox[{\"(\", FractionBox[SubscriptBox[\"V\", \"f\"], SubscriptBox[\"M\", \"0.5`\"]], \")\"}], \"h\"]}], 
RowBox[{\"1\", \"+\", 
RowBox[{\"\[Alpha]\", \" \", SuperscriptBox[
RowBox[{\"(\", FractionBox[SubscriptBox[\"V\", \"f\"], SubscriptBox[\"M\", \"0.5\"]], \")\"}], \"h\"]}]}]]\)."


hillmmr::usage="hillmmr[S, P, M, \!\(\*SubscriptBox[\"S\", \"0.5\"]\), \!\(\*SubscriptBox[\"P\", \"0.5\"]\), \!\(\*SubscriptBox[\"M\", \"0.5\"]\), \!\(\*SubscriptBox[\"M\", \"a\"]\), \!\(\*SubscriptBox[\"M\", SubscriptBox[\"a\", \"0.5\"]]\), \!\(\*SubscriptBox[\"M\", \"b\"]\), \!\(\*SubscriptBox[\"M\", SubscriptBox[\"b\", \"0.5\"]]\), \!\(\*SubscriptBox[\"V\", \"f\"]\), \!\(\*SubscriptBox[\"K\", \"eq\"]\), h, a, b, \!\(\*SubscriptBox[\"\[Alpha]\", \"1\"]\),\!\(\*SubscriptBox[\"\[Alpha]\", \"2\"]\),\!\(\*SubscriptBox[\"\[Alpha]\", \"12\"]\)] is a predefined rate law for reversible Hill Kinetics with Two Modifiers. The Rate Law is \!\(\*FractionBox[
RowBox[{\"S\", \" \", 
RowBox[{\"(\", 
RowBox[{\"1\", \"-\", FractionBox[\"P\", 
RowBox[{\"S\", \" \", SubscriptBox[\"K\", \"eq\"]}]]}], \")\"}], \" \", SuperscriptBox[
RowBox[{\"(\", 
RowBox[{FractionBox[\"P\", SubscriptBox[\"P\", \"0.5`\"]], \"+\", FractionBox[\"S\", SubscriptBox[\"S\", \"0.5`\"]]}], \")\"}], 
RowBox[{
RowBox[{\"-\", \"1\"}], \"+\", \"h\"}]], \" \", SubscriptBox[\"V\", \"f\"]}], 
RowBox[{SubscriptBox[\"S\", \"0.5`\"], \" \", 
RowBox[{\"(\", 
RowBox[{SubscriptBox[\"K\", \"1\"], \"+\", SubscriptBox[\"K\", \"2\"]}], \")\"}]}]]\) where \!\(\*SubscriptBox[\"K\", \"1\"]\)=(P/\!\(\*SubscriptBox[\"P\", \"0.5\"]\)+S/\!\(\*SubscriptBox[\"S\", \"0.5\"]\)\!\(\*SuperscriptBox[\")\", \"h\"]\)  and \!\(\*SubscriptBox[\"K\", \"2\"]\)=(1+\!\(\*SuperscriptBox[
RowBox[{\"(\", 
RowBox[{SubscriptBox[\"M\", \"a\"], \"/\", SubscriptBox[\"M\", SubscriptBox[\"a\", \"0.5\"]]}], \")\"}], \"h\"]\)+\!\(\*SuperscriptBox[
RowBox[{\"(\", 
RowBox[{SubscriptBox[\"M\", \"b\"], \"/\", SubscriptBox[\"M\", SubscriptBox[\"b\", \"0.5\"]]}], \")\"}], \"h\"]\))/(1+\!\(\*SuperscriptBox[
RowBox[{\"(\", 
RowBox[{SubscriptBox[\"M\", \"a\"], \"/\", SubscriptBox[\"M\", SubscriptBox[\"a\", \"0.5\"]]}], \")\"}], \"h\"]\) \!\(\*SubscriptBox[\"\[Alpha]\", \"1\"]\)+\!\(\*SuperscriptBox[
RowBox[{\"(\", 
RowBox[{SubscriptBox[\"M\", \"b\"], \"/\", SubscriptBox[\"M\", SubscriptBox[\"b\", \"0.5\"]]}], \")\"}], \"h\"]\) \!\(\*SubscriptBox[\"\[Alpha]\", \"2\"]\)+\!\(\*SuperscriptBox[
RowBox[{\"(\", 
RowBox[{SubscriptBox[\"M\", \"a\"], \"/\", SubscriptBox[\"M\", SubscriptBox[\"a\", \"0.5\"]]}], \")\"}], \"h\"]\) \!\(\*SuperscriptBox[
RowBox[{\"(\", 
RowBox[{SubscriptBox[\"M\", \"b\"], \"/\", SubscriptBox[\"M\", SubscriptBox[\"b\", \"0.5\"]]}], \")\"}], \"h\"]\) \!\(\*SubscriptBox[\"\[Alpha]\", \"1\"]\) \!\(\*SubscriptBox[\"\[Alpha]\", \"2\"]\) \!\(\*SubscriptBox[\"\[Alpha]\", \"12\"]\))"


usii::usage="usii[S,V,\!\(\*SubscriptBox[\"K\", \"m\"]\),\!\(\*SubscriptBox[\"K\", \"i\"]\)] is a predefined rate law for substrate inhibition kinetics (irreversible).  The rate law returned is \!\(\*FractionBox[
RowBox[{\"S\", \" \", \"V\"}], 
RowBox[{
RowBox[{\"(\", 
RowBox[{\"1\", \"+\", FractionBox[SuperscriptBox[\"S\", \"2\"], SubscriptBox[\"K\", \"i\"]], \"+\", FractionBox[\"S\", SubscriptBox[\"K\", \"m\"]]}], \")\"}], \" \", SubscriptBox[\"K\", \"m\"]}]]\). "


usir::usage="usir[S,P,\!\(\*SubscriptBox[\"V\", \"f\"]\),\!\(\*SubscriptBox[\"V\", \"r\"]\),\!\(\*SubscriptBox[\"K\", \"ms\"]\),\!\(\*SubscriptBox[\"K\", \"mp\"]\),\!\(\*SubscriptBox[\"K\", \"i\"]\)] is a predefined rate law for substrate inhibition kinetics (reversible). The rate law returned is \!\(\*FractionBox[
RowBox[{FractionBox[
RowBox[{\"S\", \" \", SubscriptBox[\"V\", \"f\"]}], SubscriptBox[\"K\", \"ms\"]], \"+\", FractionBox[
RowBox[{\"P\", \" \", SubscriptBox[\"V\", \"r\"]}], SubscriptBox[\"K\", \"mp\"]]}], 
RowBox[{\"1\", \"+\", FractionBox[SuperscriptBox[\"S\", \"2\"], SubscriptBox[\"K\", \"i\"]], \"+\", FractionBox[\"P\", SubscriptBox[\"K\", \"mp\"]], \"+\", FractionBox[\"S\", SubscriptBox[\"K\", \"ms\"]]}]]\)."


uai::usage="uai[S,V,\!\(\*SubscriptBox[\"K\", \"sa\"]\),\!\(\*SubscriptBox[\"K\", \"sc\"]\)] is a predefined rate law for substrate activation. The rate law returned is \!\(\*FractionBox[
RowBox[{SuperscriptBox[\"S\", \"2\"], \" \", \"V\"}], 
RowBox[{SubsuperscriptBox[\"K\", \"sa\", \"2\"], \" \", 
RowBox[{\"(\", 
RowBox[{\"1\", \"+\", FractionBox[SuperscriptBox[\"S\", \"2\"], SubsuperscriptBox[\"K\", \"sa\", \"2\"]], \"+\", FractionBox[\"S\", SubscriptBox[\"K\", \"sa\"]], \"+\", FractionBox[\"S\", SubscriptBox[\"K\", \"sc\"]]}], \")\"}]}]]\)."


ucii::usage="ucii[S,V,Inh, \!\(\*SubscriptBox[\"K\", \"m\"]\),\!\(\*SubscriptBox[\"K\", \"i\"]\)] is a predefined rate law for competitive inhibition (irreversible). The rate law returned is \!\(\*FractionBox[
RowBox[{\"S\", \" \", \"V\"}], 
RowBox[{
RowBox[{\"(\", 
RowBox[{\"1\", \"+\", 
RowBox[{\"Inh\", \"/\", SubscriptBox[\"K\", \"i\"]}], \"+\", 
RowBox[{\"S\", \"/\", SubscriptBox[\"K\", \"m\"]}]}], \")\"}], \" \", SubscriptBox[\"K\", \"m\"]}]]\)."


ucir::usage="ucir[S, P,Inh, \!\(\*SubscriptBox[\"V\", \"f\"]\), \!\(\*SubscriptBox[\"V\", \"r\"]\), \!\(\*SubscriptBox[\"K\", \"ms\"]\), \!\(\*SubscriptBox[\"K\", \"mp\"]\), \!\(\*SubscriptBox[\"K\", \"i\"]\)] is a predefined rate law for competitive inhibition (reversible). The rate law returned is \!\(\*FractionBox[
RowBox[{FractionBox[
RowBox[{\"S\", \" \", SubscriptBox[\"V\", \"f\"]}], SubscriptBox[\"K\", \"ms\"]], \"-\", FractionBox[
RowBox[{\"P\", \" \", SubscriptBox[\"V\", \"r\"]}], SubscriptBox[\"K\", \"mp\"]]}], 
RowBox[{\"1\", \"+\", FractionBox[\"Inh\", SubscriptBox[\"K\", \"i\"]], \"+\", FractionBox[\"P\", SubscriptBox[\"K\", \"mp\"]], \"+\", FractionBox[\"S\", SubscriptBox[\"K\", \"ms\"]]}]]\)."


unii::usage="unii[S, Inh, V, \!\(\*SubscriptBox[\"K\", \"m\"]\),\!\(\*SubscriptBox[\"K\", \"i\"]\)]is a predefined rate law for noncompetitive inhibition (irreversible). The rate law returned is \!\(\*FractionBox[
RowBox[{\"S\", \" \", \"V\"}], 
RowBox[{
RowBox[{\"(\", 
RowBox[{\"1\", \"+\", FractionBox[\"Inh\", SubscriptBox[\"K\", \"i\"]], \"+\", FractionBox[
RowBox[{\"S\", \" \", 
RowBox[{\"(\", 
RowBox[{\"1\", \"+\", FractionBox[\"Inh\", SubscriptBox[\"K\", \"i\"]]}], \")\"}]}], SubscriptBox[\"K\", \"m\"]]}], \")\"}], \" \", SubscriptBox[\"K\", \"m\"]}]]\)."


unir::usage="unir[S, P, Inh, \!\(\*SubscriptBox[\"V\", \"f\"]\), \!\(\*SubscriptBox[\"V\", 
RowBox[{\"r\", \",\", \" \"}]]\)\!\(\*SubscriptBox[\"K\", \"ms\"]\), \!\(\*SubscriptBox[\"K\", \"mp\"]\), \!\(\*SubscriptBox[\"K\", \"i\"]\)] is a predefined rate law for noncompetitive inhibition (reversible). The rate law returned is \!\(\*FractionBox[
RowBox[{FractionBox[
RowBox[{\"S\", \" \", SubscriptBox[\"V\", \"f\"]}], SubscriptBox[\"K\", \"ms\"]], \"-\", FractionBox[
RowBox[{\"P\", \" \", SubscriptBox[\"V\", \"r\"]}], SubscriptBox[\"K\", \"mp\"]]}], 
RowBox[{\"1\", \"+\", FractionBox[\"Inh\", SubscriptBox[\"K\", \"i\"]], \"+\", 
RowBox[{
RowBox[{\"(\", 
RowBox[{\"1\", \"+\", FractionBox[\"Inh\", SubscriptBox[\"K\", \"i\"]]}], \")\"}], \" \", 
RowBox[{\"(\", 
RowBox[{FractionBox[\"P\", SubscriptBox[\"K\", \"mp\"]], \"+\", FractionBox[\"S\", SubscriptBox[\"K\", \"ms\"]]}], \")\"}]}]}]]\) ."


uuci::usage="uuci[S,Inh,V,\!\(\*SubscriptBox[\"K\", \"m\"]\),\!\(\*SubscriptBox[\"K\", \"i\"]\)] is a predefined rate law for uncompetitive inhibition (irreversible). The rate law returned is  \!\(\*FractionBox[
RowBox[{\"S\", \" \", \"V\"}], 
RowBox[{
RowBox[{\"(\", 
RowBox[{\"1\", \"+\", FractionBox[
RowBox[{\"S\", \" \", 
RowBox[{\"(\", 
RowBox[{\"1\", \"+\", FractionBox[\"Inh\", SubscriptBox[\"K\", \"i\"]]}], \")\"}]}], SubscriptBox[\"K\", \"m\"]]}], \")\"}], \" \", SubscriptBox[\"K\", \"m\"]}]]\)."


uucr::usage="uucr[S,P,Inh,\!\(\*SubscriptBox[\"V\", \"f\"]\), \!\(\*SubscriptBox[\"V\", \"r\"]\), \!\(\*SubscriptBox[\"K\", \"ms\"]\),\!\(\*SubscriptBox[\"K\", \"mp\"]\), \!\(\*SubscriptBox[\"K\", \"i\"]\)] is a predefined rate law for uncompetitive inhibition (reversible). The rate law returned is \!\(\*FractionBox[
RowBox[{FractionBox[
RowBox[{\"S\", \" \", SubscriptBox[\"V\", \"f\"]}], SubscriptBox[\"K\", \"ms\"]], \"-\", FractionBox[
RowBox[{\"P\", \" \", SubscriptBox[\"V\", \"r\"]}], SubscriptBox[\"K\", \"mp\"]]}], 
RowBox[{\"1\", \"+\", 
RowBox[{
RowBox[{\"(\", 
RowBox[{\"1\", \"+\", FractionBox[\"Inh\", SubscriptBox[\"K\", \"i\"]]}], \")\"}], \" \", 
RowBox[{\"(\", 
RowBox[{FractionBox[\"P\", SubscriptBox[\"K\", \"mp\"]], \"+\", FractionBox[\"S\", SubscriptBox[\"K\", \"ms\"]]}], \")\"}]}]}]]\)."


umi::usage="umi[S,Inh,V,\!\(\*SubscriptBox[\"K\", \"m\"]\), \!\(\*SubscriptBox[\"K\", \"is\"]\), \!\(\*SubscriptBox[\"K\", \"ic\"]\)] is a predefined rate law for mixed inhibition kinetics (irreversible). The rate law returned is \!\(\*FractionBox[
RowBox[{\"S\", \" \", \"V\"}], 
RowBox[{
RowBox[{\"(\", 
RowBox[{\"1\", \"+\", FractionBox[\"Inh\", SubscriptBox[\"K\", \"is\"]], \"+\", FractionBox[
RowBox[{\"S\", \" \", 
RowBox[{\"(\", 
RowBox[{\"1\", \"+\", FractionBox[\"Inh\", SubscriptBox[\"K\", \"ic\"]]}], \")\"}]}], SubscriptBox[\"K\", \"m\"]]}], \")\"}], \" \", SubscriptBox[\"K\", \"m\"]}]]\)."


umr::usage="umr[S,P,Inh,\!\(\*SubscriptBox[\"V\", \"f\"]\),\!\(\*SubscriptBox[\"V\", \"r\"]\), \!\(\*SubscriptBox[\"K\", \"ms\"]\),\!\(\*SubscriptBox[\"K\", \"mp\"]\),  \!\(\*SubscriptBox[\"K\", \"is\"]\), \!\(\*SubscriptBox[\"K\", \"ic\"]\)] is a predefined rate law for mixed inhibition kinetics (reversible). The rate law returned is \!\(\*FractionBox[
RowBox[{FractionBox[
RowBox[{\"S\", \" \", SubscriptBox[\"V\", \"f\"]}], SubscriptBox[\"K\", \"ms\"]], \"-\", FractionBox[
RowBox[{\"P\", \" \", SubscriptBox[\"V\", \"r\"]}], SubscriptBox[\"K\", \"mp\"]]}], 
RowBox[{\"1\", \"+\", FractionBox[\"Inh\", SubscriptBox[\"K\", \"is\"]], \"+\", 
RowBox[{
RowBox[{\"(\", 
RowBox[{\"1\", \"+\", FractionBox[\"Inh\", SubscriptBox[\"K\", \"ic\"]]}], \")\"}], \" \", 
RowBox[{\"(\", 
RowBox[{FractionBox[\"P\", SubscriptBox[\"K\", \"mp\"]], \"+\", FractionBox[\"S\", SubscriptBox[\"K\", \"ms\"]]}], \")\"}]}]}]]\)."


uaii::usage="uaii[S, \!\(\*SubscriptBox[\"A\", \"c\"]\),V,\!\(\*SubscriptBox[\"K\", \"m\"]\),\!\(\*SubscriptBox[\"K\", \"a\"]\)] is a predefined rate law for specific action kinetics (irreversible). The rate law returned is \!\(\*FractionBox[
RowBox[{\"S\", \" \", \"V\"}], 
RowBox[{
RowBox[{\"(\", 
RowBox[{\"1\", \"+\", FractionBox[SubscriptBox[\"K\", \"a\"], SubscriptBox[\"A\", \"c\"]], \"+\", FractionBox[\"S\", SubscriptBox[\"K\", \"m\"]]}], \")\"}], \" \", SubscriptBox[\"K\", \"m\"]}]]\)."


uar::usage="uar[S,P,\!\(\*SubscriptBox[\"A\", \"c\"]\),\!\(\*SubscriptBox[\"V\", \"f\"]\), \!\(\*SubscriptBox[\"V\", \"r\"]\), \!\(\*SubscriptBox[\"K\", \"ms\"]\), \!\(\*SubscriptBox[\"K\", \"mp\"]\), \!\(\*SubscriptBox[\"K\", \"a\"]\)] is a predefined rate law for specific action kinetics (reversible). The rate law returned is \!\(\*FractionBox[
RowBox[{FractionBox[
RowBox[{\"S\", \" \", SubscriptBox[\"V\", \"f\"]}], SubscriptBox[\"K\", \"ms\"]], \"-\", FractionBox[
RowBox[{\"P\", \" \", SubscriptBox[\"V\", \"r\"]}], SubscriptBox[\"K\", \"mp\"]]}], 
RowBox[{\"1\", \"+\", FractionBox[SubscriptBox[\"K\", \"a\"], SubscriptBox[\"A\", \"c\"]], \"+\", FractionBox[\"P\", SubscriptBox[\"K\", \"mp\"]], \"+\", FractionBox[\"S\", SubscriptBox[\"K\", \"ms\"]]}]]\)."


ucti::usage="ucti[S, \!\(\*SubscriptBox[\"A\", \"c\"]\), V, \!\(\*SubscriptBox[\"K\", \"m\"]\), \!\(\*SubscriptBox[\"K\", \"a\"]\)] is a predefined rate law for catalytic activation (irreversible). The rate law returned is \!\(\*FractionBox[
RowBox[{\"S\", \" \", \"V\"}], 
RowBox[{
RowBox[{\"(\", 
RowBox[{\"1\", \"+\", FractionBox[SubscriptBox[\"K\", \"a\"], SubscriptBox[\"A\", \"c\"]], \"+\", FractionBox[
RowBox[{\"S\", \" \", 
RowBox[{\"(\", 
RowBox[{\"1\", \"+\", FractionBox[SubscriptBox[\"K\", \"a\"], SubscriptBox[\"A\", \"c\"]]}], \")\"}]}], SubscriptBox[\"K\", \"m\"]]}], \")\"}], \" \", SubscriptBox[\"K\", \"m\"]}]]\)."


uctr::usage="uctr[S, P, \!\(\*SubscriptBox[\"A\", \"c\"]\), \!\(\*SubscriptBox[\"V\", \"f\"]\), \!\(\*SubscriptBox[\"V\", \"r\"]\), \!\(\*SubscriptBox[\"K\", \"ms\"]\), \!\(\*SubscriptBox[\"K\", \"mp\"]\), \!\(\*SubscriptBox[\"K\", \"a\"]\)] is a predefined rate law for catalytic activation (reversible). The rate law returned is \!\(\*FractionBox[
RowBox[{FractionBox[
RowBox[{\"S\", \" \", SubscriptBox[\"V\", \"f\"]}], SubscriptBox[\"K\", \"ms\"]], \"-\", FractionBox[
RowBox[{\"P\", \" \", SubscriptBox[\"V\", \"r\"]}], SubscriptBox[\"K\", \"mp\"]]}], 
RowBox[{\"1\", \"+\", FractionBox[SubscriptBox[\"K\", \"a\"], SubscriptBox[\"A\", \"c\"]], \"+\", 
RowBox[{
RowBox[{\"(\", 
RowBox[{\"1\", \"+\", FractionBox[SubscriptBox[\"K\", \"a\"], SubscriptBox[\"A\", \"c\"]]}], \")\"}], \" \", 
RowBox[{\"(\", 
RowBox[{FractionBox[\"P\", SubscriptBox[\"K\", \"mp\"]], \"+\", FractionBox[\"S\", SubscriptBox[\"K\", \"ms\"]]}], \")\"}]}]}]]\)."


umai::usage="umai[S, \!\(\*SubscriptBox[\"A\", \"c\"]\), V, \!\(\*SubscriptBox[\"K\", \"m\"]\), \!\(\*SubscriptBox[\"K\", \"as\"]\), \!\(\*SubscriptBox[\"K\", \"ac\"]\)] is a predefined rate law for mixed activation kinetics (irreversible). The rate law returned is \!\(\*FractionBox[
RowBox[{\"S\", \" \", \"V\"}], 
RowBox[{
RowBox[{\"(\", 
RowBox[{\"1\", \"+\", FractionBox[SubscriptBox[\"K\", \"as\"], SubscriptBox[\"A\", \"c\"]], \"+\", FractionBox[
RowBox[{\"S\", \" \", 
RowBox[{\"(\", 
RowBox[{\"1\", \"+\", FractionBox[SubscriptBox[\"K\", \"ac\"], SubscriptBox[\"A\", \"c\"]]}], \")\"}]}], SubscriptBox[\"K\", \"m\"]]}], \")\"}], \" \", SubscriptBox[\"K\", \"m\"]}]]\)."


umar::usage="umar[S, P, \!\(\*SubscriptBox[\"A\", \"c\"]\), \!\(\*SubscriptBox[\"V\", \"f\"]\), \!\(\*SubscriptBox[\"V\", \"r\"]\), \!\(\*SubscriptBox[\"K\", \"ms\"]\), \!\(\*SubscriptBox[\"K\", \"mp\"]\), \!\(\*SubscriptBox[\"K\", \"as\"]\), \!\(\*SubscriptBox[\"K\", \"ac\"]\)] is a predefined rate law for mixed activation kinetics (reversible). The rate law returned is \!\(\*FractionBox[
RowBox[{FractionBox[
RowBox[{\"S\", \" \", SubscriptBox[\"V\", \"f\"]}], SubscriptBox[\"K\", \"ms\"]], \"-\", FractionBox[
RowBox[{\"P\", \" \", SubscriptBox[\"V\", \"r\"]}], SubscriptBox[\"K\", \"mp\"]]}], 
RowBox[{\"1\", \"+\", FractionBox[SubscriptBox[\"K\", \"as\"], SubscriptBox[\"A\", \"c\"]], \"+\", 
RowBox[{
RowBox[{\"(\", 
RowBox[{\"1\", \"+\", FractionBox[SubscriptBox[\"K\", \"ac\"], SubscriptBox[\"A\", \"c\"]]}], \")\"}], \" \", 
RowBox[{\"(\", 
RowBox[{FractionBox[\"P\", SubscriptBox[\"K\", \"mp\"]], \"+\", FractionBox[\"S\", SubscriptBox[\"K\", \"ms\"]]}], \")\"}]}]}]]\)."


uhmi::usage="uhmi[S, M, V, \!\(\*SubscriptBox[\"K\", \"m\"]\), \!\(\*SubscriptBox[\"K\", \"d\"]\), a, b] is a predefined rate law for general hyperbolic modifier kinetics (irreversible). The rate law returned is \!\(\*FractionBox[
RowBox[{\"S\", \" \", \"V\", \" \", 
RowBox[{\"(\", 
RowBox[{\"1\", \"+\", FractionBox[
RowBox[{\"b\", \" \", \"M\"}], 
RowBox[{\"a\", \" \", SubscriptBox[\"K\", \"d\"]}]]}], \")\"}]}], 
RowBox[{
RowBox[{\"(\", 
RowBox[{\"1\", \"+\", FractionBox[\"M\", SubscriptBox[\"K\", \"d\"]], \"+\", FractionBox[
RowBox[{\"S\", \" \", 
RowBox[{\"(\", 
RowBox[{\"1\", \"+\", FractionBox[\"M\", 
RowBox[{\"a\", \" \", SubscriptBox[\"K\", \"d\"]}]]}], \")\"}]}], SubscriptBox[\"K\", \"m\"]]}], \")\"}], \" \", SubscriptBox[\"K\", \"m\"]}]]\)."


uhmr::usage="uhmr[S, P, M,\!\(\*SubscriptBox[\"V\", \"f\"]\), \!\(\*SubscriptBox[\"V\", \"r\"]\), \!\(\*SubscriptBox[\"K\", \"ms\"]\), \!\(\*SubscriptBox[\"K\", \"mp\"]\), \!\(\*SubscriptBox[\"K\", \"d\"]\), a, b] is a predefined rate law for general hyperbolic modifier kinetics (reversible). The rate law returned is \!\(\*FractionBox[
RowBox[{
RowBox[{\"(\", 
RowBox[{\"1\", \"+\", FractionBox[
RowBox[{\"b\", \" \", \"M\"}], 
RowBox[{\"a\", \" \", SubscriptBox[\"K\", \"d\"]}]]}], \")\"}], \" \", 
RowBox[{\"(\", 
RowBox[{FractionBox[
RowBox[{\"S\", \" \", SubscriptBox[\"V\", \"f\"]}], SubscriptBox[\"K\", \"ms\"]], \"-\", FractionBox[
RowBox[{\"P\", \" \", SubscriptBox[\"V\", \"r\"]}], SubscriptBox[\"K\", \"mp\"]]}], \")\"}]}], 
RowBox[{\"1\", \"+\", FractionBox[\"M\", SubscriptBox[\"K\", \"d\"]], \"+\", 
RowBox[{
RowBox[{\"(\", 
RowBox[{\"1\", \"+\", FractionBox[\"M\", 
RowBox[{\"a\", \" \", SubscriptBox[\"K\", \"d\"]}]]}], \")\"}], \" \", 
RowBox[{\"(\", 
RowBox[{FractionBox[\"P\", SubscriptBox[\"K\", \"mp\"]], \"+\", FractionBox[\"S\", SubscriptBox[\"K\", \"ms\"]]}], \")\"}]}]}]]\)."


ualii::usage="ualii[S, Inh, V, \!\(\*SubscriptBox[\"K\", \"s\"]\), \!\(\*SubscriptBox[\"K\", \"ii\"]\), n, L] is a predefined rate law for allosteric inhibition (irreversible). The rate law returned is \!\(\*FractionBox[
RowBox[{\"S\", \" \", \"V\", \" \", SuperscriptBox[
RowBox[{\"(\", 
RowBox[{\"1\", \"+\", FractionBox[\"S\", SubscriptBox[\"K\", \"s\"]]}], \")\"}], 
RowBox[{
RowBox[{\"-\", \"1\"}], \"+\", \"n\"}]]}], 
RowBox[{
RowBox[{\"(\", 
RowBox[{
RowBox[{\"L\", \" \", SuperscriptBox[
RowBox[{\"(\", 
RowBox[{\"1\", \"+\", FractionBox[\"Inh\", SubscriptBox[\"K\", \"ii\"]]}], \")\"}], \"n\"]}], \"+\", SuperscriptBox[
RowBox[{\"(\", 
RowBox[{\"1\", \"+\", FractionBox[\"S\", SubscriptBox[\"K\", \"s\"]]}], \")\"}], \"n\"]}], \")\"}], \" \", SubscriptBox[\"K\", \"s\"]}]]\)."


ordubr::usage="ordubr[A, P, Q, \!\(\*SubscriptBox[\"V\", \"f\"]\), \!\(\*SubscriptBox[\"V\", \"r\"]\), \!\(\*SubscriptBox[\"K\", \"ma\"]\), \!\(\*SubscriptBox[\"K\", \"mq\"]\), \!\(\*SubscriptBox[\"K\", \"mp\"]\), \!\(\*SubscriptBox[\"K\", \"ip\"]\),\!\(\*SubscriptBox[\"K\", \"eq\"]\)] is a predefined rate for Ordered Uni-Bi Kinetics. The rate law returned is \!\(\*FractionBox[
RowBox[{
RowBox[{\"(\", 
RowBox[{\"A\", \"-\", FractionBox[
RowBox[{\"P\", \" \", \"Q\"}], SubscriptBox[\"K\", \"eq\"]]}], \")\"}], \" \", SubscriptBox[\"V\", \"f\"]}], 
RowBox[{
RowBox[{\"A\", \" \", 
RowBox[{\"(\", 
RowBox[{\"1\", \"+\", FractionBox[\"P\", SubscriptBox[\"K\", \"ip\"]]}], \")\"}]}], \"+\", SubscriptBox[\"K\", \"ma\"], \"+\", FractionBox[
RowBox[{
RowBox[{\"(\", 
RowBox[{
RowBox[{\"P\", \" \", \"Q\"}], \"+\", 
RowBox[{\"Q\", \" \", SubscriptBox[\"K\", \"mp\"]}], \"+\", 
RowBox[{\"P\", \" \", SubscriptBox[\"K\", \"mq\"]}]}], \")\"}], \" \", SubscriptBox[\"V\", \"f\"]}], 
RowBox[{SubscriptBox[\"K\", \"eq\"], \" \", SubscriptBox[\"V\", \"r\"]}]]}]]\)."


ordbur::usage="ordbur[A, B, P, \!\(\*SubscriptBox[\"V\", \"f\"]\), \!\(\*SubscriptBox[\"V\", \"r\"]\), \!\(\*SubscriptBox[\"K\", \"ma\"]\), \!\(\*SubscriptBox[\"K\", \"mb\"]\), \!\(\*SubscriptBox[\"K\", \"mp\"]\), \!\(\*SubscriptBox[\"K\", \"ia\"]\), \!\(\*SubscriptBox[\"K\", \"eq\"]\)] is a predefined rate for Ordered Bi-Uni Kinetics. The rate law returned is \!\(\*FractionBox[
RowBox[{
RowBox[{\"(\", 
RowBox[{
RowBox[{\"A\", \" \", \"B\"}], \"-\", FractionBox[\"P\", SubscriptBox[\"K\", \"eq\"]]}], \")\"}], \" \", SubscriptBox[\"V\", \"f\"]}], 
RowBox[{
RowBox[{\"A\", \" \", \"B\"}], \"+\", 
RowBox[{\"B\", \" \", SubscriptBox[\"K\", \"ma\"]}], \"+\", 
RowBox[{\"A\", \" \", SubscriptBox[\"K\", \"mb\"]}], \"+\", FractionBox[
RowBox[{
RowBox[{\"(\", 
RowBox[{
RowBox[{\"P\", \" \", 
RowBox[{\"(\", 
RowBox[{\"1\", \"+\", FractionBox[\"A\", SubscriptBox[\"K\", \"ia\"]]}], \")\"}]}], \"+\", SubscriptBox[\"K\", \"mp\"]}], \")\"}], \" \", SubscriptBox[\"V\", \"f\"]}], 
RowBox[{SubscriptBox[\"K\", \"eq\"], \" \", SubscriptBox[\"V\", \"r\"]}]]}]]\) ."


ordbbr::usage="ordbbr[A, B, P, Q, \!\(\*SubscriptBox[\"V\", \"f\"]\), \!\(\*SubscriptBox[\"V\", \"r\"]\), \!\(\*SubscriptBox[\"K\", \"mA\"]\),\!\(\*SubscriptBox[\"K\", \"mB\"]\), \!\(\*SubscriptBox[\"K\", \"mP\"]\), \!\(\*SubscriptBox[\"K\", \"mQ\"]\), \!\(\*SubscriptBox[\"K\", \"iA\"]\),  \!\(\*SubscriptBox[\"K\", \"iB\"]\), \!\(\*SubscriptBox[\"K\", \"iP\"]\), \!\(\*SubscriptBox[\"K\", \"eq\"]\)] is a predefined rate for Ordered Bi-Bi Kinetics. The rate law returned is \!\(\*FractionBox[
RowBox[{
RowBox[{\"(\", 
RowBox[{
RowBox[{\"A\", \" \", \"B\"}], \"-\", 
RowBox[{\"PQ\", \"/\", SubscriptBox[\"K\", \"eq\"]}]}], \")\"}], \" \", SubscriptBox[\"V\", \"f\"]}], 
RowBox[{
RowBox[{\"A\", \" \", \"B\", \" \", 
RowBox[{\"(\", 
RowBox[{\"1\", \"+\", 
RowBox[{\"P\", \"/\", SubscriptBox[\"K\", \"iP\"]}]}], \")\"}]}], \"+\", 
RowBox[{\"B\", \" \", SubscriptBox[\"K\", \"mA\"]}], \"+\", 
RowBox[{
RowBox[{\"(\", 
RowBox[{\"A\", \"+\", SubscriptBox[\"K\", \"iA\"]}], \")\"}], \" \", SubscriptBox[\"K\", \"mB\"]}], \"+\", SubscriptBox[\"K\", \"1\"]}]]\) where \!\(\*SubscriptBox[\"K\", \"1\"]\)=(\!\(\*SubscriptBox[\"V\", \"f\"]\)/(\!\(\*SubscriptBox[\"K\", \"eq\"]\)\!\(\*SubscriptBox[\"V\", \"r\"]\)))(Q \!\(\*SubscriptBox[\"K\", \"2\"]\)+P (1+A/\!\(\*SubscriptBox[\"K\", \"iA\"]\)) \!\(\*SubscriptBox[\"K\", \"mQ\"]\)) and \!\(\*SubscriptBox[\"K\", \"2\"]\)=(1+P (1+B/\!\(\*SubscriptBox[\"K\", \"iB\"]\))+\!\(\*SubscriptBox[\"BK\", \"mA\"]\)/(\!\(\*SubscriptBox[\"K\", \"iA\"]\)\!\(\*SubscriptBox[\"K\", \"mB\"]\))) \!\(\*SubscriptBox[\"K\", \"mP\"]\)."


ppbr::usage="ppbr[A, B, P, Q, \!\(\*SubscriptBox[\"V\", \"f\"]\),\!\(\*SubscriptBox[\"V\", \"r\"]\), \!\(\*SubscriptBox[\"K\", \"ma\"]\), \!\(\*SubscriptBox[\"K\", \"mb\"]\), \!\(\*SubscriptBox[\"K\", \"mp\"]\), \!\(\*SubscriptBox[\"K\", \"mq\"]\), \!\(\*SubscriptBox[\"K\", \"ia\"]\),\!\(\*SubscriptBox[\"K\", \"iq\"]\), \!\(\*SubscriptBox[\"K\", \"eq\"]\)] is a predefined rate for Ping-Pong Bi-Bi Kinetics. The rate law returned is \!\(\*FractionBox[
RowBox[{
RowBox[{\"(\", 
RowBox[{
RowBox[{\"A\", \" \", \"B\"}], \"-\", FractionBox[
RowBox[{\"P\", \" \", \"Q\"}], SubscriptBox[\"K\", \"eq\"]]}], \")\"}], \" \", SubscriptBox[\"V\", \"f\"]}], 
RowBox[{
RowBox[{\"A\", \" \", \"B\"}], \"+\", 
RowBox[{\"B\", \" \", 
RowBox[{\"(\", 
RowBox[{\"1\", \"+\", FractionBox[\"Q\", SubscriptBox[\"K\", \"iq\"]]}], \")\"}], \" \", SubscriptBox[\"K\", \"ma\"]}], \"+\", 
RowBox[{\"A\", \" \", SubscriptBox[\"K\", \"mb\"]}], \"+\", FractionBox[
RowBox[{
RowBox[{\"(\", 
RowBox[{
RowBox[{\"Q\", \" \", 
RowBox[{\"(\", 
RowBox[{\"P\", \"+\", SubscriptBox[\"K\", \"mp\"]}], \")\"}]}], \"+\", 
RowBox[{\"P\", \" \", 
RowBox[{\"(\", 
RowBox[{\"1\", \"+\", FractionBox[\"A\", SubscriptBox[\"K\", \"ia\"]]}], \")\"}], \" \", SubscriptBox[\"K\", \"mq\"]}]}], \")\"}], \" \", SubscriptBox[\"V\", \"f\"]}], 
RowBox[{SubscriptBox[\"K\", \"eq\"], \" \", SubscriptBox[\"V\", \"r\"]}]]}]]\)."


setEcho::usage="";
hideEcho::usage="";


newModel::usage="newModel[options] resets all counters and variables used by the MathSBML Model Builder. If any previous model has been constructed using add_ functions, it is erased.\nnewModel[x,options], where x is an identifier or string, is interpreted as newModel[id->x, options].\nOptions include:\nid->string, model id\nname->string, model name\nnotes->string, model notes\ncomments->string, comments to add to beginning of file."<>"\ncreator\[Rule]{family, given, email, org} data for MIRIAM creator annotation. Overrides MIRIAM` options\nMIRIAM`Given\[Rule]string\nMIRIAM`Family\[Rule]string\nMIRIAM`EMAIL\[Rule]string\nMIRIAM`Orgname\[Rule]string";


reactionToSBML::usage="reactionToSBML[options] returns the SBML for a <reaction.../>.\nreactionToSBML[r,options] is identical to reactionToSBML[reaction-> r, options].\nreactionToSBML[{{options},{options},...}] returns a <listOfReactions.../>, where each option list describes a different reaction. Alternatively the first argument in any option list may be a reaction, which in this case does not have be preceded by the reaction keyword.\n\nEach {options} is either {optionList} or {reaction, optionList}, where reaction has the form \!\(\*SubscriptBox[\"\[CapitalSigma]e\", \"i\"]\)\!\(\*SubscriptBox[\"r\", \"i\"]\)->\!\(\*SubscriptBox[\"\[CapitalSigma]s\", \"i\"]\)\!\(\*SubscriptBox[\"p\", \"i\"]\). If any option list does not have either the reactions option or at least one the reactants or products options,the first element in options is assumed to be a rule describing the reaction.\n\nAvailable Options:\n"<>
"reaction->(\!\(\*SubscriptBox[\"\[CapitalSigma]e\", \"i\"]\)\!\(\*SubscriptBox[\"r\", \"i\"]\)->\!\(\*SubscriptBox[\"\[CapitalSigma]s\", \"i\"]\)\!\(\*SubscriptBox[\"p\", \"i\"]\)), where \!\(\*SubscriptBox[\"r\", \"i\"]\) and \!\(\*SubscriptBox[\"p\", \"i\"]\) are names of of reactants and products; and \!\(\*SubscriptBox[\"e\", \"i\"]\) and \!\(\*SubscriptBox[\"s\", 
RowBox[{\"i\", \" \"}]]\)are the corresponding stoichiometry expressions. The stoichiometry expressions must be either a number or have the form Stoichiometry[expr] where expr is any expression. If the option reaction is used then the options reactants, products, reactantStoichiometry, and productStoichiometry are ignored.\n"<>
"id \[Rule]string - required reaction identifier, no default\n"<>"name\[Rule] string - reaction name.\n"<>"reactants\[Rule] {} (none, default), r,  or {\!\(\*SubscriptBox[\"r\", \"1\"]\), \!\(\*SubscriptBox[\"r\", \"2\"]\), ....}, names of reactants. This option is ignored if the option reaction is used.\n"<>
"products\[Rule] {} (none, default), p,  or {\!\(\*SubscriptBox[\"p\", \"1\"]\), \!\(\*SubscriptBox[\"p\", \"2\"]\), ....}, names of products. This option is ignored if the option reaction is used.\n"<>
"modifiers\[Rule] {} (none, default), m,  or {\!\(\*SubscriptBox[\"m\", \"1\"]\), \!\(\*SubscriptBox[\"m\", \"2\"]\), ....}, names of modifiers\n"<>
"reactantStoichiometry\[Rule]integer, expression, {\!\(\*SubscriptBox[\"e\", \"1\"]\),\!\(\*SubscriptBox[\"e\", \"2\"]\),..}, where  \!\(\*SubscriptBox[\"e\", \"j\"]\) is any expression. The stoichiometries are listed in the same order as the names of the reactants. If fewer stoichiometries then reactants are specified the remaining reactants are assigned a stoichiometry of 1. . This option is ignored if the option reaction is used.\n"<>
"productStoichiometry\[Rule]integer, expression, {\!\(\*SubscriptBox[\"e\", \"1\"]\),\!\(\*SubscriptBox[\"e\", \"2\"]\),..}, where  \!\(\*SubscriptBox[\"e\", \"j\"]\) is any expression. The stoichiometries are listed in the same order as the names of the products. If fewer stoichiometries then producrts are specified the remaining products are assigned a stoichiometry of 1.. This option is ignored if the option reaction is used. \n"<>"kineticLaw\[Rule] any expression (no default); if no kinetic law is specified, none is included in the SBML; alternatively, kineticLaw\[Rule]{\"math\"\[Rule]expression, \"annotation\"\[Rule]list of symbolic XML containing annotations.\n"<>"parameters->{\!\(\*SubscriptBox[\"i\", \"1\"]\)\[Rule]\!\(\*SubscriptBox[\"o\", \"1\"]\),\!\(\*SubscriptBox[\"i\", \"2\"]\)\[Rule]\!\(\*SubscriptBox[\"o\", \"3\"]\),...}, where \!\(\*SubscriptBox[\"i\", \"1\"]\),\!\(\*SubscriptBox[\"i\", \"2\"]\),... are the ids of the parameters, and \!\(\*SubscriptBox[\"o\", \"1\"]\),\!\(\*SubscriptBox[\"o\", \"2\"]\),... are option lists of the form {name\[Rule]\!\(\*SubscriptBox[\"v\", \"1\"]\),value\[Rule]\!\(\*SubscriptBox[\"v\", \"2\"]\), units\[Rule]\!\(\*SubscriptBox[\"v\", \"3\"]\), constant\[Rule]\!\(\*SubscriptBox[\"v\", \"4\"]\), annotation\[Rule]\!\(\*SubscriptBox[\"v\", \"5\"]\)}, or any subset thereof, where \!\(\*SubscriptBox[\"v\", \"1\"]\),etc., are the values of the name, value, units and constant field.\n"<>"reversible\[Rule]True\nfast\[Rule]False\n\nExample:\nreactionToSBML[reaction\[Rule] (A+2B\[Rule] C),kineticLaw\[Rule] k*A*B,parameters\[Rule] {k\[Rule] {value\[Rule] 12,name\[Rule] \"Rate Constant\"}}]\n\n"<>"<reaction id=\"reaction2\"\n    name=\"reaction2\"\n    reversible=\"true\"\n    fast=\"false\">\n <listOfReactants>\n  <speciesReference species=\"A\"/>\n  <speciesReference species=\"B\">\n   <math xmlns=\"http://www.w3.org/1998/Math/MathML\">\n    <cn type=\"integer\">2</cn>\n   </math>\n  </speciesReference>\n </listOfReactants>\n <listOfProducts>\n  <speciesReference species=\"C\"/>\n </listOfProducts>\n <listOfModifiers/>\n <kineticLaw timeUnits=\"time\"\n     substanceUnits=\"substance\">\n  <math xmlns=\"http://www.w3.org/1998/Math/MathML\">\n   <apply>\n    <times/>\n    <ci>A</ci>\n    <ci>B</ci>\n    <ci>k</ci>\n   </apply>\n  </math>\n  <listOfParameters>\n   <parameter id=\"k\"\n       value=\"12\"\n       name=\"Rate Constant\"/>\n  </listOfParameters>\n </kineticLaw>\n</reaction>";


speciesToSBML::usage="speciesToSBML[options] returns an SBML <species ... /> definition\nspeciesToSBML[x,options], where x is an identifier or string, is interpreted as speciesToSBML[id->x,options]\n"<>"speciesToSBML[{{options}, {options},...}] returns an SBML <listOfSpecies .../> block for a set of species described by the option lists.\n"<>"Options have the same names as the SBML fields for species: id, name, metaid, compartment, initialAmount, initialConcentration, units, boundaryCondition, charge, constant, annotation, notes. If both a concentration and an amount are given, the first one in the option list is assumed to be the correct one."<>
"\n\nThe following PROPOSED LEVEL 3 option is allowed if Arrays->True is set by an call to newModel[]:\nArrayDimensions->{i->{min,max},j->{min,max},...} or {} (default)."<>
"\n\n\!\(\*
StyleBox[\"Example\",\nFontVariations->{\"Underline\"->True}]\)\!\(\*
StyleBox[\" \",\nFontVariations->{\"Underline\"->True}]\)\!\(\*
StyleBox[\"1\",\nFontVariations->{\"Underline\"->True}]\)\!\(\*
StyleBox[\" \",\nFontVariations->{\"Underline\"->True}]\)\!\(\*
StyleBox[\"(\",\nFontVariations->{\"Underline\"->True}]\)\!\(\*
StyleBox[\"single\",\nFontVariations->{\"Underline\"->True}]\)\!\(\*
StyleBox[\" \",\nFontVariations->{\"Underline\"->True}]\)\!\(\*
StyleBox[\"species\",\nFontVariations->{\"Underline\"->True}]\)\!\(\*
StyleBox[\")\",\nFontVariations->{\"Underline\"->True}]\):\n\n"<>"speciesToSBML[id\[Rule] \"fred\", name\[Rule] \"Fred Flintstone\", compartment\[Rule] \"bedrock\" , boundaryCondition\[Rule] \"false\", constant\[Rule] \"true\", initialConcentration\[Rule]5, units\[Rule] \"rocks\" , charge\[Rule]17]\n\n"<>"returns the string\n\n"<>"<species id=\"fred\" name=\"Fred Flintstone\" compartment=\"bedrock\" boundaryCondition=\"false\" constant=\"true\" initialConcentration=\"5\" units=\"rocks\" charge=\"17\"/>"<>"\n\n\!\(\*
StyleBox[\"Example\",\nFontVariations->{\"Underline\"->True}]\)\!\(\*
StyleBox[\" \",\nFontVariations->{\"Underline\"->True}]\)\!\(\*
StyleBox[\"2\",\nFontVariations->{\"Underline\"->True}]\)\!\(\*
StyleBox[\" \",\nFontVariations->{\"Underline\"->True}]\)\!\(\*
StyleBox[\"(\",\nFontVariations->{\"Underline\"->True}]\)\!\(\*
StyleBox[\"multiple\",\nFontVariations->{\"Underline\"->True}]\)\!\(\*
StyleBox[\" \",\nFontVariations->{\"Underline\"->True}]\)\!\(\*
StyleBox[\"species\",\nFontVariations->{\"Underline\"->True}]\)\!\(\*
StyleBox[\")\",\nFontVariations->{\"Underline\"->True}]\):\n\n"<>"speciesToSBML[{{id\[Rule] \"fred\", compartment\[Rule] \"bedrock\"}, {id\[Rule] \"barney\",compartment\[Rule] \"bedrock\"}}]\n\nreturns the string\n\n"<>"<listOfSpecies>\n <species id=\"fred\"\n     name=\"fred\"\n     compartment=\"bedrock\"\n     boundaryCondition=\"false\"\n     constant=\"false\"/>\n <species id=\"barney\"\n     name=\"barney\"\n     compartment=\"bedrock\"\n     boundaryCondition=\"false\"\n     constant=\"false\"/>\n</listOfSpecies>";


speciesTypeToSBML::usage="speciesTypeToSBML[options] returns the SBML for a speciesType. Options include:"<>"\nid->Sid\nname->optional string."


functionToSBML::usage="functionToSBML[options] returns an SBML string for a <functionDefinition ... /> definition.\n"<>"functionToSBML[{{options}, {options},...}] returns an SBML string for a <listOfFunctionDefinitions ... />\n\nOptions:\narguments\[Rule]x or {\!\(\*SubscriptBox[\"x\", \"1\"]\),\!\(\*SubscriptBox[\"x\", \"2\"]\),...}, names of the function arguments. At least one argument must be supplied. If no arguments are given a single dummy argument will be generated.\nid\[Rule]string, value of SBML id field; if not specified, a name functionk, where k is an incrementing integer, will be supplied.\nmetaid->string,if different from \"\" the metaid will be assigned to the value of the given string.\nmath\[Rule]expression, Mathematica expression for the function return value in terms of the arguments. If not specified, the value of 1 will be returned.\nname\[Rule]string, value of SBML name field if not specified, the value of the id field will be used.\n\nExample 1, <functionDefinition ...>:\n\nfunctionToSBML[id\[Rule] alfafa, arguments\[Rule] {horse, grass}, math\[Rule] ( 1/(horse*grass))]\n\nreturns the string:\n\n"<>"<functionDefinition id=\"alfafa\"\n    name=\"alfafa\">\n <math xmlns=\"http://www.w3.org/1998/Math/MathML\">\n  <lambda>\n   <bvar>\n    <ci>horse</ci>\n   </bvar>\n   <bvar>\n    <ci>grass</ci>\n   </bvar>\n   <apply>\n    <times/>\n    <cn type=\"integer\">1</cn>\n    <apply>\n     <power/>\n     <apply>\n      <times/>\n      <ci>grass</ci>\n      <ci>horse</ci>\n     </apply>\n     <cn type=\"integer\">-1</cn>\n    </apply>\n   </apply>\n  </lambda>\n </math>\n</functionDefinition>"<>"\n\nExample 2, <listOfFunctionDefintions ...>\n\n"<>"functionToSBML[{{id\[Rule] QRT,arguments\[Rule] {x}, math\[Rule] x^(1/4)},{id\[Rule] sinc, arguments\[Rule] {x}, math\[Rule] Sin[x]/x}}]"<>"\n\nreturns the string:\n\n"<>"<listOfFunctionDefinitions>\n <functionDefinition id=\"QRT\"\n     name=\"QRT\">\n  <math xmlns=\"http://www.w3.org/1998/Math/MathML\">\n   <lambda>\n    <bvar>\n     <ci>x</ci>\n    </bvar>\n    <apply>\n     <power/>\n     <ci>x</ci>\n     <cn type=\"rational\">1<sep/>4</cn>\n    </apply>\n   </lambda>\n  </math>\n </functionDefinition>\n <functionDefinition id=\"sinc\"\n     name=\"sinc\">\n  <math xmlns=\"http://www.w3.org/1998/Math/MathML\">\n   <lambda>\n    <bvar>\n     <ci>x</ci>\n    </bvar>\n    <apply>\n     <times/>\n     <apply>\n      <sin/>\n      <ci>x</ci>\n     </apply>\n     <apply>\n      <power/>\n      <ci>x</ci>\n      <cn type=\"integer\">-1</cn>\n     </apply>\n    </apply>\n   </lambda>\n  </math>\n </functionDefinition>\n</listOfFunctionDefinitions>";
 


unitToSBML::usage="unitToSBML[options] returns an SBML <unitDefinition .../>.\nunitToSBML[x,options], where x is an identifier or string, is the same as unitToSBML[id->x,options].\nunitToSBML[{{options},{options},...}] returns a <listOfUnitDefinitions ...> where each sub-option list corresponds to the option list of the first form.\nOptions:\nid->no default, value of id field of unitDefiniton, if not specified, supplied by program as unitn, where n is an integer\nname->no default, if not supplied, value of id  is used\nunit->{}, contains an option list of the form \"string\"->{scale->0, exponent->1, multiplier->1, offset->1}, where \"string\" is a quote-delimited string indicated the value of the kind field of the <unit ...> expression.\n\nExample:\n\nunitToSBML[id\[Rule] \"mmlh\",name\[Rule] \"millimoles_per_liter_per_hour\",unit\[Rule] {\"mole\"\[Rule] {scale\[Rule] -3}, \"litre\"\[Rule] {exponent\[Rule] -1}, \"second\"\[Rule] {multiplier\[Rule] 0.000277778, exponent\[Rule] -1}}]";


compartmentToSBML::usage="compartmentToSBML[options] returns a <compartment .../>\ncompartmentToSBML[x, options], where x is an identifier or string, is the same as compartmentToSBML[id->x,options]\ncompartmentToSBML[{{options},{options},...}] returns a <listOfCompartments .../> where each option list corresponds to a single <compartment .../> definition.\nOptions are the same as valid compartment fields: id, name, spatialDimensions, size, untis, outside, constant. Default values are set as per the SBML Level 2 spec."<>"\n\nThe following PROPOSED LEVEL 3 option is allowed if Arrays->True is set by an call to newModel[]:\nArrayDimensions->{i->{min,max},j->{min,max},...} or {} (default)."<>"\n\nExample:\n\ncompartmentToSBML[id\[Rule] \"bedrock\", size\[Rule] \"40000\"]\n\nreturns the string:\n\<compartment id=\"bedrock\" name=\"bedrock\" size=\"40000\"/>\n\nThe input:\n\ncompartmentToSBML[{{id\[Rule] \"c1\",size\[Rule] 5},{id\[Rule] \"c2\",spatialDimensions\[Rule] 2},{id\[Rule] \"c3\",name\[Rule] \"unsized_compartment_3\"}}]\n\nreturns the string:\n\n<listOfCompartments>\n <compartment id=\"c1\"\n     name=\"c1\"\n     size=\"5\"/>\n <compartment id=\"c2\"\n     name=\"c2\"\n     spatialDimensions=\"2\"/>\n <compartment id=\"c3\"\n     name=\"unsized_compartment_3\"/>\n</listOfCompartments>";

setCompartment::usage="setCompartment[name] sets the current compartment to name in the model builder. \nAny subsequent call to addSpecies that specifies a compartment will override this setting.\nAll subsequent calls to addSpecies, until the option compartment is used, will place the species in compartment \"name\".\nsetCompartment[Null] will clear the compartment name stack. The result will be that subsequent species will be added to the first compartment of the model."


initialAssignmentToSBML::usage="initialAssignmentToSBML[options] returns the SBML for an <initiaAssignment>...<../> object. Options are: symbol, math, SBOTerm, metaid, notes, annotation."



compartmentTypeToSBML::usage="compartmentTypeToSBML[options] returns the SBML for a compartmentTYPE. Options include:"<>"\nid->Sid\nname->optional string."


parameterToSBML::usage="parameterToSBML[options] returns a <parameter.../> definition.\nparameterToSBML[x,options], where x is an identifier or string, is interpreted as parameterToSBML[id->x,options].\nparameterToSBML[id\[Rule]value] can be used if value is a number (name will be set to id).\nparameterToSBML[{{options},{options},...}] returns a <listOfParameters.../> where each option list corresponds to a single <parameter.../> definiton. Options are identical to those for a parameter: id, name, value, units, constant."<>"\n\nThe following PROPOSED LEVEL 3 options are allowed if Arrays->True is set by an call to newModel[]:\nArrayDimensions->{i->{min,max},j->{min,max},...} or {} (default).\nforeach->name of compartment array for implied parameter array."<>"\n\nExample:\n\nparameterToSBML[id\[Rule] \"Pi\", name\[Rule] \"pi\",  value\[Rule] 3.14]\n\nreturns\n\n<parameter id=\"Pi\" name=\"pi\" value=\"3.14\"/>\n\nparameterToSBML[{{id\[Rule]\"pi\", value->3.14}, {id\[Rule]\"e\",value\[Rule]2.718}, {id\[Rule]\"E\",name\[Rule]\"Enzyme_Concentration\",constant\[Rule]\"false\",value\[Rule]1}}]\n\nreturns\n\n<listOfParameters>\n <parameter id=\"pi\"\n     name=\"pi\"\n     value=\"3.14\"/>\n <parameter id=\"e\"\n     name=\"e\"\n     value=\"2.718\"/>\n <parameter id=\"E\"\n     name=\"Enzyme_Concentration\"\n     value=\"1\"\n     constant=\"false\"/>\n</listOfParameters>";


ruleToSBML::usage="ruleToSBML[options] returns a rule definition.\nruleToSBML[x, options] is the same as ruleToSBML[id->x,options].\nruleToSBML[{{options},{options},...}] returns a <listOfRules.../>, where each option list corresponds to a separate rule.\n\nOptions:\nid-> Optional identifier to ading the rule. Since SBML does not define an \"id\" field for rules, ids are placed as a metaid within the rule definition.\ntype->algebraicRule,assignmentRule,or rateRule (no default)\nvariable->name of variable (variable n) if not specified.\nmath->formula for the rule."<>"\n\nThe following PROPOSED LEVEL 3 options are allowed if Arrays->True is set by an call to newModel[]:\nArrayDimensions->{i->{min,max},j->{min,max},...} or {} (default).\nvariableLInk->{variable->{index1,index2,...}} or {} (default). If variableLink is specified then the variable field is ignored.\nruleToSBML[type->initialAssignmentRule,variableLink->{x->i},ArrayDimensions->{i->{1,3}},data->{5,10,15}] for a vector, assigns the data {5,10,15} to the vector x with an index of i that runs from 1 to 3\nruleToSBML[type->initialAssignmentRule,variableLink->{x->{i,j}},ArrayDimensions->{i->{1,3},j->{1,3}, data->{{5,10,15},{20,25,30},{35,40,50}}] for a matrix, assigns the data to a matrix with indices i and j that each run from 1 to 3."<>"\n\nExample 1: ruleToSBML[type\[Rule] assignmentRule, variable\[Rule] x, math\[Rule] x+y]\nreturns:\n<assignmentRule variable=\"x\">\n <math xmlns=\"http://www.w3.org/1998/Math/MathML\">\n  <apply>\n   <plus/>\n   <ci>x</ci>\n   <ci>y</ci>\n  </apply>\n </math>\n</assignmentRule>\n\nExample2:\nruleToSBML[{{type->\"algebraicRule\",math->x^2}, {type->\"rateRule\",variable->y,math->2*x}}]\nreturns:\n<listOfRules>\n <algebraicRule>\n  <math xmlns=\"http://www.w3.org/1998/Math/MathML\">\n   <apply>\n    <power/>\n    <ci>x</ci>\n    <cn type=\"integer\">2</cn>\n   </apply>\n  </math>\n </algebraicRule>\n <rateRule variable=\"y\">\n  <math xmlns=\"http://www.w3.org/1998/Math/MathML\">\n   <apply>\n    <times/>\n    <cn type=\"integer\">2</cn>\n    <ci>x</ci>\n   </apply>\n  </math>\n </rateRule>\n</listOfRules>";


constraintToSBML::usage="constraintToSBML[options] returns the SBML for a <constraint>...<../> object. Options are: message, math, SBOTerm, metaid, notes, annotation."


eventToSBML::usage="eventToSBML[options] returns a single <event.../> definition.\neventToSBML[{{options},{options},...}] returns a <listOfEvents.../>, where each option list corresponds to a single event.\n\nOptions:\nid\[Rule]event id, if not provided, defaults to eventn where n is an integer.\nname\[Rule]event name, if not provided, defaults to value of event.\ntrigger->expression, required,any Mathematica expression that evaluates to True or False.\ndelay->expression, optional, any expression that evaluates to a number.\ntimeUnits->units, optional units to use for time.\neventAssignment->{\!\(\*SubscriptBox[\"var\", \"1\"]\)\[Rule]\!\(\*SubscriptBox[\"expr\", \"1\"]\),\!\(\*SubscriptBox[\"var\", \"2\"]\)\[Rule]\!\(\*SubscriptBox[\"expr\", \"2\"]\),...}, what should happen when the event is triggered, each variable \!\(\*SubscriptBox[\"var\", \"i\"]\) is assigned to the value of expression \!\(\*SubscriptBox[\"expr\", \"i\"]\).\n\nExample 1: single event:\neventToSBML[id\[Rule]\"foo\", name\[Rule]\"A basic event\", timeUnits\[Rule] \"hours\",trigger\[Rule] (x>5), eventAssignment\[Rule] {x\[Rule] y+x, y\[Rule] 0}]\nreturns:\n<event id\"foo\" name=\"A basic event\" timeUnits=\"hours\">\n <trigger>\n  <math xmlns=\"http://www.w3.org/1998/Math/MathML\">\n   <apply>\n    <gt/>\n    <ci>x</ci>\n    <cn>5</cn>\n   </apply>\n  </math>\n </trigger>\n <listOfEventAssignments>\n  <eventAssignment variable=\"x\">\n   <math xmlns=\"http://www.w3.org/1998/Math/MathML\">\n    <apply>\n     <plus/>\n     <ci>x</ci>\n     <ci>y</ci>\n    </apply>\n   </math>\n  </eventAssignment>\n  <eventAssignment variable=\"y\">\n   <math xmlns=\"http://www.w3.org/1998/Math/MathML\">\n    <cn>0</cn>\n   </math>\n  </eventAssignment>\n </listOfEventAssignments>\n</event>\n\nExample 2: listOfEvents:\neventToSBML[{{id\[Rule]\"yon\", name\[Rule]\"y turned on\", trigger\[Rule] x>17, eventAssignment\[Rule]{y\[Rule]0, z\[Rule]100}}, {id\[Rule]\"yoff\",name\[Rule]\"y turned off\", trigger\[Rule]x>20, eventAssignment\[Rule]{y\[Rule]100, z\[Rule]0}}}]\n\nreturns:\n<listOfEvents>\n <event id=\"yon\" name=\"y turned on\">\n  <trigger>\n   <math xmlns=\"http://www.w3.org/1998/Math/MathML\">\n    <apply>\n     <gt/>\n     <ci>x</ci>\n     <cn>17</cn>\n    </apply>\n   </math>\n  </trigger>\n  <listOfEventAssignments>\n   <eventAssignment variable=\"y\">\n    <math xmlns=\"http://www.w3.org/1998/Math/MathML\">\n     <cn>0</cn>\n    </math>\n   </eventAssignment>\n   <eventAssignment variable=\"z\">\n    <math xmlns=\"http://www.w3.org/1998/Math/MathML\">\n     <cn>100</cn>\n    </math>\n   </eventAssignment>\n  </listOfEventAssignments>\n </event>\n <event id=\"yoff\" name=\"y turned off\">\n  <trigger>\n   <math xmlns=\"http://www.w3.org/1998/Math/MathML\">\n    <apply>\n     <gt/>\n     <ci>x</ci>\n     <cn>20</cn>\n    </apply>\n   </math>\n  </trigger>\n  <listOfEventAssignments>\n   <eventAssignment variable=\"y\">\n    <math xmlns=\"http://www.w3.org/1998/Math/MathML\">\n     <cn>100</cn>\n    </math>\n   </eventAssignment>\n   <eventAssignment variable=\"z\">\n    <math xmlns=\"http://www.w3.org/1998/Math/MathML\">\n     <cn>0</cn>\n    </math>\n   </eventAssignment>\n  </listOfEventAssignments>\n </event>\n</listOfEvents>";


reactionToSymbolicSBML::usage="reactionToSymbolicSBML returns Symbolic SBML for a reaction or listOfReactions. Usage is identical to reactionToSBML.";
speciesToSymbolicSBML::usage="speciesToSymbolicSBML returns Symbolic SBML for a species or listOfSpecies. Usage is identical to speciesToSBML.";
speciesTypeToSymbolicSBML::usage="speciesTypeToSymbolicSBML returns Symbolic SBML for a speciesType or listOfSpeciesTypes. Usage is identical to speciesTypeToSBML.";
functionToSymbolicSBML::usage="functionToSymbolicSBML returns Symbolic SBML for a function or listOfFunctions. Usage is identical to functionToSBML.";
unitToSymbolicSBML::usage="unitToSymbolicSBML returns Symbolic SBML for a unit or a listOfUnits. Usage is identical to unitToSBML.";
compartmentToSymbolicSBML::usage="compartmentToSymbolicSBML returns Symbolic SBML for a compartment or listOfCompartments. Usage is identical to compartmentToSBML.";
compartmentTypeToSymbolicSBML::usage="compartmentTypeToSymbolicSBML returns Symbolic SBML for a compartmentType or listOfcompartmentTypes. ";
parameterToSymbolicSBML::usage="parameterToSymbolicSBML returns Symbolic SBML for a parameter or listOfParameters. Usage is identical to parameterToSBML.";
ruleToSymbolicSBML::usage="ruleToSymbolicSBML returns Symbolic SBML for a rule or listOfRules. Usage is identical to ruleToSBML.";
constraintToSymbolicSBML::usage="constraintToSymbolicSBML[options] returns the symbolic SBML for a <constraint>...<../> object. Options are: message, math, SBOTerm, metaid, notes, annotation."
eventToSymbolicSBML::usage="eventToSymbolicSBML returns Symbolic SBML for an event or a listOfEvents. Usage is identical to eventToSBML.";
initialAssignmentToSymbolicSBML::usage="initialAssignmentToSymbolicSBML returns Symbolic SBML for an initialAssignment. Usage is idential to initialAssignmentToSBML";



getObjectAttribute::usage="getObjectAttribute[object, attribute, number]\nobject is an sbml object such as \"species\", and attribute is one of its attributes, such as \"id\" or \"name\", e.g., getObjectAttribute[\"compartment\", \"size\", 1]. The value returned will always be a string because it is coming from xml.";
getObjectID::usage="getObjectID[sbmlobject, n] returns the ID of the nth SBML object sbmlobject, e.g., getObjectID[\"species\", 2]. The value returned will always be a string because it is coming from xml.";
getObjectIDs::usage="getObjectIds[ojbect]"; 

getObjectName::usage="getObjectName[sbmlobject, n] returns the name of the nth SBML object sbmlobject, e.g., getObjecName[\"species\", 3].  The value returned will always be a string because it is coming from xml.";
getObjectNames::usage="getObjectNames[object]"; 
 
getNumberOfObjects::usage="getNumberOfObjects[object] where object is a string such as \"compartment\""; 

getCompartmentID::usage="getCompartmentID[number]";
getEventID::usage="getEventID[number]";
getFunctionID::usage="getFunctionID[number]";
getParameterID::usage="getParameterID[number]";
getRuleID::usage="getRuleID[number]";
getSpeciesID::usage="getSpeciesID[number]";
getUnitID::usage="getUnitID[number]";
getSpeciesTypeID::usage="getSpeciesTypeID[number]";
getCompartmentTypeID ::usage="getCompartmentTypeID[number]";
getConstraintID::usage="getConstraintID[number]";
getInitialAssignmentID::usage="getInitialAssignmentID[number]";

getCompartmentName::usage="getCompartmentName[number]";
getEventName::usage="getEventName[number]";
getFunctionName::usage="getFunctionName[number]";
getParameterName::usage="getParameterName[number]";
getRuleName::usage="getRuleName[number]";
getSpeciesName::usage="getSpeciesName[number]";
getUnitName::usage="getUnitName[number]";
getSpeciesTypeName::usage="getSpeciesTypeName[number]";
getCompartmentTypeName::usage="getCompartmentTypeName[number]";
getConstraintName::usage="getConstraintName[number]";
getInitialAssignmentName::usage="getInitialAssignmentName[number]";

getCompartmentNames::usage="getCompartmentNames[]";
getEventNames::usage="getEventNames[]";
getFunctionNames::usage="getFunctionNames[]";
getParameterNames::usage="getParameterNames[]";
getRuleNames::usage="getRuleNames[]";
getSpeciesNames::usage="getSpeciesNames[]";
getUnitNames::usage="getUnitNames[]";
getSpeciesTypeNames::usage="getSpeciesTypeNames[]";
getCompartmentTypeNames::usage="getCompartmentTypeNames[]";
getConstraintNames::usage="getConstraintNames[]";
getInitialAssignmentNames::usage="getInitialAssignmentNames[]";

getCompartmentIDs::usage="getCompartmentIDs[]";
getEventIDs::usage="getEventIDs[]";
getFunctionIDs::usage="getFunctionIDs[]";
getParameterIDs::usage="getParameterIDs[]";
getRuleIDs::usage="getRuleIDs[]";
getSpeciesIDs::usage="getSpeciesIDs[]";
getUnitIDs::usage="getUnitIDs[]";
getSpeciesTypeIDs::usage="getSpeciesTypeIDs[]";
getCompartmentTypeIDs::usage="getCompartmentTypeIDs[]";
getConstraintIDs::usage="getConstraintIDs[]";
getInitialAssignmentIDs::usage="getInitialAssignmentIDs[]";


getObject::usage="getObject[type,arguments] retrieves the specified object type. See also getObjects.\ntype must be one of the following strings: \"compartment\",\"event\",\"function\",\"parameter\",\"reaction\",\"rule\"\"species\",\"unit\"\narguments may be a single integer, id, or a list of integers and/or ids. ";
getObjectNumber::usage="getObjectNumber[type,arguments] retrieves the number of the specified object type.\ntype must be one of the following strings: \"compartment\",\"event\",\"function\",\"parameter\",\"reaction\",\"rule\"\"species\",\"unit\"\nargument must be a valid sid";
getObjects::usage="getObject[type1,args1,type2,args2,...] returns a list of the specified objects as symbolic XML.  See getObject.\ngetObject[type1\[Rule]arg1,type2\[Rule]arg2,...] returns the objects as a rule list\nexamples:\ngetObject[\"event\",A,\"Species\",B]\ngetObject[\"rule\"\[Rule]{1,3},\"function\"\[Rule]1,\"species\"\[Rule]{x,y,z}]";

replaceObject::usage="";


getReaction::usage="getReaction[x] returns the selected reaction (in symbolic XML) from the model. The argument may be either an SID or an integer n to retrieve the nth reaction in the model.\ngetReaction[{x1,x2,...}] returns the list of reactions x1, x2, ..., which can be specified in any combination of identifying SIDs or integers.";
getNumberOfReactions::usage="getNumberOfReactions returns the number of reactions in the model.";
getReactions::usage="getReactions[] returns all of the reactions in the model.";
getReactionNumber::usage="No information is available about this function at the present time.";
replaceReaction::usage="No information is available about this function at the present time.";



getRule::usage="getRule[x] returns the selected rule (in symbolic XML) from the model. The argument must be an integer n, to retrieve the nth rule in the model, or a list of integers,to retrieve a list of rules.";
getRules::usage="getRules[] returns a list of all the rules in the model.";
getNumberOfRules::usage="getNumberOfRules[] returns the number of rules in the model.";
getRuleNumber::usage="No information is available about this function at the present time.";
replaceRule::usage="No information is available about this function at the present time.";




getConstraint::usage="getConstraint[n] returns the selected Constraint (in symbolic XML) from the model. The argument must be an integer n.";
getConstraints::usage="getConstraints[] returns a list of all the <Constraint> objects in the model (in symbolic SBML).";
getNumberOfConstraints::usage="getNumberOfConstraints[] returns the number of <Constraint> objects in the model.";
getConstraintNumber::usage="No information is available about this function at the present time.";
replaceConstraint::usage="No information is available about this function at the present time.";
addConstraint::usage="No information is available about this function at the present time.";
removeConstraint::usage="No information is available about this function at the present time.";
modifyConstraint::usage="No information is available about this function at the present time.";


getInitialAssignment::usage="getInitialAssignment[n] returns the selected initialAssignment (in symbolic XML) from the model. The argument must be an integer n or an SID referring to the symbol field of the initialAssignment.";
getInitialAssignments::usage="getInitialAssignments[] returns a list of all the <initialAssignment> objects in the model (in symbolic SBML).";
getNumberOfInitialAssignments::usage="getNumberOfInitialAssignments[] returns the number of <initialAssignment> objects in the model.";
getInitialAssignmentNumber::usage="No information is available about this function at the present time.";
replaceInitialAssignment::usage="No information is available about this function at the present time.";
addInitialAssignment::usage="No information is available about this function at the present time.";
removeInitialAssignment::usage="No information is available about this function at the present time.";
modifyInitialAssignment::usage="No information is available about this function at the present time.";


getCompartment::usage="getCompartment[x] returns the selected compartment (in symbolic XML) from the model. The argument may be either an SID or an integer n to retrieve the nth compartment in the model.\ngetCompartment[{x1,x2,...}] returns the list of compartments x1, x2, ..., which can be specified in any combination of identifying SIDs or integers.";
getNumberOfCompartments::usage="getNumberOfCompartments[] returns the number of compartments in the model";
getCompartments::usage="getCompartments[] returns a list of all the compartments in the model";
getCompartmentNumber::usage="No information is available about this function at the present time.";
replaceCompartment::usage="No information is available about this function at the present time.";


getUnit::usage="getUnit[x] returns the selected unit (in symbolic XML) from the model. The argument may be either an SID or an integer n to retrieve the nth unit in the model.\ngetUnit[{x1,x2,...}] returns the list of unit x1, x2, ..., which can be specified in any combination of identifying SIDs or integers.";
getUnits::usage="getUnits[] returns a list of all the units in the model.";
getNumberOfUnits::usage="getNumberOfUnits[] returns the number of units in the model.";
getUnitNumber::usage="No information is available about this function at the present time.";
replaceUnit::usage="No information is available about this function at the present time.";

getParameter::usage="getParameter[x] returns the selected parameter (in symbolic XML) from the model. The argument may be either an SID or an integer n to retrieve the nth parameter in the model.\ngetParameter[{x1,x2,...}] returns the list of parameters x1, x2, ..., which can be specified in any combination of identifying SIDs or integers.";
getNumberOfParameters::usage="getNumberOfParameters[] returns the number of global parameters in the model";
getParameters::usage="getParameters[] returns a list of all the global parameters in the model.";
getParameterNumber::usage="";
replaceParameter::usage="";

getSpecies::usage="getSpecies[x] returns the selected species (in symbolic XML) from the model. The argument may be either an SID or an integer n to retrieve the nth species in the model.\ngetSpecies[{x1,x2,...}] returns the list of species x1, x2, ..., which can be specified in any combination of identifying SIDs or numbers.\ngetSpecies[] returns a list of all the species in the model.";
getNumberOfSpecies::usage="getNumberOfSpecies[] returns the number of species in the model.";
getSpeciesNumber::usage="No information is available about this function at the present time.";
replaceSpecies::usage="No information is available about this function at the present time.";

getFunction::usage="getFunction[x] returns the selected function (in symbolic XML) from the model. The argument may be either an SID or an integer n to retrieve the nth function in the model.\ngetFunction[{x1,x2,...}] returns the list of functions x1, x2, ..., which can be specified in any combination of identifying SIDs or integers.";
getNumberOfFunctions::usage="getNumberOfFunctions[] returns the number of functions in the model";
getFunctions::usage="getFunctions[] returns a list of all the functions in the model.";
getFunctionNumber::usage="No information is available about this function at the present time.";
replaceFunction::usage="No information is available about this function at the present time.";

getEvent::usage="getEvent[x] returns the selected event (in symbolic XML) from the model. The argument may be either an SID or an integer n to retrieve the nth event in the model.\ngetEvent[{x1,x2,...}] returns the list of events x1, x2, ..., which can be specified in any combination of identifying SIDs or integers.";
getNumberOfEvents::usage="getNumberOfFunctions[] returns the number of events in the model";
getEvents::usage="getFunctions[] returns a list of all the events in the model.";
getEventNumber::usage="No information is available about this function at the present time.";
replaceEvent::usage="No information is available about this function at the present time.";

addSpecies::usage="addSpecies[id, options] adds a species to the current model. Options are the same as speciesToSBML. If the species previously exists, the previous information about it in the model is replaced. If the required compartment is not specified for the species it is assigned to \"Indeterminate.\" If any units are specified for the species and they have not been previously defined in the model or are not predefined units, new units are added to the model without any <unit kind...> information.\naddSpecies[{s1,s2,..}, options] adds the set of species to the model.";

removeSpecies::usage="removeSpecies[id] removes a species from the model.";

addCompartment::usage="addCompartment[id, options] adds a new compartment to the model. Options are the same as compartmentToSBML. If the compartment previously exists, the previous information about it in the model is replaced.";
removeCompartment::usage="removeCompartment[id] removes a compartment from the model. If the compartment contains any species, the compartment may not be removed.";
compartmentCreate::usage="";
compartmentCreateWith::usage="";

addEvent::usage="addEvent[id, options] adds a new event to the model. Options are the same as eventToSBML. If an event with the same id already exists in the model, it will be replaced with the new event.";
removeEvent::usage="removeEvent[id] removes the event from the model.";

addFunction::usage="addFunction[id, options] adds a new function to the model. Options are the same as functionToSBML. If a function with the same id has been previously defined, the old definition is replaced with the new definition.";
removeFunction::usage="removeFunction[id] removes a function from the model.";

addParameter::usage="addParameter[id, options] adds a new parameter to the model. Options are the same as parameterTOSBML. If the parameter has been previously defined, the old definition is replaced with the new definiton.";
removeParameter::usage="removeParameter[id] removes a parameter from the model.";

addReaction::usage="addReaction[reaction, options] adds a reaction to the current model. Options are the same as reactionToSBML. If the id is specified and a reaction with the same id already exists in the model then the previous information about that reaction is replaced. If any of the reactants, products, or modifiers in the reaction have not been previously defined in the model, they are added to compartment \"Indeterminate.\"";
removeReaction::usage="removeReaction[id] removes a reaction from the current model.";

addRule::usage="addRule[options] adds a rule to the current model. Options are the same as ruleToSBML.";
removeRule::usage="removeRule[id] removes a rule from the current model.";

addUnit::usage="addUnit[unit, options] adds a unit to the current model. If a unit by the same name has been previously defined, it is replaced.";
removeUnit::usage="removeUnit[id] removes a unit from the current model. If the unit is referenced by a species or parameter in the model it may not be removed.";

getSpeciesType::usage="gets a speciesType as symbolic SBML by number or name";
getSpeciesTypeNumber::usage="";
getNumberOfSpeciesTypes::usage="getNumberOfSpeciesTypes[] returns the number of speciesTypes that have  been defined in the current model.";
addSpeciesType::usage="addSpeciesType adds a speciesType to the model. Options are the same speciesTypeToSBML";
removeSpeciesType::usage="removeSpeciesType[id] removes a speciesType from the model.";
modifySpeciesType::usage="modifySpeciesType[id, options] modifies a species in the current model.";
replaceSpeciesType::usage="No information is available about this function at the present time.";


getCompartmentType::usage="gets a CompartmentType as symbolic SBML by number or name";
getCompartmentTypeNumber::usage="getCompartmentTypeNumber[id] returns the integer number of the compartmentType with the specified id";
getCompartmentTypes::usage="gets a list of all compartmentTypes as symbolic SBML";
getNumberOfCompartmentTypes::usage="getNumberOfCompartmentTypes[] returns the number of CompartmentTypes that have  been defined in the current model.";
addCompartmentType::usage="addCompartmentType adds a CompartmentType to the model. Options are the same CompartmentTypeToSBML";
removeCompartmentType::usage="removeCompartmentType[id] removes a CompartmentType from the model.";
modifyCompartmentType::usage="modifyCompartmentType[id, options] modifies a Compartment in the current model.";
replaceCompartmentType::usage="No information is available about this function at the present time.";

resetDefaultUnits::usage="resetDefaultUnits[] resets the set of predefined units to the default set in the spec. Some of these units may have been overridden in a model definition.";

createModel::usage="createModel[] returns the SBML text for the current model.\ncreateModel[filename] writes the SBML to a file.\nOptions:\n\"annotations\"\[Rule]True, If False, suppresses all annotations\n\"notes\"\[Rule]True, If False, suppresses all annotations\n\"comments\"\[Rule]True, If False, suppresses all comments.";
createSymbolicModel::usage="createSymbolicModel[] returns Symbolic XML for the current model.";
getModel::usage="getModel[] is the same as createSymbolicModel.";
getSBMLModel::usage="getSBMLModel[] is the same as createModel."

showModel::usage="showModel[] gives a verbose listing of the current model similar to the verbose listing provided by SBMLRead";
dumpModel::usage="dumpModel performs a debugging dumpt of the current model.";
loadSimulator::usage="loadSimulator[] loads the current model into simulator-readable form, i.e, the same form returned by SBMLREAD. Thus functions such as SBMLNDSolve can be run on it. SBMLRead automatically loads both the simulator  (unless return->False) and the model builder (unless LoadModelBuilder->False) when it reads a file. ";
loadModelBuilder::usage="loadModelBuilder[file,options] reads an SBML file into the model builder.";

modifyCompartment::usage="modifyCompartment[id,options] or modifyCompartments[options] modifies the specified compartment in the current model. The compartment must be identified by the value of its id tag. Any options that are specified in the call to modifyCompartment replace the previously existing values for the corresponding SBML tag. All other tags retain their original values.Any valid options for compartmentToSBML may be used.";
modifyModel::usage="modifyModel[options] changes properties of a model. Valid options are:id, name.";
modifyFunction::usage="modifyFunction[id, options] or modifyFunction[options] modifies the specified function in the current modmel. The function must be identified by the value of its id tag. Any options that are specified in the call to modifyFunction replace the previously existing values for the corresponding SBML tag. All other tags retain their original values. Any valid option for functionToSBML or addFunction may be used.";
modifyUnit::usage="modifyUnit[id, options] or modifyUnit[options] modifies the specified unit definition in the current model. The unit definition must be identified by the value of its id tag. Any options that are specified in the call to modifyUnit replace the previously existing values for the corresponding SBML tag. All other tags retain their original values. Any valid options for unitToSBML may be used.";
modifyParameter::usage="modifyParameter[id, options] or modifyParameter[options] modifies the specified parameter definition in the current model.  The parameter must be identified by the value of its id tag. Any options that are specified in the call to modifyParameter replace the previously existing values for the corresponding SBML tag. All other tags retain their original values.  Any valid option for parameterToSBML or addParameter may be used.";
modifySpecies::usage="modifySpecies[id, options] or modifySpecies[options] modifies the specified species in the current model. The species must be identified by the value of its id tag. Any options that are specified in the call to modifySpecies replace the previously existing values for the corresponding SBML tag. All other tags retain their original values. Any valid option for speciesToSBML or addSpecies may be used.";
modifyReaction::usage="modifyReaction[id, options] or modifyReaction[options] modifies the specified reaction in the current model. The reaction must be identified by the value of its id tag. Any options that are specified in the call to modifyReaction replace the previously existing values for the corresponding SBML tag. All other tags retain their original values. Any valid option for reactionToSBML or addReaction may be used.";
modifyRule::usage="modifyRule[id, options] or modifyRule[options] modifies the specified rule in the current model.  The reaction must be identified by the value of its metaid tag, which is specified with the id option. Any options that are specified in the call to modifyRule replace the previously existing values for the corresponding SBML tag. All other tags retain their original values.  Any valid options for ruleToSBML or addRule may be used.";
modifyEvent::usage="modifyEvent[id, options] or modifyEvent[options] modifies the specified event definition in the current model. The event must be identified by the value of its id tag. Any options that are specified in the call to modifyEvent replace the previously existing values for the corresponding SBML tag. All other tags retain their original values. Any valid options for eventToSBML or addEvent may be used.";


MathMLToInfix::usage="MathMLToInfix[string_] converts a MathML content string into an infix expression.";
InfixToMathML::usage="InfixToMathML[expression_] returns a MathML string representing the given Mathematica expression.";


sameReaction::usage="TBD";
compareReactions::usage="TBD";


setAnnotationNamespace::usage="setAnnotationNamespace[URI] sets the URI to be used in subsequent annotations. setAnnotationNamespace is identical to setAnnotationURI"; 
setAnnotationURI::usage="setAnnotationURI[URI] sets the URI to be used in subsequent annotations. setAnnotationURI is identical to setAnnotationNamespace.";
setAnnotationURL::usage="setAnnotationURL has been replaced by setAnnotationURI.";

setAnnotationPackage::usage="setAnnotationPackage[name] sets the name of the package to be used in subsequent annotations. The annotation block is formatted as\n<annotation xmlns:package=\"url\">...</annotation>";
annotationToSymbolicSBML::usage="annotationToSymbolicSBML[a\[Rule]b] returns Symbolic SBML for an annotation that is specified heirarchically; a is a string, and b is either a string, a list consisting of a single string, or a list of rules of the same form as a\[Rule]b. The annotation uses the package and URI most recently defined by setAnnotationPackage and setAnnotationURI. Curly brackets {} around a single string on the right hand side of any arrow indicate that the string should be represented heirarchically as \n\n\t<foo:tag>\n\t <foo:f>v</foo:f>\n\t ...\n\t</foo:tag>\n\nrather than inline as\n\n\t <foo:tag \"foo:f\"=\"g\" .../> \n\nin the ultimate XML.\n\n"<>"annotationToSymbolicSBML[a\[Rule]b,package,URI] returns the Symbolic SBML using the specified package and URI.\n\n"<>"annotationToSymbolicSBML[XMLElement[\"annotation\",...]] returns the argument passed to it.\n\n"<>"annotationToSymbolicSBML[XMLElement[...]] encapsulates the XML in an annotation block.\n\nSee annotationToSBML for examples.";
annotationToSBML::usage="annotationToSBML returns text SBML. The arguments are the same as annotationToSymbolicSBML.\n\n"<>"annotationToSBML[\"a\"\[Rule] \"b\",\"foo\",\"http://woo.com\"] returns\n\n"<>"<annotation>\n <foo:a xmlns:foo=\"http://woo.com\">b</foo:a>\n</annotation>\n\n"<>"annotationToSBML[\"a\"\[Rule] {\"b\"\[Rule] \"c\",\"d\"\[Rule] {\"e\"},\"f\"\[Rule] {\"g\"\[Rule]{ \"h\"},\"p\"\[Rule] {\"q\"}, \"f1\"\[Rule] \"f2\"}},\"foo\",\"http://woo.com\"] returns \n\n"<>"<annotation>\n <foo:a xmlns:foo=\"http://woo.com\"\n     foo:b=\"c\">\n  <foo:d>e</foo:d>\n  <foo:f foo:f1=\"f2\">\n   <foo:g>h</foo:g>\n   <foo:p>q</foo:p>\n  </foo:f>\n </foo:a>\n</annotation>";
setSBMLAnnotation::usage="setSBMLAnnotation[annotation,package,URI] defines the annotations for the current SBML file; these annotations are outside of the model. The annotations may be listed heirarchically as rules. For example:\n\n"<>"\tsetSBMLAnnotation[\"A\"\[Rule] {\"b\"\[Rule] {\"c\"},\"d\"\[Rule] \"f\"}, \"foo\", \"http:/foo.com/ns\"]\n\n"<>"returns the symbolic XML (and saves the information for later use by createModel[]) for the following SBML fragment:\n\n"<>"<annotation>\n <foo:A xmlns:foo=\"http:/foo.com/ns\" foo:d=\"f\">\n  <foo:b>c</foo:b>\n </foo:A>\n</annotation>" ;
setModelAnnotation::usage="setModelAnnotation[annotation,package,URI] defines the annotations for the current SBML file; these annotations are outside of the model. The annotations may be listed heirarchically as rules. For example:\n\n"<>"\tsetModelAnnotation[\"A\"\[Rule] {\"b\"\[Rule] {\"c\"},\"d\"\[Rule] \"f\"}, \"foo\", \"http:/foo.com/ns\"]\n\n"<>"returns the symbolic XML (and saves the information for later use by createModel[]) for the following SBML fragment:\n\n"<>"<annotation>\n <foo:A xmlns:foo=\"http:/foo.com/ns\" foo:d=\"f\">\n  <foo:b>c</foo:b>\n </foo:A>\n</annotation>" ;


dimensionToSymbolicSBML::usage="";
dimensionToSBML::usage="";
indexToSBML::usage="";
indicesToSBML::usage="";
indexToSymbolicSBML::usage="";
indicesToSymbolicSBML::usage="";
vectorToSBML::usage="";
vectorToSymbolicSBML::usage="";
matrixToSBML::usage="";
matrixToSymbolicSBML::usage="";



XMLOut::usage="XMLOut[symbolicXML] returns a an XML string corresponding to symbolic SBML."


init::usage="init resets certain global parameters used by MathSBML.";
(* mathSBMLHelpReference::usage="mathSBMLHelpReference[options] returns a reference manual - list of all basic usage strings in MathSMBL.";*)
help::usage = "help[context] prints the help strings for the specified contexts.\nhelp[] returns a list of the available contexts."; 
Help::usage="Help[context], Help[]"; 
$HelpContexts::usage=""; 
AddHelp::usage="AddHelp[\"context`\"]. To set up the Help[context] system for context foo`,\n(1) Somewhere in the context foo`, call AddHelp[\"foo`\"]. This will tell the Help system that the help function you define in step (2) exists.\n(2) Somewhere in context foo define the function foo`Private`foohelp[]. This function will be called by Help[context]."


Clear[ bulletize,
numerize,
numerizedList,sbmlReadLimitations,sbmlReadOptions]; 


(* addCelleratorReaction::usage="addCelleratorReaction[reaction, options] is a wrapper for addReaction. All rate constants must be specified. Options may contain values for rate constants. \nAll mass action reaction are broken down into their constituitive parts. Names for intermediate compounds are generated automatically. The reaction "<>"\!\(\*OverscriptBox[
RowBox[{\"a\", \"\[RightArrowLeftArrow]\", \"b\"}], \"c\"]\), "<>"for example, is stored as three separate reactions: "<>"a+c\[ShortRightArrow]a\[UnderBracket]c, a\[UnderBracket]c\[ShortRightArrow]a+c, a\[UnderBracket]c\[ShortRightArrow]b+c; the compound name a\[UnderBracket]c is automatically generated from the constituent species, and the underbracket character may be replaced by any other character with the option MolecularDelimiter. Note that the underbracket character (\[UnderBracket]) is replaced with the underscore (_) before being written to SBML. Only valid SID characters are allowed. \n"<>"\nThe following forms for reaction have been implemented:\n"<>"\t{a\[ShortRightArrow]b,k}\n"<>"\t{Subscript[\[CapitalSigma], i]Subscript[p, i]Subscript[A, i]\[ShortRightArrow]Subscript[\[CapitalSigma], j]Subscript[q, j]Subscript[B, j],k} (p,q stoichiometries)\n"<>"\t{\!\(\*OverscriptBox[
RowBox[{\"a\", \"\[ShortRightArrow]\", \"b\"}], \"c\"]\), k}\n"<>"\t{a\[RightArrowLeftArrow]b, Subscript[k, f], Subscript[k, r]}\n"<>"\t{\!\(\*OverscriptBox[
RowBox[{\"a\", \"\[RightArrowLeftArrow]\", \"b\"}], \"enzyme\"]\), a, d, k}\n"<>"\t{\!\(\*OverscriptBox[
RowBox[{\"a\", \"\[RightArrowLeftArrow]\", \"b\"}], \"enzyme\"]\), a, d, Subscript[k, f],Subscript[k, r]}\n"<>"\t{\!\*UnderoverscriptBox[\(a \[RightArrowLeftArrow] b\), \(reverse\), \(forward\)], Subscript[a, f], Subscript[d, f], Subscript[k, f], Subscript[a, r], Subscript[d, r], Subscript[k, r]}\n"<>"The following cascades have been implemented:\n"<>"\t{a\[ShortRightArrow]b\[ShortRightArrow]c\[ShortRightArrow]...,Subscript[k, 1],Subscript[k, 2],...}\n"<>"\t{\!\(\*OverscriptBox[
RowBox[{\"a\", \"\[RightArrowLeftArrow]\", \"b\", \"\[RightArrowLeftArrow]\", \"c\", \"\[RightArrowLeftArrow]\"}], \"enzyme\"]\),Subscript[a, 1],Subscript[d, 1],Subscript[k, 1],...}\n"<>"See Cellerator documentation for an explanation of these reactions.\n\nExample:\n"<>"addCelleratorReaction[{\!\(\*OverscriptBox[
RowBox[{\"substrate\", \"\[RightArrowLeftArrow]\", \"product\"}], \"enzyme\"]\), a, d, k}, a->0.001, d->.1, k->1]"; *)


InterpolationSet::usage="InterpolationSet is an uninstantiated function that encapsulates a set of InterpolatingFunction's, as in:\n\n
InterpolationSet[tstart, tend, {x[t]\[Rule] InterpolatingFunction[..][t], y[t]\[Rule]InterpolatingFunction[..][t],..}].\n\n SBMLNDSolve returns a list of InterpolationSet's when events occur in the model.\nThe list of InterpolatingFunction's may be recovered from teh InterpolationSet using getInterpolationFunction";
getInterpolatingFunction::usage="getInterpolatingFunction[InterpolationSet[tstart,tend,f]], returns f, where f is the list of InterpolationFunctions encapsulated in the InterpolationSet.";


IgnoreCollisions::usage="IgnoreCollisions[\"context`\"] means that potential variable collisions between model variables and previously defined Mathematica variables in the specified context are to be ignored (not reported as errors) by SBMLRead.\n\nIgnoreCollisions[] means that all potential variable collisions are reported.\n\nIgnoreCollisions[\"Global`\"] is the default setting.\n\nOnly potential collisions with Mathematica Variables can be inhibited in this manner; IgnoreCollisions has no affect upon checking for collisions between model variables, which cannot be inhibited.\n\nCollisions with a Mathematica Variable do not necessarily indicate an SBML model error. However, they may cause MathSBML to produce unexpected and incorrect results. \n\nMost model collisions occur as a result of using SBMLRead[... context\[Rule]None ...]. If the option context\[Rule]None is not used then collisions will be unlikely.";


resetIC::usage="resetIC[m,var,value]\nresetIC[m,var\[Rule]value]\nresetIC[m,{var1\[Rule]val1,...}]\n\nThis function will typically be used when a modeler wants to perform multiple simulations with different initial conditions, and does not want to create a different SBML file for each set of initial conditions.\n\nThe function resetIC will return a modified version of model m (where m is the original output of SBMLRead or an equivalent function) with the specified initial conditions reset.It is not necessary to specify the model id, name, or context, as that is auto-determined and any context specified will be ignored. Compare with resetParameter.\n\nIntroduced in version 2.5.15-\[Alpha]";

resetParameter::usage="resetParameter[m,var,value]\nresetParameter[m,var\[Rule]value]\nresetParameter[m,{var1\[Rule]val1,...}]\n\nThe function resetParameter will return a modified version of the model m (where m is the original output of SBMLRead or an equivalent function) with the specified parameter (in SBMLConstants) reset to the specified value. Note that resetParameter will not have any effect unless the original model was input with evaluateParameters\[Rule]False, because otherwise all parameter values will have already been replaced with their corresponding values in the differential equations. Compare with resetIC.\nIntroduced in version 2.5.15-\[Alpha]";


setMIRIAMcreatorFamily::usage="";
setMIRIAMcreatorGiven::usage="";
setMIRIAMcreatorEMAIL::usage="";
setMIRIAMcreatorOrgname::usage="";
setMIRIAMcreatedTime::usage="";
setMIRIAMmodifiedTime::usage="";
setMIRIAMcreator::usage="";
resetMIRIAMcreator::usage="";

vCardToSymbolicXML::usage="";
createBag::usage="";
getBagSize::usage="";

MIRIAMCreateTimeToSymbolicXML::usage="";
MIRIAMmodifiedTimeToSymbolicXML::usage="";
MIRIAMcreatorToSymbolicXML::usage="";



getBiomodel::usage="getBiomodel[n: integer, opt: options (any SBMLRead options) ]"


visualizeSBMLModel::usage="visualizeSBMLModel[filename, options] uses GraphPlot to generate a visualization of the model species, including reactions and rules. Species are indicated by ovals and reactions by rectangles. Species-Species connections are rules. (Events are not included). Options are any Plot options, By default the annotations are the species and reaction ids, and the image is labeled by the model id. If  visualizeByName->True, the name field is used instead."


visualizationArrowLength::usage="An option for visualizeSBMLModel. Length of arrow in pixels";
visualizationBoxWidth::usage="An option for visualizeSBMLModel. Width of reaction box in relative coordinates."
visualizationBoxHeight::usage="An option for visualizeSBMLModel. Height of reaction box in relative coordinates.";
visualizationRadius::usage="An option for visualizeSBMLModel. Radius of species oval in relative coordinates.";
visualizationFontSize::usage="An option for visualizeSBMLModel. Font size for visualization content.";
visualizationHeaderFontSize::usage="An option for visualizeSBMLModel. Font size for visualization header.";
visualizationFontFamily::usage="An option for visualizeSBMLModel. Font family used for visualization.";
visualizeByName::usage="True/False, default is False, use ids.";
ignoreSpecies::usage="An option for visualizedSBMLModel. A list of species id's to ignore, e.g., emptySet"; 




variableToParameter::usage="variableToParameter[model, variable]\nvariableToParameter[filename, variable, options]\nreturns an SBML Model (same format as the output of SBMLRead) where the specified variable has been changed to a constant parameter. In the first form, model is the output of SBMLRead. In the second format, options are any valid options for SBMLRead.";

parametricScan::usage="parametricScan[model, parameter, min, max, delta, X, time]\nparametricScan[filename, parameter, min, max, delta, X, time]\nreturns a list containing the values {{min,X[time]}, {min+delta, X[time]}, .., {max, X[time]}}, where the values are obtained by solving the model with the value of the specified parameter set to the values min, min+delta,..., max. Here is any model variable, and time is the duration of the SBMLNDSolve run.\nNote: in the first type of invocation, the model was be orignally imported using the option evaluateParameters\[Rule]False (the default is True).";


icScan::usage="icScan[model, var, min, max, delta, X, time]\nicScan[filename, var, min, max, delta, X, time]\nreturns a list containing the values {{min,X[time]}, {min+delta, X[time]}, .., {max, X[time]}}, where the values are obtained by solving the model with the value of the specified initial conditin var[0] set to the values min, min+delta,..., max. Here is any model variable, and time is the duration of the SBMLNDSolve run.";


Begin["`Private`"];


$$LoadBug=False;


csymbolTimeURL="http://www.sbml.org/sbml/symbols/time";
csymbolDelayURL="http://www.sbml.org/sbml/symbols/delay";


MyTextStyle[x___]:= If[$VersionNumber<6, TextStyle[x], Style[x]]; 
MyStyle[x___]:= If[$VersionNumber<6, StyleForm[x], Style[x]]; 
MyDate[x___]:= If[$VersionNumber<6, Date[], DateList[]];
MyStylePrint[x___]:= If[$VersionNumber<6, StylePrint[x], Print[Style[x]]]; 
MyStyleForm[x___]:= If[$VersionNumber<6, StyleForm[x], Style[x]]; 

MyFilterOptions[f_, opt___?OptionQ]:= 
If[$VersionNumber<6,
Utilities`FilterOptions`FilterOptions[f, opt]
,
Sequence@@FilterRules[Flatten[{opt}],Options[f]]
];

(* 
The following nonsense is required to suppress printing of a Global`AngleBracket::shdw error message, because Off[..] does not work propertly in version 6
*)

If[$VersionNumber<6,
 MyAngleBracket[x___]:=ToExpression["Global`AngleBracket"]@@{x};
MyRightArrowLeftArrow[x___]:=ToExpression["Global`RightArrowLeftArrow"]@@{x};
ExportXMLString[x_]:= ExportString[x, "XML", ConversionOptions-> {"AttributeQuoting"-> "\""}]
,
MyAngleBracket[x___]:=ToExpression["System`AngleBracket"]@@{x};
MyRightArrowLeftArrow[x___]:=ToExpression["System`RightArrowLeftArrow"]@@{x}; 
ExportXMLString[x_]:= ExportString[x,"XML", "AttributeQuoting"-> "\""]
]; 


Which[
$VersionNumber<6, 
Xpression2SymbolicMathML[x_]:= XML`MathML`ExpressionToSymbolicMathML[x,"Formats"-> {"ContentMathML"}],

$VersionNumber==6 \[And] $ReleaseNumber<2, 
(* Version 6.0.1 introducted a different syntax *)
Xpression2SymbolicMathML[x_]:= XML`MathML`ExpressionToSymbolicMathML[x, "Semantics"-> True, "Presentation"-> False], 

$VersionNumber==6  \[And] $ReleaseNumber>= 2, 
(* the version 5 syntax was used in 6.0.2 + 6.0.3 *)
Xpression2SymbolicMathML[x_]:= XML`MathML`ExpressionToSymbolicMathML[x,"Formats"-> {"ContentMathML"}], 

$VersionNumber ==7 , 
(* the version 5 syntax was used in 7.0*)
Xpression2SymbolicMathML[x_]:= XML`MathML`ExpressionToSymbolicMathML[x,"Formats"-> {"ContentMathML"}],

_, 
(* assume the verision 7 stuff works *)
Xpression2SymbolicMathML[x_]:= XML`MathML`ExpressionToSymbolicMathML[x,"Formats"-> {"ContentMathML"}]

];





nonOptionQ[x_]:= Not[OptionQ[x]];


RuleQ[Rule[v1_, v2_]]:= True;
RuleQ[q___?OptionQ]:= True;
(* RuleQ[q___]:= False; *)
RuleQ[q_?ListQ]:= And@@RuleQ/@q;
RuleQ[q___]:= Switch[Length[{q}],
0, True,
1, ToString[Head[q]]=="Rule",
_, RuleQ[{q}]];


functionQ[a_[z___]]:= True;
functionQ[a___]:=False;


stringer[x_]:= If[StringQ[x], x, ToString[InputForm[x]]]; 
stringrule[x_-> y_]:=stringer[x]-> stringer[y];  
destring[x_]:= If[StringQ[x], ToExpression[x], x];

expressionate[x_?ListQ]:= expressionate/@x; 
expressionate[x_]:= If[StringQ[x], ToExpression[x], x];
expressionate[Rule[x_, y_]]:= Rule[expressionate[x], 
If[decontextify[stringer[x]]=="name", y,expressionate[y]]
]; 




If[$$LoadBug, Print["Loading:SIDQ"]];


stringSIDate[x_]:=StringReplace[stringer[x], {$SBML$Underscorecharacter-> "_"}];

latinLetterQ[x_]:= MemberQ[{"A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z","a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z"},x];

SIDQ[x_]:= Module[{s,nameChar, s1, srest, ok,debug=False},

(* Print["SIDQ: x:",x]; *) 
s= Characters[stringer[x]]/.{"_"-> "\[UnderBracket]"}; 
If[Length[s]<1, Return[False]]; 
nameChar[z_?StringQ]:= latinLetterQ[z] \[Or] DigitQ[z]\[Or] (z=="\[UnderBracket]");
ok = (And@@nameChar/@s) \[And] (!DigitQ[First[s]]);
debugPrint[debug,"SIDQ: {s,ok}:",{s,ok}];

Return[ok];
];

explainSIDError[x_]:= Module[{c, s, nameChar},
s= Characters[stringer[x]]/.{"_"-> "\[UnderBracket]"}; 
If[Length[s]<1,
Print["SID Error: "//boldRed, "An identifier must be a non-null string."//boldBlack];
]; 
c=First[s]; 
If[!(latinLetterQ[c]\[Or](z=="\[UnderBracket]")),
Print["SID Error: "//boldRed, "An identifier must begin with a letter or an underscore character, but not with "//boldBlack,c//boldRed];
];
nameChar[z_?StringQ]:= latinLetterQ[z] \[Or] DigitQ[z]\[Or] (z=="\[UnderBracket]");
c={Rest[s], nameChar/@Rest[s]}; 
c=Transpose[Union[Transpose[c]]];
MapThread[If[!(#2), Print["SID Error: "//boldRed, "The character "//boldBlack, #1//boldRed," is not a latin letter, a digit, or an underscore."//boldBlack]]&,c];
];

fixSID[x_]:= Module[{c, s, nameChar},
(* Print["fixSID: x: ",x]; *) 
s= Characters[stringer[x]]/.{"_"-> "\[UnderBracket]"}; 
If[Length[s]<1, Return["\[UnderBracket]"]]; 
nameChar[z_?StringQ]:= latinLetterQ[z] \[Or] DigitQ[z]\[Or] (z=="\[UnderBracket]");
c= Map[If[nameChar[#],#, "\[UnderBracket]"]&, s];
If[DigitQ[First[c]], c= ReplacePart[c,"\[UnderBracket]",1]];
Return[StringJoin@@c];
];





characterReplacementRules={"\[RawEscape]"->"\[UnderBracket]RawEscape\[UnderBracket]","\[NonBreakingSpace]"->"\[UnderBracket]NonBreakingSpace\[UnderBracket]","\[ThickSpace]"->"\[UnderBracket]ThickSpace\[UnderBracket]","\[ThinSpace]"->"\[UnderBracket]ThinSpace\[UnderBracket]","\[VeryThinSpace]"->"\[UnderBracket]VeryThinSpace\[UnderBracket]","\[LineSeparator]"->"\[UnderBracket]LineSeparator\[UnderBracket]","\[ParagraphSeparator]"->"\[UnderBracket]ParagraphSeparator\[UnderBracket]","\[MediumSpace]"->"\[UnderBracket]MediumSpace\[UnderBracket]","\[SpaceIndicator]"->"\[UnderBracket]SpaceIndicator\[UnderBracket]","\:f209"->"\[UnderBracket]RawTab\[UnderBracket]","\:f21b"->"\[UnderBracket]RawEscape\[UnderBracket]","\[InvisibleSpace]"->"\[UnderBracket]InvisibleSpace\[UnderBracket]","\[NegativeVeryThinSpace]"->"\[UnderBracket]NegativeVeryThinSpace\[UnderBracket]","\[NegativeThinSpace]"->"\[UnderBracket]NegativeThinSpace\[UnderBracket]","\[NegativeMediumSpace]"->"\[UnderBracket]NegativeMediumSpace\[UnderBracket]","\[NegativeThickSpace]"->"\[UnderBracket]NegativeThickSpace\[UnderBracket]","
"->"\[UnderBracket]IndentingNewLine\[UnderBracket]",(* ""->"\[UnderBracket]AutoSpace\[UnderBracket]",*) "\[RoundSpaceIndicator]"->"\[UnderBracket]RoundSpaceIndicator\[UnderBracket]","\[InvisiblePrefixScriptBase]"->"\[UnderBracket]InvisiblePrefixScriptBase\[UnderBracket]","\[InvisiblePostfixScriptBase]"->"\[UnderBracket]InvisiblePostfixScriptBase\[UnderBracket]","\[AlignmentMarker]"->"\[UnderBracket]AlignmentMarker\[UnderBracket]","\[InvisibleApplication]"->"\[UnderBracket]InvisibleApplication\[UnderBracket]","\[AE]"->"\[UnderBracket]AE\[UnderBracket]","\[AAcute]"->"\[UnderBracket]AAcute\[UnderBracket]","\[ABar]"->"\[UnderBracket]ABar\[UnderBracket]","\[AGrave]"->"\[UnderBracket]AGrave\[UnderBracket]","\[ACup]"->"\[UnderBracket]ACup\[UnderBracket]","\[AHat]"->"\[UnderBracket]AHat\[UnderBracket]","\[ARing]"->"\[UnderBracket]ARing\[UnderBracket]","\[ADoubleDot]"->"\[UnderBracket]ADoubleDot\[UnderBracket]","\[ATilde]"->"\[UnderBracket]ATilde\[UnderBracket]","\[CapitalAE]"->"\[UnderBracket]CapitalAE\[UnderBracket]","\[CapitalAAcute]"->"\[UnderBracket]CapitalAAcute\[UnderBracket]","\[CapitalABar]"->"\[UnderBracket]CapitalABar\[UnderBracket]","\[CapitalAGrave]"->"\[UnderBracket]CapitalAGrave\[UnderBracket]","\[CapitalACup]"->"\[UnderBracket]CapitalACup\[UnderBracket]","\[CapitalAHat]"->"\[UnderBracket]CapitalAHat\[UnderBracket]","\[CapitalARing]"->"\[UnderBracket]CapitalARing\[UnderBracket]","\[CapitalADoubleDot]"->"\[UnderBracket]CapitalADoubleDot\[UnderBracket]","\[CapitalATilde]"->"\[UnderBracket]CapitalATilde\[UnderBracket]","\[CAcute]"->"\[UnderBracket]CAcute\[UnderBracket]","\[CHacek]"->"\[UnderBracket]CHacek\[UnderBracket]","\[CCedilla]"->"\[UnderBracket]CCedilla\[UnderBracket]","\[CapitalCAcute]"->"\[UnderBracket]CapitalCAcute\[UnderBracket]","\[CapitalCHacek]"->"\[UnderBracket]CapitalCHacek\[UnderBracket]","\[CapitalCCedilla]"->"\[UnderBracket]CapitalCCedilla\[UnderBracket]","\[Eth]"->"\[UnderBracket]Eth\[UnderBracket]","\[CapitalEth]"->"\[UnderBracket]CapitalEth\[UnderBracket]","\[EAcute]"->"\[UnderBracket]EAcute\[UnderBracket]","\[EBar]"->"\[UnderBracket]EBar\[UnderBracket]","\[EGrave]"->"\[UnderBracket]EGrave\[UnderBracket]","\[ECup]"->"\[UnderBracket]ECup\[UnderBracket]","\[EHat]"->"\[UnderBracket]EHat\[UnderBracket]","\[EDoubleDot]"->"\[UnderBracket]EDoubleDot\[UnderBracket]","\[CapitalEAcute]"->"\[UnderBracket]CapitalEAcute\[UnderBracket]","\[CapitalEBar]"->"\[UnderBracket]CapitalEBar\[UnderBracket]","\[CapitalEGrave]"->"\[UnderBracket]CapitalEGrave\[UnderBracket]","\[CapitalECup]"->"\[UnderBracket]CapitalECup\[UnderBracket]","\[CapitalEHat]"->"\[UnderBracket]CapitalEHat\[UnderBracket]","\[CapitalEDoubleDot]"->"\[UnderBracket]CapitalEDoubleDot\[UnderBracket]","\[FiLigature]"->"\[UnderBracket]FiLigature\[UnderBracket]","\[FlLigature]"->"\[UnderBracket]FlLigature\[UnderBracket]","\[DotlessI]"->"\[UnderBracket]DotlessI\[UnderBracket]","\[IAcute]"->"\[UnderBracket]IAcute\[UnderBracket]","\[IGrave]"->"\[UnderBracket]IGrave\[UnderBracket]","\[ICup]"->"\[UnderBracket]ICup\[UnderBracket]","\[IHat]"->"\[UnderBracket]IHat\[UnderBracket]","\[IDoubleDot]"->"\[UnderBracket]IDoubleDot\[UnderBracket]","\[CapitalIAcute]"->"\[UnderBracket]CapitalIAcute\[UnderBracket]","\[CapitalIGrave]"->"\[UnderBracket]CapitalIGrave\[UnderBracket]","\[CapitalICup]"->"\[UnderBracket]CapitalICup\[UnderBracket]","\[CapitalIHat]"->"\[UnderBracket]CapitalIHat\[UnderBracket]","\[CapitalIDoubleDot]"->"\[UnderBracket]CapitalIDoubleDot\[UnderBracket]","\[DotlessJ]"->"\[UnderBracket]DotlessJ\[UnderBracket]","\[LSlash]"->"\[UnderBracket]LSlash\[UnderBracket]","\[CapitalLSlash]"->"\[UnderBracket]CapitalLSlash\[UnderBracket]","\[NTilde]"->"\[UnderBracket]NTilde\[UnderBracket]","\[CapitalNTilde]"->"\[UnderBracket]CapitalNTilde\[UnderBracket]","\[OAcute]"->"\[UnderBracket]OAcute\[UnderBracket]","\[OGrave]"->"\[UnderBracket]OGrave\[UnderBracket]","\[OHat]"->"\[UnderBracket]OHat\[UnderBracket]","\[ODoubleDot]"->"\[UnderBracket]ODoubleDot\[UnderBracket]","\[ODoubleAcute]"->"\[UnderBracket]ODoubleAcute\[UnderBracket]","\[OTilde]"->"\[UnderBracket]OTilde\[UnderBracket]","\[OSlash]"->"\[UnderBracket]OSlash\[UnderBracket]","\[CapitalOAcute]"->"\[UnderBracket]CapitalOAcute\[UnderBracket]","\[CapitalOGrave]"->"\[UnderBracket]CapitalOGrave\[UnderBracket]","\[CapitalOHat]"->"\[UnderBracket]CapitalOHat\[UnderBracket]","\[CapitalODoubleDot]"->"\[UnderBracket]CapitalODoubleDot\[UnderBracket]","\[CapitalODoubleAcute]"->"\[UnderBracket]CapitalODoubleAcute\[UnderBracket]","\[CapitalOTilde]"->"\[UnderBracket]CapitalOTilde\[UnderBracket]","\[CapitalOSlash]"->"\[UnderBracket]CapitalOSlash\[UnderBracket]","\[SHacek]"->"\[UnderBracket]SHacek\[UnderBracket]","\[SZ]"->"\[UnderBracket]SZ\[UnderBracket]","\[CapitalSHacek]"->"\[UnderBracket]CapitalSHacek\[UnderBracket]","\[Thorn]"->"\[UnderBracket]Thorn\[UnderBracket]","\[CapitalThorn]"->"\[UnderBracket]CapitalThorn\[UnderBracket]","\[UAcute]"->"\[UnderBracket]UAcute\[UnderBracket]","\[UGrave]"->"\[UnderBracket]UGrave\[UnderBracket]","\[UHat]"->"\[UnderBracket]UHat\[UnderBracket]","\[UDoubleDot]"->"\[UnderBracket]UDoubleDot\[UnderBracket]","\[UDoubleAcute]"->"\[UnderBracket]UDoubleAcute\[UnderBracket]","\[CapitalUAcute]"->"\[UnderBracket]CapitalUAcute\[UnderBracket]","\[CapitalUGrave]"->"\[UnderBracket]CapitalUGrave\[UnderBracket]","\[CapitalUHat]"->"\[UnderBracket]CapitalUHat\[UnderBracket]","\[CapitalUDoubleDot]"->"\[UnderBracket]CapitalUDoubleDot\[UnderBracket]","\[CapitalUDoubleAcute]"->"\[UnderBracket]CapitalUDoubleAcute\[UnderBracket]","\[YAcute]"->"\[UnderBracket]YAcute\[UnderBracket]","\[YDoubleDot]"->"\[UnderBracket]YDoubleDot\[UnderBracket]","\[CapitalYAcute]"->"\[UnderBracket]CapitalYAcute\[UnderBracket]","\[ScriptA]"->"\[UnderBracket]ScriptA\[UnderBracket]","\[ScriptCapitalA]"->"\[UnderBracket]ScriptCapitalA\[UnderBracket]","\[ScriptB]"->"\[UnderBracket]ScriptB\[UnderBracket]","\[ScriptCapitalB]"->"\[UnderBracket]ScriptCapitalB\[UnderBracket]","\[ScriptC]"->"\[UnderBracket]ScriptC\[UnderBracket]","\[ScriptCapitalC]"->"\[UnderBracket]ScriptCapitalC\[UnderBracket]","\[ScriptD]"->"\[UnderBracket]ScriptD\[UnderBracket]","\[ScriptCapitalD]"->"\[UnderBracket]ScriptCapitalD\[UnderBracket]","\[ScriptE]"->"\[UnderBracket]ScriptE\[UnderBracket]","\[ScriptCapitalE]"->"\[UnderBracket]ScriptCapitalE\[UnderBracket]","\[ScriptF]"->"\[UnderBracket]ScriptF\[UnderBracket]","\[ScriptCapitalF]"->"\[UnderBracket]ScriptCapitalF\[UnderBracket]","\[ScriptG]"->"\[UnderBracket]ScriptG\[UnderBracket]","\[ScriptCapitalG]"->"\[UnderBracket]ScriptCapitalG\[UnderBracket]","\[ScriptH]"->"\[UnderBracket]ScriptH\[UnderBracket]","\[ScriptCapitalH]"->"\[UnderBracket]ScriptCapitalH\[UnderBracket]","\[ScriptI]"->"\[UnderBracket]ScriptI\[UnderBracket]","\[ScriptDotlessI]"->"\[UnderBracket]ScriptDotlessI\[UnderBracket]","\[ScriptCapitalI]"->"\[UnderBracket]ScriptCapitalI\[UnderBracket]","\[ScriptJ]"->"\[UnderBracket]ScriptJ\[UnderBracket]","\[ScriptDotlessJ]"->"\[UnderBracket]ScriptDotlessJ\[UnderBracket]","\[ScriptCapitalJ]"->"\[UnderBracket]ScriptCapitalJ\[UnderBracket]","\[ScriptK]"->"\[UnderBracket]ScriptK\[UnderBracket]","\[ScriptCapitalK]"->"\[UnderBracket]ScriptCapitalK\[UnderBracket]","\[ScriptL]"->"\[UnderBracket]ScriptL\[UnderBracket]","\[ScriptCapitalL]"->"\[UnderBracket]ScriptCapitalL\[UnderBracket]","\[ScriptM]"->"\[UnderBracket]ScriptM\[UnderBracket]","\[ScriptCapitalM]"->"\[UnderBracket]ScriptCapitalM\[UnderBracket]","\[ScriptN]"->"\[UnderBracket]ScriptN\[UnderBracket]","\[ScriptCapitalN]"->"\[UnderBracket]ScriptCapitalN\[UnderBracket]","\[ScriptO]"->"\[UnderBracket]ScriptO\[UnderBracket]","\[ScriptCapitalO]"->"\[UnderBracket]ScriptCapitalO\[UnderBracket]","\[ScriptP]"->"\[UnderBracket]ScriptP\[UnderBracket]","\[ScriptCapitalP]"->"\[UnderBracket]ScriptCapitalP\[UnderBracket]","\[ScriptQ]"->"\[UnderBracket]ScriptQ\[UnderBracket]","\[ScriptCapitalQ]"->"\[UnderBracket]ScriptCapitalQ\[UnderBracket]","\[ScriptR]"->"\[UnderBracket]ScriptR\[UnderBracket]","\[ScriptCapitalR]"->"\[UnderBracket]ScriptCapitalR\[UnderBracket]","\[ScriptS]"->"\[UnderBracket]ScriptS\[UnderBracket]","\[ScriptCapitalS]"->"\[UnderBracket]ScriptCapitalS\[UnderBracket]","\[ScriptT]"->"\[UnderBracket]ScriptT\[UnderBracket]","\[ScriptCapitalT]"->"\[UnderBracket]ScriptCapitalT\[UnderBracket]","\[ScriptU]"->"\[UnderBracket]ScriptU\[UnderBracket]","\[ScriptCapitalU]"->"\[UnderBracket]ScriptCapitalU\[UnderBracket]","\[ScriptV]"->"\[UnderBracket]ScriptV\[UnderBracket]","\[ScriptCapitalV]"->"\[UnderBracket]ScriptCapitalV\[UnderBracket]","\[ScriptW]"->"\[UnderBracket]ScriptW\[UnderBracket]","\[ScriptCapitalW]"->"\[UnderBracket]ScriptCapitalW\[UnderBracket]","\[ScriptX]"->"\[UnderBracket]ScriptX\[UnderBracket]","\[ScriptCapitalX]"->"\[UnderBracket]ScriptCapitalX\[UnderBracket]","\[ScriptY]"->"\[UnderBracket]ScriptY\[UnderBracket]","\[ScriptCapitalY]"->"\[UnderBracket]ScriptCapitalY\[UnderBracket]","\[ScriptZ]"->"\[UnderBracket]ScriptZ\[UnderBracket]","\[ScriptCapitalZ]"->"\[UnderBracket]ScriptCapitalZ\[UnderBracket]","\[GothicA]"->"\[UnderBracket]GothicA\[UnderBracket]","\[GothicCapitalA]"->"\[UnderBracket]GothicCapitalA\[UnderBracket]","\[GothicB]"->"\[UnderBracket]GothicB\[UnderBracket]","\[GothicCapitalB]"->"\[UnderBracket]GothicCapitalB\[UnderBracket]","\[GothicC]"->"\[UnderBracket]GothicC\[UnderBracket]","\[GothicCapitalC]"->"\[UnderBracket]GothicCapitalC\[UnderBracket]","\[GothicD]"->"\[UnderBracket]GothicD\[UnderBracket]","\[GothicCapitalD]"->"\[UnderBracket]GothicCapitalD\[UnderBracket]","\[GothicE]"->"\[UnderBracket]GothicE\[UnderBracket]","\[GothicCapitalE]"->"\[UnderBracket]GothicCapitalE\[UnderBracket]","\[GothicF]"->"\[UnderBracket]GothicF\[UnderBracket]","\[GothicCapitalF]"->"\[UnderBracket]GothicCapitalF\[UnderBracket]","\[GothicG]"->"\[UnderBracket]GothicG\[UnderBracket]","\[GothicCapitalG]"->"\[UnderBracket]GothicCapitalG\[UnderBracket]","\[GothicH]"->"\[UnderBracket]GothicH\[UnderBracket]","\[GothicCapitalH]"->"\[UnderBracket]GothicCapitalH\[UnderBracket]","\[GothicI]"->"\[UnderBracket]GothicI\[UnderBracket]","\[GothicCapitalI]"->"\[UnderBracket]GothicCapitalI\[UnderBracket]","\[GothicJ]"->"\[UnderBracket]GothicJ\[UnderBracket]","\[GothicCapitalJ]"->"\[UnderBracket]GothicCapitalJ\[UnderBracket]","\[GothicK]"->"\[UnderBracket]GothicK\[UnderBracket]","\[GothicCapitalK]"->"\[UnderBracket]GothicCapitalK\[UnderBracket]","\[GothicL]"->"\[UnderBracket]GothicL\[UnderBracket]","\[GothicCapitalL]"->"\[UnderBracket]GothicCapitalL\[UnderBracket]","\[GothicM]"->"\[UnderBracket]GothicM\[UnderBracket]","\[GothicCapitalM]"->"\[UnderBracket]GothicCapitalM\[UnderBracket]","\[GothicN]"->"\[UnderBracket]GothicN\[UnderBracket]","\[GothicCapitalN]"->"\[UnderBracket]GothicCapitalN\[UnderBracket]","\[GothicO]"->"\[UnderBracket]GothicO\[UnderBracket]","\[GothicCapitalO]"->"\[UnderBracket]GothicCapitalO\[UnderBracket]","\[GothicP]"->"\[UnderBracket]GothicP\[UnderBracket]","\[GothicCapitalP]"->"\[UnderBracket]GothicCapitalP\[UnderBracket]","\[GothicQ]"->"\[UnderBracket]GothicQ\[UnderBracket]","\[GothicCapitalQ]"->"\[UnderBracket]GothicCapitalQ\[UnderBracket]","\[GothicR]"->"\[UnderBracket]GothicR\[UnderBracket]","\[GothicCapitalR]"->"\[UnderBracket]GothicCapitalR\[UnderBracket]","\[GothicS]"->"\[UnderBracket]GothicS\[UnderBracket]","\[GothicCapitalS]"->"\[UnderBracket]GothicCapitalS\[UnderBracket]","\[GothicT]"->"\[UnderBracket]GothicT\[UnderBracket]","\[GothicCapitalT]"->"\[UnderBracket]GothicCapitalT\[UnderBracket]","\[GothicU]"->"\[UnderBracket]GothicU\[UnderBracket]","\[GothicCapitalU]"->"\[UnderBracket]GothicCapitalU\[UnderBracket]","\[GothicV]"->"\[UnderBracket]GothicV\[UnderBracket]","\[GothicCapitalV]"->"\[UnderBracket]GothicCapitalV\[UnderBracket]","\[GothicW]"->"\[UnderBracket]GothicW\[UnderBracket]","\[GothicCapitalW]"->"\[UnderBracket]GothicCapitalW\[UnderBracket]","\[GothicX]"->"\[UnderBracket]GothicX\[UnderBracket]","\[GothicCapitalX]"->"\[UnderBracket]GothicCapitalX\[UnderBracket]","\[GothicY]"->"\[UnderBracket]GothicY\[UnderBracket]","\[GothicCapitalY]"->"\[UnderBracket]GothicCapitalY\[UnderBracket]","\[GothicZ]"->"\[UnderBracket]GothicZ\[UnderBracket]","\[GothicCapitalZ]"->"\[UnderBracket]GothicCapitalZ\[UnderBracket]","\[DoubleStruckA]"->"\[UnderBracket]DoubleStruckA\[UnderBracket]","\[DoubleStruckCapitalA]"->"\[UnderBracket]DoubleStruckCapitalA\[UnderBracket]","\[DoubleStruckB]"->"\[UnderBracket]DoubleStruckB\[UnderBracket]","\[DoubleStruckCapitalB]"->"\[UnderBracket]DoubleStruckCapitalB\[UnderBracket]","\[DoubleStruckC]"->"\[UnderBracket]DoubleStruckC\[UnderBracket]","\[DoubleStruckCapitalC]"->"\[UnderBracket]DoubleStruckCapitalC\[UnderBracket]","\[DoubleStruckD]"->"\[UnderBracket]DoubleStruckD\[UnderBracket]","\[DoubleStruckCapitalD]"->"\[UnderBracket]DoubleStruckCapitalD\[UnderBracket]","\[DoubleStruckE]"->"\[UnderBracket]DoubleStruckE\[UnderBracket]","\[DoubleStruckCapitalE]"->"\[UnderBracket]DoubleStruckCapitalE\[UnderBracket]","\[DoubleStruckF]"->"\[UnderBracket]DoubleStruckF\[UnderBracket]","\[DoubleStruckCapitalF]"->"\[UnderBracket]DoubleStruckCapitalF\[UnderBracket]","\[DoubleStruckG]"->"\[UnderBracket]DoubleStruckG\[UnderBracket]","\[DoubleStruckCapitalG]"->"\[UnderBracket]DoubleStruckCapitalG\[UnderBracket]","\[DoubleStruckH]"->"\[UnderBracket]DoubleStruckH\[UnderBracket]","\[DoubleStruckCapitalH]"->"\[UnderBracket]DoubleStruckCapitalH\[UnderBracket]","\[DoubleStruckI]"->"\[UnderBracket]DoubleStruckI\[UnderBracket]","\[DoubleStruckCapitalI]"->"\[UnderBracket]DoubleStruckCapitalI\[UnderBracket]","\[DoubleStruckJ]"->"\[UnderBracket]DoubleStruckJ\[UnderBracket]","\[DoubleStruckCapitalJ]"->"\[UnderBracket]DoubleStruckCapitalJ\[UnderBracket]","\[DoubleStruckK]"->"\[UnderBracket]DoubleStruckK\[UnderBracket]","\[DoubleStruckCapitalK]"->"\[UnderBracket]DoubleStruckCapitalK\[UnderBracket]","\[DoubleStruckL]"->"\[UnderBracket]DoubleStruckL\[UnderBracket]","\[DoubleStruckCapitalL]"->"\[UnderBracket]DoubleStruckCapitalL\[UnderBracket]","\[DoubleStruckM]"->"\[UnderBracket]DoubleStruckM\[UnderBracket]","\[DoubleStruckCapitalM]"->"\[UnderBracket]DoubleStruckCapitalM\[UnderBracket]","\[DoubleStruckN]"->"\[UnderBracket]DoubleStruckN\[UnderBracket]","\[DoubleStruckCapitalN]"->"\[UnderBracket]DoubleStruckCapitalN\[UnderBracket]","\[DoubleStruckO]"->"\[UnderBracket]DoubleStruckO\[UnderBracket]","\[DoubleStruckCapitalO]"->"\[UnderBracket]DoubleStruckCapitalO\[UnderBracket]","\[DoubleStruckP]"->"\[UnderBracket]DoubleStruckP\[UnderBracket]","\[DoubleStruckCapitalP]"->"\[UnderBracket]DoubleStruckCapitalP\[UnderBracket]","\[DoubleStruckQ]"->"\[UnderBracket]DoubleStruckQ\[UnderBracket]","\[DoubleStruckCapitalQ]"->"\[UnderBracket]DoubleStruckCapitalQ\[UnderBracket]","\[DoubleStruckR]"->"\[UnderBracket]DoubleStruckR\[UnderBracket]","\[DoubleStruckCapitalR]"->"\[UnderBracket]DoubleStruckCapitalR\[UnderBracket]","\[DoubleStruckS]"->"\[UnderBracket]DoubleStruckS\[UnderBracket]","\[DoubleStruckCapitalS]"->"\[UnderBracket]DoubleStruckCapitalS\[UnderBracket]","\[DoubleStruckT]"->"\[UnderBracket]DoubleStruckT\[UnderBracket]","\[DoubleStruckCapitalT]"->"\[UnderBracket]DoubleStruckCapitalT\[UnderBracket]","\[DoubleStruckU]"->"\[UnderBracket]DoubleStruckU\[UnderBracket]","\[DoubleStruckCapitalU]"->"\[UnderBracket]DoubleStruckCapitalU\[UnderBracket]","\[DoubleStruckV]"->"\[UnderBracket]DoubleStruckV\[UnderBracket]","\[DoubleStruckCapitalV]"->"\[UnderBracket]DoubleStruckCapitalV\[UnderBracket]","\[DoubleStruckW]"->"\[UnderBracket]DoubleStruckW\[UnderBracket]","\[DoubleStruckCapitalW]"->"\[UnderBracket]DoubleStruckCapitalW\[UnderBracket]","\[DoubleStruckX]"->"\[UnderBracket]DoubleStruckX\[UnderBracket]","\[DoubleStruckCapitalX]"->"\[UnderBracket]DoubleStruckCapitalX\[UnderBracket]","\[DoubleStruckY]"->"\[UnderBracket]DoubleStruckY\[UnderBracket]","\[DoubleStruckCapitalY]"->"\[UnderBracket]DoubleStruckCapitalY\[UnderBracket]","\[DoubleStruckZ]"->"\[UnderBracket]DoubleStruckZ\[UnderBracket]","\[DoubleStruckCapitalZ]"->"\[UnderBracket]DoubleStruckCapitalZ\[UnderBracket]","\[Alpha]"->"\[UnderBracket]Alpha\[UnderBracket]","\[CapitalAlpha]"->"\[UnderBracket]CapitalAlpha\[UnderBracket]","\[Beta]"->"\[UnderBracket]Beta\[UnderBracket]","\[CapitalBeta]"->"\[UnderBracket]CapitalBeta\[UnderBracket]","\[Gamma]"->"\[UnderBracket]Gamma\[UnderBracket]","\[CapitalGamma]"->"\[UnderBracket]CapitalGamma\[UnderBracket]","\[Delta]"->"\[UnderBracket]Delta\[UnderBracket]","\[CapitalDelta]"->"\[UnderBracket]CapitalDelta\[UnderBracket]","\[Epsilon]"->"\[UnderBracket]Epsilon\[UnderBracket]","\[CurlyEpsilon]"->"\[UnderBracket]CurlyEpsilon\[UnderBracket]","\[CapitalEpsilon]"->"\[UnderBracket]CapitalEpsilon\[UnderBracket]","\[Zeta]"->"\[UnderBracket]Zeta\[UnderBracket]","\[CapitalZeta]"->"\[UnderBracket]CapitalZeta\[UnderBracket]","\[Eta]"->"\[UnderBracket]Eta\[UnderBracket]","\[CapitalEta]"->"\[UnderBracket]CapitalEta\[UnderBracket]","\[Theta]"->"\[UnderBracket]Theta\[UnderBracket]","\[CurlyTheta]"->"\[UnderBracket]CurlyTheta\[UnderBracket]","\[CapitalTheta]"->"\[UnderBracket]CapitalTheta\[UnderBracket]","\[Iota]"->"\[UnderBracket]Iota\[UnderBracket]","\[CapitalIota]"->"\[UnderBracket]CapitalIota\[UnderBracket]","\[Kappa]"->"\[UnderBracket]Kappa\[UnderBracket]","\[CurlyKappa]"->"\[UnderBracket]CurlyKappa\[UnderBracket]","\[CapitalKappa]"->"\[UnderBracket]CapitalKappa\[UnderBracket]","\[Lambda]"->"\[UnderBracket]Lambda\[UnderBracket]","\[CapitalLambda]"->"\[UnderBracket]CapitalLambda\[UnderBracket]","\[Mu]"->"\[UnderBracket]Mu\[UnderBracket]","\[CapitalMu]"->"\[UnderBracket]CapitalMu\[UnderBracket]","\[Nu]"->"\[UnderBracket]Nu\[UnderBracket]","\[CapitalNu]"->"\[UnderBracket]CapitalNu\[UnderBracket]","\[Xi]"->"\[UnderBracket]Xi\[UnderBracket]","\[CapitalXi]"->"\[UnderBracket]CapitalXi\[UnderBracket]","\[Omicron]"->"\[UnderBracket]Omicron\[UnderBracket]","\[CapitalOmicron]"->"\[UnderBracket]CapitalOmicron\[UnderBracket]","\[Pi]"->"\[UnderBracket]Pi\[UnderBracket]","\[CurlyPi]"->"\[UnderBracket]CurlyPi\[UnderBracket]","\[CapitalPi]"->"\[UnderBracket]CapitalPi\[UnderBracket]","\[Rho]"->"\[UnderBracket]Rho\[UnderBracket]","\[CurlyRho]"->"\[UnderBracket]CurlyRho\[UnderBracket]","\[CapitalRho]"->"\[UnderBracket]CapitalRho\[UnderBracket]","\[Sigma]"->"\[UnderBracket]Sigma\[UnderBracket]","\[FinalSigma]"->"\[UnderBracket]FinalSigma\[UnderBracket]","\[CapitalSigma]"->"\[UnderBracket]CapitalSigma\[UnderBracket]","\[Tau]"->"\[UnderBracket]Tau\[UnderBracket]","\[CapitalTau]"->"\[UnderBracket]CapitalTau\[UnderBracket]","\[Upsilon]"->"\[UnderBracket]Upsilon\[UnderBracket]","\[CapitalUpsilon]"->"\[UnderBracket]CapitalUpsilon\[UnderBracket]","\[CurlyCapitalUpsilon]"->"\[UnderBracket]CurlyCapitalUpsilon\[UnderBracket]","\[Phi]"->"\[UnderBracket]Phi\[UnderBracket]","\[CurlyPhi]"->"\[UnderBracket]CurlyPhi\[UnderBracket]","\[CapitalPhi]"->"\[UnderBracket]CapitalPhi\[UnderBracket]","\[Chi]"->"\[UnderBracket]Chi\[UnderBracket]","\[CapitalChi]"->"\[UnderBracket]CapitalChi\[UnderBracket]","\[Psi]"->"\[UnderBracket]Psi\[UnderBracket]","\[CapitalPsi]"->"\[UnderBracket]CapitalPsi\[UnderBracket]","\[Omega]"->"\[UnderBracket]Omega\[UnderBracket]","\[CapitalOmega]"->"\[UnderBracket]CapitalOmega\[UnderBracket]","\[Stigma]"->"\[UnderBracket]Stigma\[UnderBracket]","\[CapitalStigma]"->"\[UnderBracket]CapitalStigma\[UnderBracket]","\[Digamma]"->"\[UnderBracket]Digamma\[UnderBracket]","\[CapitalDigamma]"->"\[UnderBracket]CapitalDigamma\[UnderBracket]","\[Koppa]"->"\[UnderBracket]Koppa\[UnderBracket]","\[CapitalKoppa]"->"\[UnderBracket]CapitalKoppa\[UnderBracket]","\[Sampi]"->"\[UnderBracket]Sampi\[UnderBracket]","\[CapitalSampi]"->"\[UnderBracket]CapitalSampi\[UnderBracket]","\[Aleph]"->"\[UnderBracket]Aleph\[UnderBracket]","\[Bet]"->"\[UnderBracket]Bet\[UnderBracket]","\[Gimel]"->"\[UnderBracket]Gimel\[UnderBracket]","\[Dalet]"->"\[UnderBracket]Dalet\[UnderBracket]","\[Breve]"->"\[UnderBracket]Breve\[UnderBracket]","\[DownBreve]"->"\[UnderBracket]DownBreve\[UnderBracket]","\[Hacek]"->"\[UnderBracket]Hacek\[UnderBracket]","\[DoubleDot]"->"\[UnderBracket]DoubleDot\[UnderBracket]","\[TripleDot]"->"\[UnderBracket]TripleDot\[UnderBracket]","\[Cedilla]"->"\[UnderBracket]Cedilla\[UnderBracket]","\[Akuz]"->"\[UnderBracket]Akuz\[UnderBracket]","\[AliasDelimiter]"->"\[UnderBracket]AliasDelimiter\[UnderBracket]","\[AliasIndicator]"->"\[UnderBracket]AliasIndicator\[UnderBracket]","\[AltKey]"->"\[UnderBracket]AltKey\[UnderBracket]","\[Andy]"->"\[UnderBracket]Andy\[UnderBracket]","\[Angle]"->"\[UnderBracket]Angle\[UnderBracket]","\[Angstrom]"->"\[UnderBracket]Angstrom\[UnderBracket]","\[AscendingEllipsis]"->"\[UnderBracket]AscendingEllipsis\[UnderBracket]","\[BeamedEighthNote]"->"\[UnderBracket]BeamedEighthNote\[UnderBracket]","\[BeamedSixteenthNote]"->"\[UnderBracket]BeamedSixteenthNote\[UnderBracket]","\[Bullet]"->"\[UnderBracket]Bullet\[UnderBracket]","\[Cent]"->"\[UnderBracket]Cent\[UnderBracket]","\[CenterEllipsis]"->"\[UnderBracket]CenterEllipsis\[UnderBracket]","\[CheckedBox]"->"\[UnderBracket]CheckedBox\[UnderBracket]","\[Checkmark]"->"\[UnderBracket]Checkmark\[UnderBracket]","\[CheckmarkedBox]"->"\[UnderBracket]CheckmarkedBox\[UnderBracket]","\[CloverLeaf]"->"\[UnderBracket]CloverLeaf\[UnderBracket]","\[ClubSuit]"->"\[UnderBracket]ClubSuit\[UnderBracket]","\[CommandKey]"->"\[UnderBracket]CommandKey\[UnderBracket]","\[ConstantC]"->"\[UnderBracket]ConstantC\[UnderBracket]","\[ControlKey]"->"\[UnderBracket]ControlKey\[UnderBracket]","\[Copyright]"->"\[UnderBracket]Copyright\[UnderBracket]","\[Currency]"->"\[UnderBracket]Currency\[UnderBracket]","\[Dagger]"->"\[UnderBracket]Dagger\[UnderBracket]","\[Dash]"->"\[UnderBracket]Dash\[UnderBracket]","\[Degree]"->"\[UnderBracket]Degree\[UnderBracket]","\[DeleteKey]"->"\[UnderBracket]DeleteKey\[UnderBracket]","\[DescendingEllipsis]"->"\[UnderBracket]DescendingEllipsis\[UnderBracket]","\[Diameter]"->"\[UnderBracket]Diameter\[UnderBracket]","\[DiamondSuit]"->"\[UnderBracket]DiamondSuit\[UnderBracket]","\[DiscretionaryHyphen]"->"\[UnderBracket]DiscretionaryHyphen\[UnderBracket]","\[DottedSquare]"->"\[UnderBracket]DottedSquare\[UnderBracket]","\[DoubleDagger]"->"\[UnderBracket]DoubleDagger\[UnderBracket]","\[DoubledGamma]"->"\[UnderBracket]DoubledGamma\[UnderBracket]","\[DoubledPi]"->"\[UnderBracket]DoubledPi\[UnderBracket]","\[DoublePrime]"->"\[UnderBracket]DoublePrime\[UnderBracket]","\[DoubleStruckEight]"->"\[UnderBracket]DoubleStruckEight\[UnderBracket]","\[DoubleStruckFive]"->"\[UnderBracket]DoubleStruckFive\[UnderBracket]","\[DoubleStruckFour]"->"\[UnderBracket]DoubleStruckFour\[UnderBracket]","\[DoubleStruckNine]"->"\[UnderBracket]DoubleStruckNine\[UnderBracket]","\[DoubleStruckOne]"->"\[UnderBracket]DoubleStruckOne\[UnderBracket]","\[DoubleStruckSeven]"->"\[UnderBracket]DoubleStruckSeven\[UnderBracket]","\[DoubleStruckSix]"->"\[UnderBracket]DoubleStruckSix\[UnderBracket]","\[DoubleStruckThree]"->"\[UnderBracket]DoubleStruckThree\[UnderBracket]","\[DoubleStruckTwo]"->"\[UnderBracket]DoubleStruckTwo\[UnderBracket]","\[DoubleStruckZero]"->"\[UnderBracket]DoubleStruckZero\[UnderBracket]","\[DownExclamation]"->"\[UnderBracket]DownExclamation\[UnderBracket]","\[DownPointer]"->"\[UnderBracket]DownPointer\[UnderBracket]","\[DownQuestion]"->"\[UnderBracket]DownQuestion\[UnderBracket]","\[Earth]"->"\[UnderBracket]Earth\[UnderBracket]","\[EighthNote]"->"\[UnderBracket]EighthNote\[UnderBracket]","\[Ellipsis]"->"\[UnderBracket]Ellipsis\[UnderBracket]","\[EmptyCircle]"->"\[UnderBracket]EmptyCircle\[UnderBracket]","\[EmptyDiamond]"->"\[UnderBracket]EmptyDiamond\[UnderBracket]","\[EmptyDownTriangle]"->"\[UnderBracket]EmptyDownTriangle\[UnderBracket]","\[EmptyRectangle]"->"\[UnderBracket]EmptyRectangle\[UnderBracket]","\[EmptySet]"->"\[UnderBracket]EmptySet\[UnderBracket]","\[EmptySmallCircle]"->"\[UnderBracket]EmptySmallCircle\[UnderBracket]","\[EmptySmallSquare]"->"\[UnderBracket]EmptySmallSquare\[UnderBracket]","\[EmptySquare]"->"\[UnderBracket]EmptySquare\[UnderBracket]","\[EmptyUpTriangle]"->"\[UnderBracket]EmptyUpTriangle\[UnderBracket]","\[EmptyVerySmallSquare]"->"\[UnderBracket]EmptyVerySmallSquare\[UnderBracket]","\[EnterKey]"->"\[UnderBracket]EnterKey\[UnderBracket]","\[EntityEnd]"->"\[UnderBracket]EntityEnd\[UnderBracket]","\[EntityStart]"->"\[UnderBracket]EntityStart\[UnderBracket]","\[EscapeKey]"->"\[UnderBracket]EscapeKey\[UnderBracket]","\[Euro]"->"\[UnderBracket]Euro\[UnderBracket]","\[ExponentialE]"->"\[UnderBracket]ExponentialE\[UnderBracket]","\[FilledCircle]"->"\[UnderBracket]FilledCircle\[UnderBracket]","\[FilledDiamond]"->"\[UnderBracket]FilledDiamond\[UnderBracket]","\[FilledDownTriangle]"->"\[UnderBracket]FilledDownTriangle\[UnderBracket]","\[FilledLeftTriangle]"->"\[UnderBracket]FilledLeftTriangle\[UnderBracket]","\[FilledRectangle]"->"\[UnderBracket]FilledRectangle\[UnderBracket]","\[FilledRightTriangle]"->"\[UnderBracket]FilledRightTriangle\[UnderBracket]","\[FilledSmallCircle]"->"\[UnderBracket]FilledSmallCircle\[UnderBracket]","\[FilledSmallSquare]"->"\[UnderBracket]FilledSmallSquare\[UnderBracket]","\[FilledSquare]"->"\[UnderBracket]FilledSquare\[UnderBracket]","\[FilledUpTriangle]"->"\[UnderBracket]FilledUpTriangle\[UnderBracket]","\[FilledVerySmallSquare]"->"\[UnderBracket]FilledVerySmallSquare\[UnderBracket]","\[FirstPage]"->"\[UnderBracket]FirstPage\[UnderBracket]","\[FivePointedStar]"->"\[UnderBracket]FivePointedStar\[UnderBracket]","\[Flat]"->"\[UnderBracket]Flat\[UnderBracket]","\[Florin]"->"\[UnderBracket]Florin\[UnderBracket]","\[FreakedSmiley]"->"\[UnderBracket]FreakedSmiley\[UnderBracket]","\[GothicEight]"->"\[UnderBracket]GothicEight\[UnderBracket]","\[GothicFive]"->"\[UnderBracket]GothicFive\[UnderBracket]","\[GothicFour]"->"\[UnderBracket]GothicFour\[UnderBracket]","\[GothicNine]"->"\[UnderBracket]GothicNine\[UnderBracket]","\[GothicOne]"->"\[UnderBracket]GothicOne\[UnderBracket]","\[GothicSeven]"->"\[UnderBracket]GothicSeven\[UnderBracket]","\[GothicSix]"->"\[UnderBracket]GothicSix\[UnderBracket]","\[GothicThree]"->"\[UnderBracket]GothicThree\[UnderBracket]","\[GothicTwo]"->"\[UnderBracket]GothicTwo\[UnderBracket]","\[GothicZero]"->"\[UnderBracket]GothicZero\[UnderBracket]","\[GrayCircle]"->"\[UnderBracket]GrayCircle\[UnderBracket]","\[GraySquare]"->"\[UnderBracket]GraySquare\[UnderBracket]","\[HappySmiley]"->"\[UnderBracket]HappySmiley\[UnderBracket]","\[HBar]"->"\[UnderBracket]HBar\[UnderBracket]","\[HeartSuit]"->"\[UnderBracket]HeartSuit\[UnderBracket]","\[HorizontalLine]"->"\[UnderBracket]HorizontalLine\[UnderBracket]","\[Hyphen]"->"\[UnderBracket]Hyphen\[UnderBracket]","\[ImaginaryI]"->"\[UnderBracket]ImaginaryI\[UnderBracket]","\[ImaginaryJ]"->"\[UnderBracket]ImaginaryJ\[UnderBracket]","\[Infinity]"->"\[UnderBracket]Infinity\[UnderBracket]","\[Jupiter]"->"\[UnderBracket]Jupiter\[UnderBracket]","\[KernelIcon]"->"\[UnderBracket]KernelIcon\[UnderBracket]","\[KeyBar]"->"\[UnderBracket]KeyBar\[UnderBracket]","\[LastPage]"->"\[UnderBracket]LastPage\[UnderBracket]","\[LeftGuillemet]"->"\[UnderBracket]LeftGuillemet\[UnderBracket]","\[LeftModified]"->"\[UnderBracket]LeftModified\[UnderBracket]","\[LeftPointer]"->"\[UnderBracket]LeftPointer\[UnderBracket]","\[LightBulb]"->"\[UnderBracket]LightBulb\[UnderBracket]","\[LongDash]"->"\[UnderBracket]LongDash\[UnderBracket]","\[Mars]"->"\[UnderBracket]Mars\[UnderBracket]","\[MathematicaIcon]"->"\[UnderBracket]MathematicaIcon\[UnderBracket]","\[MeasuredAngle]"->"\[UnderBracket]MeasuredAngle\[UnderBracket]","\[Mercury]"->"\[UnderBracket]Mercury\[UnderBracket]","\[Mho]"->"\[UnderBracket]Mho\[UnderBracket]","\[Micro]"->"\[UnderBracket]Micro\[UnderBracket]","\[Mod1Key]"->"\[UnderBracket]Mod1Key\[UnderBracket]","\[Mod2Key]"->"\[UnderBracket]Mod2Key\[UnderBracket]","\[Natural]"->"\[UnderBracket]Natural\[UnderBracket]","\[Neptune]"->"\[UnderBracket]Neptune\[UnderBracket]","\[NeutralSmiley]"->"\[UnderBracket]NeutralSmiley\[UnderBracket]","\[Null]"->"\[UnderBracket]Null\[UnderBracket]","\[NumberSign]"->"\[UnderBracket]NumberSign\[UnderBracket]","\[OptionKey]"->"\[UnderBracket]OptionKey\[UnderBracket]","\[Paragraph]"->"\[UnderBracket]Paragraph\[UnderBracket]","\[Pluto]"->"\[UnderBracket]Pluto\[UnderBracket]","\[Prime]"->"\[UnderBracket]Prime\[UnderBracket]","\[QuarterNote]"->"\[UnderBracket]QuarterNote\[UnderBracket]","\[RegisteredTrademark]"->"\[UnderBracket]RegisteredTrademark\[UnderBracket]","\[ReturnIndicator]"->"\[UnderBracket]ReturnIndicator\[UnderBracket]","\[ReturnKey]"->"\[UnderBracket]ReturnKey\[UnderBracket]","\[ReverseDoublePrime]"->"\[UnderBracket]ReverseDoublePrime\[UnderBracket]","\[ReversePrime]"->"\[UnderBracket]ReversePrime\[UnderBracket]","\[RightAngle]"->"\[UnderBracket]RightAngle\[UnderBracket]","\[RightGuillemet]"->"\[UnderBracket]RightGuillemet\[UnderBracket]","\[RightModified]"->"\[UnderBracket]RightModified\[UnderBracket]","\[RightPointer]"->"\[UnderBracket]RightPointer\[UnderBracket]","\[SadSmiley]"->"\[UnderBracket]SadSmiley\[UnderBracket]","\[Saturn]"->"\[UnderBracket]Saturn\[UnderBracket]","\[ScriptEight]"->"\[UnderBracket]ScriptEight\[UnderBracket]","\[ScriptFive]"->"\[UnderBracket]ScriptFive\[UnderBracket]","\[ScriptFour]"->"\[UnderBracket]ScriptFour\[UnderBracket]","\[ScriptNine]"->"\[UnderBracket]ScriptNine\[UnderBracket]","\[ScriptOne]"->"\[UnderBracket]ScriptOne\[UnderBracket]","\[ScriptSeven]"->"\[UnderBracket]ScriptSeven\[UnderBracket]","\[ScriptSix]"->"\[UnderBracket]ScriptSix\[UnderBracket]","\[ScriptThree]"->"\[UnderBracket]ScriptThree\[UnderBracket]","\[ScriptTwo]"->"\[UnderBracket]ScriptTwo\[UnderBracket]","\[ScriptZero]"->"\[UnderBracket]ScriptZero\[UnderBracket]","\[Section]"->"\[UnderBracket]Section\[UnderBracket]","\[Sharp]"->"\[UnderBracket]Sharp\[UnderBracket]","\[ShiftKey]"->"\[UnderBracket]ShiftKey\[UnderBracket]","\[SixPointedStar]"->"\[UnderBracket]SixPointedStar\[UnderBracket]","\[SpaceKey]"->"\[UnderBracket]SpaceKey\[UnderBracket]","\[SpadeSuit]"->"\[UnderBracket]SpadeSuit\[UnderBracket]","\[SpanFromAbove]"->"\[UnderBracket]SpanFromAbove\[UnderBracket]","\[SpanFromBoth]"->"\[UnderBracket]SpanFromBoth\[UnderBracket]","\[SpanFromLeft]"->"\[UnderBracket]SpanFromLeft\[UnderBracket]","\[SphericalAngle]"->"\[UnderBracket]SphericalAngle\[UnderBracket]","\[Spooky]"->"\[UnderBracket]Spooky\[UnderBracket]","\[StepperDown]"->"\[UnderBracket]StepperDown\[UnderBracket]","\[StepperLeft]"->"\[UnderBracket]StepperLeft\[UnderBracket]","\[StepperRight]"->"\[UnderBracket]StepperRight\[UnderBracket]","\[StepperUp]"->"\[UnderBracket]StepperUp\[UnderBracket]","\[Sterling]"->"\[UnderBracket]Sterling\[UnderBracket]","\[TabKey]"->"\[UnderBracket]TabKey\[UnderBracket]","\[Trademark]"->"\[UnderBracket]Trademark\[UnderBracket]","\[UnknownGlyph]"->"\[UnderBracket]UnknownGlyph\[UnderBracket]","\[UpPointer]"->"\[UnderBracket]UpPointer\[UnderBracket]","\[Uranus]"->"\[UnderBracket]Uranus\[UnderBracket]","\[Venus]"->"\[UnderBracket]Venus\[UnderBracket]","\[VerticalEllipsis]"->"\[UnderBracket]VerticalEllipsis\[UnderBracket]","\[VerticalLine]"->"\[UnderBracket]VerticalLine\[UnderBracket]","\[Villa]"->"\[UnderBracket]Villa\[UnderBracket]","\[WarningSign]"->"\[UnderBracket]WarningSign\[UnderBracket]","\[WatchIcon]"->"\[UnderBracket]WatchIcon\[UnderBracket]","\[WeierstrassP]"->"\[UnderBracket]WeierstrassP\[UnderBracket]","\[Wolf]"->"\[UnderBracket]Wolf\[UnderBracket]","\[Yen]"->"\[UnderBracket]Yen\[UnderBracket]","\[AutoLeftMatch]"->"\[UnderBracket]AutoLeftMatch\[UnderBracket]","\[AutoRightMatch]"->"\[UnderBracket]AutoRightMatch\[UnderBracket]","\[CloseCurlyDoubleQuote]"->"\[UnderBracket]CloseCurlyDoubleQuote\[UnderBracket]","\[CloseCurlyQuote]"->"\[UnderBracket]CloseCurlyQuote\[UnderBracket]","\[LeftAngleBracket]"->"\[UnderBracket]LeftAngleBracket\[UnderBracket]","\[LeftBracketingBar]"->"\[UnderBracket]LeftBracketingBar\[UnderBracket]","\[LeftCeiling]"->"\[UnderBracket]LeftCeiling\[UnderBracket]","\[LeftDoubleBracket]"->"\[UnderBracket]LeftDoubleBracket\[UnderBracket]","\[LeftDoubleBracketingBar]"->"\[UnderBracket]LeftDoubleBracketingBar\[UnderBracket]","\[LeftFloor]"->"\[UnderBracket]LeftFloor\[UnderBracket]","\[OpenCurlyDoubleQuote]"->"\[UnderBracket]OpenCurlyDoubleQuote\[UnderBracket]","\[OpenCurlyQuote]"->"\[UnderBracket]OpenCurlyQuote\[UnderBracket]","\[RightAngleBracket]"->"\[UnderBracket]RightAngleBracket\[UnderBracket]","\[RightBracketingBar]"->"\[UnderBracket]RightBracketingBar\[UnderBracket]","\[RightCeiling]"->"\[UnderBracket]RightCeiling\[UnderBracket]","\[RightDoubleBracket]"->"\[UnderBracket]RightDoubleBracket\[UnderBracket]","\[RightDoubleBracketingBar]"->"\[UnderBracket]RightDoubleBracketingBar\[UnderBracket]","\[RightFloor]"->"\[UnderBracket]RightFloor\[UnderBracket]",(* ""->"\[UnderBracket]AutoOperand\[UnderBracket]",*) (*""->"\[UnderBracket]AutoPlaceholder\[UnderBracket]",*) "\[Continuation]"->"\[UnderBracket]Continuation\[UnderBracket]","\[InvisibleComma]"->"\[UnderBracket]InvisibleComma\[UnderBracket]","\[NoBreak]"->"\[UnderBracket]NoBreak\[UnderBracket]","\[OverBrace]"->"\[UnderBracket]OverBrace\[UnderBracket]","\[OverBracket]"->"\[UnderBracket]OverBracket\[UnderBracket]","\[OverParenthesis]"->"\[UnderBracket]OverParenthesis\[UnderBracket]","\[Placeholder]"->"\[UnderBracket]Placeholder\[UnderBracket]","\[SelectionPlaceholder]"->"\[UnderBracket]SelectionPlaceholder\[UnderBracket]","\[UnderBrace]"->"\[UnderBracket]UnderBrace\[UnderBracket]","\[UnderBracket]"->"\[UnderBracket]UnderBracket\[UnderBracket]","\[UnderParenthesis]"->"\[UnderBracket]UnderParenthesis\[UnderBracket]","\[ErrorIndicator]"->"\[UnderBracket]ErrorIndicator\[UnderBracket]","\[LeftSkeleton]"->"\[UnderBracket]LeftSkeleton\[UnderBracket]","\[RightSkeleton]"->"\[UnderBracket]RightSkeleton\[UnderBracket]","\[SkeletonIndicator]"->"\[UnderBracket]SkeletonIndicator\[UnderBracket]","\[DoubleDownArrow]"->"\[UnderBracket]DoubleDownArrow\[UnderBracket]","\[DoubleLongLeftArrow]"->"\[UnderBracket]DoubleLongLeftArrow\[UnderBracket]","\[DoubleLongLeftRightArrow]"->"\[UnderBracket]DoubleLongLeftRightArrow\[UnderBracket]","\[DoubleLongRightArrow]"->"\[UnderBracket]DoubleLongRightArrow\[UnderBracket]","\[DoubleUpArrow]"->"\[UnderBracket]DoubleUpArrow\[UnderBracket]","\[DoubleUpDownArrow]"->"\[UnderBracket]DoubleUpDownArrow\[UnderBracket]","\[DownArrow]"->"\[UnderBracket]DownArrow\[UnderBracket]","\[DownArrowBar]"->"\[UnderBracket]DownArrowBar\[UnderBracket]","\[DownArrowUpArrow]"->"\[UnderBracket]DownArrowUpArrow\[UnderBracket]","\[DownTeeArrow]"->"\[UnderBracket]DownTeeArrow\[UnderBracket]","\[LeftDownTeeVector]"->"\[UnderBracket]LeftDownTeeVector\[UnderBracket]","\[LeftDownVector]"->"\[UnderBracket]LeftDownVector\[UnderBracket]","\[LeftDownVectorBar]"->"\[UnderBracket]LeftDownVectorBar\[UnderBracket]","\[LeftUpDownVector]"->"\[UnderBracket]LeftUpDownVector\[UnderBracket]","\[LeftUpTeeVector]"->"\[UnderBracket]LeftUpTeeVector\[UnderBracket]","\[LeftUpVector]"->"\[UnderBracket]LeftUpVector\[UnderBracket]","\[LeftUpVectorBar]"->"\[UnderBracket]LeftUpVectorBar\[UnderBracket]","\[LongLeftArrow]"->"\[UnderBracket]LongLeftArrow\[UnderBracket]","\[LongLeftRightArrow]"->"\[UnderBracket]LongLeftRightArrow\[UnderBracket]","\[LongRightArrow]"->"\[UnderBracket]LongRightArrow\[UnderBracket]","\[ReverseUpEquilibrium]"->"\[UnderBracket]ReverseUpEquilibrium\[UnderBracket]","\[RightDownTeeVector]"->"\[UnderBracket]RightDownTeeVector\[UnderBracket]","\[RightDownVector]"->"\[UnderBracket]RightDownVector\[UnderBracket]","\[RightDownVectorBar]"->"\[UnderBracket]RightDownVectorBar\[UnderBracket]","\[RightUpDownVector]"->"\[UnderBracket]RightUpDownVector\[UnderBracket]","\[RightUpTeeVector]"->"\[UnderBracket]RightUpTeeVector\[UnderBracket]","\[RightUpVector]"->"\[UnderBracket]RightUpVector\[UnderBracket]","\[RightUpVectorBar]"->"\[UnderBracket]RightUpVectorBar\[UnderBracket]","\[ShortDownArrow]"->"\[UnderBracket]ShortDownArrow\[UnderBracket]","\[ShortUpArrow]"->"\[UnderBracket]ShortUpArrow\[UnderBracket]","\[Sqrt]"->"\[UnderBracket]Sqrt\[UnderBracket]","\[UpArrow]"->"\[UnderBracket]UpArrow\[UnderBracket]","\[UpArrowBar]"->"\[UnderBracket]UpArrowBar\[UnderBracket]","\[UpArrowDownArrow]"->"\[UnderBracket]UpArrowDownArrow\[UnderBracket]","\[UpDownArrow]"->"\[UnderBracket]UpDownArrow\[UnderBracket]","\[UpEquilibrium]"->"\[UnderBracket]UpEquilibrium\[UnderBracket]","\[UpTeeArrow]"->"\[UnderBracket]UpTeeArrow\[UnderBracket]","\[CapitalDifferentialD]"->"\[UnderBracket]CapitalDifferentialD\[UnderBracket]","\[DifferentialD]"->"\[UnderBracket]DifferentialD\[UnderBracket]","\[Piecewise]"->"\[UnderBracket]Piecewise\[UnderBracket]","\[Del]"->"\[UnderBracket]Del\[UnderBracket]","\[PartialD]"->"\[UnderBracket]PartialD\[UnderBracket]","\[Square]"->"\[UnderBracket]Square\[UnderBracket]","\[SmallCircle]"->"\[UnderBracket]SmallCircle\[UnderBracket]","\[CircleDot]"->"\[UnderBracket]CircleDot\[UnderBracket]","\[Cross]"->"\[UnderBracket]Cross\[UnderBracket]","\[Divide]"->"\[UnderBracket]Divide\[UnderBracket]","\[Backslash]"->"\[UnderBracket]Backslash\[UnderBracket]","\[Diamond]"->"\[UnderBracket]Diamond\[UnderBracket]","\[Wedge]"->"\[UnderBracket]Wedge\[UnderBracket]","\[Vee]"->"\[UnderBracket]Vee\[UnderBracket]","\[CircleTimes]"->"\[UnderBracket]CircleTimes\[UnderBracket]","\[CenterDot]"->"\[UnderBracket]CenterDot\[UnderBracket]","\[InvisibleTimes]"->"\[UnderBracket]InvisibleTimes\[UnderBracket]","\[Times]"->"\[UnderBracket]Times\[UnderBracket]","\[Star]"->"\[UnderBracket]Star\[UnderBracket]","\[Coproduct]"->"\[UnderBracket]Coproduct\[UnderBracket]","\[Product]"->"\[UnderBracket]Product\[UnderBracket]","\[VerticalTilde]"->"\[UnderBracket]VerticalTilde\[UnderBracket]","\[Cap]"->"\[UnderBracket]Cap\[UnderBracket]","\[Cup]"->"\[UnderBracket]Cup\[UnderBracket]","\[ClockwiseContourIntegral]"->"\[UnderBracket]ClockwiseContourIntegral\[UnderBracket]","\[ContourIntegral]"->"\[UnderBracket]ContourIntegral\[UnderBracket]","\[CounterClockwiseContourIntegral]"->"\[UnderBracket]CounterClockwiseContourIntegral\[UnderBracket]","\[DoubleContourIntegral]"->"\[UnderBracket]DoubleContourIntegral\[UnderBracket]","\[Integral]"->"\[UnderBracket]Integral\[UnderBracket]","\[CircleMinus]"->"\[UnderBracket]CircleMinus\[UnderBracket]","\[CirclePlus]"->"\[UnderBracket]CirclePlus\[UnderBracket]","\[Sum]"->"\[UnderBracket]Sum\[UnderBracket]","\[Intersection]"->"\[UnderBracket]Intersection\[UnderBracket]","\[MinusPlus]"->"\[UnderBracket]MinusPlus\[UnderBracket]","\[PlusMinus]"->"\[UnderBracket]PlusMinus\[UnderBracket]","\[SquareIntersection]"->"\[UnderBracket]SquareIntersection\[UnderBracket]","\[SquareUnion]"->"\[UnderBracket]SquareUnion\[UnderBracket]","\[Union]"->"\[UnderBracket]Union\[UnderBracket]","\[UnionPlus]"->"\[UnderBracket]UnionPlus\[UnderBracket]","\[Congruent]"->"\[UnderBracket]Congruent\[UnderBracket]","\[CupCap]"->"\[UnderBracket]CupCap\[UnderBracket]","\[DotEqual]"->"\[UnderBracket]DotEqual\[UnderBracket]","\[DoubleVerticalBar]"->"\[UnderBracket]DoubleVerticalBar\[UnderBracket]","\[Equal]"->"\[UnderBracket]Equal\[UnderBracket]","\[EqualTilde]"->"\[UnderBracket]EqualTilde\[UnderBracket]","\[Equilibrium]"->"\[UnderBracket]Equilibrium\[UnderBracket]","\[GreaterEqual]"->"\[UnderBracket]GreaterEqual\[UnderBracket]","\[GreaterEqualLess]"->"\[UnderBracket]GreaterEqualLess\[UnderBracket]","\[GreaterFullEqual]"->"\[UnderBracket]GreaterFullEqual\[UnderBracket]","\[GreaterGreater]"->"\[UnderBracket]GreaterGreater\[UnderBracket]","\[GreaterLess]"->"\[UnderBracket]GreaterLess\[UnderBracket]","\[GreaterSlantEqual]"->"\[UnderBracket]GreaterSlantEqual\[UnderBracket]","\[GreaterTilde]"->"\[UnderBracket]GreaterTilde\[UnderBracket]","\[HumpDownHump]"->"\[UnderBracket]HumpDownHump\[UnderBracket]","\[HumpEqual]"->"\[UnderBracket]HumpEqual\[UnderBracket]","\[LeftTriangle]"->"\[UnderBracket]LeftTriangle\[UnderBracket]","\[LeftTriangleBar]"->"\[UnderBracket]LeftTriangleBar\[UnderBracket]","\[LeftTriangleEqual]"->"\[UnderBracket]LeftTriangleEqual\[UnderBracket]","\[LessEqual]"->"\[UnderBracket]LessEqual\[UnderBracket]","\[LessEqualGreater]"->"\[UnderBracket]LessEqualGreater\[UnderBracket]","\[LessFullEqual]"->"\[UnderBracket]LessFullEqual\[UnderBracket]","\[LessGreater]"->"\[UnderBracket]LessGreater\[UnderBracket]","\[LessLess]"->"\[UnderBracket]LessLess\[UnderBracket]","\[LessSlantEqual]"->"\[UnderBracket]LessSlantEqual\[UnderBracket]","\[LessTilde]"->"\[UnderBracket]LessTilde\[UnderBracket]","\[LongEqual]"->"\[UnderBracket]LongEqual\[UnderBracket]","\[NestedGreaterGreater]"->"\[UnderBracket]NestedGreaterGreater\[UnderBracket]","\[NestedLessLess]"->"\[UnderBracket]NestedLessLess\[UnderBracket]","\[NotCongruent]"->"\[UnderBracket]NotCongruent\[UnderBracket]","\[NotCupCap]"->"\[UnderBracket]NotCupCap\[UnderBracket]","\[NotDoubleVerticalBar]"->"\[UnderBracket]NotDoubleVerticalBar\[UnderBracket]","\[NotEqual]"->"\[UnderBracket]NotEqual\[UnderBracket]","\[NotEqualTilde]"->"\[UnderBracket]NotEqualTilde\[UnderBracket]","\[NotGreater]"->"\[UnderBracket]NotGreater\[UnderBracket]","\[NotGreaterEqual]"->"\[UnderBracket]NotGreaterEqual\[UnderBracket]","\[NotGreaterFullEqual]"->"\[UnderBracket]NotGreaterFullEqual\[UnderBracket]","\[NotGreaterGreater]"->"\[UnderBracket]NotGreaterGreater\[UnderBracket]","\[NotGreaterLess]"->"\[UnderBracket]NotGreaterLess\[UnderBracket]","\[NotGreaterSlantEqual]"->"\[UnderBracket]NotGreaterSlantEqual\[UnderBracket]","\[NotGreaterTilde]"->"\[UnderBracket]NotGreaterTilde\[UnderBracket]","\[NotHumpDownHump]"->"\[UnderBracket]NotHumpDownHump\[UnderBracket]","\[NotHumpEqual]"->"\[UnderBracket]NotHumpEqual\[UnderBracket]","\[NotLeftTriangle]"->"\[UnderBracket]NotLeftTriangle\[UnderBracket]","\[NotLeftTriangleBar]"->"\[UnderBracket]NotLeftTriangleBar\[UnderBracket]","\[NotLeftTriangleEqual]"->"\[UnderBracket]NotLeftTriangleEqual\[UnderBracket]","\[NotLess]"->"\[UnderBracket]NotLess\[UnderBracket]","\[NotLessEqual]"->"\[UnderBracket]NotLessEqual\[UnderBracket]","\[NotLessFullEqual]"->"\[UnderBracket]NotLessFullEqual\[UnderBracket]","\[NotLessGreater]"->"\[UnderBracket]NotLessGreater\[UnderBracket]","\[NotLessLess]"->"\[UnderBracket]NotLessLess\[UnderBracket]","\[NotLessSlantEqual]"->"\[UnderBracket]NotLessSlantEqual\[UnderBracket]","\[NotLessTilde]"->"\[UnderBracket]NotLessTilde\[UnderBracket]","\[NotNestedGreaterGreater]"->"\[UnderBracket]NotNestedGreaterGreater\[UnderBracket]","\[NotNestedLessLess]"->"\[UnderBracket]NotNestedLessLess\[UnderBracket]","\[NotPrecedes]"->"\[UnderBracket]NotPrecedes\[UnderBracket]","\[NotPrecedesEqual]"->"\[UnderBracket]NotPrecedesEqual\[UnderBracket]","\[NotPrecedesSlantEqual]"->"\[UnderBracket]NotPrecedesSlantEqual\[UnderBracket]","\[NotPrecedesTilde]"->"\[UnderBracket]NotPrecedesTilde\[UnderBracket]","\[NotRightTriangle]"->"\[UnderBracket]NotRightTriangle\[UnderBracket]","\[NotRightTriangleBar]"->"\[UnderBracket]NotRightTriangleBar\[UnderBracket]","\[NotRightTriangleEqual]"->"\[UnderBracket]NotRightTriangleEqual\[UnderBracket]","\[NotSucceeds]"->"\[UnderBracket]NotSucceeds\[UnderBracket]","\[NotSucceedsEqual]"->"\[UnderBracket]NotSucceedsEqual\[UnderBracket]","\[NotSucceedsSlantEqual]"->"\[UnderBracket]NotSucceedsSlantEqual\[UnderBracket]","\[NotSucceedsTilde]"->"\[UnderBracket]NotSucceedsTilde\[UnderBracket]","\[NotTilde]"->"\[UnderBracket]NotTilde\[UnderBracket]","\[NotTildeEqual]"->"\[UnderBracket]NotTildeEqual\[UnderBracket]","\[NotTildeFullEqual]"->"\[UnderBracket]NotTildeFullEqual\[UnderBracket]","\[NotTildeTilde]"->"\[UnderBracket]NotTildeTilde\[UnderBracket]","\[NotVerticalBar]"->"\[UnderBracket]NotVerticalBar\[UnderBracket]","\[Precedes]"->"\[UnderBracket]Precedes\[UnderBracket]","\[PrecedesEqual]"->"\[UnderBracket]PrecedesEqual\[UnderBracket]","\[PrecedesSlantEqual]"->"\[UnderBracket]PrecedesSlantEqual\[UnderBracket]","\[PrecedesTilde]"->"\[UnderBracket]PrecedesTilde\[UnderBracket]","\[Proportion]"->"\[UnderBracket]Proportion\[UnderBracket]","\[Proportional]"->"\[UnderBracket]Proportional\[UnderBracket]","\[ReverseEquilibrium]"->"\[UnderBracket]ReverseEquilibrium\[UnderBracket]","\[RightTriangle]"->"\[UnderBracket]RightTriangle\[UnderBracket]","\[RightTriangleBar]"->"\[UnderBracket]RightTriangleBar\[UnderBracket]","\[RightTriangleEqual]"->"\[UnderBracket]RightTriangleEqual\[UnderBracket]","\[Succeeds]"->"\[UnderBracket]Succeeds\[UnderBracket]","\[SucceedsEqual]"->"\[UnderBracket]SucceedsEqual\[UnderBracket]","\[SucceedsSlantEqual]"->"\[UnderBracket]SucceedsSlantEqual\[UnderBracket]","\[SucceedsTilde]"->"\[UnderBracket]SucceedsTilde\[UnderBracket]","\[Tilde]"->"\[UnderBracket]Tilde\[UnderBracket]","\[TildeEqual]"->"\[UnderBracket]TildeEqual\[UnderBracket]","\[TildeFullEqual]"->"\[UnderBracket]TildeFullEqual\[UnderBracket]","\[TildeTilde]"->"\[UnderBracket]TildeTilde\[UnderBracket]","\[UpTee]"->"\[UnderBracket]UpTee\[UnderBracket]","\[VerticalBar]"->"\[UnderBracket]VerticalBar\[UnderBracket]","\[DoubleLeftArrow]"->"\[UnderBracket]DoubleLeftArrow\[UnderBracket]","\[DoubleLeftRightArrow]"->"\[UnderBracket]DoubleLeftRightArrow\[UnderBracket]","\[DoubleRightArrow]"->"\[UnderBracket]DoubleRightArrow\[UnderBracket]","\[DownLeftRightVector]"->"\[UnderBracket]DownLeftRightVector\[UnderBracket]","\[DownLeftTeeVector]"->"\[UnderBracket]DownLeftTeeVector\[UnderBracket]","\[DownLeftVector]"->"\[UnderBracket]DownLeftVector\[UnderBracket]","\[DownLeftVectorBar]"->"\[UnderBracket]DownLeftVectorBar\[UnderBracket]","\[DownRightTeeVector]"->"\[UnderBracket]DownRightTeeVector\[UnderBracket]","\[DownRightVector]"->"\[UnderBracket]DownRightVector\[UnderBracket]","\[DownRightVectorBar]"->"\[UnderBracket]DownRightVectorBar\[UnderBracket]","\[LeftArrow]"->"\[UnderBracket]LeftArrow\[UnderBracket]","\[LeftArrowBar]"->"\[UnderBracket]LeftArrowBar\[UnderBracket]","\[LeftArrowRightArrow]"->"\[UnderBracket]LeftArrowRightArrow\[UnderBracket]","\[LeftRightArrow]"->"\[UnderBracket]LeftRightArrow\[UnderBracket]","\[LeftRightVector]"->"\[UnderBracket]LeftRightVector\[UnderBracket]","\[LeftTeeArrow]"->"\[UnderBracket]LeftTeeArrow\[UnderBracket]","\[LeftTeeVector]"->"\[UnderBracket]LeftTeeVector\[UnderBracket]","\[LeftVector]"->"\[UnderBracket]LeftVector\[UnderBracket]","\[LeftVectorBar]"->"\[UnderBracket]LeftVectorBar\[UnderBracket]","\[LowerLeftArrow]"->"\[UnderBracket]LowerLeftArrow\[UnderBracket]","\[LowerRightArrow]"->"\[UnderBracket]LowerRightArrow\[UnderBracket]","\[RightArrow]"->"\[UnderBracket]RightArrow\[UnderBracket]","\[RightArrowBar]"->"\[UnderBracket]RightArrowBar\[UnderBracket]","\[RightArrowLeftArrow]"->"\[UnderBracket]RightArrowLeftArrow\[UnderBracket]","\[RightTeeArrow]"->"\[UnderBracket]RightTeeArrow\[UnderBracket]","\[RightTeeVector]"->"\[UnderBracket]RightTeeVector\[UnderBracket]","\[RightVector]"->"\[UnderBracket]RightVector\[UnderBracket]","\[RightVectorBar]"->"\[UnderBracket]RightVectorBar\[UnderBracket]","\[ShortLeftArrow]"->"\[UnderBracket]ShortLeftArrow\[UnderBracket]","\[ShortRightArrow]"->"\[UnderBracket]ShortRightArrow\[UnderBracket]","\[UpperLeftArrow]"->"\[UnderBracket]UpperLeftArrow\[UnderBracket]","\[UpperRightArrow]"->"\[UnderBracket]UpperRightArrow\[UnderBracket]","\[Element]"->"\[UnderBracket]Element\[UnderBracket]","\[NotElement]"->"\[UnderBracket]NotElement\[UnderBracket]","\[NotReverseElement]"->"\[UnderBracket]NotReverseElement\[UnderBracket]","\[NotSquareSubset]"->"\[UnderBracket]NotSquareSubset\[UnderBracket]","\[NotSquareSubsetEqual]"->"\[UnderBracket]NotSquareSubsetEqual\[UnderBracket]","\[NotSquareSuperset]"->"\[UnderBracket]NotSquareSuperset\[UnderBracket]","\[NotSquareSupersetEqual]"->"\[UnderBracket]NotSquareSupersetEqual\[UnderBracket]","\[NotSubset]"->"\[UnderBracket]NotSubset\[UnderBracket]","\[NotSubsetEqual]"->"\[UnderBracket]NotSubsetEqual\[UnderBracket]","\[NotSuperset]"->"\[UnderBracket]NotSuperset\[UnderBracket]","\[NotSupersetEqual]"->"\[UnderBracket]NotSupersetEqual\[UnderBracket]","\[ReverseElement]"->"\[UnderBracket]ReverseElement\[UnderBracket]","\[SquareSubset]"->"\[UnderBracket]SquareSubset\[UnderBracket]","\[SquareSubsetEqual]"->"\[UnderBracket]SquareSubsetEqual\[UnderBracket]","\[SquareSuperset]"->"\[UnderBracket]SquareSuperset\[UnderBracket]","\[SquareSupersetEqual]"->"\[UnderBracket]SquareSupersetEqual\[UnderBracket]","\[Subset]"->"\[UnderBracket]Subset\[UnderBracket]","\[SubsetEqual]"->"\[UnderBracket]SubsetEqual\[UnderBracket]","\[Superset]"->"\[UnderBracket]Superset\[UnderBracket]","\[SupersetEqual]"->"\[UnderBracket]SupersetEqual\[UnderBracket]","\[Conjugate]"->"\[UnderBracket]Conjugate\[UnderBracket]","\[ConjugateTranspose]"->"\[UnderBracket]ConjugateTranspose\[UnderBracket]","\[Exists]"->"\[UnderBracket]Exists\[UnderBracket]","\[ForAll]"->"\[UnderBracket]ForAll\[UnderBracket]","\[HermitianConjugate]"->"\[UnderBracket]HermitianConjugate\[UnderBracket]","\[NotExists]"->"\[UnderBracket]NotExists\[UnderBracket]","\[Transpose]"->"\[UnderBracket]Transpose\[UnderBracket]","\[Not]"->"\[UnderBracket]Not\[UnderBracket]","\[Rule]"->"\[UnderBracket]Rule\[UnderBracket]","\[RuleDelayed]"->"\[UnderBracket]RuleDelayed\[UnderBracket]","\[And]"->"\[UnderBracket]And\[UnderBracket]","\[Nand]"->"\[UnderBracket]Nand\[UnderBracket]","\[Xor]"->"\[UnderBracket]Xor\[UnderBracket]","\[Nor]"->"\[UnderBracket]Nor\[UnderBracket]","\[Or]"->"\[UnderBracket]Or\[UnderBracket]","\[Implies]"->"\[UnderBracket]Implies\[UnderBracket]","\[RoundImplies]"->"\[UnderBracket]RoundImplies\[UnderBracket]","\[DoubleLeftTee]"->"\[UnderBracket]DoubleLeftTee\[UnderBracket]","\[DoubleRightTee]"->"\[UnderBracket]DoubleRightTee\[UnderBracket]","\[DownTee]"->"\[UnderBracket]DownTee\[UnderBracket]","\[LeftTee]"->"\[UnderBracket]LeftTee\[UnderBracket]","\[RightTee]"->"\[UnderBracket]RightTee\[UnderBracket]","\[SuchThat]"->"\[UnderBracket]SuchThat\[UnderBracket]","\[Colon]"->"\[UnderBracket]Colon\[UnderBracket]","\[VerticalSeparator]"->"\[UnderBracket]VerticalSeparator\[UnderBracket]","\[Because]"->"\[UnderBracket]Because\[UnderBracket]","\[Therefore]"->"\[UnderBracket]Therefore\[UnderBracket]", "$"-> "\[UnderBracket]RawDollar\[UnderBracket]","_"-> "\[UnderBracket]"};


SIDify[s_?StringQ]:= Module[{r,alpha,alphaNumQ,okrest,okfirst,flags},

alphaQ[x_]:= StringMatchQ[x,RegularExpression["([a-z]|[A-Z])"]];
alphaNumQ[x_]:= DigitQ[x]\[Or]alphaQ[x];
okrest[x_]:= alphaNumQ[x]\[Or](x=="\[UnderBracket]");
okfirst[x_]:=alphaQ[x]\[Or](x=="\[UnderBracket]");
 
(* remove special Named Mathematica Characters from the String*)
r=StringReplace[s,characterReplacementRules];

(* now remove non-SID's *)

r=Characters[r];
flags=Prepend[okrest/@Rest[r],okfirst[First[r]]];
Print[flags];

r=StringJoin@@r;

If[StringLength[r]==0, r="\[UnderBracket]NullString\[UnderBracket]"];
Return[r];
];
SIDify[x___]:= Print["Error: "//boldRed," SIDify: argument is not a string: "//boldBlack, {x}//boldBlue];


$SubsetMathML = {"cn", "ci", "csymbol", "apply", "piecewise", "piece", "otherwise","eq", "neq", "gt", "lt", "geq", "leq","plus", "minus", "times", "divide", "power", "root", "abs", "exp", "ln", "log", "floor", "ceiling", "factorial", "and", "or", "not", "xor", "degree","bvar", "logbase", "sin", "cos", "tan", "sec", "csc", "cot", "sinh", "cosh","sech", "csch", "coth", "arcsin", "arccos", "arctan", "arccosh", "arccot", "arccoth", "arccsc", "arccsch", "arcsec", "arcsech", "arcsinh", "arcsinh", "arctanh", "true", "false", "notanumber", "pi", "infinity", "exponentiale", "semantics", "annotation", "annotation-xml"};
$ArrayMathML={"matrix","matrixrow", "vector", "selector", "bvar","lowlimit", "uplimit", "interval", "condition", "vectorproduct", "scalarproduct", "outerproduct","transpose","sum", "product", "forall", "exists"};


sunderscore[x_?StringQ]:= Module[{u},
u=StringJoin@@(("&#"<>#<>";")&/@ToString/@ToCharacterCode[$SBML$Underscorecharacter]);
Return[StringReplace[x, {$SBML$Underscorecharacter-> "_",u-> "_"}]];
]; 


now[]:= If[$VersionNumber<6, now5[], now6[]]; 
now6[]:= DateString[{"Day","-", "MonthNameShort","-", "Year", " ","Hour", ":", "Minute", ":", "Second"," (", "TimeZone",")"}];
now5[]:= Module[{yr,month,day,hr,min,sec,dateString,
months={"January","February","March","April",
"May","June","July","August",
"September","October","November","December"}, integerform
},
integerform[i_, n_]:= Module[{j},
j = i + 10^n;
StringDrop[ToString[j],1]
];
{yr,month,day,hr,min,sec}=MyDate[];
dateString=ToString[day]<>"-"<>months[[month]]<>"-"<>ToString[yr]<>" "<>ToString[integerform[hr,2]]<>":"<>ToString[integerform[min,2]]<>":"<>ToString[integerform[sec,2]];
Return[dateString]
];
W3CDTF[]:= Module[{yr,month,day,hr,min,sec,dateString,info
},
info=MyDate[];
sec=StringTake["0"<>ToString[Round[Last[info]]],-2];
info=Most[info];
info=ToString/@info;
yr=First[info];
info=Rest[info];
info="0"<>#&/@info;
info=StringTake[#,-2]&/@info;
{month,day,hr,min}=info;

dateString=yr<>"-"<>month<>"-"<>day<>"T"<>hr<>":"<>min<>":"<>sec;
Return[dateString]
];
today[]:= Module[{yr,month,day,hr,min,sec,dateString,
months={"January","February","March","April",
"May","June","July","August",
"September","October","November","December"}, integerform
},
integerform[i_, n_]:= Module[{j},
j = i + 10^n;
StringDrop[ToString[j],1]
];
{yr,month,day,hr,min,sec}=MyDate[];
dateString=ToString[day]<>"-"<>months[[month]]<>"-"<>ToString[yr];
Return[dateString]
];


XMLOutSquish[XMLElement[a___]]:=Module[{xml},xml=XMLElement[a];xml=XMLOut[xml];xml=FixedPoint[StringReplace[#1,{"\"\n "->"\"\n"}]&,xml];
xml=StringReplace[xml,{"\"\n"->"\" "}];Return[xml];];
XMLPrintForm[XMLElement[a___],color_,fsize_:12]:=Module[{xml},xml=XMLElement[a];xml=XMLOutSquish[xml];xml=MyStyleForm[xml,FontWeight->"Bold",FontColor->color,FontSize->fsize];
Return[xml];];
XMLHighlightForm[XMLElement[a___],color_,hstringin_,fsize_:12]:=Module[{xml,xml1,xml2,xml3,xmlist={},n,nlast,n1,n2,s1,s2,s3,nl,hstring},hstring=StringReplace[hstringin,{"\[UnderBracket]"->"_"}];
xml=XMLElement[a];
xml=XMLOutSquish[xml];
n=StringPosition[xml,hstring];
nl=StringLength[xml];If[Length[n]==0,
xmlist={MyStyleForm[xml,FontWeight->"Bold",FontColor->color,FontSize->fsize]};
Return[xmlist];
];
nlast=1;
While[Length[n]>0,
{n1,n2}=First[n];
n=Rest[n];
If[n1>=nlast,s1=StringTake[xml,{nlast,n1-1}],s1=""];
If[n2>=n1,s2=StringTake[xml,{n1,n2}],s2=""];AppendTo[xmlist,MyStyleForm[s1,FontWeight->"Bold",FontColor->color,FontSize->fsize]];AppendTo[xmlist,MyStyleForm[s2,FontWeight->"Bold",FontColor->color,FontSize->fsize,Background->Yellow]];nlast=n2+1;
];
If[nlast<=nl,s3=StringTake[xml,{nlast,nl}],s3=""];AppendTo[xmlist,MyStyleForm[s3,FontWeight->"Bold",FontColor->color,FontSize->fsize]];
Return[xmlist];
];


quote[x_]:= "\""<>stringer[x]<>"\"";


If[$$LoadBug, Print["Loading:functions"]];


init[]:= Module[{},
$SBML$SessionWarnings = 0;
$SBML$FileWarnings=0;
MathSBML`Private`$SBML$warnings= True;
]; 
init[];


Options[SBMLRead]={Global`debug-> False,Global`verbose-> False, Global`warnings-> True,Global`evaluateParameters-> True,Global`showKineticLaw-> True,
Global`showReactionParameters-> True,
Global`shortenODES-> False,Global`stats->False,Global`concise-> False, Global`underscore-> "\[UnderBracket]",Global`defaultIC-> "Indeterminate",Global`defaultParameterValue->"Indeterminate",Global`indeterminateValueString-> "Indeterminate",
Global`printModelName-> False,
Global`printSessionStats-> False ,
Global`return-> {Global`SBMLODES-> True, 
Global`SBMLIC-> True, 
Global`SBMLConstants-> True, 
Global`SBMLParameters-> True,
Global`SBMLModelVariables-> True,
Global`SBMLSpecies-> True,
Global`SBMLBoundaryConditions-> True,
Global`SBMLAlgebraicRules-> True,
Global`SBMLAssignmentRules-> True,
Global`SBMLConstraints-> True,
Global`SBMLInitialAssignments-> True,
Global`SBMLContext-> True,
Global`SBMLUnitDefinitions-> True,
Global`SBMLUnitAssociations->True, 
Global`SBMLReactions-> True,
Global`SBMLModelName-> True, 
Global`SBMLFunctions-> True, 
Global`SBMLEvents-> True,
Global`SBMLNameIDAssociations-> True,
Global`SBMLNumericalSolution-> 0,
Global`SBMLCompartments-> True,
Global`SBMLSpeciesCompartmentAssociations-> True,
Global`SBMLStoichiometryMatrix-> False,
Global`SBMLConservationMatrix-> False, 
Global`SBMLMassBalanceEquations-> False,
Global`SBMLMassActionEquations-> False,
Global`SBMLSpeciesTypes-> True,
Global`SBMLCompartmentTypes-> True, 
Global`SBMLKineticLaws-> True,
Global`SBMLMetaIDAssociations-> True},
Global`SBMLMassBalanceRateVector-> Automatic,
Global`SBMLSimplifyRateLaws-> False, 
Global`context-> "Automatic",
Global`verboseContext-> False,
Global`align-> "Left",
Global`NDSolveOptions-> {}, 
MathSBMLSaveVerboseData-> "False",
Global`PlotOptions-> {},
Global`LoadModelBuilder-> True,
Global`EchoLoad-> False,
Global`rationals-> False,
Global`verboseBuiltInUnits-> False,
Global`verboseNormalizedValues-> False,
Global`units-> False,
Global`verboseStoichiometry-> False,
Global`verboseMassBalanceEquations-> False,
Global`verboseMassActionEquations-> False, 
Global`reportMissingODES-> False
};


$SBML$modelcount = 0;
$SBML$SessionWarnings = 0;
$SBML$SessionStartTime=TimeUsed[];
$SBML$FilesRead=0;
$SBML$OutputFormatIsHTML=False;


SBMLRead[x_,opt___?OptionQ]:= Module[
{sbml, returnFlags, plot,plotopt, solve},


Off[General::"spell"];
Off[General::"spell1"];
Off[Part::"pspec"]; 

previouslyDefinedNamesInTheMathematicaEnvirnoment=Names["*"];
previouslyDefinedContextsInTheMathematicaEnvironment=Contexts[];

$CPU$Trace=False;
$CPUZero=TimeUsed[];
$CPU=$CPUZero;
$SBML$InitialCPU=TimeUsed[];
$SBML$debug = Global`debug/.{opt}/.Options[SBMLRead];
$SBML$verbose = Global`verbose/.{opt}/.Options[SBMLRead];
SBML$VerboseData = {}; 


$ReportMissingODE=Global`reportMissingODES/.{opt}/.Options[SBMLRead]; 

If[$SBML$debug,
Print["SBMLRead: {opt}:"//boldRed,{opt}//boldBlue];
Print["SBMLRead: $SBML$debug:"//boldRed,$SBML$debug//boldBlue];
];

MB$Load = Global`LoadModelBuilder/.{opt}/.Options[SBMLRead];
MB$Load=True; (* need for force this for checking *)
MB$Echo = Global`EchoLoad/.{opt}/.Options[SBMLRead];
$SBML$MetaIDAssociations={}; 

If[MB$Load, newModel[opt,Global`echo-> MB$Echo]]; 

If[$SBML$debug \[And] MB$Load,
Print["SBMLRead: Model Builder Loaded."//boldRed];
];

$SBML$Rationals=Global`rationals/.{opt}/.Options[SBMLRead];
$SBML$verboseContext=Global`verboseContext/.{opt}/.Options[SBMLRead];
$SBML$verboseBuiltInUnits = Global`verboseBuiltInUnits/.{opt}/.Options[SBMLRead]; 
$SBML$verboseNormalizedValues=Global`verboseNormalizedValues/.{opt}/.Options[SBMLRead];

$SBML$UseUnits=Global`units/.{opt}/.Options[SBMLRead];
$SBML$verboseNormalizedValues = And[$SBML$verboseNormalizedValues, $SBML$UseUnits];

$SBML$Normalize=$SBML$UseUnits; 

$SBML$printModelName = Global`printModelName/.{opt}/.Options[SBMLRead];
$SBML$modelcount++; 
$SBML$FileWarnings=0;
$SBML$warnings = Global`warnings/.{opt}/.Options[SBMLRead];

$SBML$evaluateParameters = Global`evaluateParameters/.{opt}/.Options[SBMLRead];


$SBML$KineticLaw = Global`showKineticLaw/.{opt}/.Options[SBMLRead];
$SBMLSimplifyRateLaws=Global`SBMLSimplifyRateLaws/.{opt}/.Options[SBMLRead];
$SBML$ShowReactionParameters=Global`showReactionParameters/.{opt}/.Options[SBMLRead];
$SBML$shortenODES = Global`shortenODES/.{opt}/.Options[SBMLRead];
$SBML$Stats = Global`stats/.{opt}/.Options[SBMLRead];
$SBML$Underscorecharacter=Global`underscore/.{opt}/.Options[SBMLRead];
$SBML$IndeterminateValue=Global`indeterminateValueString/.{opt}/.Options[SBMLRead];
$SBML$DefaultIC= ToString[Global`defaultIC/.{opt}/.Options[SBMLRead]];
$SBML$UseDefaultIC =($SBML$DefaultIC!= $SBML$IndeterminateValue);
$SBML$DefaultParameterValue=ToString[ Global`defaultParameterValue/.{opt}/.Options[SBMLRead]];
$SBML$UseDefaultParameterValue =($SBML$DefaultParameterValue!= $SBML$IndeterminateValue );
$SBML$VerboseAlign = ToString[(Global`align/.{opt}/.Options[SBMLRead])];

$SBML$ReportCPU = False; (* change this line to enable CPU observation *) 
If[$SBML$ReportCPU, $SBML$CPU={TimeUsed[]}]; 

SBMLUndefinedConstants={};

If[Global`concise/.{opt}/.Options[SBMLRead], 
$SBML$verbose=False;
$SBML$warnings=False;
$SBML$Stats=False;
];

If[$SBML$debug,
Print["SBMLRead: Basic constants set ."//boldRed];
];

saveVerboseData = $SBML$verbose \[Or] (MathSBMLSaveVerboseData/.{opt}/.Options[SBMLRead]); 

If[$SBML$debug,
Print["SBMLRead: verbose flag set ."//boldRed];
];

Clear[SBMLVariableQ];
Clear[SBMLParameterQ];
Clear[SBMLIC]; 
Clear[SBMLIC\[UnderBracket]SI];
Clear[SBMLSpeciesToSubstanceUnits];
Clear[SBMLSpeciesSIConcentration];
Clear[SBMLCompartmentSize];
Clear[SBMLSpeciesToUnitsOfTheSpecies];

If[$SBML$debug,
Print["SBMLRead: SBML parameters cleared."//boldRed];
];

SBMLVariableQ[unknownVariable_]:= False;
SBMLParameterQ[unknownParameter_]:= False;
SBMLIC[unknownVariable_]:= ToString[$SBML$IndeterminateValue];
SBMLSpeciesToSubstanceUnits[unknownVariable_]:= unknownVariable;
SBMLSpeciesSIConcentration={};

SBMLCompartmentSize[unknownVariable_]:= unknownVariable;
SBMLSpeciesToUnitsOfTheSpecies[unknownVariable_]:= 1;
SBMLIC\[UnderBracket]SI[unknownVariable_]:= SBMLIC[unknownVariable];

SBMLVariables={}; 
SBMLConstants={}; 
SBMLBoundaryConditions={};
SBMLGlobalParameters={}; 
SBMLReplacementRules={}; 
$SBML$MassActionVariables={};
SBML$MassAction$Equations={};
$SBML$SpeciesTypes={};
$SBML$SpeciesTypeAssociations={};
$SBML$CompartmentTypes={};
$SBML$CompartmentTypeAssociations={};

(* determine what needs to be returned *) 

returnFlags=(Global`return/.{opt}/.Options[SBMLRead]);

If[$SBML$debug,
Print["SBMLRead: setting return flags; {returnFlags}="//boldRed,{returnFlags}//boldBlue];
];


SBMLRead$return = (ToUpperCase[ToString[returnFlags]]!= "NONE");
If[SBMLRead$return,
returnFlags = Join[returnFlags,Global`return/.Options[SBMLRead]];

SBMLRead$returnODES= Global`SBMLODES/.returnFlags;
SBMLRead$returnContext=Global`SBMLContext/.returnFlags;
SBMLRead$returnIC= Global`SBMLIC/.returnFlags;
SBMLRead$returnConstants= 
 Global`SBMLConstants/.returnFlags;
SBMLRead$returnBoundaryConditions=Global`SBMLBoundaryConditions/.returnFlags;
SBMLRead$returnGlobalParameters=Global`SBMLParameters/.returnFlags;
SBMLRead$returnModelVariables= Global`SBMLModelVariables/.returnFlags;
SBMLRead$returnSpecies= Global`SBMLSpecies/.returnFlags;
SBMLRead$returnSpeciesTypes= Global`SBMLSpeciesTypes/.returnFlags;
SBMLRead$returnCompartmentTypes=Global`SBMLCompartmentTypes/.returnFlags;
SBMLRead$returnAlgebraicRules= Global`SBMLAlgebraicRules/.returnFlags;SBMLRead$returnConstraints= Global`SBMLConstraints/.returnFlags;
SBMLRead$returnInitialAssignments = Global`SBMLInitialAssignments/.returnFlags;
SBMLRead$returnAssignmentRules=Global`SBMLAssignmentRules/.returnFlags;
 SBMLRead$returnUnitDefinitions= Global`SBMLUnitDefinitions/.returnFlags;
SBMLRead$returnUnitAssociations=Global`SBMLUnitAssociations/.returnFlags;
SBMLRead$returnKineticLaws=Global`SBMLKineticLaws/.returnFlags;
SBMLRead$returnReactions= Global`SBMLReactions/.returnFlags;
SBMLRead$returnModelName=Global`SBMLModelName/.returnFlags;
SBMLRead$returnFunctions=Global`SBMLFunctions/.returnFlags;
SBMLRead$returnEvents=Global`SBMLEvents/.returnFlags;
SBMLRead$returnNameIDAssociations=Global`SBMLNameIDAssociations/.returnFlags;
SBMLRead$returnSolution=Global`SBMLNumericalSolution/.returnFlags;
SBMLRead$returnCompartments=Global`SBMLCompartments/.returnFlags;
SBMLRead$returnSpeciesCompartmentAssociations = Global`SBMLSpeciesCompartmentAssociations/.returnFlags;
SBMLRead$returnMetaIDAssociations=Global`SBMLMetaIDAssociations/.returnFlags;

SBML$NDSolveOptions = Sequence[Global`NDSolveOptions/.{opt}/.Global`NDSolveOptions-> {}];

solve = NumberQ[SBMLRead$returnSolution] \[And] SBMLRead$returnSolution>0; 
If[!NumberQ[SBMLRead$returnSolution],
Print[boldRed["Warning:"],
boldBlack["SBMLNDSolve must be assigned a numerical value, not "],
boldBlue[SBMLRead$returnSolution]
];
SBMLRead$returnSolution = 0; 
];
 

If[$SBML$debug,
Print["SBMLRead: basic SBMLRead return flags set, returnFlags="//boldRed,{returnFlags}//boldBlue];
];

SBMLRead$returnMassBalanceEquations=Global`SBMLMassBalanceEquations/.returnFlags;
SBMLRead$returnConservationMatrix=Global`SBMLConservationMatrix/.returnFlags;
SBMLRead$returnStoichiometryMatrix=(SBMLRead$returnConservationMatrix \[Or] (Global`SBMLStoichiometryMatrix/.returnFlags));

SBMLRead$returnMassActionEquations=And[Global`SBMLMassActionEquations/.returnFlags, SBMLRead$returnMassBalanceEquations];

If[$SBML$debug,
Print["SBMLRead:  SBMLRead$returnStoichiometryMatrix flags set"//boldRed];
];


If[SBMLRead$returnMassBalanceEquations,
SBML$RateVectorID=Global`SBMLMassBalanceRateVector/.{opt}/.Options[SBMLRead];
SBML$RateVectorID=stringer[SBML$RateVectorID];
If[SBML$RateVectorID=="Automatic",SBML$RateVectorID=Unique["v"];];
SBML$RateVectorID=ToExpression[SBML$RateVectorID];
SBML$MassBalanceEquations={};
];
If[$SBML$debug,
Print["SBMLRead:  mass balance flags set"//boldRed];
];


$SBML$VerboseStoichiometry=Global`verboseStoichiometry/.{opt}/.Options[SBMLRead]; 

$SBML$Verbose$MassBalanceEquations=And[SBMLRead$returnMassBalanceEquations,Global`verboseMassBalanceEquations/.{opt}/.Options[SBMLRead]]; 
$SBML$Verbose$MassActionEquations=And[SBMLRead$returnMassActionEquations,Global`verboseMassActionEquations/.{opt}/.Options[SBMLRead]]; 


];
If[$SBML$debug,
Print["SBMLRead: stoichiometric SBMLRead return flags set"//boldRed];
];

$SBML$Context = Global`context/.{opt}/.Options[SBMLRead];
$SBML$Context=ToString[$SBML$Context];

If[$SBML$debug,
Print["SBMLRead: Return flags set ."//boldRed];
];

cpuSet[]; 

If[$SBML$debug,
Print["SBMLRead::calling getSBML: x:"//boldRed,x//boldBlue];
Print["SBMLRead::calling getSBML: {opt}:"//boldRed,{opt}//boldBlue];
]; 

sbml  = getSBML[x,opt]; 

If[$SBML$debug,
Print["SBMLRead::returned from getSBML: sbml:"//boldRed,sbml//boldBlue];
]; 

plotopt=Global`PlotOptions/.{opt}/.Options[SBMLRead];
plot=(ListQ[plotopt] \[And] (Length[plotopt]>0))\[Or] ((ToUpperCase[ToString[plotopt]]) =="TRUE");

If[plot,
If[solve,
If[ToUpperCase[ToString[plotopt]]=="TRUE", 
SBMLPlot[sbml],
SBMLPlot[sbml, Sequence[plotopt]]
],
Print[boldRed["Warning:  "], boldBlack["SBMLRead: "],
boldBlue["PlotOptions\[Rule]"<>ToString[plotopt]],
boldBlack["\nignored because numerical solution is inhibited by "],"return\[Rule]{SBMLNumericalSolution\[Rule]0}"//boldBlue];
]; 
];

cpuReport["getSBML"]; 

If[Global`printSessionStats/.{opt}/.Options[SBMLRead],
Print["Aggregate Statistics: ",
$SBML$modelcount," models; ",
$SBML$SessionWarnings," warnings; ",
TimeUsed[]-$SBML$SessionStartTime," CPU."
];
]; 

sbml = Sort[sbml]; (* put options in alphabetical order *)

Return[sbml];
];


textODES[model_]:=Module[{eqs},
eqs=Global`SBMLODES/.model;
eqs=InputForm/@eqs;
eqs=ToString/@eqs;
eqs = (#<>"\n")&/@eqs;
eqs=StringJoin@@eqs;
Return[eqs]
];
textODES[model_, filename_]:= Module[{eqs,f},
eqs= textODES[model];
f=validateOutputFileName[filename];
f=Export[f,eqs,"text"];
Return[f];
];


SBMLNDSolve[{}, x___]:= Module[{}, Print["Error: "//boldRed, "Expecting "//boldBlack,"SBMLNDSolve[model, duration, options]"//boldBlue, " and not "//boldBlack,
"SBMLNDSolve[{}, ...]"//boldBlue ];
 Return[$Failed]
]; 
SBMLNDSolve[$Failed, x___]:= Module[{}, Print["Error: "//boldRed, "Expecting "//boldBlack,"SBMLNDSolve[model, duration, options]"//boldBlue, " and not "//boldBlack,
"SBMLNDSolve[$Failed, ...]"//boldBlue ];
 Return[$Failed]
]; 

SBMLNDSolve[x_,tmax_,opt___?OptionQ]:= Module[{n, ev,cr},


$ReportMissingIC=True;
(*$ReportMissingODE = False; *) 
$FirstIteration = True;
ev = Global`SBMLEvents/.x;

cr=Global`SBMLConstraints/.x/.{Global`SBMLConstraints-> {}};

$InitialRun=True;

If[Length[ev]>0 \[Or] Length[cr]>0, 

n=NDSolveSBMLWithEvents[x, tmax,ev,cr,opt];
,
n=NDSolveSBMLModel[x,0, tmax, opt];
]; 
Return[n];

];

SBMLNDSolve[x___]:= Module[{}, Print["Error: "//boldRed, "Expecting "//boldBlack,"SBMLNDSolve[model, duration, options]"//boldBlue];
 Return[$Failed]
]


DEBUGGridPlot=False; 

SBMLGridPlot[q_?InterpolationSetListQ,opt___?OptionQ]:=Module[{v},
If[DEBUGGridPlot, Print["SBMLGridPlot (1):"]]; 
(* v=Head/@decontextify/@First/@q[[1,3]]; *)

v=ToString/@(Head/@First/@q[[1,3]]);

(* v=StringReplace[decontextify/@ToString/@First/@q[[1,3]], "[t]"-> ""]; *)

If[DEBUGGridPlot, Print["SBMLGridPlot (1): v: ", v]]; 

Return[SBMLGridPlot[q,v,opt]];
];
SBMLGridPlot[q_?InterpolationSetListQ,{vars__},opt___?OptionQ]:=Module[{tstart,tend},
If[DEBUGGridPlot, Print["SBMLGridPlot (2): {vars}: ", {vars}]]; 
tstart=q[[1,1]];
tend=q[[Length[q],2]];
Return[SBMLGridPlot[q,{vars},{tstart,tend},opt]];
];
SBMLGridPlot[q_?InterpolationSetListQ,{vars__},{tstart_,tend_},opt___?OptionQ]:=Module[{p,n,colors,nc,g,np},
If[DEBUGGridPlot, Print["SBMLGridPlot (3): {vars}: ", {vars}]]; 
n=Length[Flatten[{vars}]];
colors=Hue/@(Range[n]/(1.` n));p=MapThread[SBMLPlot[q,{#1},PlotLabel->stringer[#1],PlotStyles->#2,Global`holdLegend->True,DisplayFunction->Identity,opt]&,{{vars},colors}];
nc=Global`columns/.{opt}/.{Global`columns->3};g=Partition[p,nc];
ng=Length[Flatten[g]];
np=Length[Flatten[p]];
If[np>ng,
g=Append[g,Take[p,ng-np]];
];
g=Show[GraphicsGrid[g]];
Return[g];
];
SBMLGridPlot[sol_,var_?ListQ,{tbegin_?NumberQ,tend_?NumberQ},opt___?OptionQ]:=Module[{n,colors,p,popt,nc,g,ng,np},
If[DEBUGGridPlot, Print["SBMLGridPlot (4):"]]; 
n=Length[Flatten[var]];
colors=Hue/@(Range[n]/(1.` n));
With[{popt=MyFilterOptions[Plot,System`DisplayFunction->Identity,opt ]},p=MapThread[SBMLPlot[sol,#1,{tbegin, tend}, PlotStyle->#2,PlotLabel->stringer[#1],Global`holdLegend-> True, popt]&,{var,colors}];
];
nc=Global`columns/.{opt}/.{Global`columns->3};
g=Partition[p,nc];
ng=Length[Flatten[g]];
np=Length[Flatten[p]];
If[np>ng,g=Append[g,Take[p,ng-np]];];
g=Show[GraphicsGrid[g]];
Return[g];
];
SBMLGridPlot[sol_,var_?ListQ,opt___?OptionQ]:=Module[{soln,g,tbegin,tend,debug=False},
If[DEBUGGridPlot, Print["SBMLGridPlot (5):"]]; 
soln=selectSolution[sol];
If[debug,Print["soln=",soln];];
{tbegin,tend}=getPlotTimes[soln];
g=SBMLGridPlot[soln,var,{tbegin,tend},opt];
Return[g];];
SBMLGridPlot[sol_,opt___?OptionQ]:=Module[{soln,g,vars},
If[DEBUGGridPlot, Print["SBMLGridPlot (6):"]]; 
vars=decontextify[Head/@First/@Flatten[sol]];
g=SBMLGridPlot[sol,vars,opt];Return[g];];


InterpolationSetListQ[x_]:= Module[{},
If[!ListQ[x], Return[False]]; 
Return[Length[Complement[Head/@x,{InterpolationSet}]]<1];
];


startAndEndValues[InterpolationSet[start_, end_, f_]]:= Module[{vars,startValues, endvalues},
vars = First/@f;
startValues = vars/.f/.{Global`t-> start};
endValues=vars/.f/.{Global`t-> end};
vars = decontextify[vars];

startValues = MapThread[{#1,start,#2}&, {vars,startValues}];
endValues = MapThread[{#1,end,#2}&,{ vars,endValues}];
Return[{startValues, endValues}]
];
startAndEndValues[f_?InterpolationSetListQ]:= Join@@(startAndEndValues/@f);


DEBUGPLOT=False;


SBML$LogPlotZero=0;
SBML$MultiPlot=False;
SBMLPlot[$Failed]:= Module[{}, Print["Error: "//boldRed, "SBMLPlot: unable to plot: "//boldBlack, $Failed//boldBlue]];
SBMLPlot[{}]:= Module[{}, Print["Error: "//boldRed, "SBMLPlot: unable to plot: "//boldBlack, {}//boldBlue]]

SBMLPlot[q_?InterpolationSetListQ, {}]:= Module[{},
Print["Error: "//boldRed, "SBMLPlot: Invalid input."//boldBlack];
Abort[];
];

SBMLPlot[q_?InterpolationSetListQ,z___?OptionQ]:=Module[{p,s,opts,legend,savs,vars,datasets,createLines,connectingLines,debug=True, dbg,zbad,logplot,zerovalue,hold,colors,df},

SBML$MultiPlot=True;
dbg=DEBUGPLOT;
If[dbg,Print["SBMLPlot: InterpolationSetListQ (0): "//boldRed, "SBMLPlot: plotting interpolation set"]];


opts=Select[{z},OptionQ];
hold=holdLegend/.opts/.{holdLegend->False};
colors=SBMLPlotColors/.opts/.{SBMLPlotColors->{}};

If[dbg,Print["SBMLPlot: InterpolationSetListQ: "//boldRed, "\ncolors:"//boldRed,colors//boldBlue, "\nhold:"//boldRed, hold//boldBlue]];

zbad=Complement[{z},{opts}];
logplot=stringer[type/.{z}/.{type->""}]=="Log";
zbad=Complement[zbad,{type->"Log"}];
zbad=Select[zbad,stringer[First[#1]]!="zero"&];
zbad=Select[zbad,!First[#1]===holdLegend];
zbad=Select[zbad,!First[#1]===SBMLPlotColors];
zbad=Select[zbad,!First[#1]===PlotStyles];
 
If[dbg, Print["SBMLPlot: InterpolationSetListQ: q:"//boldRed, q//boldBlue]];

If[Length[zbad]>0,(Print[boldOrange[">>Warning: "],boldBlack[" The option "],boldRed[#1],boldBlack[" is not allowed (or has not yet been implemented) for models that contain events."]]&)/@zbad;];

If[logplot,
If[dbg,Print["SBMLPlot: InterpolationSetListQ: "//boldRed, "About to call SBMLPlot[interpolatingFunction] - LogPlot"]];
zerovalue={zero/.{z}/.{zero->0}};
SBML$LogPlotZero=Max[zerovalue,0];
p=SBMLLogPlot[q,Sequence@@opts,PlotRange->All];,

If[dbg,Print["SBMLPlot: InterpolationSetListQ: "//boldRed, "About to call SBMLPlot[interpolatingFunction]"]];
p=(SBMLPlot[#1,Sequence@@opts,
Global`holdLegend->hold,
Global`SBMLPlotColors->colors,
PlotRange->All
]&)/@q
];


If[dbg,Print["SBMLPlot: InterpolationSetListQ: "//boldRed, "dbg: SBMLPlot: plotting interpolation sets: p: ",Show[p,DisplayFunction->$DisplayFunction]]];

SBML$MultiPlot=False;legend={MapThread[{Graphics[{Sequence@@#1,Line[{{0,0},{1,0}}]}],ToString[#2]}&,{MultiPlot$Styles,MultiPlot$Legends}]};


If[$VersionNumber<6, legend=Join[legend,{LegendSize->{1,1},LegendPosition->{1,-0.5`},TextStyle->{FontFamily->Times}}], 
legend=Join[legend,{LegendSize->{1,1},LegendPosition->{1,-0.5`},BaseStyle->{FontFamily->Times}}];
]; 

If[Length[p]>1&&!logplot,
sav=startAndEndValues[q];

vars=(#1[Global`t]&)/@ToExpression/@MultiPlot$Legends;

If[dbg, Print["SBMLPlot: InterpolationSetListQ: "//boldRed, "sav: "//boldRed, sav//boldBlue, "\nvars:"//boldRed, vars//boldBlue]]; 

datasets=(Cases[sav,{#1,___},\[Infinity]]&)/@vars;

If[dbg,Print["SBMLPlot: InterpolationSetListQ: "//boldRed, "dbg: SBMLPlot: plotting interpolation set: datasets(1): ",datasets//boldBlue]];

datasets=(Drop[Drop[#1,1],-1]&)/@datasets;

If[dbg,Print["SBMLPlot: InterpolationSetListQ: "//boldRed, "dbg: SBMLPlot: plotting interpolation set: datasets(2): ",datasets//boldBlue]];datasets=Transpose/@(Drop[#1,1]&)/@Transpose/@datasets;datasets=(Partition[#1,2]&)/@datasets;createLines[dataset_,style_]:=Module[{},If[dbg,Print["createLines: style:",style]];(Graphics[{Sequence@@style,Line[{#1[[1]],#1[[2]]}]}]&)/@dataset];datasets=MapThread[createLines,{datasets,MultiPlot$Styles}];If[dbg,Print["SBMLPlot: InterpolationSetListQ: "//boldRed, "datasets:",datasets]];connectingLines=Show[Flatten[datasets],DisplayFunction->Identity];p=Show[p,connectingLines];If[dbg,Print["SBMLPlot: InterpolationSetListQ: "//boldRed, "p with connectingLines:",Show[p,DisplayFunction->$DisplayFunction]]];,Off[Graphics::"gptn"];p=Show[p,DisplayFunction->Identity];On[Graphics::"gptn"];];If[AllowMultiPlot$Legends,s=ShowLegend[p,legend],df=DisplayFunction/.opts/.{DisplayFunction->$DisplayFunction};If[dbg,Print["SBMLPlot: InterpolationSetListQ: "//boldRed, "df:",df]];
Return[Show[p,DisplayFunction->df]]]
];
SBMLPlot[q_?InterpolationSetListQ,{var__},z___?OptionQ]:=Module[{tstart,tend},
If[DEBUGPLOT, Print["SBMLPlot: InterpolationSetListQ: (1): {var}: ", {var} ]];
tstart=q[[1,1]];
tend=q[[Length[q],2]];
Return[SBMLPlot[q,{var},{tstart,tend},z]];];

SBMLPlot[q_?InterpolationSetListQ,{var__},{tstart_,tend_},z___?OptionQ]:=Module[{convars,devars,r,n,selvars},

If[DEBUGPLOT, Print["SBMLPlot: InterpolationSetListQ: (2): {var}: ", {var}]];

selvars[InterpolationSet[t1_,t2_,set_],vin_]:=Module[{newset,v,  notfound, varsInSolution},


v= If[StringQ[#], ToExpression[#], #]&/@vin;


newset=Select[set,MemberQ[v,First[#1]]&];

varsInSolution=First/@set;
debugPrint[DEBUGPLOT, "SBMLPlot: selvars: varsInSolution:", varsInSolution];
debugPrint[DEBUGPLOT, "SBMLPlot: selvars:  v:", v]; 
debugPrint[DEBUGPLOT, "SBMLPlot: selvars:  defunctionate/@v:", defunctionate/@v]; 


notFound=Complement[decontextify/@defunctionate/@v, decontextify/@defunctionate/@varsInSolution];
Print["Warning:"//boldRed, "SBMLPlot: The requested variable "//boldBlack,defunctionate[#]//boldBlue, " was not found in the solution set for the time period "//boldBlack , {t1, t2}//boldBlack]&/@notFound;


If[DEBUGPLOT, 
Print["v:", v]; 
Print["set: ", set, "\nnewset:", newset];
];

If[Length[newset]==0, 
Print["Error: "//boldRed, "SBMLPlot: requested variables: "//boldBlack,(defunctionate/@ v)//boldBlue, " not found in solution set. There is nothing to plot. " //boldBlack];
Abort[];
];
Return[InterpolationSet[t1,t2,newset]];
];

 
devars=decontextify/@{var};
convars=contextify/@devars;
(* devars=(#1[Global`t]&)/@devars;
convars=(#1[Global`t]&)/@convars;*)
devars = functionate/@devars;
convars= functionate/@convars; 


r=MapThread[#1->#2&,{convars,devars}];
(* n=(selvars[#1,Union[Join[devars,convars]]]&)/@q; *) 

n=(selvars[#1,convars]&)/@q;


If[DEBUGPLOT, Print["SBMLPlot: InterpolationSetListQ: (2): n: ", n]];

Return[
SBMLPlot[n,PlotRange->{{tstart,tend},All},z]
];
];

SBMLPlot[InterpolationSet[t1_,t2_,sol_],{var__?nonOptionQ},{tbegin_?NumberQ,tend_?NumberQ},opt___?OptionQ]:=Module[{},
If[DEBUGPLOT, Print["SBMLPlot:InterpolationSet: (1)"//boldRed]]; 

SBMLPlot[sol,{var},{Max[tbegin,t1],Min[tend,t2]},opt]
];

SBMLPlot[InterpolationSet[t1_,t2_,sol_],var_?nonOptionQ,{tbegin_?NumberQ,tend_?NumberQ},opt___?OptionQ]:=Module[{},
If[DEBUGPLOT, Print["SBMLPlot:InterpolationSet: (2)"//boldRed]]; 
SBMLPlot[sol,var,{Max[tbegin,t1],Min[tend,t2]},opt]
];

SBMLPlot[InterpolationSet[t1_,t2_,sol_],{tbegin_?NumberQ,tend_?NumberQ},opt___?OptionQ]:=Module[{},
If[DEBUGPLOT, Print["SBMLPlot:InterpolationSet: (3)"//boldRed]]; 
SBMLPlot[sol,{Max[tbegin,t1],Min[tend,t2]},opt]
];

SBMLPlot[InterpolationSet[t1_,t2_,sol_],var_?nonOptionQ,opt___?OptionQ]:=Module[{},
If[DEBUGPLOT, Print["SBMLPlot:InterpolationSet: (4), var="//boldRed, var//boldBlue]]; 

SBMLPlot[sol,var,{t1,t2},opt]
];

SBMLPlot[InterpolationSet[t1_,t2_,sol_],opt___?OptionQ]:=Module[{},
If[DEBUGPLOT, Print["SBMLPlot:InterpolationSet: (5)"//boldRed]]; 
If[DEBUGPLOT, Print["SBMLPlot: InterpolationSet: (5): sol:"//boldRed, sol//boldBlue]];
SBMLPlot[sol,{t1,t2},opt]
];


SBMLPlot[sol_, {var__?nonOptionQ},{tbegin_?NumberQ, tend_?NumberQ},opt___?OptionQ]:= Module[{legends, variables,n,colors,defaultColors,plotType, soln,p,legend,allowLegend,popt,styles,trace, dbg=False,tt, vars, plot, gopt},
trace=DEBUGPLOT;
dbg=DEBUGPLOT; 
If[dbg \[Or] trace, Print["==== SBMLPlot Trace ON ====\nSBMLPlot: {var}="//boldRed,{var}//boldBlue,"\nSBMLPlot: {tbegin, tend}="//boldRed,{tbegin,tend}//boldBlue, "\nSBMLPlot: {opt}="//boldRed, {opt}//boldBlue]]; 

soln = selectSolution[sol]; 

If[dbg, Print["decontextify/@{var}: ", decontextify/@stringer/@{var}]]; 
If[dbg, Print["contextify/@decontextify/@{var}: ",contextify/@ decontextify/@stringer/@{var}]]; 

variables=contextify/@decontextify/@stringer/@{var}; 
variables = Map[If[StringQ[#], ToExpression[#], #]&, variables];

vars = variables;

variables = Map[#[Global`t]&,variables];
legends = decontextify[Map[ToString,{var}]];
n=Length[legends];

(* get styles and make sure it is a list of lists *)
styles=Global`PlotStyles/.{opt}/.{Global`PlotStyles-> {}};
(* if PlotSTyles is not used, maybe PlotStyle was used globally *) 
If[Length[styles]<1, styles=PlotStyle/.{opt}/.{PlotStyle-> {}}]; 

If[dbg, Print["styles (1):",styles]]; 

(* If there is just one style, apply it to each variable*)
If[\[Not]ListQ[styles], styles=Table[{styles},{n}]];
If[dbg, Print["styles (2):",styles]]; 

(* If there is more than one style, but only a one level list, apply them to all variables *)

If[Length[styles]>0,
If[\[Not]ListQ[First[styles]],styles={styles}];
];
If[dbg, Print["styles (3):",styles]]; 

While[Length[styles]<n, styles=Append[styles,{}]]; 
If[Length[styles]>n, Print["Warning: "//boldRed," SBMLPlot: "//boldBlack, Length[styles]//boldBlue, " PlotStyles supplied only "//boldBlack,n//boldBlue," expected. Extra styles ignored. "//boldBlack];
styles=Take[styles,n];
];
If[dbg, Print["styles (4):",styles]]; 


(* add in colors if not supplied in PlotStyles *)

colors =Flatten[ Global`SBMLPlotColors/.{opt}/.{Global`SBMLPlotColors-> {}}]; 
(* If[SameQ[colors,None], 
colors = Map[Hue,Range[n]/(1.0*n)]]; *)
If[Length[colors]>0,
If[Length[colors]>n, Print["Warning: "//boldRed,"SBMLPlot: "//boldBlack, "\nSBMLPlotColors\[Rule]"<>ToString[colors]//boldBlue," contains "//boldBlack, Length[colors]//boldBlue, " colors; only "//boldBlack,
n//boldBlue,
boldBlack["\nare expected. The input will be interpreted as"],
boldBlue["\nSBMLPlotColors\[Rule]"<>ToString[Take[colors,n]]]
];
colors=Take[colors,n];
];
];

If[dbg,Print["n=",n," Length[colors]:",Length[colors]]];
If[Length[colors]<n,
defaultColors = Map[Hue,Range[n]/(1.0*n)];
defaultColors=Drop[defaultColors,Length[colors]];
colors=Join[colors, defaultColors];
];
If[dbg, Print["colors:",colors]]; 
If[dbg, Print["original styles:",styles]]; 

(* Seems that Mathematica choose the LAST style to use, not the FIRST, like Options *)
styles=MapThread[Prepend[#1,#2]&, {styles, colors}];

If[dbg, Print["revised styles:",styles]]; 

plotType = stringer[(Global`type/.{opt})]; 
If[plotType=="Log", 
p=SBMLLogPlot[soln,{var}, {tbegin, tend},opt];
Return[p];
];
allowLegend = \[Not](Global`holdLegend/.{opt}/.{Global`holdLegend-> False});
AllowMultiPlot$Legends=allowLegend;



If[trace, 
 Print["SBMLPlot: "//boldRed, "variables: "//boldRed, variables//boldBlue];
Print["SBMLPlot: "//boldRed, "styles: "//boldRed, styles//boldBlue]; 
Print["SBMLPlot: "//boldRed, "legends: "//boldRed, legends//boldBlue]; 
]; 

With[{popt=MyFilterOptions[Plot,opt]}, 

If[trace, Print["SBMLPlot: "//boldRed, "{popt}:"//boldRed, {popt}//boldBlue]]; 

If[SBML$MultiPlot,
If[trace, Print["SBMLPlot: SBML$MultiPlot"//boldRed]]; 

If[$VersionNumber<6,
p=Plot[Evaluate[variables/.soln], {Global`t,tbegin,tend},
PlotStyle->styles,  
Sequence[popt], 
DisplayFunction-> Identity
],

plot[x_, directives_]:= Plot[x/.soln, {Global`t, tbegin, tend}, PlotStyle->directives, popt]; 
(*
p=Plot[variables/.soln, {Global`t,tbegin,tend},
PlotStyle->((Directive@@#)&/@styles), 
Sequence[popt]
]*)

p=MapThread[plot, {variables, Directive/@styles}]
]; 

MultiPlot$Colors=colors;
MultiPlot$Legends = legends;
MultiPlot$Styles = styles;
,
If[trace, Print["SBMLPlot: "//boldRed, "Not SBML$MultiPlot: allowLegend: "//boldRed, allowLegend//boldBlue]]; 

If[$VersionNumber<6, 

If[allowLegend,
p=Plot[Evaluate[variables/.soln], {Global`t,tbegin,tend},
Sequence[popt],
Graphics`Legend`PlotLegend-> legends,
PlotStyle->styles, 
Graphics`Legend`LegendPosition-> {1,-0.5},
Graphics`Legend`LegendSize-> {.5,1}],
p=Plot[Evaluate[variables/.soln], {Global`t,tbegin,tend},
Sequence[popt],
PlotStyle->styles]
], 
If[trace, Print["SBMLPlot: variables:"//boldRed, variables//boldBlue]]; 

plot[x_, directives_]:= Plot[x/.soln, {Global`t, tbegin, tend}, PlotStyle->directives, popt, PlotRange-> All]; 

If[allowLegend,

p=
{ 
Show[MyLegend[legends, colors],AspectRatio-> 1/GoldenRatio],
MapThread[plot, {variables, Directive/@styles}]
}; 
If[trace, Print["SBMLPlot: p "//boldRed, p//boldBlue]];

With[{gopt=MyFilterOptions[Graphics,opt]}, 
p=Show[p, gopt,  Axes-> True]
]
,
p=Show[MapThread[plot, {variables, Directive/@styles}]]
]

]; 

]


];

If[trace, Print["SBMLPlot: Plot: "//boldRed, p, "\n=== SBMLPlot Trace: EXIT ==="//boldRed]]; 

Return[p]
];

MyLegend[names_?ListQ, colors_?ListQ]:= Module[{p, n, nc, x, y, xy},
n=Length[names];
nc=Length[colors]; 
If[n != nc,
Print["Error:"//boldRed, "MyLegend:"//boldBlue, " number of names = "//boldBlack, n//boldBlack, " is different from the number of colors = "//boldBlack, nc//boldBlack];
 Return[$Failed]
]; 

x=1.1;
xy=Table[Scaled[{x, 1-1.0*y/(n+1)}], {y, 1, n}]; 
p=MapThread[Text, {stringer/@names, xy}];
p=Transpose[{colors, p}];
p=Graphics/@p
]; 



SBMLPlot[sol_, variable_?nonOptionQ, {tbegin_?NumberQ, tend_?NumberQ}, opt___?OptionQ]:= Module[{vars,lvars,r,n,pvar,p, dbg},
dbg=DEBUGPLOT; 
If[dbg, Print["SBMLPlot 2: variable: "//boldRed, variable//boldBlue, " {begin, end}:"//boldRed, {tbegin, tend}//boldBlue, " {options}:"//boldRed, {opt}//boldBlue]; ]; 

(*rev 2.6.2 to check for "ALL" here *)
If[ToUpperCase[ToString[variable]]=="ALL", 
Return[SBMLPlot[sol, {tbegin, tend}, opt]]
];


SBMLPlot[sol, {variable}, {tbegin, tend}, opt]
];



SBMLPlot[sol_,{tbegin_?NumberQ, tend_?NumberQ}, opt___?OptionQ]:= Module[{soln,vars, dbg},
dbg=DEBUGPLOT;
If[dbg, Print["SBMLPlot 3: {tbegin, tend}: "//boldRed, {tbegin, tend}//boldBlue, " {opt}:"//boldRed, {opt}//boldBlue];];

soln = selectSolution[sol]; 

(* added the following check 2.7.3 in responsed to bug 1892076 *)
vars = Global`variables/.{opt}/.{Global`variables-> All}; 
If[SameQ[vars, All], vars  =Map[Head,Map[First,Flatten[soln]]]];

If[dbg, Print["SBMLPlot 3: vars: ", vars]]; 
Return[SBMLPlot[soln, vars,{tbegin,tend},opt]]
];


SBMLPlot[sol_, variable_?nonOptionQ, opt___?OptionQ]:= Module[{p, tbegin, tend, soln, dbg},
dbg=DEBUGPLOT;
(**) If[dbg, Print["SBMLPlot 4: variable: "//boldRed, variable//boldBlue, " {options}:"//boldRed, {opt}//boldRed]] ;(* *)

(* allow plotting of either solutions or solutions incorporated within a model *)
soln = selectSolution[sol]; 
{tbegin, tend} = getPlotTimes[soln]; 


p = SBMLPlot[soln,variable, {tbegin, tend},opt];
Return[p];
];

SBMLPlot[sol_, opt___?OptionQ]:= Module[{vars,svars, tbegin, tend, soln, dbg},
dbg=DEBUGPLOT;
If[dbg, Print["SBMLPlot 5: opt: "//boldRed, {opt}//boldBlue];]; 

(* allow plotting of either solutions or solutions incorporated within a model *)
soln = selectSolution[sol]; 

{tbegin, tend} = getPlotTimes[soln]; 

vars = Flatten[{Global`variables/.{opt}/.Global`variables-> {"All"}}]; 
If[dbg, Print["SBMLPlot 5: variables: ", vars]]; 

svars = ToUpperCase/@ToString/@vars;
If[MemberQ[svars, "ALL"], 
Return[SBMLPlot[soln, {tbegin,tend},opt]]
]; 

Return[SBMLPlot[soln,vars,  {tbegin,tend},opt]];
];


getPlotTimes[soln_]:= Module[{solTimes, n1, tbegin, tend, pos,part},
solTimes[System`InterpolatingFunction[deltat_, ___][t_]]:= Flatten[{deltat}];
part[x_,{i__}]:= Part[x,i];
(* replace the following 2.4.4 because may have things like expression * interpolatingFUnction, etc, rather than just pure interpolating funcitons*)
(* n1=Map[Last,Flatten[soln]]; *)
pos=Position[soln, InterpolatingFunction[___][Global`t]];
n1 = part[soln,#]&/@pos;

n1=Map[solTimes,n1];
(* numerical error could make the solution times slightly different: some may be real and some may be integer, for example! 
corrected 2.4.15 - 9 May 2005 - Tokyo Hackathon *)
(* {tbegin, tend} = (n1//Union)//Flatten;
*)
tbegin = Max[First/@n1];
tend = Min[Last/@n1];

Return[{tbegin, tend}]; 
]; 

selectSolution[sol_]:= Module[{},
If[MemberQ[ToString/@First/@sol, "SBMLNumericalSolution"], 
Return[Global`SBMLNumericalSolution/.sol];
, 
Return[sol//Flatten]; 
];
Print[boldOrange["Error:"], boldRed["selectSolution: law of excluded middles violation. Catastrophic failure of nature."];];
Abort[]; 
]; 


SBMLListPlot[vars_,{t_,tmin_,tmax_, dt_}, sol_,opt___?OptionQ]:= Module[{data,x,variableNames,xname,xdata,plts,colors,nvars,style},
data=dataTable[vars,{t,tmin,tmax,dt},sol];
variableNames = First[data];
xname=First[variableNames];
variableNames=Rest[variableNames];

data = Transpose[Rest[data]];
xdata = First[data];
data = Rest[data];
nvars = Length[data];
colors = Range[nvars]*1.0/nvars;

style = {PlotStyle/.{opt}/.{PlotStyle-> {}}}//Flatten;
plots = MapThread[ListPlot[Transpose[{xdata,#1}],PlotStyle-> Flatten[{Hue[#2],style}],MyFilterOptions[ListPlot,opt],DisplayFunction-> Identity]&,{data,colors}];
Return[Show[plots,MyFilterOptions[Show,opt],DisplayFunction-> $DisplayFunction]];


]


Options[SBMLWrite]={
Global`format->"",
Global`inputfile-> "",
Global`outputfile-> ""
};


SBMLWrite[opt___?OptionQ]:= Module[{model, format, inputfile,outputfile,msg,tofile, dbg=False},
inputfile = (Global`inputfile/.{opt});
inputfile=stringer[inputfile]; 
If[!fileExists[inputfile], Print["Error: "//boldOrange,"The file "//boldBlack,
ToFileName[Directory[],inputfile]//boldRed, " does not exist."//boldBlack]; Return[$Failed];];

If[dbg, Print["SBMLWrite: inputfile:",inputfile]];

format=(Global`format/.{opt}/.Options[SBMLWrite])//ToString//ToUpperCase;
$SBML$OutputFormat=format;
$SBML$OutputFormatIsHTML=(format=="HTML");
Switch[format,
"BERKELEYMADONNA",
model = SBMLRead[inputfile,MathSBMLSaveVerboseData-> True,
 opt,Global`context-> "$",Global`LoadModelBuilder-> False]
,
_,
model = SBMLRead[inputfile,MathSBMLSaveVerboseData-> True,
 opt,Global`LoadModelBuilder-> False]; 
];

$SBML$OutputFormatIsHTML=False;

$SBML$Inputfile=inputfile;
outputfile = (Global`outputfile/.{opt}/.Options[SBMLWrite])//ToString;
tofile = outputfile!= ""; 

If[dbg, Print["SBMLWrite: inputfile,outputfile,format:",inputfile,",",outputfile,",",format]];

If[tofile,
outputfile=validateOutputFileName[outputfile];
];
If[outputfile=="$Failed",
tofile=False;
];

Switch[format,

"BERKELEYMADONNA",
msg = If[tofile, 
toBerkeleyMadonnaForm[model,outputfile, opt], 
toBerkeleyMadonnaForm[model,opt]
]; 
,

"XPP",
msg = If[tofile, 
toXPPForm[model,outputfile], 
toXPPForm[model]
]; 

,
"FORTRAN",

Print[boldRed["Warning: SBMLWrite: FORTRAN format is Developemental and subject to both error. Please report any errors to the developers."]
];
msg = fortranize[model, opt];
If[tofile, msg = Export[outputfile,msg,"Text"]]; 
,

"HTML",
msg = htmlPrint[model,opt]; 
If[dbg, Print["SBMLWrite: msg (1): ", msg]]; 

(* The character \[CenterEllipsis] is \ [ CenterEllipsis ] and is not three dots!*)

msg = StringReplace[msg, {"\[CenterEllipsis];"-> "", "\[CenterEllipsis]"-> "", "\[EmptySet]"-> "","\[Rule]"-> "&rarr;" (*"&#x2192;"*) , "\[RightArrowLeftArrow]"-> "&larr;<span style=\"margin-left:-12;\">&rarr;</span>" (* "&#x21CC;"*) }];

If[dbg, Print["SBMLWrite: msg (2): ", msg]]; 
If[tofile, msg=Export[outputfile,msg,"Text"]];
,

_, 
printWarning["SBMLWrite: invalid format = '"<>format<>"'. No file written. Valid formats are: XPP, HTML"];
msg = model; 
]; 
Return[msg];
];


If[$$LoadBug, Print["Loading: model builder funtions"]];


fixMathematicaENotation[x_?StringQ]:= StringReplace[x, "*^"-> "e"];


checkMathMLSubset[math_, type_, id_]:=Module[{dbg=False,XML2Sym,m, commands, attributes,
oksubset={"math", "lambda","cn","ci","csymbol","sep","apply", "piecewise", "piece", "otherwise", "eq","neq", "gt", "lt", "geq", "leq", "plus", "minus", "times", "divide", "power", "root", "abs", "exp", "ln", "log", "floor", "ceiling", "factorial", "and", "or", "xor", "not", "degree", "bvar","logbase", "sin", "cos", "tan", "sec", "csc", "cot", "sinh", "cosh", "Tanh", "sech", "csch", "coth", "arcsin", "arccos", "arctan", "arcsec", "arccsc", "arccot", "arcsinh", "arccosh", "arctanh", "arcsech", "arccsch", "arccoth", "true", "false", "notanumber", "pi", "infinity", "exponentiale", "semantics", "annotation", "annotation-xml"},
okattributes={"style", "class", "id", "encoding","definitionURL", "type","xmlns"},
oktypes={"real", "integer", "rational", "e-notation"},
types, xmlns, isanumber, notanumber
}, 

isanumber[x_]:= numberFormQ[x] \[Or] eFormQ[x]; 
notanumber[x_]:= !isanumber[x]; 

If[type!= "function", oksubset=Complement[oksubset, {"bvar","lambda"}]]; 

If[dbg, Print["checkMathMLSubset: math:", math]];
XML2Sym["ci",___]:= {};
XML2Sym["csymbol",___]:= {}; 
XML2Sym[x___]:= XMLElement[x];

m=math/.{XMLElement-> XML2Sym};
m=Flatten[m/.{XMLElement-> List}];
If[dbg, Print["checkMathMLSubset: m:", m]]; 
attributes = Select[m, SameQ[Head[#], Rule]&];
types=Select[attributes, First[#]=="type"&]; 
commands=Complement[m, attributes];
commands=Select[commands,notanumber];
If[dbg, Print["checkMathMLSubset: attributes:", attributes]]; 
If[dbg, Print["checkMathMLSubset: commands:", commands]]; 
If[dbg, Print["checkMathMLSubset: types:", types]]; 

commands = Complement[commands, oksubset];
attributes=Complement[First/@attributes, okattributes];
xmlns=Cases[attributes,{_,"xmlns"},Infinity];
attributes=Complement[attributes,xmlns];

types = Select[types, !MemberQ[oktypes, Last[#]]&]; 

Print["Error:"//boldRed," Invalid MathML element "//boldBlack,#//boldBlue, " used in "//boldBlack, type//boldBlue, " definition for "//boldBlack, id//boldBlue]&/@commands;
Print["Error:"//boldRed," Invalid MathML attribute "//boldBlack, #//boldBlue, " used in "//boldBlack, type//boldBlue, " definition for "//boldBlack, id//boldBlue]&/@attributes;
Print["Error:"//boldRed," Invalid MathML type "//boldBlack, #//boldBlue,  " used in "//boldBlack, type//boldBlue, " definition for "//boldBlack, id//boldBlue]&/@types;

Return[]
];



If[$$LoadBug, Print["Loading:newModel"]];


setEcho[value_]:= (MB$Echo=value);
setEcho[]:= setEcho[True];
hideEcho[]:= setEcho[False];
setEcho[];

setArray[value_]:= (MB$Arrays=value);
setArray[]:= setArray[True];
setArray[False];

ifArrays[]:= MB$Arrays;

setArraysAreAnnotations[value_]:= (MB$ArraysAreAnnotations=value);
setArraysAreAnnotations[]:= setArraysAreAnnotations[True];
setArraysAreAnnotations[];

ifArraysAreAnnotations[]:= MB$ArraysAreAnnotations;
$SBML$Rationals=False;



popCompartment[]:= Module[{n},
If[!ListQ[MB$CurrentCompartment], MB$CurrentCompartment={MB$CurrentCompartment}]; 

If[Length[MB$CurrentCompartment]>0, 
n=First[MB$CurrentCompartment];
MB$CurrentCompartment=Rest[MB$CurrentCompartment];
,
n=Null;
]; 
Return[n];
];
If[$$LoadBug, Print["Loading:newModel:pushCompartment"]];
pushCompartment[n_]:= Module[{},
If[n==Null,MB$CurrentCompartment={}; Return[];]; 
If[(ListQ[MB$CurrentCompartment]&&Length[MB$CurrentCompartment]>0),
If[stringer[n]!= stringer[First[MB$CurrentCompartment]], 
MB$CurrentCompartment=
Prepend[MB$CurrentCompartment,stringer[n]]];
,
MB$CurrentCompartment={n}];
];

forgetCompartment[n_]:= Module[{},
MB$CurrentCompartment=
Flatten[MB$CurrentCompartment/.{n-> {},stringer[n]-> {}}];
];
If[$$LoadBug, Print["Loading:newModel:setCompartment"]];
setCompartment[n_]:= Module[{},

If[compartmentExists[stringer[n]],
pushCompartment[n];
If[MB$Echo,Print["Current compartment set to "//boldGreen,n//boldBlue]];
,
If[n==Null,
pushCompartment[Null],
Print["Warning:"//boldOrange,"pushCompartment: Requested compartment "//boldBlack,n//boldRed," does not exist."//boldBlack];
]; 
];
]


If[$$LoadBug, Print["Loading:newModel:newModel"]];
newModel[opt___?OptionQ]:= Module[{stringer,val,c, defaultNotes, family, given,email,org, creator, domain}, 


SBML$CheckModelContext = Global`checkModelContext/.{opt}/.{Global`checkModelContext-> False};

Off[General::"spell"];
Off[General::"spell1"];
Off[Part::"pspec"]; 

stringer[x_?StringQ]:= x;
stringer[x_]:= ToString[InputForm[x]]; 
stringer[x_-> y_]:= (stringer[x]-> stringer[y]);

val = (Global`Arrays)/.{opt}/.{Global`Arrays-> ifArrays[]}; 
setArray[val]; 

val = (Global`ArraysAreAnnotations)/.{opt}/.{Global`ArraysAreAnnotations-> ifArraysAreAnnotations[]}; 
setArraysAreAnnotations[val]; 

$SBML$Rationals=(Global`rationals)/.{opt}/.{Global`rationals-> False};

family=stringer/@(MIRIAM`Family/.{opt}/.{MIRIAM`Family-> $MachineName<>" at "<>$MachineDomain<>" (automatically generated)"});
given=stringer/@(MIRIAM`Given/.{opt}/.{MIRIAM`Given->$UserName<>" (automatically generated)"});
domain=$MachineDomain;
If[domain=="", domain="not.specified"]; 
email=stringer/@(MIRIAM`EMAIL/.{opt}/.{MIRIAM`EMAIL-> "anonymous@"<>domain});
org=stringer/@(MIRIAM`Orgname/.{opt}/.{MIRIAM`Orgname-> "MathSBML User Community"}); 
creator=Global`CreatedBy/.{opt}/.{Global`CreatedBy-> {family,given,email,org}}; 
creator=Flatten[{creator}];
Switch[Length[creator],
0, creator={family, given, email, org};,
1, creator=Join[creator,{given,email, org}];,
2, creator=Join[creator, {email, org}];,
3, creator=Join[creator, {org}];,
_, creator=Take[creator,4]
];


MB$Modify=False;

MB$Species={};
MB$SpeciesTypes={};
MB$CompartmentTypes={};
MB$Compartments={}; 
MB$Functions={};
MB$Events={}; 
MB$Reactions={};
MB$Parameters={}; 
MB$InitialAssignments={};
MB$Units={};
MB$Rules={};
MB$Constraints={};
MB$UnitsOfTheSpecies={};
MB$CurrentCompartment=Null;
previouslyDefinedNamesInTheMathematicaEnvirnoment=Names["*"];
previouslyDefinedContextsInTheMathematicaEnvironment=Contexts[];

resetDefaultUnits[];

MB$ID=(Global`id)/.{opt}/.{Global`id-> "SBMLModel"};
MB$ID=stringer[MB$ID];
MB$MetaID=(Global`metaid)/.{opt}/.{Global`metaid-> ""};
MB$MetaID=stringer[MB$MetaID];


If[!SIDQ[MB$ID] , 
c=fixSID[MB$ID];
Print["Error: "//boldRed, "\""<>MB$ID<>"\""//boldBlue, "is not a valid SID, replaced with "//boldBlack, "\""<>c<>"\""//boldBlue];
MB$ID=c;
];
If[MB$MetaID== "",
MB$MetaID="\[UnderBracket]"<>MB$ID;
,
If[!SIDQ[MB$MetaID] , 
c=fixSID[MB$MetaID];
Print["Error: "//boldRed, "\""<>MB$MetaID<>"\""//boldBlue, "is not a valid SID, replaced with "//boldBlack, "\""<>c<>"\""//boldBlue];
MB$MetaID=c;
];
]; 

$SBML$IDTable={};
$SBML$MetaIDTable={};
$SBML$function$bvars={}; 
$SBML$MetaIDAssociations={};

addID[MB$ID,"model",False];
addMetaID[MB$MetaID,MB$ID, "model", True];

MB$ModelAnnotation={};
MB$SBMLAnnotation={}; 
MB$Name= (Global`name)/.{opt}/.{Global`name->MB$ID}; 
$SBML$Underscorecharacter=Global`underscore/.{opt}/.Options[SBMLRead];
$SBML$IndeterminateValue=Global`indeterminateValueString/.{opt}/.Options[SBMLRead];

setAnnotationNamespace["http://sbml.org/software/mathsbml/ns"]; 
setAnnotationPackage["mathsbml"]; 

setSBMLAnnotation["AuthorConfiguration"->
 {"SoftwareVersion"-> {$MathSBML$Version},
"MathematicaVersion"-> {$Version},
"ProcessorType"-> {$ProcessorType},
"MachineType"-> {$MachineType},
"System"-> {$SystemID},
"OperatingSystem"-> {$OperatingSystem},
"date"-> {W3CDTF[]},
"MachineName"-> {$MachineName},
"MachineID"-> {$MachineID},
"MachineDomain"-> {$MachineDomain},
"UserName"-> {$UserName},
"ProductInformation"-> stringer/@$ProductInformation
},
"mathsbml","http://sbml.org/software/mathsbml/ns"];



MB$reactioncounter=1; 
MB$speciescounter=1;
MB$speciestypecounter=1;
MB$functioncounter=1;
MB$unitcounter=1;
MB$compartmentcounter=1;
MB$parametercounter=1;
MB$variablecounter=1;
MB$eventcounter = 1;
MB$rulecounter=1;
MB$dimensionCounter=1;
MB$CurrentDimension={};
MB$indexCounter=1; 

MB$SBMLNotes={};
MB$AssignmentRuleVariables={};
MB$RateRuleVariables={};
MB$ReactionVariables={};
MB$BoundaryConditionSpecies={}; 

defaultNotes ="<p style='font-size:x-small;'>This is a Systems Biology Markup Language (SBML) file, generated by MathSBML "<>$MathSBML$Version<>" "<>now[]<>".  SBML is a form of XML, and most XML files will not display properly in an internet browser. To view the contents of an XML file use the \"Page Source\" or equivalent button on you browser. </p>";
MB$ModelNotes = (Global`notes/.{opt}/.Global`notes-> "")//stringer;
MB$ModelNotes=MB$ModelNotes<>defaultNotes;

MB$Comments = (Global`comments/.{opt}/.Global`comments-> "")//stringer;



MB$Echo = (Global`echo)/.{opt}/.{Global`echo-> False};

MB$Index[x_]:= {};
MB$Dimensions= {};

MB$Level=stringer[(Global`level)/.{opt}/.{Global`level-> 2}]; 
MB$Version=stringer[(Global`version)/.{opt}/.{Global`version-> 3}];
MB$LevelVersion=MB$Level<>"."<>MB$Version;

Switch[MB$Level,
"2",
Switch[MB$Version,
"1",
MB$xmlns="http://www.sbml.org/sbml/level2",
"2",
MB$xmlns="http://www.sbml.org/sbml/level2/version2",
"3",
MB$xmlns="http://www.sbml.org/sbml/level2/version3",

_,
Print["Error: newModel: "//boldRed," SBML Level "//boldBlack, MB$Level//boldBlue," Version "//boldBlack,MB$Version//boldBlue," is not supported."//boldBlack];
Abort[];
]; ,
_,
Print["Error:"//boldRed," SBML Level "//boldBlack, MB$Level//boldBlue," is not currently supported by the model builder."//boldBlack];
Abort[];
]; 
setModelAnnotation[MIRIAMcreatorToSymbolicXML@@creator];

If[MB$Echo,Print["Model "//boldGreen,MB$ID//boldBlue," initialized: SBML Level "//boldGreen, MB$Level//boldBlue," Version "//boldGreen, MB$Version//boldBlue]];

];

If[$$LoadBug, Print["Loading:newModel: newModel: default "]];
newModel[x_?nonOptionQ, opt___?OptionQ]:= newModel[Global`id-> x,opt];

If[$$LoadBug, Print["Loading:newModel: modifyModel"]];
modifyModel[opt___?OptionQ]:= Module[{id, name, val},
id=stringer[(Global`id)/.{opt}/.{Global`id-> ""}]; 
name= stringer[(Global`name)/.{opt}/.{Global`name->""}]; 
If[id!= "", MB$ID=id];
If[name!= "", MB$Name=name];

val = (Global`Arrays)/.{opt}/.{Global`Arrays-> ifArrays[]}; 
setArray[val]; 

val = (Global`ArraysAreAnnotations)/.{opt}/.{Global`ArraysAreAnnotations-> ifArraysAreAnnotations[]}; 
setArraysAreAnnotations[val]; 

];

If[$$LoadBug, Print["Loading:newModel:showModel"]];
showModel[opt___?OptionQ]:=Module[{m,saveEcho},
saveEcho=MB$Echo;
m=SBMLRead[createSymbolicModel[], opt, Global`evaluateParameters-> False, Global`verbose-> True, Global`return->"None", Global`LoadModelBuilder-> False, Global`warnings-> False]; 
MB$Echo=saveEcho;
Return[m]; 
]; 

If[$$LoadBug, Print["Loading:newModel:loadSimulator"]];
loadSimulator[opt___?OptionQ]:=Module[{echo,m,dbg=False},
echo=MB$Echo;
m=createSymbolicModel[];
dbg = (Global`debug/.{opt}/.{Global`debug-> False}); 
If[dbg,Print["loadSimulator: m(1)="//boldRed,m//boldBlue]];
If[dbg, Print["loadSimulator: {opt}="//boldRed,{opt}//boldBlue]];

m= SBMLRead[m,opt, Global`verbose-> False];
If[dbg, Print["loadSimulator: m(2)="//boldRed,m//boldBlue]];
MB$Echo=echo;
Return[m]; 
];

If[$$LoadBug, Print["Loading:newModel: loadModelBuilder"]];
loadModelBuilder[file_,opt___?OptionQ] := Module[{echo,m},
echo = MB$Echo;
m=SBMLRead[file,  opt,Global`LoadModel-> True,Global`EchoLoad-> True]; 
MB$Echo=echo;
Return[m];
]




If[$$LoadBug, Print["setting Annotation"]];
setModelAnnotation[MIRIAMcreatorToSymbolicXML["None Given","No Name Given","no@email.address","Unspecified"]];

If[$$LoadBug, Print["executing newModel"]];
newModel["temporary"];

If[$$LoadBug, Print["resetting MIRIAM"]];
resetMIRIAMcreator[];
 


If[$$LoadBug, Print["Loading:dumpModel"]];


dumpModel[]:= Module[{},
Print["MB$Functions="//boldRed,MB$Functions//boldBlack];
Print["MB$Units="//boldRed,MB$Units//boldBlack];
Print["MB$CompartmentTypes="//boldRed,MB$CompartmentTypes//boldBlack]; 
Print["MB$SpeciesTypes="//boldRed,MB$SpeciesTypes//boldBlack];

Print["MB$Compartments="//boldRed,MB$Compartments//boldBlack]; 
Print["MB$Species="//boldRed,MB$Species//boldBlack];
Print["MB$UnitsOfTheSpecies="//boldRed,MB$UnitsOfTheSpecies//boldBlack];

Print["MB$Parameters="//boldRed,MB$Parameters//boldBlack]; 
Print["MB$InitialAssignments="//boldRed, MB$InitialAssignments//boldBlack];
Print["MB$Rules="//boldRed,MB$Rules//boldBlack];
Print["MB$Reactions="//boldRed,MB$Reactions//boldBlack];
Print["MB$Events="//boldRed,MB$Events//boldBlack]; 

Print["MB$ID="//boldRed,MB$ID//boldBlack]; 
Print["MB$MetaID="//boldRed,MB$MetaID//boldBlack]; 

Print["MB$Name="//boldRed,MB$Name//boldBlack]; 

Print["MB$ModelNotes="//boldRed, MB$ModelNotes//boldBlack];
Print["MB$SBMLNotes="//boldRed,MB$SBMLNotes//boldBlack];

Print["MB$ModelAnnotation="//boldRed, MB$ModelAnnotation//boldBlack];
Print["MB$SBMLAnnotation="//boldRed, MB$SBMLAnnotation//boldBlack]; 


Print["MB$functioncounter="//boldRed,MB$functioncounter//boldBlack];
Print["MB$unitcounter="//boldRed,MB$unitcounter//boldBlack];
Print["MB$compartmentcounter="//boldRed,MB$compartmentcounter//boldBlack];
Print["MB$speciescounter="//boldRed,MB$speciescounter//boldBlack];
Print["MB$variablecounter="//boldRed,MB$variablecounter//boldBlack];
Print["MB$parametercounter="//boldRed,MB$parametercounter//boldBlack];
Print["MB$rulecounter="//boldRed,MB$rulecounter//boldBlack];
Print["MB$reactioncounter="//boldRed,MB$reactioncounter//boldBlack]; 
Print["MB$eventcounter="//boldRed,MB$eventcounter//boldBlack];

]; 


removeEmptyStandardElements[s_]:= Module[{sbmlStandardElements={"listOfFunctionDefinitions","listOfUnitDefinitions","listOfCompartments","listOfCompartmentTypes", "listOfSpeciesTypes","listOfSpecies","listOfParameters","listOfInitialAssignments","listOfReactions","listOfRules","listOfConstraints","listOfEvents","listOfReactants","listOfProducts","listOfModifiers", "notes"},sr,r},
sr[x_]:= ToString[XMLOut[XMLElement[x,{},{}]]];
r=Rule[sr[#],"<!-- "<>sr[#]<> " -->"]&/@sbmlStandardElements;
Return[StringReplace[s,r]];
]


createModel[opt___?OptionQ]:= Module[{SBML, dbg=False},
SBML = createSymbolicModel[opt];
If[dbg, Print["createModel:"//boldRed, "SBML: "//boldBlue, SBML//boldBlack]]; 

SBML = postprocess[SBML]; 
If[dbg, Print["createModel:"//boldRed, "SBML (postprocessed): "//boldBlue, SBML//boldBlack]]; 

SBML=ExportXMLString[SBML];
If[dbg, Print["createModel:"//boldRed, "SBML (Exported): "//boldBlue, SBML//boldBlack]]; 


If["RemoveEmptySBML"/.{opt}/.{"RemoveEmptySBML"-> True},
SBML=removeEmptyStandardElements[SBML];
];
SBML = sunderscore[SBML];
SBML = fixMathematicaENotation[SBML];
Return[SBML];
];
createModel[fileName_?StringQ,opt___?OptionQ]:= Module[{s,f},
f=validateOutputFileName[fileName];
If[f!= "$Failed",
s = createModel[opt]; 
s=Export[f,s,"text"];
Return[s];
];
];
getSBMLModel[x___]:= createModel[x];

createSymbolicModel[opt___?OptionQ]:= Module[{functions,units, compartments, species, parameters, rules, reactions, events, SBML,notes,preface,comments,speciesTypes,compartmentTypes,dbg=False,sub,inline, initialAssignments, includeAnnotations, includeNotes, includeComments, stuff},

includeAnnotations = "annotations"/.{opt}/.{"annotations"-> True}; 
includeNotes="notes"/.{opt}/.{"notes"-> True};
includeComments="comments"/.{opt}/.{"comments"-> True}; 

functions = XMLElement["listOfFunctionDefinitions",{},Last/@MB$Functions];
units =XMLElement["listOfUnitDefinitions",{}, Last/@MB$Units];
compartments=XMLElement["listOfCompartments",{},Last/@MB$Compartments];
speciesTypes = XMLElement["listOfSpeciesTypes",{},Last/@MB$SpeciesTypes];
compartmentTypes = XMLElement["listOfCompartmentTypes",{},Last/@MB$CompartmentTypes];

species = XMLElement["listOfSpecies",{},Last/@MB$Species];
parameters = XMLElement["listOfParameters",{},Last/@MB$Parameters];
initialAssignments=XMLElement["listOfInitialAssignments", {}, Last/@MB$InitialAssignments];
rules = XMLElement["listOfRules",{},Last/@MB$Rules];
constraints=XMLElement["listOfConstraints",{},MB$Constraints];
reactions = XMLElement["listOfReactions",{},Last/@MB$Reactions];
events =XMLElement["listOfEvents",{}, Last/@MB$Events];
If[dbg,
Print["createSymbolicModel:MB$ModelNotes:",MB$ModelNotes];
Print[MB$ModelNotes!= ""];
];

(* following line fixed 2.3.22*)
notes=stringToNotes[{MB$ModelNotes}//Flatten];

If[dbg, 
Print["createSymbolicModel:MB$ModelNotes:",MB$ModelNotes];
Print["createSymbolicModel:notes:",notes];
]; 
sub={functions,units};
If[ToExpression[MB$LevelVersion ]>2.15, 
sub=Append[sub,compartmentTypes];
];
If[ToExpression[MB$LevelVersion ]>2.15, 
sub=Append[sub,speciesTypes];
];

sub = Join[sub, {compartments, species,parameters }]; 
If[ToExpression[MB$LevelVersion ]>2.15, 
sub=Append[sub,initialAssignments];
];
sub = Join[sub, {rules }]; 
If[ToExpression[MB$LevelVersion ]>2.15, 
sub=Append[sub,constraints];
];

sub = Join[sub, {reactions, events }]; 

inline={"id"->stringer[MB$ID], "name"-> stringer[MB$Name]};
If[MB$MetaID!= "", AppendTo[inline,"metaid"-> stringer[MB$MetaID]]]; 

If[includeAnnotations, sub=Join[ MB$ModelAnnotation, sub]]; 
If[includeNotes, sub = Join[notes, sub]]; 

SBML = XMLElement["model",inline, sub];

SBML = {SBML}; 
 If[includeAnnotations, SBML=Join[ MB$SBMLAnnotation, SBML]]; 
 If[includeNotes, SBML=Join[ MB$SBMLNotes, SBML]]; 


SBML = XMLElement["sbml", {"xmlns"-> MB$xmlns, "level"-> MB$Level, "version"-> MB$Version},SBML];

If[includeComments, 
preface = {
XMLObject["Declaration"]["Version"->"1.0","Encoding"->"UTF-8"],
XMLObject["Comment"][" Generated "<>now[]<>" "],
XMLObject["Comment"][" Generated by MathSBML "<>$MathSBML$Version<>" "],
XMLObject["Comment"][" Generated using Mathematica Version "<>$Version<>" " ]
};
If[MB$Comments=="",comments={},
comments=XMLObject["Comment"][MB$Comments];
preface=Append[preface,comments];
]; 

,
preface = {
XMLObject["Declaration"]["Version"->"1.0","Encoding"->"UTF-8"]};
];


SBML = XMLObject["Document"][preface,SBML,{}];
If[dbg, Print["createSymbolicModel: SBML: ", SBML]]; 
Return[SBML];
];
getModel[x___]:= createSymbolicModel[x];



retrieveSBMLObject[type_?StringQ,id_?StringQ]:= Module[{data, c,p,x},

data =
Switch[type,
"function", MB$Functions,
"unit",MB$Units,
"compartment",MB$Compartments,
"compartmentType",MB$CompartmentTypes,
"species",MB$Species,
"speciesType",MB$SpeciesTypes,
"parameter",MB$Parameters,
"initialAssignment", MB$InitialAssignments,
"rule",MB$Rules,
"reaction",MB$Reactions,
"event",MB$Events,
_, 
Print["Error: "//boldRed,"retrieveSBMLObject "//boldBlack," type = "//boldBlack, type//boldBlue," unknown."//boldBlack];
Abort[];
]; 
c = Map[First,data]; 
If[MemberQ[c,id],
p=Position[c,id];
While[ListQ[p], p=First[p]]; 
x=Last[data[[p]]];
Return[x];
];
Return[{}];
]; 


globalize[Rule[a_,b_]]:= Rule[contextify[a,"Global"]//ToExpression,b];
globalize[{x_}]:= globalize/@{x};
globalize[x_]:= contextify[decontextify[x],Global];


extractAndUpdateXMLOptions[XMLElement[x___],opt___?OptionQ]:= Module[{y},
y=extractXMLOptions[XMLElement[x]];
y = stringrule/@(Join[{opt},y]//Flatten);
Return[y];
];



getReaction[n_?IntegerQ]:= Module[{m},
m=Length[MB$Reactions];
If[n>m \[Or] n<1, Print["Error: getReaction: "//boldOrange," Reaction: "//boldBlack,n//boldRed," does not exist. There are "//boldBlack,m//boldRed," reaction definitions."//boldBlack];Return[{}];];
Return[MB$Reactions[[n]]//Last];
]; 
getReactionNumber[id_?SIDQ]:=Module[{m,n},
m = First/@MB$Reactions;
n=Position[m, stringer[id]];
If[Length[n]<1, Print["Error: getReactionNumber: "//boldOrange,"Reaction: "//boldBlack,id//boldRed," does not exist. Valid reactions are "//boldBlack, m//boldRed];Return[0];]; 
While[ListQ[n], n=First[n]];
Return[n];
]; 

getReaction[id_?SIDQ]:=Module[{m,n},
n=getReactionNumber[id];
If[n>0,
Return[MB$Reactions[[n]]//Last],
Return[{}]
]; 
]; 

getReaction[x_?ListQ]:= getReaction/@Flatten[x];
getReaction[x___]:= Module[{},
Print["Error: getReaction: "//boldOrange, "Correct format is "//boldBlack,"getReaction[id]"//boldRed, " where id is an integer or an SID "//boldBlack,"getReaction[Integer]"//boldRed, " or "//boldBlack,
"getReaction[{x1,x2,...}]"//boldRed," where x1,x2,... are integers or SIDs."//boldBlack];
Return[{}];
];

getNumberOfReactions[]:= Length[MB$Reactions];
getReactions[]:= getReaction[Range[getNumberOfReactions[]]];



replaceReaction[i_?IntegerQ, XMLElement["reaction",x___]]:= Module[{n,j},
n=Length[MB$Reactions];
If[n>0 \[And] i>0 \[And] i<=n, 

j=getSBMLfield["id",XMLElement["reaction",x]]; 
If[j=="", j=MB$Reactions[[i,1]]];


MB$Reactions=ReplacePart[MB$Reactions,j-> XMLElement["reaction",x],i];
If[MB$Echo, Print["Reaction ",i, " replaced."]];
Return[];
]; 
Print["Error: replaceReaction: "//boldOrange," unable to replace reaction "//boldBlack,i//boldRed];
Return[];
]; 

replaceReaction[id_?SIDQ, XMLElement["reaction",x___]]:= Module[{n},
n=getReactionNumber[id];
If[n>0, 
replaceReaction[n, XMLElement["reaction",x]]; 
Return[];
]; 
Print["Error: replaceReaction: "//boldOrange," unable to replace reaction "//boldBlack,id//boldRed];
Return[];
]; 

replaceReaction[x___]:= Print["Error: "//boldOrange,"replaceReaction: "//boldRed, "Invalid arguments. Correct format is:"//boldBlack,"replaceReaction["//boldBlack," Integer|SID "//boldBlack,","//boldBlack, " XMLElement[\"reaction\",...]"//boldBlack," ]"//boldBlack];




 reactionToSBML[{x__?ListQ}]:=Module[{SBML}, 
SBML =Flatten[ reactionToSymbolicSBML/@{x}];
SBML = XMLElement["listOfReactions",{},SBML]; 
SBML=ExportXMLString[SBML];
SBML = sunderscore[SBML];
SBML=fixMathematicaENotation[SBML];
Return[SBML];
];

reactionToSBML[opt___?OptionQ]:= Module[{r},
r = reactionToSymbolicSBML[opt]; 
r=ExportXMLString[r];
r=sunderscore[r];
r=fixMathematicaENotation[r]; 
Return[r];
];

reactionToSBML[reaction_, opt___?OptionQ]:= reactionToSBML[Global`reaction-> reaction, opt];

reactionToSBML[x___]:=
Print[boldRed["Error:"], boldBlack["The argument to reactionToSBML must be a sequence of options."]]; 



deleteReaction[opt___?OptionQ]:= Module[{n,c,p},
n =( Global`id/.{opt}/.{id-> ""})//stringer;
If[id=="", 
Print["Error: deleteReaction"//boldRed," No "//boldBlack,"id"//boldBlue," was specified."//boldBlack]]; 
removeID[n, "reaction"]; 
MB$Currentid=n;
c = Map[First,MB$Reactions]; 
If[MemberQ[c,n],
p=Position[c,n];
MB$Reactions= Drop[MB$Reactions,First[p]]; 
Return[True];
];
Return[False];
];
deleteReaction[x_, opt___?OptionQ]:= deleteReaction[Global`id-> x,opt];
removeReaction[x___]:=Module[{flag},
flag = deleteReaction[x];
If[flag, 
If[MB$Echo,Print["Reaction "//boldGreen,MB$Currentid//boldBlue," removed."//boldGreen]],
Print["Error: "//boldRed,"removeReaction:Requested reaction "//boldBlack,MB$Currentid//boldRed," does not exist. No removal peformed."//boldBlack]];
];


checkKineticLaw[opt___?OptionQ]:=Module[{dbg,klaw,parameters, reaction,modifiers, reactants,products,species,compartments,GlobalParameters,functions, missingSpecies,xml,myXMLElement,syms,undefinedSymbols,undefinedSpecies,definedSymbols, undefinedModifiers,id, caller, allSpeciesReferenced , csymbols,math, csymbolsInFormula},




caller=invokedBy/.{opt}/.{invokedBy-> "Unknown"};

dbg=Global`debug/.{opt}/.{dbg-> False};

csymbolsInFormula = csymbolsused/.{opt}/.{csymbolsused-> {}}; 

(* get parameters and then convert to just parameter ids, not values *)
id=stringer[Global`id/.{opt}/.{Global`id-> "ID_unassigned"}];

debugPrint[dbg, "checkKineticLaw: id",id]; 

parameters=Global`parameters/.{opt}/.{Global`parameters-> {}};
parameters=Flatten[List[#]]&/@(parameters/.{Rule-> List});
parameters =stringer/@( First/@parameters);

klaw = Global`kineticLaw/.{opt}/.{Global`kineticLaw-> {}};
If[OptionQ[klaw],klaw=Global`math/.klaw/.{Global`math-> {}}]; 
reaction=Global`reaction/.{opt}/.{Global`reaction-> {}};
modifiers=Global`modifiers/.{opt}/.{Global`modifiers-> {}};

debugPrint[dbg, "checkKineticLaw: reaction ",reaction]; 
debugPrint[dbg, "checkKineticLaw: caller ",caller]; 

If[ListQ[reaction]\[And] Length[reaction]==0,
reactants=List[Global`reactants/.{opt}/.{Global`reactants-> {}}]//Flatten;
products=List[Global`products/.{opt}/.{Global`products-> {}}]//Flatten;
debugPrint[dbg,"checkKineticLaw: products(1)",products];

If[reactants=={} \[And]products=={},
reaction=First[{opt}];
If[!SameQ[Head[reaction],Rule], Print["Error: unknown form for reaction."]];
debugPrint[dbg,"checkKineticLaw: reaction",reaction];
{reactants, products}=(reaction/.{Rule-> List, Plus-> List, Times-> List});
{reactants, products}=Flatten/@List/@{reactants, products};
reactants=Select[reactants, !NumberQ[#]&];
products=Select[products, !NumberQ[#]&];

(* reactants=First[reaction];
products=Last[reaction]; *)
debugPrint[dbg,"checkKineticLaw: products(2a)",products];
debugPrint[dbg,"checkKineticLaw: reactants(2a)",reactants];

];
debugPrint[dbg,"checkKineticLaw: products(2b)",products];
debugPrint[dbg,"checkKineticLaw: reactants(2b)",reactants];

,
If[SameQ[Head[reaction], Rule],
{reactants, products}=(reaction/.{Rule-> List, Plus-> List, Times-> List});
{reactants, products}=Flatten/@List/@{reactants, products};
reactants=Select[reactants, !NumberQ[#]&];
products=Select[products, !NumberQ[#]&];
debugPrint[dbg,"checkKineticLaw: products(2c)",products];
debugPrint[dbg,"checkKineticLaw: reactants(2c)",reactants];

]; 
debugPrint[dbg,"checkKineticLaw: products(2d)",products];
debugPrint[dbg,"checkKineticLaw: reactants(2d)",reactants];

];

debugPrint[dbg,"checkKineticLaw: products(3)",products];


debugPrint[dbg, "checkKineticLaw: caller: ", caller];
debugPrint[dbg, "checkKineticLaw: First/@MB$Species: ", First/@MB$Species];

If[caller=="getReaction",
species=decontextify/@stringer/@$SBML$Species$IDs;
compartments=decontextify/@stringer/@$SBML$Compartmentids;
GlobalParameters=decontextify/@stringer/@SBMLGlobalParameters;
functions=decontextify/@stringer/@First/@$SBML2$Functions
,
species=First/@MB$Species;
compartments=First/@MB$Compartments;
GlobalParameters=First/@MB$Parameters;
functions=First/@MB$Functions;
];

debugPrint[dbg,"checkKineticLaw: products",products];

reactants=stringer/@Flatten[List[reactants]];
products=stringer/@Flatten[List[products]];
modifiers=stringer/@Flatten[List[modifiers]];
allSpeciesReferenced=Join[reactants, products , modifiers];

debugPrint[dbg,"checkKineticLaw: opt",{opt}];
debugPrint[dbg,"checkKineticLaw: klaw(1)",klaw];
debugPrint[dbg,"checkKineticLaw: parameters",parameters];
debugPrint[dbg,"checkKineticLaw: reactants",reactants];
debugPrint[dbg,"checkKineticLaw: products",products];
debugPrint[dbg,"checkKineticLaw: modifiers",modifiers];
debugPrint[dbg,"checkKineticLaw: species",species];
debugPrint[dbg,"checkKineticLaw: allSpeciesReferenced",allSpeciesReferenced];
debugPrint[dbg,"checkKineticLaw: compartments",compartments];
debugPrint[dbg,"checkKineticLaw: GlobalParameters",GlobalParameters];
debugPrint[dbg,"checkKineticLaw: functions",functions];

reaction=Rule[Plus@@reactants,Plus@@products];
If[Length[modifiers]>0, 
reaction=System`Overscript[reaction,modifiers];
];

debugPrint[dbg,"checkKineticLaw: reaction(2)",reaction];

Print["Warning: "//boldRed, " the global parameter "//boldBlack,#//boldBlue," has been referenced in the reaction "//boldBlack,id//boldBlue," = "//boldBlack, reaction//boldBlue , " as a species."//boldBlack]&/@Intersection[allSpeciesReferenced, GlobalParameters];

missingSpecies=Complement[allSpeciesReferenced,species];

(* this line checks for species that are declared in the reaction but not in the model *)

Print["Warning: checkKineticLaw: "//boldRed," the species "//boldBlack,#//boldBlue," is referenced in the reaction "//boldBlack,id//boldBlue," = "//boldBlack,reaction//boldBlue," but has not been previously defined."//boldBlack]&/@missingSpecies;

If[caller=="addReaction",
Map[addSpecies[Global`id-> #]&,  missingSpecies];
(* need to redefined species because it may have changed *)
 species=First/@MB$Species;  
]; 

(* now check for species that are referenced in the kinetic law but are not declared as modifiers *)

debugPrint[dbg,"checkKineticLaw: klaw(2)",klaw];
debugPrint[dbg, "checkKineticLaw: csymbolsInFormula: ", csymbolsInFormula]; 

csymbols=Join[Cases[FullForm[klaw],MyAngleBracket[_,"time"],Infinity],
Cases[FullForm[klaw],MyAngleBracket[_,"delay"][_,_],Infinity]
];
Block[{ANG}, 
ANG[x_,"time"]:= x;
ANG[x_, "delay"][_, _]:= x;
csymbols=csymbols/.{MyAngleBracket-> ANG};
];
AppendTo[csymbols, MyAngleBracket];

(* csymbols=Append[First/@(csymbols/.{Global`AngleBracket-> List}),Global`AngleBracket]; *)

csymbols = Join[stringer/@csymbols,stringer/@Flatten[{csymbolsInFormula}] ];
debugPrint[dbg,"checkKineticLaw: csymbols",csymbols];


xml=Xpression2SymbolicMathML[klaw];
math=xml;
xml=Cases[xml, XMLElement["ci",{},{_}],Infinity];
debugPrint[dbg,"checkKineticLaw: xml",xml];

myXMLElement["ci",{},{"t"}]:= {};
myXMLElement["ci",{}, {x_}]:= x;
myXMLElement[x___]:= "XMLFormatError";
syms=Flatten[xml/.{XMLElement-> myXMLElement}];
debugPrint[dbg,"checkKineticLaw: syms",syms];

definedSymbols=defunctionate/@Join[parameters,  species, compartments, functions, GlobalParameters, csymbols];
debugPrint[dbg, "checkKineticLaw: definedSymbols", definedSymbols]; 
(* this gives all symbols that are not declared *)
undefinedSymbols=Complement[syms, definedSymbols];

debugPrint[dbg,"checkKineticLaw: undefinedSymbols",undefinedSymbols];

Print["Warning: checkKineticLaw: "//boldRed," the symbol "//boldBlack,#//boldBlue," is referenced in the kinetic law "//boldBlack, klaw//boldBlue," for reaction "//boldBlack,id//boldBlue," = ",reaction//boldBlue," but has not been defined in the model."//boldBlack]&/@undefinedSymbols;

(* this gives all objects that are used as species but are not defined *)
undefinedSpecies=Complement[Join[modifiers,reactants, products],species];
debugPrint[dbg,"checkKineticLaw: undefinedSpecies",undefinedSpecies];



(* Print["Warning: "//boldRed," the species "//boldBlack,#//boldBlue," is referenced in reaction "//boldBlack,id//boldBlue," but has not been previously defined as a species in the model."//boldBlack]&/@undefinedSpecies; *) 

(* this gives all the species that are referenced in the kinetic law that are not declared as modifiers *)
undefinedModifiers=Complement[Complement[Intersection[syms, species],reactants, products],modifiers];
debugPrint[dbg,"checkKineticLaw: undefinedModifiers",undefinedModifiers];

Print["Error: "//boldRed," the species "//boldBlack,#//boldBlue," is referenced in the kinetic law "//boldBlack, klaw//boldBlue," for reaction "//boldBlack,id//boldBlue," = "//boldBlack, reaction//boldBlue," but is not defined as a modifier in the reaction."//boldBlack]&/@undefinedModifiers;

checkFunctionCalls[math,"reaction",stringer[id], opt];

modifiers=Join[modifiers,undefinedModifiers];

If[caller=="addReaction",
Return[
Flatten[Join[{
Global`reactants-> reactants,
Global`products-> products, 
Global`modifiers-> modifiers},
{opt}
]]
];
];
Return[{}];
];


addReaction[XMLElement[x___]]:=Module[{r,n, reacts, prods, mods,sp, compartment,rstring,reactListString, 
meta, rmetas, pmetas, mmetas,addmeta, dbg=False, reactionparameters
},


addmeta[metau_,idu_, object_]:= Module[{id, cn, cio},
If[dbg, Print["addmeta: metau=", metau, " idu=", idu, " object=", object]]; 
cio=contextify[idu, object]; 
If[dbg, Print["addmeta: cio: ", cio]]; 
cn=contextify[n, MB$ID]; 
If[dbg, Print["addmeta: n, cn: ",n, ",", cn]]; 

id=contextify[cio, cn];

If[dbg, Print["addmeta: id: ", id]]; 

If[metau!= "", addMetaID[metau,id, object, True]]; 
]; 


reactListString[{}]:= "";
reactListString[{q__}]:= ToString[Plus[q]];
r =XMLElement[x];
n=getSBMLid[r];

If[dbg, Print["addReaction[XML]: r: ", r]]; 
If[dbg, Print["addReaction[XML]: n: ", n]]; 



If[deleteReaction[Global`id-> n],If[MB$Echo,Print["Previous occurance of reaction "//boldGreen,n//boldBlue," removed."//boldGreen]]];
addID[n, "reaction",True];

meta = getSBMLfield["metaid", r]; 
If[meta!= "", addMetaID[meta,contextify[n], "reaction", True]]; 
If[dbg, Print["addReaction[XML]: meta: ", meta]]; 


MB$Reactions=Append[MB$Reactions,n->r];

(* add code here to verify that reactants, products, modifiers are in model *)

reacts = Cases[r,XMLElement["listOfReactants",_,_],2 ];
reacts = Cases[reacts,XMLElement["speciesReference",_,_],3]; 
rmetas=Map[getSBMLfield["metaid",#]&, reacts];
reacts = Map[getSBMLfield["species",#]&, reacts];

If[dbg, Print["addReaction[XML]: addmeta: ", {rmetas, reacts}]];
MapThread[addmeta[#1, #2, "reactant"]&, {rmetas, reacts}];
If[dbg, Print["addReaction[XML]: addmeta: done "]];



prods = Cases[r,XMLElement["listOfProducts",_,_],2];
prods = Cases[prods,XMLElement["speciesReference",_,_],3]; 
pmetas=Map[getSBMLfield["metaid",#]&, prods];
prods = Map[getSBMLfield["species",#]&, prods];

If[dbg, Print["addReaction[XML]: addmeta: ", {pmetas, prods}]];
MapThread[addmeta[#1, #2, "product"]&, {pmetas, prods}];
If[dbg, Print["addReaction[XML]: addmeta: done "]];


(* check to see if any reactant or product is already referenced in an assignment rule *)


Block[{prior, check},

prior[variable_]:= Module[{},

If[MemberQ[MB$AssignmentRuleVariables, variable], 
Return["assignmentRule"];
];
If[MemberQ[MB$RateRuleVariables, variable], 
Return["rateRule"];
];
Return[""]; 
]; 

check[variable_]:= (StringLength[prior[variable]]>0) \[And] !MemberQ[MB$BoundaryConditionSpecies, variable]; 

Map[If[check[#], Print["Error: "//boldRed, "addReaction: "//boldBlack,
prior[#]//boldBlue, " already defined for the variable "//boldBlack, #//boldBlue , " which is not a boundaryCondition\n"//boldBlack, Sequence@@XMLHighlightForm[r, Purple, "species="<>quote[#]]

]]&, Union[prods, reacts]];


MB$ReactionVariables=Flatten[AppendTo[MB$ReactionVariables, Union[prods, reacts]]]//Union; 


]; 


mods = Cases[r,XMLElement["listOfModifiers",_,_] ,2];
mods = Cases[mods,XMLElement["modifierSpeciesReference",_,_],3]; 
mmetas=Map[getSBMLfield["metaid",#]&, mods];
mods = Map[getSBMLfield["species",#]&, mods];
MapThread[addmeta[#1, #2, "modifier"]&, {mmetas, mods}];


(*rstring=Rule[(reacts/.{List-> Plus}),prods/.{List-> Plus}];*) 
rstring=reactListString[reacts]<>"\[Rule]"<>reactListString[prods];
rstring=StringReplace[rstring," "-> ""]; 

If[Length[mods]>0,rstring=Overscript[rstring,mods]];

reacts =Union[ Flatten[{reacts,prods,mods}]]; 
reacts = Complement[reacts,Map[First,MB$Species]];
If[Length[reacts]>0,
Map[addSpecies[Global`id-> #]&, reacts]
];

reactionparameters=getSBMLfield["id", #]&/@Cases[r, XMLElement["parameter",___], Infinity]; 
addID[#, "reaction-parameter ("<>n<>")", False]&/@reactionparameters;

If[MB$Echo, Print["Reaction "//boldGreen,rstring//boldBlue, " added as "//boldGreen,n//boldBlue]];
Return[n];
];

addReaction[opt___?OptionQ]:=Module[{r,n,id, opts,optss, rs, ps, reaction, info, dbg=False},
(* MB$Echo = Global`echo/.{opt}/.{Global`echo-> True}; *) 


opts=Flatten[{opt}];

If[dbg, Print["addReaction[options]: opts: ", opts]]; 

rs=(Global`reactants)/.opts/.{Global`reactants-> {}};
ps=(Global`products)/.opts/.{Global`products-> {}};
reaction=(Global`reaction)/.opts/.{Global`reaction-> {}};

info = Flatten[Join[rs, ps, {reaction}]]; 
If[info=={}, 
reaction=First[opts]; 
opts=Rest[opts];
AppendTo[opts, Global`reaction-> reaction];
]; 

id=(Global`id)/.{opt}/.{Global`id-> ""};
If[id=="",id = "reaction"<>ToString[MB$reactioncounter++]; ]; 

opts={opts,Global`id-> id, invokedBy-> "addReaction"}//Flatten;

optss=checkKineticLaw@@opts;
optss= Select[optss, !SameQ[First[#], invokedBy]&];

r =reactionToSymbolicSBML@@optss;
If[dbg, Print["addReaction[options]: r: ", r]]; 

n = addReaction[r]; 
If[dbg, Print["addReaction[options]: n: ", n]]; 

Return[n]; 
];

addReaction[r_, opt___?OptionQ]:= Module[{},
Return[addReaction[Global`reaction-> r, opt]];
];


modifyReaction[opt___?OptionQ]:= Module[{n,x,y, m,dbg=False,dummyvariable,
r, p,rn, pn,rs, ps,  k,kopt,kann,knotes,rann,pann,mann,reactionAnnotation,reactionNotes,rmetaids,pmetaids,mmetaids, getFirst, getSpecies, speciesName, stoic, infix, parameter, getspeciesReferenceInfo, getModifierSpecies, speciesMetaid
},

getFirst[a_]:= Module[{b}, 
b=a; 
While [ListQ[b] \[And] Length[b]>0, b = First[b]];
Return[b]; 
]; 

getSpecies[a_]:= 
 Cases[a, XMLElement["speciesReference",___],Infinity];
getModifierSpecies[a_]:= 
 Cases[a, XMLElement["modifierSpeciesReference",___],Infinity];

getSpecies[a_, tag_]:= Module[{},
Switch[tag,
"listOfReactants",getSpecies[a],
"listOfProducts",getSpecies[a],
"listOfModifiers",getModifierSpecies[a],
_,"Error"
]//Return;
]; 

speciesName[a_]:= getSBMLfield["species",a]; 
speciesMetaid[a_]:= getSBMLfield["metaid",a];

getspeciesReferenceInfo[tag_, input_]:= Module[{r,names, stoichiometries,dbg=False, ann, metaids, notes},

r=Cases[input, XMLElement[tag, ___],Infinity];

r=getSpecies[r//getFirst,tag]; 
debugPrint[dbg,"\!\(\*
StyleBox[\"getspeciesReferenceInfo\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\":\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\" \",\nFontColor->RGBColor[0, 0, 1]]\)"<>tag,r];

ann = getAnnotations/@r;
debugPrint[dbg,"\!\(\*
StyleBox[\"getspeciesReferenceInfo\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\":\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\" \",\nFontColor->RGBColor[0, 0, 1]]\)"<>tag<>": annotations",ann];

names =speciesName/@r;
debugPrint[dbg,"\!\(\*
StyleBox[\"getspeciesReferenceInfo\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\":\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\" \",\nFontColor->RGBColor[0, 0, 1]]\)"<>tag<>": names ",names];

notes = getNotes/@r; 

metaids=speciesMetaid/@r;


If[tag== "listOfReactants" \[Or] tag=="listOfProducts",
stoichiometries= stoic/@r;
debugPrint[dbg,"getspeciesReferenceInfo: "<>tag<>": stoichiometries ",stoichiometries];,
stoichiometries={};
];

Return[{names,stoichiometries,ann,notes, metaids }];
];

infix[XMLElement["math",x___]]:= SymbolicSBMLMathMLToExpression[XMLElement["math",x]];
infix[x___]:= 1; 
stoic[a_]:= s = Cases[a, XMLElement["math",___], Infinity]//getFirst//infix;

parameter[p_]:=Module[{s,ann,notes,r},
s= extractXMLOptions[p];
ann = getAnnotations[p]; 
notes=getNotes[p]//stringToNotes; 
r=Rule[ getSBMLfield["id",p],Join[s,{"annotation"-> ann,"notes"-> notes}]
];
Return[r]
];

debugPrint[dbg,"modifyReaction,opt",{opt}]; 
n =( Global`id/.{opt}/.{Global`id-> ""})//stringer;
If[n=="", Print["Error: "//boldRed,"modifyReaction: No reaction id specified."//boldBlack];Return[{}]; ]; 

MB$Currentid=n;
debugPrint[dbg,"modifyReaction,n",n]; 
x=retrieveSBMLObject["reaction",n];

debugPrint[dbg,"modifyReaction,x",x];
reactionAnnotation = updateAnnotations[x,opt]; 
debugPrint[dbg,"modifyReaction: annotations ",reactionAnnotation];

reactionNotes=updateNotes[x,opt];
debugPrint[dbg,"modifyReaction: notes ",reactionNotes];


If[ToString[Head[x]]=="XMLElement",

y=extractXMLOptions[x];
y = Join[{opt},y]//Flatten;

debugPrint[dbg,"modifyReaction,y",y];

{rn,rs,rann,rnotes, rmetaids}=getspeciesReferenceInfo["listOfReactants", x];
{pn,ps,pann,pnotes,pmetaids}=getspeciesReferenceInfo["listOfProducts", x];
{m,dummyvariable, mann,mnotes, mmetaids}=getspeciesReferenceInfo["listOfModifiers", x];

y = Join[y,
{"reactants"-> rn, "products"-> pn, "reactantStoichiometry"-> rs, "productStoichiometry"-> ps, "modifiers"-> m,
"reactantannotations"-> rann,"productannotations"-> pann,"modifierannotations"-> mann,
"reactantmetaids"-> rmetaids,"productmetaids"-> pmetaids,
"modifiermetaids"-> mmetaids,
"reactantnotes"-> rnotes, "productnotes"-> pnotes,"modifiernotes"-> mnotes
}
];
debugPrint[dbg,"modifyReaction,y",y];

k = Cases[x,XMLElement["kineticLaw",___],Infinity]//getFirst; 
kopt = extractXMLOptions[k]; 
debugPrint[dbg,"modifyReaction,k",k];
debugPrint[dbg,"modifyReaction,kopt",kopt];

p = Cases[k, XMLElement["parameter",___],Infinity]; 
debugPrint[dbg,"modifyReaction, parameters",p];
p = parameter/@p;
debugPrint[dbg,"modifyReaction, parameters",p];

kann = getAnnotations[k];
knotes = getNotes[k]//stringToNotes; 
k = Cases[k, XMLElement["math",___],Infinity]//getFirst//infix; 
debugPrint[dbg,"modifyReaction,kinetic law",k];
y = Join[y,kopt/.{"metaid"-> "kineticlawmetaid"}]; 
y = Append[y, 
"kineticLaw"->{ "math"-> k, "annotation"-> kann, "notes"-> knotes}]; 

y = Append[y, "parameters"-> p]; 
y = Prepend[y,"annotation"-> reactionAnnotation]; 
y = Prepend[y,"notes"-> reactionNotes]; 

y = globalize/@y; 
debugPrint[dbg,"modifyReaction,y",y];

n=Apply[addReaction,y];  
,
Print["Warning: "//boldOrange, "The reaction "//boldBlack,n//boldRed, " was not found."//boldBlack]; 
n={};
];
Return[n]; 
];
modifyReaction[id_, opt___?OptionQ]:= modifyReaction[Global`id-> id, opt];


getSpecies[n_?IntegerQ]:= Module[{m},
m=Length[MB$Species];
If[n>m \[Or] n<1, Print["Error: getSpecies: "//boldRed," Species: "//boldBlack,n//boldRed," does not exist. There are "//boldBlack,m//boldRed," species."//boldBlack];Return[{}];];
Return[MB$Species[[n]]//Last];
]; 
getSpeciesNumber[id_?SIDQ]:=Module[{m,n},
m = First/@MB$Species;
n=Position[m, stringer[id]];
If[Length[n]<1, Print["Error: getSpeciesNumber: "//boldRed,"Species: "//boldBlack,id//boldRed," does not exist. Valid species are "//boldBlack, m//boldRed];Return[0];]; 
While[ListQ[n], n=First[n]];
Return[n];
]; 
getSpecies[id_?SIDQ]:=Module[{m,n},
n=getSpeciesNumber[id];
If[n>0,Return[MB$Species[[n]]//Last]];
Return[{}];
]; 
getSpecies[x_?ListQ]:= getSpecies/@Flatten[x];
getNumberOfSpecies[]:= Length[MB$Species];
getSpecies[]:= getSpecies[Range[getNumberOfSpecies[]]]; 

getSpecies[x___]:= Module[{},
Print["Error: getSpecies: "//boldRed, "Correct format is: "//boldBlack,"getSpecies[id]"//boldRed, " where id is an integer or an SID, "//boldBlack,"getSpecies[Integer]"//boldRed, " or "//boldBlack,"getSpecies[{x1,x2,...}]"//boldRed," where x1,x2,... are integers or SIDs."//boldBlack];
Return[{}];
];




replaceSpecies[i_?IntegerQ, XMLElement["species",x___]]:= Module[{n,j},
n=Length[MB$Species];
If[n>0 \[And] i>0 \[And] i<=n, 
j=getSBMLfield["id",XMLElement["species",x]]; 
If[j=="", j=MB$Species[[i,1]]];
MB$Species=ReplacePart[MB$Species,j-> XMLElement["species",x],i];
If[MB$Echo, Print["Species ",i, " replaced."]];
Return[];
]; 
Print["Error: replaceSpecies: "//boldOrange," unable to replace species "//boldBlack,i//boldRed];
Return[];
]; 

replaceSpecies[id_?SIDQ, XMLElement["species",x___]]:= Module[{n},
n=getSpeciesNumber[id];
If[n>0, 
replaceSpecies[n, XMLElement["species",x]]; 
Return[];
]; 
Print["Error: replaceSpecies: "//boldOrange," unable to replace species "//boldBlack,id//boldRed];
Return[];
]; 
replaceSpecies[x___]:= Print["Error: "//boldOrange,"replaceSpecies: "//boldRed, "Invalid arguments. Correct format is:"//boldBlack,"replaceSpecies["//boldBlack," Integer|SID "//boldBlack,","//boldBlack, " XMLElement[\"species\",...]"//boldBlack," ]"//boldBlack]



speciesToSBML[{x__?ListQ}]:=Module[{SBML}, 
SBML =Flatten[ speciesToSymbolicSBML/@{x}];
SBML = XMLElement["listOfSpecies",{},SBML]; 
SBML=ExportXMLString[SBML];
SBML = sunderscore[SBML];
Return[SBML];
];

speciesToSBML[opt___?OptionQ]:= Module[{r},
r =speciesToSymbolicSBML[opt]; 
r=ExportXMLString[r];
r = sunderscore[r];
Return[r];
];

speciesToSBML[x_, opt___?OptionQ]:= speciesToSBML[Global`id-> x, opt]; 


speciesToSBML[x___]:= Print[
boldRed["Error:"], 
boldBlack["speciesToSBML:  invalid syntax: "], boldBlue[ToString[{x}]]
]; 




deleteSpecies[opt___?OptionQ]:= Module[{n,c,p},
n =( Global`id/.{opt}/.{id-> ""})//stringer;
If[id=="", 
Print["Error: deleteSpecies"//boldRed," No "//boldBlack,"id"//boldRed," was specified."//boldBlack]]; 
removeID[n,"species"]; 

MB$Currentid=n;
c = Map[First,MB$Species]; 
If[MemberQ[c,n],
p=Position[c,n];
MB$Species= Drop[MB$Species,First[p]]; 
Return[True];
];
Return[False];
];
deleteSpecies[x_, opt___?OptionQ]:= deleteSpecies[Global`id-> x,opt];
removeSpecies[x___]:=Module[{flag},
flag = deleteSpecies[x];
If[flag, 
If[MB$Echo,Print["Species "//boldGreen,MB$Currentid//boldBlue," removed."//boldGreen]],
Print["Error: "//boldRed,"removeSpecies: Requested species "//boldBlack,MB$Currentid//boldBlue," does not exist."//boldBlack]];
];



addSpecies[XMLElement[x___]]:=Module[{r,n, comp,comps, units, cdata, dbg=False,
substanceUnits, spatialSizeUnits, defSpatialSizeUnits,dim,hasOnlySubstanceUnits,logicate, opts,sub,unitsofthespecies,stype,stypes, meta, bc},
r =XMLElement[x];
n=getSBMLid[r];


(* check for previous occurance of this species *)

If[deleteSpecies[Global`id-> n],If[MB$Echo,Print["Previous occurance of species "//boldGreen,n//boldBlue," removed."//boldGreen]]
];


addID[n, "species",True];
meta = getSBMLfield["metaid", r]; 
If[meta!= "", addMetaID[meta,contextify[n], "species", True]]; 




opts={x}[[2]];
sub={x}[[3]];

logicate["true"]:= True;
logicate["false"]:= False;
logicate[___]:=False;

bc= getSBMLfield["boundaryCondition", r]; 
If[logicate[bc], AppendTo[MB$BoundaryConditionSpecies, n]]; 

(* check to make sure assigned compartment exists *) 

comp = getSBMLfield["compartment",r];
comps = First/@MB$Compartments;

If[!MemberQ[comps,comp],addCompartment[comp];];

cdata = comp/.MB$Compartments;
If[dbg, Print["addSpecies: cdata: ",cdata]]; 

stype=getSBMLfield["speciesType",r];
If[stype!= "",

stypes=First/@MB$SpeciesTypes;
If[!MemberQ[stypes,stype], addSpeciesType[stype]]; 

]; 

(* check for substanceUnits and insert default if not present *)
substanceUnits=getSBMLfield["substanceUnits",r,default-> "substance"];
opts=Select[opts,(First[#]!= "substanceUnits")&];
opts = Append[opts,"substanceUnits"-> substanceUnits];
If[!unitExists[substanceUnits], addUnit[substanceUnits]];
If[dbg, Print["addSpecies: opts (1):",opts]]; 

(* check for hasOnlySubstanceUntis and insert default value if not present *)
hasOnlySubstanceUnits=getSBMLfield["hasOnlySubstanceUnits",r,default-> "false"]; 
opts=Select[opts,(First[#]!= "hasOnlySubstanceUnits")&];
opts = Append[opts,"hasOnlySubstanceUnits"-> hasOnlySubstanceUnits];
If[dbg, Print["addSpecies: opts (2):",opts]]; 



If[logicate[hasOnlySubstanceUnits],
unitsofthespecies=Rule[n,substanceUnits];

,
	
(*check spatial size units; compare with compartment units; insert default if not there *)
dim = getSBMLfield["spatialDimensions",cdata,default-> "3"]; 

defSpatialSizeUnits=Switch[dim,
"0","dimensionless",
"1","length",
"2","area",
"3","volume",
_,"Indeterminate"
]; 
defSpatialSizeUnits=getSBMLfield["units",cdata,default-> defSpatialSizeUnits];

If[ToExpression[MB$LevelVersion]<2.3,
spatialSizeUnits=getSBMLfield["spatialSizeUnits",r,default-> defSpatialSizeUnits];
opts = Select[opts, (First[#]!= "spatialSizeUnits")&]; 
If[spatialSizeUnits!= "Indeterminate",
opts = Append[opts,"spatialSizeUnits"-> spatialSizeUnits]
];
unitsofthespecies=Rule[n,substanceUnits<>"/"<>spatialSizeUnits];
, 
(* spatialSizeUnits were removed in L2V3 *)

unitsofthespecies=Rule[n,substanceUnits<>"/"<>defSpatialSizeUnits];
spatialSizeUnits=getSBMLfield["spatialSizeUnits",r,default-> ""];
If[spatialSizeUnits!= "", 
Print["Error: addSpecies: "//boldRed, "spatialSizeUnits is not a valid option in SMBL Level.Version "//boldBlack, MB$LevelVersion//boldBlack]
];
]; 

If[spatialSizeUnits=="Indeterminate" , unitsofthespecies="Indeterminate"];
];
If[dim=="0" , unitsofthespecies=substanceUnits];


MB$UnitsOfTheSpecies=Append[MB$UnitsOfTheSpecies,unitsofthespecies];


If[dbg, 
Print["addSpecies: substanceUnits: ", n,":",substanceUnits]; 
Print["addSpecies: spatialSizeUnits: ",n,":",spatialSizeUnits];
Print["addSpecies: hasOnlySubstanceUnits: ", n,":",hasOnlySubstanceUnits];
]; 


r=XMLElement["species",opts,sub];
If[dbg, Print["addSpecies: opts (3):",opts]]; 
If[dbg, Print["addSpecies: r:",r];];
MB$Species=Append[MB$Species,n->r];

(* check to make sure assigned units exits *) 
units = getSBMLfield["units",r];
If[units!= "", 
If[!unitExists[units], addUnit[units]]];

If[MB$Echo, Print["Species "//boldGreen,n//boldBlue," added to compartment "//boldGreen, comp//boldBlue]];
Return[n];
];


addSpecies[s_?ListQ, opt___?OptionQ]:= Map[addSpecies[#,opt]&,s];    

addSpecies[opt___?OptionQ]:=Module[{r,n, c,comps,opts, allowedOpts, dbg=False},
opts ={opt}; 

Switch[MB$LevelVersion, 
"2.1",
allowedOpts={Global`annotation, Global`boundaryCondition, Global`charge, Global`compartment,Global`constant,  Global`id, Global`metaid,  Global`name,Global`notes,Global`initialAmount, Global`initialConcentration, Global`substanceUnits,Global`spatialSizeUnits, Global`ArrayDimensions, Global`hasOnlySubstanceUnits};
,
"2.2", 
allowedOpts={Global`annotation, Global`boundaryCondition, Global`charge, Global`compartment,Global`constant,  Global`id, Global`metaid,  Global`name,Global`notes,Global`initialAmount, Global`initialConcentration, Global`substanceUnits,Global`spatialSizeUnits, Global`ArrayDimensions, Global`hasOnlySubstanceUnits, Global`speciesType};
,
"2.3",
allowedOpts={Global`annotation, Global`boundaryCondition, Global`charge, Global`compartment,Global`constant,  Global`id, Global`metaid,  Global`name,Global`notes,Global`initialAmount, Global`initialConcentration, Global`substanceUnits, Global`ArrayDimensions, Global`hasOnlySubstanceUnits, Global`speciesType}; 
,
_,
Print["addSpecies: ", "unable to process MB$LevelVersion: ", MB$LevelVersion];
Return[$Failed];
];
 
checkOptions[addSpecies, opts, allowedOpts];
If[dbg, Print["addSpecies: opts: ", opts]]; 

c = stringer[Global`compartment/.{opt}/.{Global`compartment-> ""}]; 

(* If no compartment, automatically add it! *) 
If[c=="",

(* if there is at least one compartment already, use the first one *) 
(* otherwise add a new compartment *) 

If[Length[MB$Compartments]>0, 
(* check for possible invalid reassignment of MB$CurrentCompartment by another program or possible deletion of compartment *)
c=popCompartment[];
While[
(!MemberQ[First/@MB$Compartments,c] )&&(c!= Null),
c=popCompartment[];
];
If[c==Null, c = MB$Compartments//First//First]; 
,
c = "Compartment"<>ToString[MB$compartmentcounter]; 
];
opts = Prepend[opts, Global`compartment-> c]; 
]; 

(* reset current compartment *)

pushCompartment[c];

r =Apply[speciesToSymbolicSBML,opts]; 
If[dbg, Print["addSpecies:r ", r]];

n=addSpecies[r];
Return[n];
];

addSpecies[id_, opt___?OptionQ]:= addSpecies[Global`id-> id, opt];


 modifySpecies[opt___?OptionQ]:= Module[{n,x,y,ann, notes},
n =( Global`id/.{opt}/.{Global`id-> ""})//stringer;
MB$Currentid=n;

x=retrieveSBMLObject["species",n];

If[ToString[Head[x]]=="XMLElement",
y=globalize/@extractAndUpdateXMLOptions[x,opt];



ann = updateAnnotations[x, opt];
notes = updateNotes[x, opt]; 

y = Prepend[y, globalize["annotation"-> ann]]; 
y = Prepend[y, globalize["notes"-> notes]]; 

n=Apply[addSpecies,y];
,
n=addSpecies[opt]; 
];
Return[n]; 
];
modifySpecies[id_, opt___?OptionQ]:= modifySpecies[Global`id-> id, opt];



getSpeciesType[n_?IntegerQ]:= Module[{m},
m=getNumberOfSpeciesTypes[];
If[n>m \[Or] n<1, Print["Error: getSpeciesType: "//boldRed," speciesType: "//boldBlack,n//boldRed," does not exist. There are "//boldBlack,m//boldRed," speciesTypes."//boldBlack];Return[{}];];
Return[MB$SpeciesTypes[[n]]//Last];
]; 
getSpeciesTypeNumber[id_?SIDQ]:=Module[{m,n},
m = First/@MB$SpeciesTypes;
n=Position[m, stringer[id]];
If[Length[n]<1, Print["Error: getSpeciesTypeNumber: "//boldRed,"speciesType: "//boldBlack,id//boldRed," does not exist. Valid speciesType are "//boldBlack, m//boldRed];Return[0];]; 
While[ListQ[n], n=First[n]];
Return[n];
]; 
getSpeciesType[id_?SIDQ]:=Module[{m,n},
m = First/@MB$SpeciesTypes;
n=Position[m, stringer[id]];
If[Length[n]<1, Print["Error: getSpeciesType: "//boldRed,"speciesType: "//boldBlack,id//boldRed," does not exist. Valid speciesType are "//boldBlack, m//boldRed];Return[{}];]; 
While[ListQ[n], n=First[n]];
Return[MB$SpeciesTypes[[n]]//Last];
]; 
getSpeciesType[x_?ListQ]:= getSpeciesType/@Flatten[x];
getNumberOfSpeciesTypes[]:= Length[MB$SpeciesTypes];
getSpeciesType[]:= getSpeciesType[Range[getNumberOfSpeciesTypes[]]]; 

getSpeciesType[x___]:= Module[{},
Print["Error: getSpeciesType: "//boldRed, "Correct format is: "//boldBlack,"getSpeciesType[id]"//boldRed, " where id is an integer or an SID, "//boldBlack,"getSpeciesType[Integer]"//boldRed, " or "//boldBlack,"getSpeciesType[{x1,x2,...}]"//boldRed," where x1,x2,... are integers or SIDs."//boldBlack];
Return[{}];
];




speciesTypeToSBML[{x__?ListQ}]:=Module[{SBML}, 
SBML =Flatten[ speciesTypeToSymbolicSBML/@{x}];
SBML = XMLElement["listOfSpeciesTypes",{},SBML]; 
SBML=ExportXMLString[SBML];
SBML = sunderscore[SBML];
Return[SBML];
];

speciesTypeToSBML[opt___?OptionQ]:= Module[{r},
r =speciesTypeToSymbolicSBML[opt]; 
r=ExportXMLString[r];
r = sunderscore[r];
Return[r];
];

speciesTypeToSBML[x_, opt___?OptionQ]:= speciesTypeToSBML[Global`id-> x, opt]; 


speciesTypeToSBML[x___]:= Print[
boldRed["Error:"], 
boldBlack["speciesTypeToSBML:  invalid syntax: "], boldBlue[ToString[{x}]]
]; 




deleteSpeciesType[opt___?OptionQ]:= Module[{n,c,p},
n =( Global`id/.{opt}/.{Global`id-> ""})//stringer;
If[n=="", 
Print["Error: "//boldRed," deleteSpeciesType: id not specified."//boldBlack]]; 
removeID[n,"speciesType"]; 
MB$Currentid=n;
c = Map[First,MB$SpeciesTypes]; 
If[MemberQ[c,n],
p=Position[c,n];
MB$SpeciesTypes= Drop[MB$SpeciesTypes,First[p]]; 
Return[True];
];
Return[False];
];
deleteSpeciesType[x_, opt___?OptionQ]:= deleteSpeciesType[Global`id-> x,opt];
removeSpeciesType[x___]:=Module[{flag},
flag = deleteSpeciesType[x];
If[flag, 
If[MB$Echo,Print["Species Type "//boldGreen,MB$Currentid//boldBlue," removed."//boldGreen]],
Print["Error: "//boldRed,"removeSpeciesType:"//boldBlack,MB$Currentid//boldBlue," not found."//boldBlack]];
];



addSpeciesType[XMLElement[x___]]:=Module[
{r,n, opts,sub, meta},
If[ToExpression[MB$LevelVersion]<2.2, Print["Error:"//boldOrange," Cannot add a speciesType in SBML Level "//boldBlack,MB$LevelVersion//boldBlack];Abort[]];
r =XMLElement[x];
n=getSBMLid[r];

opts={x}[[2]];
sub={x}[[3]];

(* check for previous occurance of this species type *)

If[deleteSpeciesType[Global`id-> n],If[MB$Echo,Print["Previous occurance of speciesType "//boldGreen,n//boldBlue," removed."//boldGreen]]
];

addID[n, "speciesType",True];
meta = getSBMLfield["metaid", r]; 
If[meta!= "", addMetaID[meta,contextify[n], "speciesType", True]]; 


r=XMLElement["speciesType",opts,sub];
MB$SpeciesTypes=Append[MB$SpeciesTypes,n->r];
If[MB$Echo, Print["SpeciesType "//boldGreen,n//boldBlue," added."//boldGreen]];

Return[n];
];


addSpeciesType[s_?ListQ, opt___?OptionQ]:= Map[addSpeciesType[#,opt]&,s];    

addSpeciesType[opt___?OptionQ]:=Module[{r,n},
checkOptions[addSpeciesType, opt, 
{Global`annotation,  Global`id, Global`metaid,  Global`name,Global`notes}];
r =speciesTypeToSymbolicSBML@@{opt};
n=addSpeciesType[r];
Return[n];
];

addSpeciesType[id_, opt___?OptionQ]:= addSpeciesType[Global`id-> id, opt];


 modifySpeciesType[opt___?OptionQ]:= Module[{n,x,y,ann, notes},
n =( Global`id/.{opt}/.{Global`id-> ""})//stringer;
MB$Currentid=n;

x=retrieveSBMLObject["speciesType",n];

If[ToString[Head[x]]=="XMLElement",
y=globalize/@extractAndUpdateXMLOptions[x,opt];

ann = updateAnnotations[x, opt];
notes = updateNotes[x, opt]; 

y = Prepend[y, globalize["annotation"-> ann]]; 
y = Prepend[y, globalize["notes"-> notes]]; 

n=Apply[addSpeciesType,y];
,
n=addSpeciesType[opt]; 
];
Return[n]; 
];
modifySpeciesType[id_, opt___?OptionQ]:= modifySpeciesType[Global`id-> id, opt];



getFunction[n_?IntegerQ]:= Module[{m},
m=Length[MB$Functions];
If[n>m \[Or] n<1, Print["Error: getFunction: "//boldOrange," Function: "//boldBlack,n//boldRed," does not exist. There are "//boldBlack,m//boldRed," functions."//boldBlack];Return[{}];];
Return[MB$Functions[[n]]//Last];
];
getFunctionNumber[id_?SIDQ]:=Module[{m,n},
m = First/@MB$Functions;
n=Position[m, stringer[id]];
If[Length[n]<1, Print["Error: getFunctionNumber: "//boldOrange,"Function: "//boldBlack,id//boldRed," does not exist. Valid functions are "//boldBlack, m//boldRed];Return[0];]; 
While[ListQ[n], n=First[n]];
Return[n];
];  
getFunction[id_?SIDQ]:=Module[{m,n},
n=getFunctionNumber[id];
If[n>0, Return[MB$Functions[[n]]//Last]]; 
Return[{}]; 
]; 
getFunction[x_?ListQ]:= getFunction/@Flatten[x];
getNumberOfFunctions[]:= Length[MB$Functions];
getFunctions[]:= getFunction[Range[getNumberOfFunctions[]]]; 

getFunction[x___]:= Module[{},
Print["Error: getFunction: "//boldOrange, "Correct format is: "//boldBlack,"getFunction[id]"//boldRed, " where id is an integer or an SID, "//boldBlack,"getFunction[Integer]"//boldRed, " or "//boldBlack,"getFunction[{x1,x2,...}]"//boldRed," where x1,x2,... are integers or SIDs."//boldBlack];
Return[{}];
];




replaceFunction[i_?IntegerQ, XMLElement["functionDefinition",x___]]:= Module[{n,j},
n=Length[MB$Functions];
If[n>0 \[And] i>0 \[And] i<=n, 
j=getSBMLfield["id",XMLElement["functionDefinition",x]]; 
If[j=="", j=MB$Functions[[i,1]]];
MB$Functions=ReplacePart[MB$Functions,j-> XMLElement["functionDefinition",x],i];
If[MB$Echo, Print["Function ",i, " replaced."]];
Return[];
]; 
Print["Error: replaceFunction: "//boldOrange," unable to replace function "//boldBlack,i//boldRed];
Return[];
]; 

replaceFunction[id_?SIDQ, XMLElement["functionDefinition",x___]]:= Module[{n},
n=getFunctionNumber[id];
If[n>0, 
replaceFunction[n, XMLElement["functionDefinition",x]]; 
Return[];
]; 
Print["Error: replaceFunction: "//boldOrange," unable to replace function "//boldBlack,id//boldRed];
Return[];
]; 

replaceFunction[x___]:= Print["Error: "//boldOrange,"replaceFunction: "//boldRed, "Invalid arguments. Correct format is:"//boldBlack,"replaceFunction["//boldBlack," Integer|SID "//boldBlack,","//boldBlack, " XMLElement[\"functionDefinition\",...]"//boldBlack," ]"//boldBlack];


 functionToSBML[{x__?ListQ}]:=Module[{SBML}, 
SBML =Flatten[ functionToSymbolicSBML/@{x}];
SBML = XMLElement["listOfFunctionDefinitions",{},SBML]; 
SBML=ExportXMLString[SBML];
SBML = sunderscore[SBML];
Return[SBML];
];

functionToSBML[opt___?OptionQ]:= Module[{r},
r=functionToSymbolicSBML[opt];
r=ExportXMLString[r];
r=sunderscore[r];
Return[r];
];

functionToSBML[x_, opt___?OptionQ]:= functionToSBML[Global`id-> x, opt]; 

functionToSBML[x___]:=
Print[boldRed["Error:"],
 boldBlack[" functionToSBML: invalid argument syntax: "],
boldBlue[ToString[{x}]]]; 


deleteFunction[opt___?OptionQ]:= Module[{n,c,p},
n =( Global`id/.{opt}/.{id-> ""})//stringer;
If[id=="", 
Print["Error: deleteFunction"//boldOrange," No "//boldBlack,"id"/boldRed," was specified."]]; 
removeID[n,"function"]; 
MB$Currentid=n;
c = Map[First,MB$Functions]; 
If[MemberQ[c,n],
p=Position[c,n];
MB$Functions= Drop[MB$Functions,First[p]]; 
Return[True];
];
Return[False];
];
deleteFunction[x_, opt___?OptionQ]:= deleteFunction[Global`id-> x,opt];
removeFunction[x___]:=Module[{flag},
flag = deleteFunction[x];
If[flag, 
If[MB$Echo,Print["Function "//boldGreen,MB$Currentid//boldBlue," removed."//boldGreen]],
Print["Warning: "//boldOrange,"Requested function "//boldBlack,MB$Currentid//boldRed," can not be removed."//boldBlack]];
];



addFunction[XMLElement[x___]]:=Module[{n,meta, syms,XML2Sym, bvars,hf, math, csymbols, mycsymbol, lambda,checkIfLambda,  dbg=False},

checkIfLambda[XMLElement["math",v_, XMLElement[w___]]]:=True;
checkIfLambda[XMLElement["math",v_, {XMLElement[w___]}]]:=True;
checkIfLambda[w___]:=False;


XML2Sym["ci",{},{u_}]:=u;
XML2Sym[u___]:= "??--Unknown--??";

n=getSBMLid[XMLElement[x]];
If[dbg, Print["addFunction: id: ",n]]; 

If[deleteFunction[Global`id-> n] , If[MB$Echo,Print["Previous occurance of function "//boldGreen,n//boldBlue," removed."//boldGreen]]
];

addID[n,"function",True];
meta = getSBMLfield["metaid", XMLElement[x]]; 
If[meta!= "", addMetaID[meta,contextify[n], "function", True]]; 

MB$Functions=Append[MB$Functions,n->XMLElement[x]];

(* check for undefined symbols *)

math=Cases[{XMLElement[x]}, XMLElement["math",___], Infinity];
checkMathMLSubset[math, "function", n];

If[!checkIfLambda[#], 
Print["Error: "//boldRed, " The "//boldBlack,"<math ...>"//boldBlue," object in "//boldBlack,"<functionDefinition id=\""//boldBlue,n//boldBlue,"\" ..>"//boldBlue, " contains the wrong number of "//boldBlack,"<lambda ..>"//boldBlue," elements. It should begin with a "//boldBlack,"<lambda ..>"//boldBlue," element and contain precisely one "//boldBlack,"<lambda ..>"//boldBlue," element:\n"//boldBlack,
Sequence@@XMLHighlightForm[XMLElement[x],Purple, "math"]
]
]&/@math;


syms=Cases[{XMLElement[x]}, XMLElement["ci",___], Infinity];
syms=Union[syms/.{XMLElement-> XML2Sym}];

bvars=Cases[{XMLElement[x]}, XMLElement["bvar",___], Infinity];
bvars=Cases[bvars, XMLElement["ci",___], Infinity];
bvars=bvars/.{XMLElement-> XML2Sym};
bvars=Union[bvars];

addID[#, "function-argument", False]&/@bvars;

If[dbg, Print["addFunction:bvars:",bvars]];
AppendTo[$SBML$function$bvars, {n, Length[bvars]}]; 
If[dbg, Print["$SBML$function$bvars: ", $SBML$function$bvars]];


csymbols = Cases[XMLElement[x], XMLElement["csymbol",___],Infinity];
If[Length[csymbols]>0,
mycsymbol["csymbol",{___},xx_]:= xx;
mycsymbol[xx___]:= XMLElement[xx];
csymbols=Flatten[(csymbols/.{XMLElement-> mycsymbol})/.{XMLElement-> List}];
csymbols=Complement[csymbols,{"ci"}];
];

syms=Complement[syms, bvars,csymbols,  First/@$SBML$IDTable];

hf[var_]:= XMLHighlightForm[XMLElement[x],Purple,"<ci>"<>stringer[var]<>"</ci>"];

Print["Error: "//boldRed, "addFunction: undefined symbol "//boldBlack, #//boldBlue, " referenced in the definition of the function "//boldBlack,n//boldBlue,"\n",
Sequence@@hf[#]


]&/@syms;

lambda = Cases[XMLElement[x], XMLElement["lambda",___], Infinity];
If[Length[lambda]>1, 
Print["Error: "//boldRed, "Multiple lambda elements in function "//boldBlack, n//boldBlue, Sequence@@XMLHighlightForm[XMLElement[x], Purple, "<lambda>"]]; 
];
checkFunctionCalls[lambda, "function",n];

If[MB$Echo, Print["Function "//boldGreen,n//boldBlue," added."//boldGreen]];
Return[n];
];

addFunction[opt___?OptionQ]:=Module[{r,n},
(* MB$Echo = Global`echo/.{opt}/.{Global`echo-> True}; *) 
r =functionToSymbolicSBML[opt]; 
n=addFunction[r]; 
Return[n];
];

addFunction[id_, opt___?OptionQ]:= addFunction[Global`id-> id, opt];


modifyFunction[opt___?OptionQ]:= Module[{n,x,y, m, arguments, math,ann,notes},

arguments[_[args_, formula_]]:= args;
math[_[args_, formula_]]:= formula;

n =( Global`id/.{opt}/.{Global`id-> ""})//stringer;
MB$Currentid=n;
x=retrieveSBMLObject["function",n];

If[ToString[Head[x]]=="XMLElement",
y=extractAndUpdateXMLOptions[x,opt];

ann = updateAnnotations[x, opt]; 
notes = updateNotes[x, opt];

y = Prepend[y, globalize["annotation"-> ann]]; 
y  =Prepend[y, globalize["notes"-> notes]]; 

m = Cases[x, XMLElement["math",___], Infinity];
While [ListQ[m] \[And] Length[m]>0, m = First[m]]; 

m = SymbolicSBMLMathMLToExpression[m];

y = Append[y, "arguments"-> arguments[m]//Flatten]; 
y = Append[y,"math"-> math[m]]; 
y = globalize/@y; 

n=Apply[addFunction,y];  
,
n=addFunction[opt]; 
];
Return[n]; 
];
modifyFunction[id_, opt___?OptionQ]:= modifyFunction[Global`id-> id, opt];


getUnit[n_?IntegerQ]:= Module[{m},
m=Length[MB$Units];
If[n>m \[Or] n<1, Print["Error: getUnit: "//boldOrange," Unit definition: "//boldBlack,n//boldRed," does not exist. There are "//boldBlack,m//boldRed," unit definitions."//boldBlack];Return[{}];];
Return[MB$Units[[n]]//Last];
]; 
getUnitNumber[id_?SIDQ]:=Module[{m,n},
m = First/@MB$Units;
n=Position[m, stringer[id]];
If[Length[n]<1, Print["Error: getUnitNumber: "//boldOrange,"Unit: "//boldBlack,id//boldRed," does not exist. Valid units are "//boldBlack, m//boldRed];Return[0];]; 
While[ListQ[n], n=First[n]];
Return[n];
]; 
getUnit[id_?SIDQ]:=Module[{n},
n=getUnitNumber[id];
If[n>0, Return[MB$Units[[n]]//Last]];
Return[{}]; 
]; 
getUnit[x_?ListQ]:= getUnit/@Flatten[x];
getUnit[x___]:= Module[{},
Print["Error: getUnit: "//boldOrange, "Correct format is "//boldBlack,"getUnit[id]"//boldRed, " where id is an integer or an SID "//boldBlack,"getUnit[Integer]"//boldRed, " or "//boldBlack,
"getUnit[{x1,x2,...}]"//boldRed," where x1,x2,... are integers or SIDs."//boldBlack];
Return[{}];
];
getNumberOfUnits[]:=Length[MB$Units];
getUnits[]:= getUnit[Range[getNumberOfUnits[]]];



replaceUnit[i_?IntegerQ, XMLElement["unitDefinition",x___]]:= Module[{n,j},
n=Length[MB$Units];
If[n>0 \[And] i>0 \[And] i<=n, 

j=getSBMLfield["id",XMLElement["unitDefinition",x]]; 
If[j=="", j=MB$Units[[i,1]]];
MB$Units=ReplacePart[MB$Units,j-> XMLElement["unitDefinition",x],i];
If[MB$Echo, Print["Unit ",i, " replaced."]];
Return[];
]; 
Print["Error: replaceUnit: "//boldOrange," unable to replace unitDefinition "//boldBlack,i//boldRed];
Return[];
]; 

replaceUnit[id_?SIDQ, XMLElement["unitDefinition",x___]]:= Module[{n},
n=getUnitNumber[id];
If[n>0, 
replaceUnit[n, XMLElement["unitDefinition",x]]; 
Return[];
]; 
Print["Error: replaceUnit: "//boldOrange," unable to replace unitDefinition "//boldBlack,id//boldRed];
Return[];
]; 

replaceUnit[x___]:= Print["Error: "//boldOrange,"replaceUnit: "//boldRed, "Invalid arguments. Correct format is:"//boldBlack,"replaceUnit["//boldBlack," Integer|SID "//boldBlack,","//boldBlack, " XMLElement[\"unitDefinition\",...]"//boldBlack," ]"//boldBlack];


 unitToSBML[{x__?ListQ}]:=Module[{r}, 
r =Flatten[ unitToSymbolicSBML/@{x}];
r = XMLElement["listOfUnitDefinitions",{},r]; 
r=ExportXMLString[r];
r=sunderscore[r];
Return[r];
];


unitToSBML[opt___?OptionQ]:= Module[{r},
r=unitToSymbolicSBML[opt];
r=ExportXMLString[r];
r=sunderscore[r];
Return[r];
];

unitToSBML[x_, opt___?OptionQ]:= unitToSBML[Global`id-> x, opt];


deleteUnit[opt___?OptionQ]:= Module[{n,c,p,sp},
n =( Global`id/.{opt}/.{id-> ""})//stringer;
If[id=="", 
Print["Error: deleteUnit"//boldOrange," No "//boldBlack,"id"/boldRed," was specified."]]; 
MB$Currentid=n;
removeID[n,"unit"]; 

c = Map[First,MB$Units]; 
(* Print["deleteUnit: c=",c]; *)
If[MemberQ[c,n],
If[\[Not]MB$Modify,
(* check to see if any species or parameters reference this unit *) 
sp = Position[MB$Species, "units"-> n];
If[Length[sp]>0,
sp = First/@sp;
sp=Map[Part[First/@MB$Species,#]&,sp];
Print["Warning: "//boldOrange, "The species "//boldBlack,list2CommaSeparatedString[sp]//boldRed, " refer to units "//boldBlack,n//boldRed ];
Return[False];
];
sp = Position[MB$Parameters,"units"-> n]; 
If[Length[sp]>0,
sp = First/@sp;
sp=Map[Part[First/@MB$Parameters,#]&,sp];
Print["Warning: "//boldOrange, "The parameters "//boldBlack,list2CommaSeparatedString[sp]//boldRed, " refer to units "//boldBlack,n//boldRed ];
Return[False];
];
]; 

p=Position[c,n];
MB$Units= Drop[MB$Units,First[p]]; 
Return[True];
];
Return[False];
];
deleteUnit[x_, opt___?OptionQ]:= deleteUnit[Global`id-> x,opt];
removeUnit[x___]:=Module[{flag},
flag = deleteUnit[x];
If[flag, 
If[MB$Echo,Print["Unit "//boldGreen,MB$Currentid//boldBlue," removed."//boldGreen]],
Print["Warning: "//boldOrange,"Requested unit "//boldBlack,MB$Currentid//boldRed," can not be removed."//boldBlack]];
];


Global`$DEBUG$ADDUNIT=False; 

addUnit[XMLElement[x___]]:= Module[{n, meta},
debugPrint[Global`$DEBUG$ADDUNIT,"addUnit[XMLElement]: ", XMLElement[x]];


n=getSBMLid[XMLElement[x]];

If[defaultUnit[n],
If[\[Not]removeDefaultUnit[n],
Print["Warning: Unable to redefine default unit"//boldOrange," Unit "//boldBlack,n//boldRed];
Return[{}]
];
,
If[unitExists[n], 
If[deleteUnit[Global`id-> n] ,
If[MB$Echo,
Print["Previous occurance of unit "//boldBlack,n//boldRed," removed."//boldBlack];
];
,
Print["Warning: "//boldOrange," Unit "//boldBlack,n//boldRed," can not be added."//boldBlack];
Return[{}];
];
]; 
]; 

addID[n,"unit",True];
meta = getSBMLfield["metaid", XMLElement[x]]; 
If[meta!= "", addMetaID[meta,contextify[n], "unit", True]]; 

MB$Units=Append[MB$Units,n->XMLElement[x]];
If[MB$Echo, Print["Unit "//boldGreen,n//boldBlue," added."//boldGreen]];
Return[n];
]; 

addUnit[opt___?OptionQ]:=Module[{r,n},
debugPrint[Global`$DEBUG$ADDUNIT,"addUnit[options]: ", {opt}];

(* MB$Echo = Global`echo/.{opt}/.{Global`echo-> True}; *)
r =unitToSymbolicSBML[opt]; 

n=addUnit[r];
Return[n];
];

addUnit[id_, opt___?OptionQ]:= addUnit[Global`id-> id, opt];



 modifyUnit[opt___?OptionQ]:= Module[{n,x,y,k,dbg=True, u,name, ann, newann,unitann, metaid},
n =( Global`id/.{opt}/.{Global`id-> ""})//stringer;
metaid = Global`metaid/.{opt}/.{Global`metaid->1}; 

MB$Currentid=n;
x=retrieveSBMLObject["unit",n];

If[ToString[Head[x]]=="XMLElement",
y=extractXMLOptions[x];
If[metaid== 1, metaid="metaid"/.y/.{"metaid"->""}]; 
y = stringrule/@(Join[{opt},y]//Flatten);
u =Cases[x, XMLElement["listOfUnits",___],Infinity]; 
If[Length[u]>0,
While[ListQ[u] \[And] Length[u]>0, u=First[u]]; 
u = Cases[u, XMLElement["unit",___], Infinity];
unitann = getAnnotations/@u;

u = expressionate/@(extractXMLOptions/@u);
u = MapThread[Append[#1,Global`annotation-> #2]&,{u,unitann}];
k = Map[Global`kind/.#&, u]; 
u = MapThread[Rule[#1, #2]&, {k,u}]; 

u = "unit"/.y/.{"unit"-> u}//expressionate; 

name ="name"/.y/.{"name"-> ""}; 

ann = getAnnotations[x];
newann = (Global`annotation/.{opt}/.{Global`annotation-> {}});
ann = Join[ann, newann]; 


y  = {Global`id-> n, Global`unit-> u,Global`annotation-> ann, Global`metaid->metaid}; 
If[name!= "", y = Append[y, Global`name-> name]]; 

]; 
 
MB$Modify=True;
n=Apply[addUnit,y];
MB$Modify=False;
,
n=addUnit[opt]; 
];
Return[n]; 
];
modifyUnit[id_, opt___?OptionQ]:= modifyUnit[Global`id-> id, opt];



getCompartmentType[n_?IntegerQ]:= Module[{m},
m=getNumberOfCompartmentTypes[];
If[n>m \[Or] n<1, Print["Error: getCompartmentType: "//boldOrange," compartmentType: "//boldBlack,n//boldRed," does not exist. There are "//boldBlack,m//boldRed," compartmentTypes."//boldBlack];Return[{}];];
Return[MB$CompartmentTypes[[n]]//Last];
]; 
getCompartmentTypeNumber[id_?SIDQ]:=Module[{m,n},
m = First/@MB$CompartmentTypes;
n=Position[m, stringer[id]];
If[Length[n]<1, Print["Error: getCompartmentTypeNumber: "//boldOrange,"compartmentType: "//boldBlack,id//boldRed," does not exist. Valid compartmentType are "//boldBlack, m//boldRed];Return[0];]; 
While[ListQ[n], n=First[n]];
Return[n];
];
getCompartmentType[id_?SIDQ]:=Module[{m,n},
m = First/@MB$CompartmentTypes;
n=Position[m, stringer[id]];
If[Length[m]>0, m =list2CommaSeparatedString[m], m="No compartmentTypes have been defined."]; 
If[Length[n]<1, Print["Error: "//boldRed, " getCompartmentType: "//boldBlack,"compartmentType: "//boldBlack,id//boldBlue," does not exist. Valid compartmentTypes are: "//boldBlack, m//boldBlue];Return[{}];]; 
While[ListQ[n], n=First[n]];
Return[MB$CompartmentTypes[[n]]//Last];
]; 
getCompartmentType[x_?ListQ]:= getCompartmentType/@Flatten[x];
getNumberOfCompartmentTypes[]:= Length[MB$CompartmentTypes];
getCompartmentTypes[]:= getCompartmentType[Range[getNumberOfCompartmentTypes[]]]; 

getCompartmentType[x___]:= Module[{},
Print["Error: getCompartmentType: "//boldOrange, "Correct format is: "//boldBlack,"getCompartmentType[id]"//boldRed, " where id is an integer or an SID, "//boldBlack,"getCompartmentType[Integer]"//boldRed, " or "//boldBlack,"getCompartmentType[{x1,x2,...}]"//boldRed," where x1,x2,... are integers or SIDs."//boldBlack];
Return[{}];
];




compartmentTypeToSBML[{x__?ListQ}]:=Module[{SBML}, 
SBML =Flatten[ compartmentTypeToSymbolicSBML/@{x}];
SBML = XMLElement["listOfCompartmentTypes",{},SBML]; 
SBML=ExportXMLString[SBML];
SBML = sunderscore[SBML];
Return[SBML];
];

compartmentTypeToSBML[opt___?OptionQ]:= Module[{r},
r =compartmentTypeToSymbolicSBML[opt]; 
r=ExportXMLString[r];
r = sunderscore[r];
Return[r];
];

compartmentTypeToSBML[x_, opt___?OptionQ]:= compartmentTypeToSBML[Global`id-> x, opt]; 


compartmentTypeToSBML[x___]:= Print[
boldOrange["Warning:"], 
boldBlack["The argument to compartmentTypeToSBML must be either a sequence of options or a list of option lists"]
]; 




deleteCompartmentType[opt___?OptionQ]:= Module[{n,c,p},
n =( Global`id/.{opt}/.{id-> ""})//stringer;
If[id=="", 
Print["Error: deleteCompartmentType"//boldRed," No "//boldBlack,"id"/boldRed," was specified."]]; 
removeID[n,"compartmentType"]; 
MB$Currentid=n;
c = Map[First,MB$CompartmentTypes]; 
If[MemberQ[c,n],
p=Position[c,n];
MB$CompartmentTypes= Drop[MB$CompartmentTypes,First[p]]; 
Return[True];
];
Return[False];
];
deleteCompartmentType[x_, opt___?OptionQ]:= deleteCompartmentType[Global`id-> x,opt];
removeCompartmentType[x___]:=Module[{flag},
flag = deleteCompartmentType[x];
If[flag, 
If[MB$Echo,Print["Compartment Type "//boldGreen,MB$Currentid//boldBlue," removed."//boldGreen]],
Print["Error: "//boldRed,"Requested compartmentType "//boldBlack,MB$Currentid//boldBlue," does not exist. No removal peformed."//boldBlack]];
];



addCompartmentType[XMLElement[x___]]:=Module[
{r,n, opts,sub, meta},
If[ToExpression[MB$LevelVersion]<2.15, Print["Error:"//boldRed," Cannot add a compartmentType in SBML Level "//boldBlack,MB$LevelVersion//boldBlack];Abort[]];
r =XMLElement[x];
n=getSBMLid[r];

opts={x}[[2]];
sub={x}[[3]];

(* check for previous occurance of this Compartment type *)

If[deleteCompartmentType[Global`id-> n],If[MB$Echo,Print["Previous occurance of compartmentType "//boldGreen,n//boldBlue," removed."//boldGreen]]
];

addID[n, "compartmentType",True];

meta = getSBMLfield["metaid", XMLElement[x]]; 
If[meta!= "", addMetaID[meta,contextify[n], "compartmentType", True]]; 


r=XMLElement["compartmentType",opts,sub];
MB$CompartmentTypes=Append[MB$CompartmentTypes,n->r];
If[MB$Echo, Print["CompartmentType "//boldGreen,n//boldBlue," added."//boldGreen]];

Return[n];
];


addCompartmentType[s_?ListQ, opt___?OptionQ]:= Map[addCompartmentType[#,opt]&,s];    

addCompartmentType[opt___?OptionQ]:=Module[{r,n, dbg=False},
checkOptions[addCompartmentType, opt, 
{Global`annotation,  Global`id, Global`metaid,  Global`name,Global`notes}];
If[dbg, Print["addCompartmentType[opt]:{opt}:", {opt}]]; 
r =compartmentTypeToSymbolicSBML@@{opt};
If[dbg, Print["addCompartmentType[opt]:r:",r]];
n=addCompartmentType[r];
If[dbg,Print["addCompartmentType[opt]:n:",n]];

Return[n];
];

addCompartmentType[id_, opt___?OptionQ]:= addCompartmentType[Global`id-> id, opt];


 modifyCompartmentType[opt___?OptionQ]:= Module[{n,x,y,ann, notes},
n =( Global`id/.{opt}/.{Global`id-> ""})//stringer;
MB$Currentid=n;

x=retrieveSBMLObject["compartmentType",n];

If[ToString[Head[x]]=="XMLElement",
y=globalize/@extractAndUpdateXMLOptions[x,opt];

ann = updateAnnotations[x, opt];
notes = updateNotes[x, opt]; 

y = Prepend[y, globalize["annotation"-> ann]]; 
y = Prepend[y, globalize["notes"-> notes]]; 

n=Apply[addCompartmentType,y];
,
n=addCompartmentType[opt]; 
];
Return[n]; 
];
modifyCompartmentType[id_, opt___?OptionQ]:= modifyCompartmentType[Global`id-> id, opt];



getCompartment[n_?IntegerQ]:= Module[{m},
m=Length[MB$Compartments];
If[n>m \[Or] n<1, Print["Error: getCompartment: "//boldOrange," Compartment: "//boldBlack,n//boldRed," does not exist. There are "//boldBlack,m//boldRed," compartments."//boldBlack];Return[{}];];
Return[MB$Compartments[[n]]//Last];
]; 
getCompartmentNumber[id_?SIDQ]:=Module[{m,n},
m = First/@MB$Compartments;
n=Position[m, stringer[id]];
If[Length[n]<1, Print["Error: getCompartmentNumber: "//boldOrange,"Compartment: "//boldBlack,id//boldRed," does not exist. Valid compartments are "//boldBlack, m//boldRed];Return[0];]; 
While[ListQ[n], n=First[n]];
Return[n];
]; 
getCompartment[id_?SIDQ]:=Module[{n},
n = getCompartmentNumber[id];
If[n>0, Return[MB$Compartments[[n]]//Last]];
Return[{}];
]; 
getCompartment[x_?ListQ]:= getCompartment/@Flatten[x];
getCompartment[x___]:= Module[{},
Print["Error: getCompartment: "//boldOrange, "Correct format is: "//boldBlack,"getCompartment[id]"//boldRed, " where id is an integer or an SID, "//boldBlack,"getCompartment[Integer]"//boldRed, " or "//boldBlack,"getCompartment[{x1,x2,...}]"//boldRed," where x1,x2,... are integers or SIDs."//boldBlack];
Return[{}];
];
getNumberOfCompartments[]:=Length[MB$Compartments];
getCompartments[]:= getCompartment[Range[getNumberOfCompartments[]]];




replaceCompartment[i_?IntegerQ, XMLElement["compartment",x___]]:= Module[{n,j},
n=Length[MB$Compartments];
If[n>0 \[And] i>0 \[And] i<=n, 

j=getSBMLfield["id",XMLElement["compartment",x]]; 
If[j=="", j=MB$Compartments[[i,1]]];


MB$Compartments=ReplacePart[MB$Compartments,j-> XMLElement["compartment",x],i];
If[MB$Echo, Print["Compartment ",i, " replaced."]];
Return[];
]; 
Print["Error: replaceCompartment: "//boldOrange," unable to replace compartment "//boldBlack,i//boldRed];
Return[];
]; 

replaceCompartment[id_?SIDQ, XMLElement["compartment",x___]]:= Module[{n},
n=getCompartmentNumber[id];
If[n>0, 
replaceCompartment[n, XMLElement["compartment",x]]; 
Return[];
]; 
Print["Error: replaceCompartment: "//boldOrange," unable to replace compartment "//boldBlack,id//boldRed];
Return[];
]; 

replaceCompartment[x___]:= Print["Error: "//boldOrange,"replaceCompartment: "//boldRed, "Invalid arguments. Correct format is:"//boldBlack,"replaceCompartment["//boldBlack," Integer|SID "//boldBlack,","//boldBlack, " XMLElement[\"compartment\",...]"//boldBlack," ]"//boldBlack];


compartmentExists[n_]:= MemberQ[First/@MB$Compartments,n];


 compartmentToSBML[{x__?ListQ}]:=Module[{r}, 
r =Flatten[ compartmentToSymbolicSBML/@{x}];
r = XMLElement["listOfCompartments",{},r]; 
r=ExportXMLString[r];
r=sunderscore[r];
Return[r];
];


compartmentToSBML[opt___?OptionQ]:= Module[{r},
r=compartmentToSymbolicSBML[opt]; 
r=ExportXMLString[r];
r=sunderscore[r];
Return[r];
];

compartmentToSBML[x_, opt___?OptionQ]:= compartmentToSBML[Global`id->x, opt];


deleteCompartment[opt___?OptionQ]:= Module[{n,c,p, sp, mod},
n =( Global`id/.{opt}/.{id-> ""})//stringer;

If[id=="", 
Print["Error: deleteCompartment"//boldOrange," No "//boldBlack,"id"/boldRed," was specified."]]; 
MB$Currentid=n;
removeID[n,"compartment"]; 

c = Map[First,MB$Compartments]; 
If[MemberQ[c,n],

If[\[Not]MB$Modify,
(* check to see if there are any species references to this compartment *) 
sp = Position[MB$Species, "compartment"-> n];
If[Length[sp]>0,
sp = First/@sp;
sp=Map[Part[First/@MB$Species,#]&,sp];
Print["Warning: "//boldOrange, "The species "//boldBlack,list2CommaSeparatedString[sp]//boldRed, " refers to compartment "//boldBlack,n//boldRed ];
Return[False];
];
(* check for other compartments referring to this *)
sp = Position[MB$Compartments, "outside"-> n];
If[Length[sp]>0,
sp = First/@sp;
sp=Map[Part[First/@MB$Compartments,#]&,sp];
Print["Warning: "//boldRed, "The compartment "//boldBlack,list2CommaSeparatedString[sp]//boldRed, " refers to compartment "//boldBlack,n//boldRed," in its outside field. This message usually occurs when compartments are not defined in the proper order. "//boldBlack];
Return[False];
];
]; 
(* delete the compartment *) 

p=Position[c,n];
MB$Compartments= Drop[MB$Compartments,First[p]]; 

forgetCompartment[n];

Return[True];
];
Return[False];
];
deleteCompartment[x_, opt___?OptionQ]:= deleteCompartment[Global`id-> x,opt];
removeCompartment[x___]:=Module[{flag},
flag = deleteCompartment[x];
If[flag, 
Print["Compartment "//boldGreen,MB$Currentid//boldBlue," removed."//boldGreen],
Print["Warning: "//boldOrange,"Requested compartment "//boldBlack,MB$Currentid//boldRed," can not be removed."//boldBlack]];
];



addCompartment[XMLElement[x___]]:= Module[{n,r,outside, comps, meta},
r = XMLElement[x];
n=getSBMLid[r];



If[compartmentExists[n],
If[deleteCompartment[Global`id-> n] ,If[MB$Echo,Print["Previous occurance of "//boldGreen,n//boldBlue," removed."//boldGreen]];
,
Print["Warning: "//boldRed," Compartment "//boldBlack,n//boldRed," cannot be added because it already exists. This message usually occurs when compartments are defined out of order in the SBML model and added automatically by SBMLRead during the prior (invalid) reference. "//boldBlack];
Return[{}];
]; 
]; 
addID[n, "compartment",True];
meta = getSBMLfield["metaid", XMLElement[x]]; 
If[meta!= "", addMetaID[meta,contextify[n], "compartment", True]]; 



MB$Compartments=Append[MB$Compartments,n->r];
pushCompartment[n];

outside = getSBMLfield["outside",r];
If[outside!= "",
comps = First/@MB$Compartments;
If[!MemberQ[comps,outside],
addCompartment[outside];
];
];
If[MB$Echo, Print["Compartment "//boldGreen,n//boldBlue," added."//boldGreen]];

Return[n];
]; 

addCompartment[opt___?OptionQ]:=Module[{r,n},
(* MB$Echo = Global`echo/.{opt}/.{Global`echo-> True}; *)

r =compartmentToSymbolicSBML[opt]; 
n=addCompartment[r];
Return[n];
];


addCompartment[id_, opt___?OptionQ]:= addCompartment[Global`id-> id, opt];



 modifyCompartment[opt___?OptionQ]:= Module[{n,x,y,ann,notes},
n =( Global`id/.{opt}/.{Global`id-> ""})//stringer;
MB$Currentid=n;
x=retrieveSBMLObject["compartment",n];
If[ToString[Head[x]]=="XMLElement",
y=globalize/@extractAndUpdateXMLOptions[x,opt];

ann = updateAnnotations[x, opt]; 
notes = updateNotes[x, opt];

y = Prepend[y, globalize["annotation"-> ann]]; 
y  =Prepend[y, globalize["notes"-> notes]]; 

MB$Modify=True;
n=Apply[addCompartment,y];
MB$Modify=False;
,
n=addCompartment[opt]; 
];
Return[n]; 
];
modifyCompartment[id_, opt___?OptionQ]:= modifyCompartment[Global`id-> id, opt];



getParameter[n_?IntegerQ]:= Module[{m},
m=Length[MB$Parameters];
If[n>m \[Or] n<1, Print["Error: getParameter: "//boldOrange," Parameter: "//boldBlack,n//boldRed," does not exist. There are "//boldBlack,m//boldRed," parameters"//boldBlack];Return[{}];];
Return[MB$Parameters[[n]]//Last];
]; 
getParameterNumber[id_?SIDQ]:=Module[{m,n, sid},
sid=stringer[id];
m=First/@MB$Parameters;
n=Position[m, sid];
If[Length[n]<1, Print["Error: getParameterNumber: "//boldOrange,
"Parameters: "//boldBlack,id//boldRed," does not exist. Valid parameters are "//boldBlack, m//boldRed];
Return[0];
]; 
While[ListQ[n], n=First[n]];
Return[n];
]; 
getParameter[id_?SIDQ]:=Module[{n,p},
n = getParameterNumber[id]; 
If[n>0, 
p=Last[MB$Parameters[[n]]]; 
Return[p]];
Return[{}]; 
]; 
getParameter[x_?ListQ]:= getParameter/@Flatten[x];
getParameter[x___]:= Module[{},
Print["Error: getParameter: "//boldOrange, "Correct format is: "//boldBlack,"getParameter[id]"//boldRed, " where id is an integer or an SID, "//boldBlack,"getParameter[Integer]"//boldRed, " or "//boldBlack,
"getParameter[{x1,x2,...}]"//boldRed," where x1,x2,... are integers or SIDs."//boldBlack];
Return[{}];
];
getNumberOfParameters[]:=Length[MB$Parameters];
getParameters[]:= getParameter[Range[getNumberOfParameters[]]];


replaceParameter[i_?IntegerQ, XMLElement["parameter",x___]]:= Module[{n,j},
n=Length[MB$Parameters];
If[n>0 \[And] i>0 \[And] i<=n, 

j=getSBMLfield["id",XMLElement["parameter",x]]; 
If[j=="", j=MB$Parameters[[i,1]]];

MB$Parameters=ReplacePart[MB$Parameters,j-> XMLElement["parameter",x],i];
If[MB$Echo, Print["Parameter ",i, " replaced."]];
Return[];
]; 
Print["Error: replaceParameter: "//boldOrange," unable to replace parameter "//boldBlack,i//boldRed];
Return[];
]; 

replaceParameter[id_?SIDQ, XMLElement["parameter",x___]]:= Module[{n},
n=getParameterNumber[id];
If[n>0, 
replaceParameter[n, XMLElement["parameter",x]]; 
Return[];
]; 
Print["Error: replaceParameter: "//boldOrange," unable to replace parameter "//boldBlack,id//boldRed];
Return[];
]; 

replaceParameter[x___]:= Print["Error: "//boldOrange,"replaceParameter: "//boldRed, "Invalid arguments. Correct format is:"//boldBlack,"replaceParameter["//boldBlack," Integer|SID "//boldBlack,","//boldBlack, " XMLElement[\"parameter\",...]"//boldBlack," ]"//boldBlack];


 parameterToSBML[{x__?ListQ}]:=Module[{r}, 
r =Flatten[ parameterToSymbolicSBML/@{x}];
r = XMLElement["listOfParameters",{},r]; 
r=ExportXMLString[r];
r=sunderscore[r];
Return[r];
];


parameterToSBML[opt___?OptionQ]:= Module[{r},
r=parameterToSymbolicSBML[opt]; 
r=ExportXMLString[r];
r=sunderscore[r];
Return[r];
];

parameterToSBML[x_, opt___?OptionQ]:= parameterToSBML[Global`id-> x, opt];



deleteParameter[opt___?OptionQ]:= Module[{n,c,p},
n =( Global`id/.{opt}/.{Global`id-> ""})//stringer;
If[id=="", 
Print["Error: deleteParameter"//boldOrange," No "//boldBlack,"id"/boldRed," was specified."]]; 
removeID[n,"parameter"];
MB$Currentid=n;
c = Map[First,MB$Parameters]; 
If[MemberQ[c,n],
p=Position[c,n];
MB$Parameters= Drop[MB$Parameters,First[p]]; 
Return[True];
];
Return[False];
];
deleteParameter[x_, opt___?OptionQ]:= deleteParameter[Global`id-> x,opt];
removeParameter[x___]:=Module[{flag},
flag = deleteParameter[x];
If[flag, 
If[MB$Echo,Print["Parameter "//boldGreen,MB$Currentid//boldBlue," removed."//boldGreen]],
Print["Warning: "//boldOrange,"Requested Parameter "//boldBlack,MB$Currentid//boldRed," can not be removed."//boldBlack]];
];


addParameter[XMLElement[x___]]:=Module[{r,n, units,dbg=False, val, meta},
r =XMLElement[x]; 
n=getSBMLid[r];

If[deleteParameter[Global`id-> n] ,If[MB$Echo,Print["Previous occurance of parameter "//boldGreen,n//boldBlue," removed."//boldGreen]]
];

addID[n,"parameter",True];
meta = getSBMLfield["metaid", XMLElement[x]]; 
If[meta!= "", addMetaID[meta,contextify[n], "parameter", True]]; 


MB$Parameters=Append[MB$Parameters,n->r];

(* check to make sure assigned units exits *) 
units = getSBMLfield["units",r];
If[units!= "", 
If[!unitExists[units], addUnit[units]]];

If[dbg, Print["addParameter: r=",r]];

val = getSBMLfield["value",r];
If[val!= "", val="="<>stringer[val]];
If[MB$Echo, Print["Parameter "//boldGreen,n//boldBlue,val//boldBlue," added."//boldGreen]];
Return[n];
];

addParameter[opt___?OptionQ]:=Module[{r,n, dbg=False},
If[dbg, Print["addParameter: {opt}: ", {opt}]]; 
r =parameterToSymbolicSBML[opt]; 
n=addParameter[r]; 
Return[n];
];

addParameter[id_, opt___?OptionQ]:= Module[{dbg=False}, 
If[dbg, Print["addParameter: id = ", id, " {opt}=", {opt}]]; 
Return[addParameter[Global`id-> id, opt]]
];


 modifyParameter[opt___?OptionQ]:= Module[{n,x,y,ann, notes, bug=False},
n =( Global`id/.{opt}/.{Global`id-> ""})//stringer;
MB$Currentid=n;
x=retrieveSBMLObject["parameter",n];
If[ToString[Head[x]]=="XMLElement",
If[bug, Print["x=", x]]; 

y=globalize/@extractAndUpdateXMLOptions[x,opt];
If[bug, Print["y(1)=", y]]; 

ann = updateAnnotations[x, opt];
notes = updateNotes[x,opt]; 

y = Prepend[y, globalize["annotation"-> ann]]; 
If[bug, Print["y(2)=", y]]; 
y = Prepend[y,globalize["notes"->notes]]; 
If[bug, Print["y(3)=", y]]; 


MB$Modify=True;
n=Apply[addParameter,y];
If[bug, Print["n=", n]]; 

MB$Modify=False;
,
n=addParameter[opt]; 
];
Return[n]; 
];
modifyParameter[id_, opt___?OptionQ]:= modifyParameter[Global`id-> id, opt];



getInitialAssignment[n_?IntegerQ]:= Module[{m},
m=Length[MB$InitialAssignments];
If[n>m \[Or] n<1, Print["Error: "//boldRed,"getInitialAssignment: "//boldBlack," initialAssignment: "//boldBlack,n//boldBlue," does not exist. There are "//boldBlack,m//boldBlue," initialAssignments"//boldBlack];Return[{}];];
Return[MB$InitialAssignments[[n]]//Last];
]; 
getInitialAssignmentNumber[id_?SIDQ]:=Module[{m,n, sid},
sid=stringer[id];
m=First/@MB$InitialAssignments;
n=Position[m, sid];
If[Length[n]<1, Print["Error: "//boldRed,"getInitialAssignmentNumber: "//boldBlack,
"initialAssignment for "//boldBlack,id//boldBlue," does not exist."//boldBlack];
Return[0];
]; 
While[ListQ[n], n=First[n]];
Return[n];
]; 
getInitialAssignment[id_?SIDQ]:=Module[{n,p},
n = getInitialAssignmentNumber[id]; 
If[n>0, 
p=Last[MB$InitialAssignments[[n]]]; 
Return[p]];
Return[{}]; 
]; 
getInitialAssignment[x_?ListQ]:= getInitialAssignment/@Flatten[x];
getInitialAssignment[x___]:= Module[{},
Print["Error: "//boldRed,"getInitialAssignment: "//boldBlack, "Correct format is: "//boldBlack,"getInitialAssignment[id]"//boldBlue, " where id is an integer or an SID, "//boldBlack,"getInitialAssignment[Integer]"//boldBlue, " or "//boldBlack,
"getInitialAssignment[{x1,x2,...}]"//boldBlue," where x1,x2,... are integers or SIDs."//boldBlack];
Return[{}];
];
getNumberOfInitialAssignments[]:=Length[MB$InitialAssignments];
getInitialAssignments[]:= getInitialAssignment[Range[getNumberOfInitialAssignments[]]];


 initialAssignmentToSBML[{x__?ListQ}]:=Module[{r}, 
r =Flatten[ initialAssignmentToSymbolicSBML/@{x}];
r = XMLElement["listOfInitialAssignments",{},r]; 
r=ExportXMLString[r];
r=sunderscore[r];
Return[r];
];


initialAssignmentToSBML[opt___?OptionQ]:= Module[{r},
r=initialAssignmentToSymbolicSBML[opt]; 
r=ExportXMLString[r];
r=sunderscore[r];
Return[r];
];

initialAssignmentToSBML[x_, opt___?OptionQ]:= initialAssignmentToSBML[Global`symbol-> x, opt];



deleteInitialAssignment[opt___?OptionQ]:= Module[{n,c,p, meta, dbg=False},
n =( Global`symbol/.{opt}/.{Global`symbol-> ""})//stringer;
If[n=="", 
Print["Error: "//boldRed, " deleteInitialAssignment"//boldBlack," No "//boldBlack,"symbol"//boldBlue," was specified."//boldBlack]];
MB$Currentid=n; 
c = Map[First,MB$InitialAssignments]; 
If[MemberQ[c,n],
p=Position[c,n];
MB$InitialAssignments= Drop[MB$InitialAssignments,First[p]]; 

(* remove metaids pointing to n *)
meta =functionate["initialAssignment", n]/.(Reverse/@$SBML$MetaIDAssociations);
If[dbg==True, 
Print["deleteInitialAssignment: meta, n: ", {meta, n}];
];
removeMetaID[meta, "initialAssignment"];
Return[True];


];
Return[False];
];
deleteInitialAssignment[x_, opt___?OptionQ]:= deleteInitialAssignment[Global`symbol-> x,opt];
removeInitialAssignment[x___]:=Module[{flag},
flag = deleteInitialAssignment[x];
If[flag, 
If[MB$Echo,Print["InitialAssignment for "//boldGreen,MB$Currentid//boldBlue," removed."//boldGreen]],
Print["Error: "//boldRed,"Requested initialAssignment for "//boldBlack,MB$Currentid//boldBlue," could not be removed."//boldBlack]];
];


addInitialAssignment[XMLElement[x___]]:=Module[
{r,n, meta},

If[ToExpression[MB$LevelVersion]<2.2, 
Print["Error: "//boldRed, "addInitialAssignment: initialAssignment is not permitted in SBML level.version "//boldBlack, MB$LevelVersion//boldBlue]
];

n=getSBMLfield["symbol", r];
r =XMLElement[x]; 

If[deleteInitialAssignment[Global`symbol-> n] ,If[MB$Echo,Print["Previous occurance of initialAssignment for "//boldGreen,n//boldBlue," removed."//boldGreen]]
];


 meta = getSBMLfield["metaid", r]; 
If[meta!= "", 
addMetaID[meta,"initialAssignment["<>n<>"]", "initialAssignment", True];
]; 


MB$InitialAssignments=Append[MB$InitialAssignments,n->r];

checkInitialAssignment[r, "addInitialAssignment"];

If[MB$Echo, Print["InitialAssignment for "//boldGreen,n//boldBlue," added."//boldGreen]];
Return[n];
];

addInitialAssignment[opt___?OptionQ]:=Module[{r,n},
r =initialAssignmentToSymbolicSBML[opt]; 
n=addInitialAssignment[r]; 
Return[n];
];

addInitialAssignment[id_, opt___?OptionQ]:= addInitialAssignment[Global`symbol-> id, opt];


replaceInitialAssignment[i_?IntegerQ, XMLElement["initialAssignment",x___]]:= Module[{n,j},
n=Length[MB$InitialAssignments];
If[n>0 \[And] i>0 \[And] i<=n, 

j=getSBMLfield["symbol",XMLElement["initialAssignment",x]]; 
If[j=="", j=MB$InitialAssignments[[i,1]]];

MB$InitialAssignments=ReplacePart[MB$InitialAssignments,j-> XMLElement["initialAssignment",x],i];
If[MB$Echo, Print["InitialAssignment ",i, " replaced."]];
Return[];
]; 
Print["Error: "//boldRed," replaceParameter: "//boldBlack," unable to replace initialAssignment "//boldBlack,i//boldBlue];
Return[];
]; 

replaceInitialAssignment[id_?SIDQ, XMLElement["initialAssignment",x___]]:= Module[{n},
n=getInitialAssignmentNumber[id];
If[n>0, 
replaceInitialAssignment[n, XMLElement["initialAssignment",x]]; 
Return[];
]; 
Print["Error: "//boldRed," replaceInitialAssignment: "//boldBlack," unable to replace initialAssignment for "//boldBlack,id//boldBlue];
Return[];
]; 

replaceInitialAssignment[x___]:= Print["Error: "//boldRed,"replaceInitialAssignment: "//boldBlack, "Invalid arguments. Correct format is:"//boldBlack,"replaceInitialAssignment["//boldBlack," Integer|SID,"//boldBlack, " XMLElement[\"initialAssignment\",...]"//boldBlack," ]"//boldBlack];


 modifyInitialAssignment[opt___?OptionQ]:= Module[{n,x,y,ann, notes, oldmath,xmlsub, dbg=False},
n =( Global`symbol/.{opt}/.{Global`symbol-> ""})//stringer;
MB$Currentid=n;
x=retrieveSBMLObject["initialAssignment",n];
If[ToString[Head[x]]=="XMLElement",
y=globalize/@extractAndUpdateXMLOptions[x,opt];

ann = updateAnnotations[x, opt];


notes=updateNotes[stringToNotes[x,opt]];

y = Prepend[y, globalize["annotation"-> ann]]; 
y = Prepend[y,globalize["notes"->notes]];

xmlsub=extractXMLSubElements[x];
If[dbg, Print["modifyInitialAssignment: xmlsub: ", xmlsub]]; 


oldmath = Cases[xmlsub, XMLElement["math",___]]; 
If[Length[oldmath]>1, Print["Error: "//boldRed,
"modifyInitialAssignment: previous value of initialAssignment for "//boldblack,
n//boldBlue, " has multiple math fields. Only the first will be retrieved. "//boldBlack
]];
If[Length[oldmath]<1, 
Print["Error: "//boldRed,
"modifyInitialAssignment: previous value of initialAssignment for "//boldblack,
n//boldBlue, " has no math field.  "//boldBlack
];
,
While[ListQ[oldmath] \[And] Length[oldmath]>0, oldmath=First[oldmath]];
If[dbg, Print["modifyInitialAssignment: oldmath: ", oldmath]]; 
oldmath = MathMLToInfix[XMLOut[oldmath]];
If[dbg, Print["modifyInitialAssignment: oldmath: ", oldmath]]; 
y = Append[y, Global`math-> oldmath]; 

];


If[dbg, Print["modifyInitialAssignment: y:", y]]; 

MB$Modify=True;
n=Apply[addInitialAssignment,y];
MB$Modify=False;
,
n=addInitialAssignment[opt]; 
];
Return[n]; 
];
modifyInitialAssignment[id_, opt___?OptionQ]:= modifyInitialAssignment[Global`symbol-> id, opt];



checkInitialAssignment[r_,calledby_, opt___?OptionQ]:=Module[{dbg=False,
symbolsReferenced,math,options,subXML, XML2Symbol,knownSymbols,
unknownSymbols,variable,ruleType,hf, csymbols, mycsymbol, mathexpression,symbol,
calledbySBMLRead},

calledbySBMLRead=(calledby=="calledbySBMLRead");

XML2Symbol["ci",{},{x_}]:= x;
XML2Symbol[x___]:= {};

options=extractXMLOptions[r];
subXML=extractXMLSubElements[r];

symbol= ("symbol"/.options)/.{"symbol"-> "??-symbol-not-specified-??"};

If[MemberQ[First/@$SBML$IDTable, symbol], 
Block[{p,s},
p=Position[$SBML$IDTable, symbol];
While[ListQ[p], p=First[p]];
s=$SBML$IDTable[[p,2]];
If[!MemberQ[{"compartment","parameter", "species"}, s], 

Print["Error: "//boldRed, "checkInitialAssignment: an initial assignment cannot be made to a "//boldBlack,s//boldBlue," only to a compartment, parameter, or species:\n"//boldBlack,
Sequence@@XMLHighlightForm[r, Purple,"symbol="<>quote[symbol]]
];

];
];
,
Print["Error: "//boldRed, "checkInitialAssignment: undefined or invalid symbol "//boldBlack,
symbol//boldBlue, " in "//boldBlack, "initialAssignment:\n"//boldBlue,
Sequence@@XMLHighlightForm[r,Purple, "symbol="<>quote[symbol]]
]
];



(* Prevent duplicate messaging - catch this in addInitialAssignment*)

If[!calledbySBMLRead,
If[MemberQ[MB$AssignmentRuleVariables, symbol], 
Print["Error: "//boldRed, " An "//boldBlack,
"initialAssignment "//boldBlue, 
"may not refer to a symbol for which an "//boldBlack, "assignmentRule"//boldBlue," has been previously defined. Symbol: "//boldBlack, symbol//boldBlue];
]; 
];

(* The following test will never pass when called by addInitialAssignment because of the deleteInitialAssignment *)

If[calledbySBMLRead,
If[MemberQ[First/@MB$InitialAssignments, symbol], 
Print["Error: "//boldRed, " Multiple initialAssignments may not be made to the same symbol. Symbol: "//boldBlack, symbol//boldBlue];
]; 
]; 

math=Cases[subXML, XMLElement["math",___],1];
If[Length[math]<1,
Return[];
,
If[Length[math]>1,
Print["Error: "//boldRed, "Multiple math objects in initialAssignment:\n"//boldBlack,
Sequence@@XMLHighlightForm[r,Purple,"math"]
];
];
While[ListQ[math],math=First[math]];
]; 

symbolsReferenced=Cases[math,XMLElement["ci",___],Infinity];
symbolsReferenced=symbolsReferenced/.{XMLElement-> XML2Symbol};
symbolsReferenced=Union[symbolsReferenced]; 

csymbols = Cases[math, XMLElement["csymbol",___],Infinity];
If[Length[csymbols]>0,
mycsymbol["csymbol",{___},x_]:= x;
mycsymbol[x___]:= XMLElement[x];
csymbols=Flatten[(csymbols/.{XMLElement-> mycsymbol})/.{XMLElement-> List}];
csymbols=Complement[csymbols,{"ci"}];
];




knownSymbols=Join[First/@$SBML$IDTable, csymbols];
unknownSymbols=Complement[symbolsReferenced,knownSymbols];

mathexpression=Cases[subXML, XMLElement["math",___],1];
mathexpression=First[mathexpression];
mathexpression=XMLOut[mathexpression];

hf[var_]:= XMLHighlightForm[#,Purple,"<ci>"<>stringer[var]<>"</ci>"]&@@ Cases[subXML, XMLElement["math",___],1];


Print["Error: "//boldRed,"addInitialAssignment: Unknown symbol "//boldBlack,#//boldBlue," is referenced in the initialAssignment "//boldBlack,
MathMLToInfix[mathexpression]//boldBlue,"\n",
Sequence@@hf[#]

]&/@unknownSymbols;

checkFunctionCalls[math,"initialAssignment", "(addInitialAssignment)"];

Return[];
];


 constraintToSBML[{x__?ListQ}]:=Module[{r}, 
r =Flatten[ constraintToSymbolicSBML/@{x}];
r = XMLElement["listOfConstraints",{},r]; 
r=ExportXMLString[r];
r=sunderscore[r];
Return[r];
];


constraintToSBML[opt___?OptionQ]:= Module[{r},
r=constraintToSymbolicSBML[opt]; 
r=ExportXMLString[r];
r=sunderscore[r];
Return[r];
];


getConstraint[n_?IntegerQ]:= Module[{m},
m=Length[MB$Constraints];
If[n>m \[Or] n<1, Print["Error: "//boldRed,"getConstraint: "//boldBlack," Constraint: "//boldBlack,n//boldBlue," does not exist. There are "//boldBlack,m//boldBlue," Constraints"//boldBlack];Return[{}];];
Return[MB$Constraints[[n]]];
]; 

getConstraint[x_?ListQ]:= getConstraint/@Flatten[x];
getConstraint[x___]:= Module[{},
Print["Error: "//boldRed,"getConstraint: "//boldBlack, "Correct format is: "//boldBlack,"getConstraint[Integer]"//boldBlue, " or "//boldBlack,
"getConstraint[{x1,x2,...}]"//boldBlue," where x1,x2,... are integers"//boldBlack];
Return[{}];
];
getNumberOfConstraints[]:=Length[MB$Constraints];
getConstraints[]:= getConstraint[Range[getNumberOfConstraints[]]];


deleteConstraint[n_?IntegerQ]:= Module[{x,meta},
If[n> Length[MB$Constraints],
Print["Error: "//boldRed, "deleteConstraint: "//boldBlack, " requested constraint number: "//boldBlack, n//boldBlue," exceeds number of constraints: "//boldBlack, Length[MB$Constraints]//boldBlue];
Return[False];
];
If[n<= 0, 
Print["Error: "//boldRed, "deleteConstraint: "//boldBlack, "argument must be a postive integer. Requested value: "//boldBlack, n//boldBlue];
Return[False];
]; 
x=getConstraint[n];
MB$Constraints= Drop[MB$Constraints,{n}]; 

meta = getSBMLfield["metaid",x]; 
removeMetaID[meta, "constraint"]; 

Return[True];
];
removeConstraint[x___]:=Module[{flag},
flag = deleteConstraint[x];
If[flag, 
If[MB$Echo,Print["Constraint "//boldGreen,x//boldBlue," removed."//boldGreen]],
Print["Error: "//boldRed,"Requested Constraint "//boldBlack,x//boldBlue," could not be removed."//boldBlack]];
];


addConstraint[XMLElement[x___]]:=Module[
{r, meta,n, math},

If[ToExpression[MB$LevelVersion]<2.2, 
Print["Error: "//boldRed, "addConstraint: Constraint is not permitted in SBML level.version "//boldBlack, MB$LevelVersion//boldBlue]
];

r =XMLElement[x]; 
checkConstraintExpression[r];
MB$Constraints=Append[MB$Constraints,r];

math = Cases[r, XMLElement["math",___], Infinity]; 
math=Flatten[math];
If[Length[math]<1, Print["Error: "//boldRed, "addConstraint: no Math"//boldBlack, 
XMLHighlightForm[r,Purple,"constraint"]
]
]; 

math=MathMLToInfix[XMLOut[math[[1]]]]; 
math=stringer[math];

n="constraint["<>math<>"]";
meta = getSBMLfield["metaid", r]; 
If[meta!= "", addMetaID[meta,n, "constraint", True]]; 


If[MB$Echo, Print["Constraint "//boldGreen, math//boldBlue, " added."//boldGreen]];
Return[];
];

addConstraint[opt___?OptionQ]:=Module[{r,n},
r =constraintToSymbolicSBML[opt]; 
n=addConstraint[r]; 
Return[n];
];

addConstraint[x___]:= Print["Error: "//boldRed, "The argument to addConstraint should be either an option list or an XMLElement[...] object"//boldBlack];


replaceConstraint[i_?IntegerQ, XMLElement["constraint",x___]]:= Module[{n,r},
n=Length[MB$Constraints];
r=XMLElement["constraint",x];
If[n>0 \[And] i>0 \[And] i<=n, 
MB$Constraints=ReplacePart[MB$Constraints, r,i];
If[MB$Echo, Print["Constraint ",i, " replaced."]];
Return[];
]; 
Print["Error: "//boldRed," replaceConstraint: "//boldBlack," unable to replace Constraint "//boldBlack,i//boldBlue];
Return[];
]; 

replaceConstraint[x___]:= Print["Error: "//boldRed,"replaceConstraint: "//boldBlack, "Invalid arguments. "//boldBlack, {x}//boldBlue, " \nCorrect format is:"//boldBlack,"replaceConstraint["//boldBlack," Integer,"//boldBlack, " XMLElement[\"constraint\",...]"//boldBlack," ]"//boldBlack];


 modifyConstraint[i_?IntegerQ, opt___?OptionQ]:= Module[{n,x,y,ann, notes, dbg=False, oldmat},

x={getConstraint[i]}//Flatten;
If[dbg,Print["modifyConstraint: x:", x]];

If[Length[x]>0, 
x=First[x];
y=globalize/@extractAndUpdateXMLOptions[x,opt];


ann = updateAnnotations[x, opt];
notes = updateNotes[x,opt]; 

y = Prepend[y, globalize["annotation"-> ann]]; 
y = Prepend[y,globalize["notes"->notes]]; 
If[dbg, Print["modifyConstraint: y:",y]];


xmlsub=extractXMLSubElements[x];
If[dbg, Print["modifyInitialAssignment: xmlsub: ", xmlsub]]; 


oldmath = Cases[xmlsub, XMLElement["math",___]]; 
If[Length[oldmath]>1, Print["Error: "//boldRed,
"modifyConstraint: previous value of constraint for "//boldblack,
n//boldBlue, " has multiple math fields. Only the first will be retrieved. "//boldBlack
]];
If[Length[oldmath]<1, 
Print["Error: "//boldRed,
"modifyConstraint: previous value of constraint for "//boldblack,
n//boldBlue, " has no math field.  "//boldBlack
];
,
While[ListQ[oldmath] \[And] Length[oldmath]>0, oldmath=First[oldmath]];
If[dbg, Print["modifyConstraint: oldmath: ", oldmath]]; 
oldmath = MathMLToInfix[XMLOut[oldmath]];
If[dbg, Print["modifyConstraint: oldmath: ", oldmath]]; 
y = Append[y, Global`math-> oldmath]; 
]; 

deleteConstraint[i];
addConstraint@@y;
,
addConstraint[opt]; 
];
Return[]; 
];



checkConstraintExpression[r_, opt___?OptionQ]:=Module[{dbg=False,
symbolsReferenced,math,options,subXML, XML2Symbol,knownSymbols,
unknownSymbols,variable,ruleType,hf, csymbols, mycsymbol, mathexpression},

XML2Symbol["ci",{},{x_}]:= x;
XML2Symbol[x___]:= {};

options=extractXMLOptions[r];
subXML=extractXMLSubElements[r];


math=Cases[subXML, XMLElement["math",___],1];
If[Length[math]<1,
Return[];
,
If[Length[math]>1,
Print["Error: "//boldRed, "Multiple math objects in constraint:\n"//boldBlack,
Sequence@@XMLHighlightForm[r,Purple,"math"]
];
];
While[ListQ[math],math=First[math]];
]; 

symbolsReferenced=Cases[math,XMLElement["ci",___],Infinity];
symbolsReferenced=symbolsReferenced/.{XMLElement-> XML2Symbol};
symbolsReferenced=Union[symbolsReferenced]; 

csymbols = Cases[math, XMLElement["csymbol",___],Infinity];
If[Length[csymbols]>0,
mycsymbol["csymbol",{___},x_]:= x;
mycsymbol[x___]:= XMLElement[x];
csymbols=Flatten[(csymbols/.{XMLElement-> mycsymbol})/.{XMLElement-> List}];
csymbols=Complement[csymbols,{"ci"}];
];


knownSymbols=Join[First/@$SBML$IDTable, csymbols];
unknownSymbols=Complement[symbolsReferenced,knownSymbols];

mathexpression=Cases[subXML, XMLElement["math",___],1];
mathexpression=First[mathexpression];
mathexpression=XMLOut[mathexpression];

hf[var_]:= XMLHighlightForm[#,Purple,"<ci>"<>stringer[var]<>"</ci>"]&@@ Cases[subXML, XMLElement["math",___],1];


Print["Error: "//boldRed,"addConstraint: Unknown symbol "//boldBlack,#//boldBlue," is referenced in the constraint "//boldBlack,
MathMLToInfix[mathexpression]//boldBlue,"\n",
Sequence@@hf[#]

]&/@unknownSymbols;

checkFunctionCalls[math,"constraint", "(addConstraint)"];

Return[];
];


getRule[n_?IntegerQ]:= Module[{m},
m=getNumberOfRules[];
If[n>m \[Or] n<1, 
Print["Error: "//boldRed,"getRule:  Rule: "//boldBlack,n//boldBlue," does not exist. There are "//boldBlack,m//boldBlue," rule definitions."//boldBlack];Return[{}];];
Return[MB$Rules[[n]]//Last];
]; 
getRuleNumber[id_?SIDQ]:=Module[{m,n},
m=Map[First,MB$Rules];
n=Position[m, stringer[id]];
If[Length[n]<1,Return[0]]; 
While[ListQ[n], n=First[n]];
Return[n];
]; 

getRule[id_?SIDQ]:=Module[{m,n},
n=getRuleNumber[id];
If[n>0, 
m=Last[MB$Rules[[n]]];
Return[m];
];
Return[{}];
]; 

getRule[x_?ListQ]:= getRule/@Flatten[x];
getRule[x___]:= Module[{},
Print["Error: "//boldRed,"getRule: Correct format is getRule[metaid],  getRule[Integer],  or getRule[{x1,x2,...}], where x1,x2,... are integers."//boldBlack];
Return[{}];
];
getRules[]:= getRule[Range[Length[MB$Rules]]];
getNumberOfRules[]:= Length[MB$Rules];


ruleStringQ["assignmentRule"]=True;
ruleStringQ["rateRule"]=True;
ruleStringQ["algebraicRule"]=True;
ruleStringQ["constraintRule"]=True;
ruleStringQ["connectionRule"]=True;
ruleStringQ[x___]:= False;

replaceRule[i_?IntegerQ, XMLElement[u_?ruleStringQ,x___]]:= Module[{n,j},
n=Length[MB$Rules];
If[n>0 \[And] i>0 \[And] i<=n, 

j=getSBMLfield["metaid",XMLElement[u,x]]; 
If[j=="", j=MB$Rules[[i,1]]];

MB$Rules=ReplacePart[MB$Rules,j-> XMLElement[u,x],i];
If[MB$Echo, Print["rule ",i, " replaced."]];
Return[];
]; 
Print["Error: replaceRule: "//boldOrange," unable to replace rule "//boldBlack,i//boldRed];
Return[];
]; 

replaceRule[id_?SIDQ, XMLElement[r_?ruleStringQ,x___]]:= Module[{n},
n=getRuleNumber[id];
If[n>0, 
replaceRule[n, XMLElement[r,x]]; 
Return[];
]; 
Print["Error: replaceRule: "//boldOrange," unable to replace rule "//boldBlack,id//boldRed];
Return[];
]; 

replaceRule[x___]:= Print["Error: "//boldOrange,"replaceRule: "//boldRed, "Invalid arguments. Correct format is:"//boldBlack,"replaceRule["//boldBlack," Integer|SID "//boldBlack,","//boldBlack, " XMLElement[r,...]"//boldBlack," ] where r=\"assignmentRule\",\"rateRule\",\"algebraicRule\",\"constraintRule\"(experimental:L2V2draft1), \"connectionRule\"(experimental:L3,arrays),\"initialAssignmentRule\"(experimental:L3,arrays)"//boldBlack];


 ruleToSBML[{x__?ListQ}]:=Module[{r}, 
r =Flatten[ ruleToSymbolicSBML/@{x}];
r = XMLElement["listOfRules",{},r]; 
r=ExportXMLString[r];
r =sunderscore[r];
Return[r];
];


ruleToSBML[opt___?OptionQ]:= Module[{r},
r=ruleToSymbolicSBML[opt]; 
r=ExportXMLString[r];
r =sunderscore[r];
Return[r];
];



 deleteRule[opt___?OptionQ]:= Module[{n,c,p, number,opts, dbg=False},
opts = Flatten[{opt}]; 
If[dbg, Print["deleteRule: opts(1):"//boldRed, opts//boldBlue]]; 

opts=checkOptions[deleteRule, opts, { "metaid"}];
If[dbg, Print["deleteRule: opts(2):"//boldRed, opts//boldBlue]]; 

n =( Global`metaid/.{opt}/.{metaid-> ""})//stringer;
If[n=="",  Return[False];]; 

number = getRuleNumber[n];
If[number>0, deleteRule[number] ];

Return[True];

]; 


deleteRule[x_?!IntegerQ[#]&, opt__?OptionQ]:= Block[{dbg=False},
If[dbg, Print["deleteRule[x, opt]: x:"//boldRed, x//boldBlue, " {opt}:"//boldRed, {opt}//boldBlue]]; 
 
deleteRule[Global`metaid-> x,opt]
];

deleteRule[n_?IntegerQ]:= Module[{p, meta, dbg=False},

If[dbg, Print["deleteRule:n:"//boldRed, n//boldBlue]]; 

If[n>0 \[And] n<= getNumberOfRules[], 


p=getRule[n];
meta=getSBMLfield["metaid",p];
removeMetaID[meta,"rule"];  


MB$Rules = Drop[MB$Rules, {n}]; 
Return[True];
];
Return[False];
]; 

removeRule[x___]:=Module[{flag},
flag = deleteRule[x];
If[flag, 
If[MB$Echo,Print["Rule "//boldGreen,MB$Currentid//boldBlue," removed."//boldGreen]],
Print["Warning: "//boldOrange,"Requested Rule "//boldBlack,MB$Currentid//boldRed," cannot be removed."//boldBlack]];
];



addRule[XMLElement[x___]]:=Module[{r,n, type, var,sp,par, a, b, c, chk,ichk,ertype, ermetaid,rhsrule,lhsrule,rhsvars,ruleContent, ruleType, functions,indices, debug=False, connection,ijk,comp, definedVariables, ruleexpr, csymbols, dbg=False},

If[dbg, Print["*************\naddRule: XMLElement "//boldRed]]; 
r = XMLElement[x]; 
checkRuleExpression[r]; 

If[dbg, Print["addRule: XMLElement: r: "//boldRed,r//boldBlue]]; 

ruleType[XMLElement[u_,___]]:= u; 

type=First[{x}]; 
type=ruleType[XMLElement[x]];
If[debug, Print["addRule: rule type: "//boldRed, type]//boldBlue]; 

If[type=="annotation",
ruleContent=Cases[XMLElement[x], XMLElement[___],2];
type = ruleType/@ruleContent;
If[Length[type]<1, 
Print["Error: Unable to decode rule within annotation: "//boldOrange, XMLElement[x]//boldBlue];
Abort[];
];
If[Length[type]>1,Print["Warning: Too many XMLElements within the annotation - only the first one is used: "//boldOrange, XMLElement[x]//boldBlue]
];
type=First[type];
If[debug, Print["addrule: rule type: "//boldRed, type//boldBlue]]; 

];

sp = First/@MB$Species;
par = First/@MB$Parameters;
comp=First/@MB$Compartments; (* added 2.5.2 *) 
definedVariables = Union[sp, par, comp];

connection= getSBMLfield["connection",r]; 




If[debug, Print["addRule:{type,sp,par,comp, definedVariables}:"//boldRed, {type,sp,par,comp,definedVariables}//boldBlue]];


n = getSBMLfield["metaid",r]; 
If[n=="",

n="rule"<>ToString[MB$rulecounter++];
{a, b, c} = {x}; 
b = Append[b, "metaid"-> n]; 
r = XMLElement[a, b, c]; 
n = getSBMLfield["metaid",r];
];
If[debug, Print["addRule:n:"//boldRed, n//boldBlue]];



var =getSBMLfield["variable",r]; 
If[debug, Print["addRule:var:"//boldRed, var//boldBlue]];

If[type=="assignmentRule", 
Block[{iavars},
iavars = First/@MB$InitialAssignments;
If [MemberQ[iavars, var], Print["Error: "//boldRed, "addRule: cannot have an "//boldBlack,"assignmentRule"//boldBlue, " and an "//boldBlack, "initialAssignment"//boldBlue, " for the same variable: "//boldBlack, var//boldBlue]];
];

];


If[var!= "" \[And] (type=="assignmentRule" \[Or] type== "rateRule"),
(* make sure that no rule has been previously defined for this variable *)
If[debug, Print["addRule:type==assignment or type==rateRule"//boldRed]];

chk = MathSBML`Private`getXMLElement/@(Last/@MB$Rules); 
(*allow earlier initialAssignmentRule*)
chk = Select[chk, First[#]!= "initialAssignmentRule"&]; 

ichk=Position[chk,var];
If[Length[ichk]>0,
(* ichk has form {{i,j,k,..},{i,j,k,..},...}; if this error correction is implemented correctly it will actually only be {{i,j,k,...}} for a single prior occurance at most: so convert to first index of first occurrence  *) 
ichk = First/@ichk;
ichk = First[ichk];

(* create a rule ruletype->{options} for the earlier reference *) 

chk = chk[[ichk]];
(* ertype, ermetaid*)
ertype = chk[[1]]; 
ermetaid = "metaid"/.Last[chk];

If[!(ifArrays[]\[And]stringer[connection]!= ""),
Print["Error: "//boldRed,"addRule: "//boldBlack,
type//boldBlue," for variable "//boldBlack, var//boldBlue, " is not allowed because a "//boldBlack,
ertype//boldBlue,
" has already been defined for this variable: \"No more than one assignment or rate rule can be defined for a given identifier.\""//boldBlack
];
Return[{}];
];
];


];
If[var!= "" \[And] type=="assignmentRule",

(* make sure that the variable is not referenced in an earlier rule *)
If[debug, Print["addRule:type==assignmentRule"//boldRed]];

chk=Cases[MB$Rules, XMLElement["ci",{},{var}], Infinity]; 
If[Length[chk]>0,
Print["Error: "//boldRed, " A rule with "//boldBlack, var//boldBlue," on its right hand side has been previously defined and therefore this rule can not be added. This is because a rule is not allowed to refer to a variable for which there is a subsequent assignment rule, and this would be the subsequent assignment rule."//boldBlack];
Return[{}]; 
]; 

(* make sure the rule does not self-refer *)
chk=Cases[XMLElement[x], XMLElement["ci",{},{var}], Infinity]; 
If[Length[chk]>0,
Print["Error: "//boldRed,type//boldBlue,  " refers to "//boldBlack, var//boldBlue," on both sides of the equation.\n"//boldBlack,

Sequence@@XMLHighlightForm[XMLElement[x],Purple,stringer[var]]

];
Return[{}]; 
]; 


]; 

(* if connection field check for previous connection def *)

If[stringer[connection]!= "", 
If[!ifArrays[],
Print["Error: "//boldOrange, " connection filed "//boldBlack, stringer[connection]//boldRed," not allowed because Arrays are off"];
,
chk = MathSBML`Private`getXMLElement/@(Last/@MB$Rules);
chk = Select[chk,( First[#]=="connectionRule")&];
chk = Last/@chk; 
chk = (("metaid"/.#)&)/@chk;
If[!MemberQ[chk,stringer[connection]], 
Print["Warning: "//boldOrange,
"Specified connectionRule: "//boldBlack,
connection//boldRed," is undefined."//boldBlack]
];
];
]; 

(* make sure the variable is previously defined either as a species or a parameter *) 
(* changed to "definedVariables" 2.5.2 *)
(* error message added 2.5.25 *)

If[var!= "" \[And] (type=="assignmentRule" \[Or] type== "rateRule"),
If[!MemberQ[definedVariables,var], 
Print["Error: "//boldRed, " addRule: "//boldBlack, type//boldBlue, " variable=\""<>var<>"\""//boldBlue, " not previously defined. Offending SBML:\n" //boldBlack,
Sequence@@XMLHighlightForm[r,Purple,"variable=\""<>stringer[var]<>"\""]
]; 
addParameter[var,Global`constant-> "false"];

];
]; 


If[debug, Print["addRule:thyme to save the Rule"//boldRed]];

Switch[type,
"assignmentRule", AppendTo[MB$AssignmentRuleVariables, stringer[var]],
"rateRule", AppendTo[MB$RateRuleVariables, stringer[var]]
]; 


(* SAVE THE RULE *) 


Block[{num, flag, debg=False},
num=getRuleNumber[n]; 
If[debg, Print["addRule: num:"//boldRed,num//boldBlue]]; 

If[flag=deleteRule[num] , If[MB$Echo,Print["Previous occurance of rule "//boldGreen,num//boldBlue," removed."//boldGreen]]
];

If[debg, Print["addRule: flag:"//boldRed, flag//boldBlue]]; 
]; 

MB$Rules=Append[MB$Rules,n->r];

(* add check for indices 2.3.26 *)
indices =Cases[r, XMLElement["index",___],Infinity]//Flatten;
If[debug, Print["addRule: indices (1): "//boldRed, indices//boldBlue]]; 
indices =getSBMLfield["id",#]&/@indices; 
If[debug, Print["addRule: indices: (2)"//boldRed, indices//boldBlue]]; 


(* Check symbols on Right hand side *) 
(* extract the xml for the rule *)
rhsrule=r;
(* get the sub-XML elements *)
If[debug, Print["addRule:rhsrule(-2):"//boldRed, rhsrule//boldBlue]];rhsrule=extractXMLSubElements[rhsrule];
(* extract the mathml - there may also be annotations, notes here *)
If[debug, Print["addRule:rhsrule(-1):"//boldRed, rhsrule//boldBlue]];rhsrule=Cases[rhsrule, XMLElement["math",___],Infinity];
If[debug, Print["addRule:rhsrule(0):"//boldRed, rhsrule//boldBlue]];While[ListQ[rhsrule] \[And] Length[rhsrule]>0, rhsrule=First[rhsrule]]; 

If[rhsrule=={}, rhsrule=Xpression2SymbolicMathML[{}]];

If[debug, Print["addRule:rhsrule(1):"//boldRed, rhsrule//boldBlue]];
csymbols = Cases[rhsrule, XMLElement["csymbol",___], Infinity]; 
Block[{XML2C}, 
XML2C["csymbol", {u__}, {y_}]:= y; 
XML2C[u___]:= {}; 
csymbols = Flatten[csymbols/.{XMLElement-> XML2C}]; 
]; 

If[debug, Print["addRule: csymbols in rule: ", csymbols]]; 
If[debug, Print["addRule:rhsrule(1.5):"//boldRed, rhsrule//boldBlue]];


rhsrule =InputForm[ SymbolicSBMLMathMLToExpression[rhsrule]];
If[debug, Print["addRule:rhsrule(2):"//boldRed, rhsrule//boldBlue]];

rhsvars=getSymbols[rhsrule];
If[debug, Print["addRule:missing vars(rhsvars)(1):"//boldRed, rhsvars//boldBlue]];

rhsvars=ToString/@InputForm/@rhsvars;
functions = stringer/@(First/@MB$Functions);
(* determine and add the undefined variables as parameters; add functions 5-19-04 *)
rhsvars = Complement[rhsvars,definedVariables, (* sp,par,*) indices, functions, $SubsetMathML, $ArrayMathML, csymbols];




If[debug, Print["addRule:missing vars(rhsvars)(2):"//boldRed, rhsvars//boldBlue]];
addParameter[#,Global`constant-> "false"]&/@rhsvars;
 

(* get info for "pretty" echo message *)

rhsrule =ToString[rhsrule];
lhsrule=Switch[type,
"assignmentRule",stringer[var]<>"="<>rhsrule,
"rateRule",stringer[var]<>"'[t]"<>"="<>rhsrule,
"algebraicRule","0"<>"="<>rhsrule,

"initialAssignmentRule",
ijk = Cases[r,XMLElement["index",___],Infinity];
ijk =getSBMLfield["id",#]&/@ijk; 
ijk = list2CommaSeparatedString[ijk];
If[StringLength[ijk]>0, ijk = "["<>ijk<>"]",ijk=""]; 
stringer[var]<>ijk<>"="<>rhsrule,

"constraintRule",rhsrule,
"connectionRule", rhsrule,
_, 
Print[">>> Program Error (addRule): notify developer: type= "//boldRed,type//boldBlue] ;
"ERROR"
];
If[MB$Echo,
 Print[type//boldGreen," ",n//boldBlue," added: "//boldGreen, lhsrule//boldBlue];
]; 

If[n!= "", 
ruleexpr=stringer[type]<>"["<>lhsrule<>"]";
addMetaID[n,ruleexpr, "rule", True];
]; 



If[(type== "rateRule" \[Or] type== "assignmentRule") \[And] MemberQ[MB$ReactionVariables, stringer[var]], 
If[!MemberQ[MB$BoundaryConditionSpecies, var], 
Print["Error: "//boldRed, "addRule: "//boldBlack, type//boldBlue, " for "//boldBlack, var//boldBlue," - the variable has been previously referenced in a reaction, even though the species is not a boundaryCondition;\n"//boldBlack, 
Sequence@@XMLHighlightForm[r, Purple,"variable="<>quote[var]]
];
]; 
]; 
Return[n];
];




addRule[opt___?OptionQ]:=Module[{r,n,c,p,echo, type, var,sp,par, metaid, dbg=False},
(* MB$Echo = Global`echo/.{opt}/.{Global`echo-> True}; *) 

If[dbg, Print["addRule:{opt}:"//boldRed, {opt}//boldBlue]]; 

metaid = stringer[Global`id/.{opt}/.{Global`id-> ""}]; 
If[metaid=="",
metaid = stringer[Global`metaid/.{opt}/.{Global`metaid-> ""}]; 
]; 
If[metaid=="",
n="rule"<>ToString[MB$rulecounter++];,
n=metaid;
];
r =ruleToSymbolicSBML[Global`id-> n, opt]; 
n = addRule[r];
Return[n];
];

addRule[id_, opt___?OptionQ]:= addRule[Global`id-> id, opt];


 modifyRule[i_?IntegerQ, opt___?OptionQ]:= Module[{r,dbg=False, n,x,y,ruletype,infix, getFirst, type,math,p,ann, notes},

ruletype[XMLElement[a_,___]]:= a;
ruletype[a___]:= "ERROR";
infix[XMLElement["math",a___]]:= SymbolicSBMLMathMLToExpression[XMLElement["math",a]];
infix[a___]:= 1; 
getFirst[a_]:= Module[{b}, 
b=a; 
While [ListQ[b] \[And] Length[b]>0, b = First[b]];
Return[b]; 
]; 

r= getRule[i]; 
If[r=={}, Return[$Failed]]; 
n=getSBMLfield["metaid", r]; 

If[dbg, 
Print["modifyRule: r: ", r];
Print["modifyRule: n: ", n];
]; 

MB$Currentid=n;


type = ruletype[r]; 
y=expressionate[globalize/@extractAndUpdateXMLOptions[r,opt]];
y = Prepend[y,Global`type-> type]; 

If[dbg, Print["modifyRule: y: ", y]]; 

math = Cases[r, XMLElement["math",___],Infinity]//getFirst//infix; 
y = Append[y, Global`math-> math]; 
If[dbg, Print["modifyRule: y: ", y]]; 



ann = updateAnnotations[r, opt];
notes = updateNotes[r, opt]; 

y = Prepend[y, globalize["annotation"-> ann]]; 
y = Prepend[y, globalize["notes"-> notes]]; 

If[deleteRule[i] \[And] MB$Echo,
Print["Previous occurance of rule "//boldGreen, i//boldBlue, " removed."//boldGreen]
]; 


addRule@@y;

If[MB$Echo, Print["Rule "//boldGreen,i//boldBlue," modified."//boldGreen]];



Return[n]; 
];

(* modifyRule[id_, opt___?OptionQ]:= modifyRule[Global`id-> id, opt]; *)
modifyRule[x___]:=Print["Error: "//boldRed, "modifyRule: as of version 2.6.0, the correct format is: "//boldBlack, "modifyRule[integer, options]"//boldBlue, "\nTo find the integer corresponding to a particular metaid value use: "//boldBlack, "getRuleNumber[metaid]"//boldBlue];


checkRuleExpression[r_, opt___?OptionQ]:=Module[{dbg=False,
symbolsReferenced,math,ruleOptions,subXML, XML2Symbol,knownSymbols,
unknownSymbols,variable,ruleType,hf, csymbols, mycsymbol},

XML2Symbol["ci",{},{x_}]:= x;
XML2Symbol[x___]:= {};

ruleType[XMLElement[type_,x___]]:= type;
ruleType[x___]:="??--Unknown rule type--??";

debugPrint[dbg, "checkRuleExpression: r",r];
ruleOptions=extractXMLOptions[r];
subXML=extractXMLSubElements[r];
debugPrint[dbg, "checkRuleExpression: ruleOptions",ruleOptions];
debugPrint[dbg, "checkRuleExpression: subXML",subXML];

variable="variable"/.ruleOptions/.{"variable"-> "??--UNKNOWN Variable--??"};

math=Cases[subXML, XMLElement["math",___],1];
If[Length[math]<1,
debugPrint[dbg,"checkRuleExpression ", "no Math"];
Return[];
,
While[ListQ[math],math=First[math]];
]; 
debugPrint[dbg, "checkRuleExpression: math", math];

symbolsReferenced=Cases[math,XMLElement["ci",___],Infinity];
symbolsReferenced=symbolsReferenced/.{XMLElement-> XML2Symbol};
symbolsReferenced=Union[symbolsReferenced]; 
debugPrint[dbg, "checkRuleExpression: symbolsReferenced", symbolsReferenced];

csymbols = Cases[math, XMLElement["csymbol",___],Infinity];
debugPrint[dbg, "checkRuleExpression: csymbols", csymbols];
If[Length[csymbols]>0,
mycsymbol["csymbol",{___},x_]:= x;
mycsymbol[x___]:= XMLElement[x];
csymbols=Flatten[(csymbols/.{XMLElement-> mycsymbol})/.{XMLElement-> List}];
csymbols=Complement[csymbols,{"ci"}];
debugPrint[dbg, "checkRuleExpression: csymbols", csymbols];
];


knownSymbols=Join[First/@$SBML$IDTable, csymbols];
debugPrint[dbg, "checkRuleExpression: knownSymbols", knownSymbols];unknownSymbols=Complement[symbolsReferenced,knownSymbols];

hf[var_]:= XMLHighlightForm[#,Purple,"<ci>"<>stringer[var]<>"</ci>"]&@@ Cases[subXML, XMLElement["math",___],1];


Print["Error: "//boldRed,"addRule: Unknown symbol "//boldBlack,#//boldBlue," is referenced in the MathML for rule (type = "//boldBlack ,ruleType[r]//boldBlue,") for "//boldBlack,variable//boldBlue,"; "//boldBlack, "\nMathML expression:\n"//boldBlack,
Sequence@@hf[#]

]&/@unknownSymbols;

checkFunctionCalls[math,ruleType[r], variable];

Return[];
];


checkFunctionCalls[symXML_, type_, id_, opt___?OptionQ]:= Module[{dbg=False, functionRefs,functions, fref, badFunctionCalls,correctType,r, knownFunctions, usedFunctionIDs, positions,pup,pup4,fcomp,functionsCalledAsNonFunctions,errMsg, getBadCall, badCallXML,hf, countArguments, argumentsUsed, checkArguments, knownCsymbols},

knownCsymbols=csymbolsused/.{opt}/.{csymbolsused-> {}}; 
If[dbg, Print["--->checkFunctionCalls: knownCsymbols: ", knownCsymbols]]; 

correctType[x_]:= Module[{c}, 
c=Cases[$SBML$IDTable,{x,_}];
If[Length[c]<1, Return["undefined"]]; 
c=c[[1,2]];
Return[c];
];

(* check for non-functions that are used as functions *)

functions=Cases[symXML, XMLElement["apply",{}, {XMLElement["ci",___ ],___}], Infinity];
fref[XMLElement["apply",{}, {XMLElement["ci",_, u_ ],___}]]:=u;
fref[u___]:= {};
functionRefs=Flatten[fref/@functions];
functionRefs = Complement[functionRefs, {"AngleBracket"}]; 

knownFunctions=First/@Select[$SBML$IDTable, Last[#]=="function"&];
badFunctionCalls=Complement[functionRefs,knownFunctions];
badFunctionCalls=Complement[badFunctionCalls, {"AngleBracket"}]; 
badFunctionCalls=Complement[badFunctionCalls, knownCsymbols]; 

getBadCall[f_]:= Cases[functions, XMLElement["apply",{},{XMLElement["ci",{},{f}],___}]];

If[dbg,
Print["debug: checkFunctionCalls: symXML:",symXML];
Print["debug: checkFunctionCalls: functions:",functions];
Print["debug: checkFunctionCalls: functionRefs:", functionRefs];
Print["debug: checkFunctionCalls: badFunctionCalls:", badFunctionCalls];
Print["debug: checkFunctionCalls: knownFunctions:",knownFunctions];
]; 

hf[f_]:= Sequence@@Flatten[{XMLHighlightForm[#,Purple,"<ci>"<>stringer[f]<>"</ci>"]&/@getBadCall[f]}];

MapThread[Print["Error: "//boldRed, stringer[type]<>":"<>stringer[id]<>":"<>#2<>":"<>#1//boldBlue," used as a function.\n"//boldBlack,
hf[#1]
]&, {badFunctionCalls, correctType/@badFunctionCalls}]; 

(* 
 check for functions that are used as non-functions 
*)

usedFunctionIDs = Cases[symXML,XMLElement["ci",_,{#}], Infinity]&/@knownFunctions;
usedFunctionIDs=Cases[symXML,#,Infinity]&/@knownFunctions;
If[dbg, Print["debug: checkFunctionCalls: usedFunctionIDs:",usedFunctionIDs];]; 
positions={#, Position[symXML,#]}&/@Union[Flatten[usedFunctionIDs]];
If[dbg, Print["debug: checkFunctionCalls: positions:",positions]];

pup[{f_,g_}]:= Module[{},
If[Length[g]<1, Return[{}]];
Return[{f, symXML[[Sequence@@Drop[#,-4]]]&/@g}];
];
pup4=pup/@positions;
If[dbg, Print["debug: checkFunctionCalls: pup4:",pup4]]; 

fcomp[{f_, g_}]:= Module[{gkeep,gdrop},
If[Length[g]<1, Return[{}]];
gdrop = Cases[g, XMLElement["apply",{},{XMLElement["ci",{},{f}],___}],Infinity];
gkeep=Complement[g,gdrop];
Return[{f,gkeep}]; 
]; 

functionsCalledAsNonFunctions=fcomp/@pup4;
If[dbg, Print["debug: checkFunctionCalls: functionsCalledAsNonFunctions:", functionsCalledAsNonFunctions]]; 

errMsg[{f_,g_}]:= Module[{},
If[Length[g]<1, Return[]];
Print["Error: "//boldRed,
stringer[type]<>":"<>stringer[id]<>": function: "<>stringer[f]//boldBlue,
" referenced as a variable:\n"//boldBlack,
Sequence@@XMLHighlightForm[#,Purple,"<ci>"<>stringer[f]<>"</ci>"]
]&/@g
];

errMsg/@functionsCalledAsNonFunctions;

(* check for functions that are called with the wrong number of arguments *)

countArguments[XMLElement["apply",{},{XMLElement["ci",{},{f_}], args___}]]:= Module[{},
{f, Length[{args}]}
];
countArguments[___]:= {};

argumentsUsed=countArguments/@functions;
If[dbg, Print["debug: checkFunctionCalls: argumentsUsed:", argumentsUsed]];

checkArguments[{f_, num_}, fdef_]:= Module[{numExpected},

If[f=="AngleBracket", Return[]]; 
If[MemberQ[knownCsymbols, f], Return[]]; 

numExpected=Cases[$SBML$function$bvars, {f, _}]; 
If[Length[numExpected]<1, numExpected=0, numExpected=numExpected[[1,2]]];
If[num!= numExpected, 
Print["Error: "//boldRed, stringer[type]<>":"<>stringer[id]<>": function: "<>stringer[f]//boldBlue,
" called with "//boldBlack, num//boldBlue, " arguments (bvars), but "//boldBlack, numExpected//boldBlue, " arguments were expected:\n"//boldBlack, 
XMLPrintForm[fdef,Purple]
];
];

];

If[dbg, Print["debug: checkFunctionCalls: functions: ", functions]]; 

MapThread[checkArguments, {argumentsUsed, functions}];
];


getEvent[n_?IntegerQ]:= Module[{m},
m=Length[MB$Events];
If[n>m \[Or] n<1, Print["Error: getEvent: "//boldOrange," Event: "//boldBlack,n//boldRed," does not exist. There are "//boldBlack,m//boldRed," events."//boldBlack];Return[{}];];
Return[MB$Events[[n]]//Last];
]; 
getEventNumber[id_?SIDQ]:=Module[{m,n},
m = First/@MB$Events;
n=Position[m, stringer[id]];
If[Length[n]<1, Print["Error: getEventNumber: "//boldOrange,"Event: "//boldBlack,id//boldRed," does not exist. Valid events are "//boldBlack, m//boldRed];Return[0];]; 
While[ListQ[n], n=First[n]];
Return[n];
];
getEvent[id_?SIDQ]:=Module[{m,n},
n=getEventNumber[id];
If[n>0,
m=Last[MB$Events[[n]]];
Return[m]
];
Return[{}]
]; 
getEvent[x_?ListQ]:= getEvent/@Flatten[x];
getNumberOfEvents[]:= Length[MB$Events];
getEvents[]:= getEvent[Range[getNumberOfEvents[]]]; 

getEvent[x___]:= Module[{},
Print["Error: getEvent: "//boldOrange, "Correct format is: "//boldBlack,"getEvent[id]"//boldRed, " where id is an integer or an SID, "//boldBlack,"getEvent[Integer]"//boldRed, " or "//boldBlack,"getEvent[{x1,x2,...}]"//boldRed," where x1,x2,... are integers or SIDs."//boldBlack];
Return[{}];
];




replaceEvent[i_?IntegerQ, XMLElement["event",x___]]:= Module[{n,j},
n=Length[MB$Events];
If[n>0 \[And] i>0 \[And] i<=n, 

j=getSBMLfield["id",XMLElement["event",x]]; 
If[j=="", j=MB$Events[[i,1]]];

MB$Events=ReplacePart[MB$Events,j-> XMLElement["event",x],i];
If[MB$Echo, Print["event ",i, " replaced."]];
Return[];
]; 
Print["Error: replaceEvent: "//boldOrange," unable to replace event "//boldBlack,i//boldRed];
Return[];
]; 

replaceEvent[id_?SIDQ, XMLElement["event",x___]]:= Module[{n},
n=getEventNumber[id];
If[n>0, 
replaceEvent[n, XMLElement["event",x]]; 
Return[];
]; 
Print["Error: replaceEvent: "//boldOrange," unable to replace event "//boldBlack,id//boldRed];
Return[];
]; 

replaceEvent[x___]:= Print["Error: "//boldOrange,"replaceEvent: "//boldRed, "Invalid arguments. Correct format is:"//boldBlack,"replaceEvent["//boldBlack," Integer|SID "//boldBlack,","//boldBlack, " XMLElement[\"event\",...]"//boldBlack," ]"//boldBlack];


 eventToSBML[{x__?ListQ}]:=Module[{r}, 
r =Flatten[ eventToSymbolicSBML/@{x}];
r = XMLElement["listOfEvents",{},r]; 
r=ExportXMLString[r];
r=sunderscore[r];
Return[r];
];


eventToSBML[opt___?OptionQ]:= Module[{r},
r=eventToSymbolicSBML[opt]; 
r=ExportXMLString[r];
r=sunderscore[r];
Return[r];
];

eventToSBML[x_, opt___?OptionQ]:= eventToSBML[Global`id-> x, opt];



deleteEvent[opt___?OptionQ]:= Module[{n,c,p},
n =( Global`id/.{opt}/.{id-> ""})//stringer;
If[id=="", 
Print["Error: deleteEvent"//boldOrange," No "//boldBlack,"id"/boldRed," was specified."]]; 
removeID[n,"event"]; 
MB$Currentid=n;
c = Map[First,MB$Events]; 
If[MemberQ[c,n],
p=Position[c,n];
MB$Events= Drop[MB$Events,First[p]]; 
Return[True];
];
Return[False];
];
deleteEvent[x_, opt___?OptionQ]:= deleteEvent[Global`id-> x,opt];
removeEvent[x___]:=Module[{flag},
flag = deleteEvent[x];
If[flag, 
If[MB$Echo,Print["Event "//boldGreen,MB$Currentid//boldBlue," removed."//boldGreen]],
Print["Warning: "//boldOrange,"Requested Event "//boldBlack,MB$Currentid//boldRed," can not be removed."//boldBlack]];
];



addEvent[XMLElement[x___]]:=Module[{r,n, a, b, c,dbg=False,ea,eamath,vars,modelSpecies,modelParameters,modelCompartments,isConstant,constants,constVal,constantParameters,trueVariables, invalidVariables, constantVariables,undefinedVariables,allowedVariables,XML2Symbol,et, etmath, hf,csymbols,mycsymbol,math, meta},

constVal["false"]:= False;
constVal["true"]:= True;
constVal[z_]:= Indeterminate;

XML2Symbol["ci",{},{u_}]:= u;
XML2Symbol[u___]:= {};

r =XMLElement[x];
n=getSBMLfield["id",r];
If[n== "", 
n = "event"<>ToString[MB$eventcounter++];
{a, b, c} = {x};
b = Append[b, "id"-> n];
r = XMLElement[a, b, c];
n  = getSBMLfield["id",r]; 
];

If[deleteEvent[Global`id-> n] ,
If[MB$Echo,Print["Previous occurance of event "//boldGreen,n//boldBlue," removed."//boldGreen]]
];

addID[n,"event",True];
meta = getSBMLfield["metaid", r]; 
If[meta!= "", addMetaID[meta,n, "event", True]]; 

MB$Events=Append[MB$Events,n->r];
(* test to see if valid variable *)
If[dbg,Print["addEvent:"//boldBlack," r "//boldRed,"="//boldBlack,r//boldBlack];];

(* check for any csymbols *)

math=XMLElement[x];
csymbols = Cases[math, XMLElement["csymbol",___],Infinity];
If[Length[csymbols]>0,
mycsymbol["csymbol",{___},xx_]:= xx;
mycsymbol[xx___]:= XMLElement[xx];
csymbols=Flatten[(csymbols/.{XMLElement-> mycsymbol})/.{XMLElement-> List}];
csymbols=Complement[csymbols,{"ci"}];
debugPrint[dbg, "checkRuleExpression: csymbols", csymbols];
];

debugPrint[dbg, "addEvent: csymbols",csymbols];

(* check event trigger *)

et = Cases[r, XMLElement["trigger",___], Infinity]; 
checkFunctionCalls[et,"event-trigger",stringer[n]];
etmath = Cases[et, XMLElement["ci",___], Infinity];
etmath=etmath/.{XMLElement-> XML2Symbol};
invalidVariables=Complement[etmath,Join[First/@$SBML$IDTable,csymbols]];


hf[var_]:= XMLHighlightForm[#,Purple,"<ci>"<>stringer[var]<>"</ci>"]&@@ et;

Print["Error: "//boldRed, "addEvent: undefined variable "//boldBlack,#//boldBlue, " referenced in trigger for event "//boldBlack, n//boldBlue,"\nInvalid trigger = \n"//boldBlack,
Sequence@@hf[#]
]&/@invalidVariables;

(* check event assignments *)

ea = Cases[r,XMLElement["eventAssignment",___], Infinity];
checkFunctionCalls[ea,"event-assignment",stringer[n]];

vars = Map[getSBMLfield["variable",#]&,ea];

Block[{metas, ids},
metas = Map[getSBMLfield["metaid",#]&, ea];
ids = Map[contextify[contextify[#,"eventAssignment"],n]&, vars];
MapThread[If[#1!= "", addMetaID[#1,#2, "eventAssignment", True]]&,{metas,ids}];
];

(* check assignment variable *)
 
modelSpecies=First/@MB$Species;
modelParameters = First/@MB$Parameters;
modelCompartments=First/@MB$Compartments;
allowedVariables=Join[modelSpecies, modelParameters,modelCompartments];
undefinedVariables=Complement[vars,allowedVariables];

hf[var_]:= XMLHighlightForm[#,Purple,"variable=\""<>stringer[var]<>"\""]&@@ Cases[r,XMLElement["listOfEventAssignments",___], Infinity];
Print["Error: "//boldRed," unknown eventAssignment variable: "//boldBlack,
#//boldBlue," in event: "//boldBlack, 
n//boldBlue,"\nInvalid listOfEventAssignments:\n"//boldBlack,
Sequence@@hf[#]
]&/@undefinedVariables;

isConstant[p_]:= constVal[getSBMLfield["constant",Last[p]]];
(* Species default to non-constant, parameters & compartments to constant! *)
constants = Join[
(isConstant/@MB$Species)/.{Indeterminate-> False},(isConstant/@MB$Parameters)/.{Indeterminate-> True},
(isConstant/@MB$Compartments)/.{Indeterminate-> True}];
constants={allowedVariables,constants}//Transpose;
constants=Select[constants,Last[#]&];
constants=First/@constants;
constants=Intersection[vars,constants];

(* check event assignment expression *)
eamath = Cases[ea,XMLElement["ci",___],Infinity]; 
eamath=(eamath/.{XMLElement-> XML2Symbol}); 
invalidVariables=Complement[eamath,Join[First/@$SBML$IDTable,csymbols]];

ea = Cases[r,XMLElement["listOfEventAssignments",___], Infinity];

hf[var_]:= XMLHighlightForm[#,Purple,"variable=\""<>stringer[var]<>"\""]&@@ea;
Print[
"Error: "//boldRed,
"the eventAssignment variable: "//boldBlack,
#//boldBlue," in event "//boldBlack,
n//boldBlue," has constant=\"true\" and may not be assigned a value as a result of an event."//boldBlack, " Invalid listOfEventAssignments:\n"//boldBlack, 
Sequence@@hf[#]
]&/@constants;

hf[var_]:= XMLHighlightForm[#,Purple,"<ci>"<>stringer[var]<>"</ci>"]&@@ Cases[r,XMLElement["listOfEventAssignments",___], Infinity];
Print["Error: "//boldRed, "addEvent: undefined variable "//boldBlack,#//boldBlue, " referenced in eventAssignment for event "//boldBlack, n//boldBlue, " Invalid listOfEventAssignments:\n"//boldBlack, 
Sequence@@hf[#]
]&/@invalidVariables;

If[MB$Echo, Print["Event "//boldGreen,n//boldBlue," added."//boldGreen]];
Return[n];
];

addEvent[opt___?OptionQ]:=Module[{r,n},
(* MB$Echo = Global`echo/.{opt}/.{Global`echo-> True}; *)
r =eventToSymbolicSBML[opt]; 
n = addEvent[r];

Return[n];
];

addEvent[id_, opt___?OptionQ]:= addEvent[Global`id-> id, opt];


 modifyEvent[opt___?OptionQ]:= Module[{n,x,y,trigger,delay, infix, getFirst, getElement,getMath, asg, vars,maths,name,ann, notes,asgann,asgnotes,asgmetids},

infix[XMLElement["math",x___]]:= SymbolicSBMLMathMLToExpression[XMLElement["math",x]];
infix[x___]:= 1; 
getFirst[a_]:= Module[{b}, 
b=a; 
While [ListQ[b] \[And] Length[b]>0, b = First[b]];
Return[b]; 
]; 
getElement[element_, xml_,level_:Infinity]:= Cases[xml, XMLElement[element, ___], level];
getMath[element_, xml_]:=infix[getFirst[getElement["math",getFirst[getElement[element,xml]]]]];

n =( Global`id/.{opt}/.{Global`id-> ""})//stringer;
MB$Currentid=n;
x=retrieveSBMLObject["event",n];

If[ToString[Head[x]]=="XMLElement",
y=globalize/@extractAndUpdateXMLOptions[x,opt];

trigger = getMath["trigger",x]; 
delay = getMath["delay",x]; 
y = Join[y, {Global`trigger-> trigger, Global`delay-> delay}]; 

asg = getElement["listOfEventAssignments", x];
asg = getElement["eventAssignment",asg//getFirst];

asgmetids = Map[getSBMLfield["metaid",#]&,asg];
asgnotes = getNotes/@asg;
asgann=getAnnotations/@asg;

vars = Map[getSBMLfield["variable",#]&, asg];
maths = infix/@getFirst/@Map[Cases[#, XMLElement["math",___],Infinity]&, asg];
asg = MapThread[Rule[#1, #2]&, {vars, maths}]; 

y =Append[y, Global`eventAssignment-> asg]; 
y =Append[y,Global`eventAssignmentMetaids-> asgmetids];
y=Append[y, Global`eventAssignmentNotes-> asgnotes];
y =Append[y, Global`eventAssignmentAnnotations-> asgann];


ann = updateAnnotations[x, opt];
notes = updateNotes[x, opt]; 
y = Prepend[y, globalize["annotation"-> ann]];
y = Prepend[y, globalize["notes"-> notes]];

MB$Modify=True;
n=Apply[addEvent,y];
MB$Modify=False;
,
n=addEvent[opt]; 
];
Return[n]; 
];
modifyEvent[id_, opt___?OptionQ]:= modifyEvent[Global`id-> id, opt];



replaceObject["compartment",x_, y_]:= replaceCompartment[x,y];
replaceObject["event",x_,y_]:= replaceEvent[x,y];
replaceObject["function",x_,y_]:= replaceFunction[x,y];
replaceObject["parameter",x_,y_]:= replaceParameter[x,y];
replaceObject["reaction",x_,y_]:= replaceReaction[x,y];
replaceObject["rule",x_,y_]:= replaceRule[x,y];
replaceObject["species",x_,y_]:= replaceSpecies[x,y];
replaceObject["unit", x_, y_]:= replaceUnit[x,y];
replaceObject["initialAssignment", x_, y_]:= replaceInitialAssignment[x,y];
replaceObject[x___]:= Print["Error: "//boldRed," replaceObject:"//boldBlack," invalid argument: "//boldBlack, {x}//boldBlue]; 


getObject["compartment",x___]:= getCompartment[x];
getObject["compartmentType", x___]:= getCompartmentType[x]; 
getObject["event",x___]:= getEvent[x];
getObject["function",x___]:= getFunction[x];
getObject["parameter",x___]:= getParameter[x];
getObject["reaction",x___]:= getReaction[x];
getObject["rule",x___]:= getRule[x];
getObject["species",x___]:= getSpecies[x];
getObject["speciesType", x___]:= getSpeciesType[x]; 
getObject["unit",x___]:= getUnit[x];
getObject["constraint", x___]:= getConstraint[x]; 
getObject["initialAssignment", x___]:= getInitialAssignment[x]; 

(* getObject[s_?StringQ,x___]:= getObject[ToLowerCase[s],x]; *)

getObject[x?StringQ_, y___]:= Module[{}, Print["Error: "//boldRed, "getObject: "//boldBlack, "unknown object: "//boldBlack, x//boldBlue]; 
Return[$Failed];
]; 

getObject[x__]:= Module[{}, Print["Error: "//boldRed, "getObject: "//boldBlack, "object must be a string, not: "//boldBlack,{ x}[[1]]//boldBlue]; 
Return[$Failed];
]; 




getNumberOfObjects["compartment"]:= getNumberOfCompartments[];
getNumberOfObjects["compartmentType"]:= getNumberOfCompartmentTypes[]; 
getNumberOfObjects["event"]:= getNumberOfEvents[];
getNumberOfObjects["function"]:= getNumberOfFunctions[];
getNumberOfObjects["parameter"]:= getNumberOfParameters[];
getNumberOfObjects["reaction"]:= getNumberOfReactions[];
getNumberOfObjects["rule"]:= getNumberOfRules[];
getNumberOfObjects["species"]:= getNumberOfSpecies[];
getNumberOfObjects["speciesType"]:= getNumberOfSpeciesTypes[]; 
getNumberOfObjects["unit"]:= getNumberOfUnits[];
getNumberOfObjects["constraint"]:= getNumberOfConstraints[]; 
getNumberOfObjects["initialAssignment"]:= getNumberOfInitialAssignments[]; 
getNumberOfObjects[x_?StringQ]:= Module[{}, Print["Error: "//boldRed, "getNumberOfObjects: unknown Object: "//boldBlack, x//boldBlue]; Return[$Failed]]; 
getNumberOfObjects[x_]:= Module[{}, Print["Error: "//boldRed, "getNumberOfObjects: Object: "//boldBlack, x//boldBlue, " is not a string."//boldBlack]; Return[$Failed]]; 



getObjectID[object_?StringQ, x_]:= Module[{id}, 
id=getObjectAttribute[object, "id" , x];
Return[id]; 
]; 

getObjectID[object_, x___]:= Module[{id}, 
Print["Error: "//boldRed, "getObjectID: "//boldBlack, " object must be a string, not "//boldBlack, object//boldBlue]; 
Return[$Failed]; 
]; 

getObjectIDs[object_?StringQ]:= Module[{id, n}, 
n=getNumberOfObjects[object]; 
If[ToString[n]=="$Failed", 
Print["Error: "//boldRed, "getObjectIDs: "//boldBlack, object//boldBlue]; 
Return[$Failed]]; 

ids=getObjectID[object, #]&/@Range[n];
Return[ids]; 
];
getObjectIDs[x___]:= Module[{}, 
Print["Error: "//boldRed, "getObjectIDs: object must be a single string, not: "//boldBlack, x//boldBlue]; 
Return[$Failed]; 
];

getObjectName[object_?StringQ, x_]:= Module[{id}, 
id=getObjectAttribute[object, "name", x];
Return[id]; 
]; 

getObjectName[object_, x___]:= Module[{id}, 
Print["Error: "//boldRed, "getObjectName: "//boldBlack, " object must be a string, not "//boldBlack, object//boldBlue]; 
Return[$Failed]; 
]; 

getObjectNames[object_?StringQ]:= Module[{names, n}, 
n=getNumberOfObjects[object]; 
If[ToString[n]=="$Failed", 
Print["Error: "//boldRed, "getObjectNames: "//boldBlack, object//boldBlue]; 
Return[$Failed]]; 

names=getObjectName[object, #]&/@Range[n];
Return[names]; 
];
getObjectNames[x___]:= Module[{}, 
Print["Error: "//boldRed, "getObjectNames: object must be a single string, not: "//boldBlack, x//boldBlue]; 
Return[$Failed]; 
];


getCompartmentID[x_]:= getObjectID["compartment", x]; 
getEventID[x_]:= getObjectID["event", x]; 
getFunctionID[x_]:= getObjectID["function", x]; 
getParameterID[x_]:= getObjectID["parameter", x]; 
getRuleID[x_]:= getObjectID["rule", x]; 
getSpeciesID[x_]:= getObjectID["species", x]; 
getUnitID[x_]:= getObjectID["unit", x]; 
getSpeciesTypeID[x_]:= getObjectID["speciesType", x]; 
getCompartmentTypeID[x_]:= getObjectID["compartmentType", x]; 
getConstraintID[x_]:= getObjectID["constraint", x]; 
getInitialAssignmentID[x_]:= getObjectID["initialAssignment", x]; 

getCompartmentIDs[]:= getObjectIDs["compartment"]; 
getEventIDs[]:= getObjectIDs["event"]; 
getFunctionIDs[]:= getObjectIDs["function"]; 
getParameterIDs[]:= getObjectIDs["parameter"]; 
getRuleIDs[]:= getObjectIDs["rule"]; 
getSpeciesIDs[]:= getObjectIDs["species"]; 
getUnitIDs[]:= getObjectIDs["unit"]; 
getSpeciesTypeIDs[]:= getObjectIDs["speciesType"]; 
getCompartmentTypeIDs[]:= getObjectIDs["compartmentType"]; 
getConstraintIDs[]:= getObjectIDs["constraint"]; 
getInitialAssignmentIDs[]:= getObjectIDs["initialAssignment"]; 

getCompartmentName[x_]:= getObjectName["compartment", x]; 
getEventName[x_]:= getObjectName["event", x]; 
getFunctionName[x_]:= getObjectName["function", x]; 
getParameterName[x_]:= getObjectName["parameter", x]; 
getRuleName[x_]:= getObjectName["rule", x]; 
getSpeciesName[x_]:= getObjectName["species", x]; 
getUnitName[x_]:= getObjectName["unit", x]; 
getSpeciesTypeName[x_]:= getObjectName["speciesType", x]; 
getCompartmentTypeName[x_]:= getObjectName["compartmentType", x]; 
getConstraintName[x_]:= getObjectName["constraint", x]; 
getInitialAssignmentName[x_]:= getObjectName["initialAssignment", x]; 

getCompartmentNames[]:= getObjectNames["compartment"]; 
getEventNames[]:= getObjectNames["event"]; 
getFunctionNames[]:= getObjectNames["function"]; 
getParameterNames[]:= getObjectNames["parameter"]; 
getRuleNames[]:= getObjectNames["rule"]; 
getSpeciesNames[]:= getObjectNames["species"]; 
getUnitNames[]:= getObjectNames["unit"]; 
getSpeciesTypeNames[]:= getObjectNames["speciesType"]; 
getCompartmentTypeNames[]:= getObjectNames["compartmentType"]; 
getConstraintNames[]:= getObjectNames["constraint"]; 
getInitialAssignmentNames[]:= getObjectNames["initialAssignment"]; 


getObjectNumber["compartment",x___]:= getCompartmentNumber[x];
getObjectNumber["event",x___]:= getEventNumber[x];
getObjectNumber["function",x___]:= getCompartmentNumber[x];
getObjectNumber["parameter",x___]:= getParameterNumber[x];
getObjectNumber["reaction",x___]:= getReactionNumber[x];
getObjectNumber["rule",x___]:= getRuleNumber[x];
getObjectNumber["species",x___]:= getSpeciesNumber[x];
getObjectNumber["unit",x___]:= getUnitNumber[x];
getObjectNumber[s_?StringQ,x___]:= getObjectNumber[ToLowerCase[s],x];
getObjectNumber[x___]:= Module[{s,xx},
Print["Error:"//boldOrange,
("getObjectNumber["<>StringDrop[StringDrop[ExportString[x//List,"Text"],1],-1]<>"]")//boldRed,
" Invalid call to getObjectNumber;  the first argument must be one of the following strings: \"compartment\",\"event\",\"function\",\"parameter\",\"reaction\",\"rule\",\"species\",\"unit\""//boldBlack
];
Return[{}]];


getObjects[]:= {};
getObjects[x_?StringQ]:= Module[{n, objs},
n = getNumberOfObjects[x]; 
If[ToString[n]== "$Failed", Print["Error: "//boldRed, "getObjects: "//boldBlack, x//boldBlue]; Return[$Failed]; 
]; 
objs=getObject[x, #]&/@Range[n]; 
Return[objs]; 

];



getObjects[opt___?OptionQ]:= Module[{x,opts,y},
x={opt}/.{Rule-> List};
opts=First/@x;
x=Join@@x;
y=getObjects@@x;
opts=Take[opts,Length[y]];
opts=ToLowerCase/@opts;
y=MapThread[Rule[#1,#2]&, {opts,y}];
Return[y];
];

getObjects[x___]:= Module[{n,p},
n=Length[{x}];
If[OddQ[n],
Print["Error:"//boldRed,n//boldBlue," arguments supplied to getObjects; an even number of arguments is required, or a single string argument."//boldBlack ];
];
p = Partition[{x},2];
Return[getObject@@#&/@p];
];




Options[SBMLCopy]={ImportOptions-> {}, ExportOptions-> {}};
SBMLCopy[in_?StringQ, out_?StringQ, opt___?OptionQ]:= Module[{f,s,msg, iopt,eopt},

iopt = ImportOptions/.{opt}/.Options[SBMLCopy];
iopt=MyFilterOptions[Import,iopt];

eopt =ExportOptions/.{opt}/.Options[SBMLCopy];
eopt=MyFilterOptions[Export,eopt];

If[!validInputFile[in],Return[]];
s = ExportXMLString[Import[in, iopt]] ;

If[availableOutputFile[out], 
msg=Export[out,s,"text", eopt];,
msg = s
];
Return[msg];
];


SBMLCopy[in_?StringQ, opt___?OptionQ]:= Module[{f,s,msg, iopt, eopt},
If[!validInputFile[in],Return[]];

iopt = ImportOptions/.{opt}/.Options[SBMLCopy];
iopt=MyFilterOptions[Import,iopt];

eopt =ExportOptions/.{opt}/.Options[SBMLCopy];
eopt=MyFilterOptions[Export,eopt];

s = ExportXMLString[Import[in,iopt]] ;
Return[s];
];

SBMLCopy[x___]:= Print[
boldOrange["Error: "],
boldRed["SBMLCopy must have two string arguments, SBMLCopy[input-file-name, output-file-name]."]
];


sameReaction[Plus[r1__]-> Plus[p1__], Plus[r2__]-> Plus[p2__]]:= Module[{plus, R1,R2, P1, P2,z},
plus[x__]:={x}/.{Plus-> List}//Flatten;
{R1,P1,R2, P2} =Map[Flatten[List[#]]&, {r1, p1, r2, p2}/.{Plus-> plus}];

z=Join[Complement[R1,R2], Complement[R2,R1],Complement[P1,P2], Complement[P2, P1]]//Flatten;

Return[Length[z]==0]; 
];
sameReaction[
MyRightArrowLeftArrow[Plus[r1__], Plus[p1__]], MyRightArrowLeftArrow[ Plus[r2__],Plus[p2__]]]:=sameReaction[Plus[r1]-> Plus[p1], Plus[r2]-> Plus[p2]];



compareReactions[fileList_,opt___?OptionQ]:= Module[{getReactions, countOccurances, rlist,rlisted, allReactions,comparison,getSame,simplifyReaction,sur,fCount, rCount,verbose,rmod,fmod,rlast,tstart,tlast,tmod,tc},
tstart = TimeUsed[];
verbose = Global`verbose/.{opt}/.{Global`verbose-> False};
fmod = Global`fmod/.{opt}/.{Global`fmod-> 1};
rmod = Global`rmod/.{opt}/.{Global`rmod-> 1};
tmod = Global`tmod/.{opt}/.{Global`tmod-> 1};


fCount=0;
rCount=0; 
log={};

rlast=0;
tlast=tstart;

getReactions[file_]:= Module[{returnVal,r, nreactions},
fCount++;

r=Global`SBMLReactions/.SBMLRead[file,Global`context-> "$$$`",Global`evaluateParameters-> False, Global`return-> {SBMLReactions-> True, SBMLODES->False,SBMLIC->False,SBMLConstants->False,SBMLModelVariables->False,SBMLAlgebraicRules->False,SBMLUnitDefinitions->False,SBMLUnitAssociations->False,SBMLModelName->False,SBMLFunctions->False,SBMLEvents->False,SBMLNameIDAssociations->False,SBMLNumericalSolution->False}];
nreactions = Length[r]; 
rCount+=nreactions; 
tc = TimeUsed[];
If[verbose &&( Mod[fCount,fmod]==0   \[Or]tc>tlast+tmod),tlast=tc; Print[fCount, " files; (at ",  file,"); ", rCount," reactions; ",tc-tstart," cpu."]];
returnVal=r;
Return[returnVal]; 
];


rlist = Map[getReactions,fileList]; 

If[verbose, Print[fCount," files; ",rCount," reactions ", TimeUsed[]-tstart," seconds CPU."]];

rlisted=rlist;

allReactions=Apply[Join,rlisted];
uniqueReactions=Union[allReactions];

If[Length[uniqueReactions]==Length[allReactions], Print["No Repeated Reactions."]; Return[{}]; ]; 

If[verbose, Print[Length[uniqueReactions], " unique Reactions."]]; 

getSame[r_]:= Select[allReactions,sameReaction[r, #]&];
rCount=0; 
countOccurances[r_]:= Module[{val},
rCount++;
val=Length[getSame[r]]; 
tc = TimeUsed[]; 
If[rCount>= rlast+rmod \[Or] tc >= tlast + tmod, 
If[verbose,rlast=rCount;tlast=tc;  Print[rCount," reactions; (current=",decontextify[r,"$$$`"],"); ",TimeUsed[]-tstart," cpu."]];
]; 
Return[val];];

simplifyReaction[x_]:= MathSBML`Private`decontextify[ToString[InputForm[x]],"$$$`"]; 

comparison=countOccurances/@ uniqueReactions; 
(* sur = simplifyReaction/@uniqueReactions; *) 
comparison={comparison,uniqueReactions};
comparison=comparison//Transpose;
comparison=Select[comparison, First[#]>1&];
comparison = Map[{#//First, simplifyReaction[#//Last]}&,comparison];


comparison = comparison//Sort//Reverse; 
Print["Total CPU:", TimeUsed[]-tstart]; 
Return[comparison];

]; 


dataTable[var_,{t_, t0_, tend_, tdelta_}, r_, opt___?OptionQ]:= Module[{v,vnames, results, is, getSet,ta,tb,file,vfile, format, vforms = {"CSV","HDF","LIST", "MAT", "MTX","NB","TSV", "TABLE"}},
v={var}//Flatten;
vnames = MathSBML`Private`stringer/@v;
v=(#[t]&)/@v;

is = Position[r, InterpolationSet];

(* Not an interpolation table *)
If[Length[is]<1, 
{ta, tb} = MathSBML`Private`getPlotTimes[r];
ta =Max[t0, ta];
tb=Min[tend, tb]; 
If[tb<ta, 
results={},
results=Table[Flatten[{t,N/@(v/.r)}],{t,ta, tb, tdelta}];
]; 
, 
(* handle interpolation sets *) 

getSet[InterpolationSet[start_, finish_, data_]]:= Module[{tbeginset, tendset, setresults},
tbeginset = Ceiling[(start-t0)/tdelta]*tdelta+t0;
tendset = Floor[(finish-t0)/tdelta]*tdelta+t0;

If[t0>tendset, Return[{}];];  
If[tend<tbeginset, Return[{}];]; 

tbeginset = Max[t0, tbeginset];
tendset = Min[tend, tendset]; 

setresults=Table[Flatten[{t,N/@(v/.{data})}],{t,tbeginset, tendset, tdelta}];
Return[setresults];
];
results = Join@@(getSet/@r);

]; 
results = Prepend[results,Flatten[{"time", vnames}]]; 

file =Global`file/.{opt}/.{Global`file-> ""}; 
file=stringer[file]; 
If[StringLength[file]>0, 

vfile=validateOutputFileName[file];
If[vfile=="$Failed",
Print["Unable to create file ",file]; 
Return[results];
];

format = Global`format/.{opt}/.{Global`format-> "CSV"};
format=stringer[format];
If[!MemberQ[vforms,format], 
Print["Error: dataTable: "//boldOrange, "invalid format\[Rule]"//boldBlack,format//boldRed," allowed values are "//boldBlack, list2CommaSeparatedString[vforms]<>"; "//boldBlack,"CSV assumed."//boldBlack];
format="CSV"]; 
If[format=="HDF" \[Or] format=="MAT" \[Or] format== "MTX", results=Rest[results]]; 

Export[ vfile,results, format];
Return[vfile];

]; 


Return[results];
]


resetIC[m_?ListQ, var_, value_]:= Module[{name,model,pos,ic,cases,time,ctxt,argument},
argument[x_[y_]]:= y;
If[!SameQ[Union[Head/@m], {Rule}], 
Print["Error: resetIC: first argument must be the output of SBMLRead."];
 Abort[];
];

ctxt=Global`SBMLContext/.m/.{Global`SBMLContext-> "None"};
name =contextify[ decontextify[var],ctxt];

ic=Global`SBMLIC/.m/.{Global`SBMLIC-> {}};

pos = Position[m,Global`SBMLIC-> ic]; 

If[Length[ic]<1,
(* if there are no initial conditions assume time is zero *)
 ic={name[0]==value},

(* otherwise there are some ic already present *)

cases=Cases[ic,Equal[name[_],_]];
If[Length[cases]>1,
Print["Warning:resetIC:multiple initial conditions found for ",name,":",cases];
];


If[Length[cases]<1,
(* in this case name has no previous initial condition *)
(* use time of other initial conditions *) 
time=argument[ic[[1,1]]];
ic = Append[ic,name[time]==value];
,

(* in this case a previous initial condition for name was found *)
ic=Complement[ic,cases];
cases=cases[[1,1]];
cases=Equal[cases,value];
ic = Append[ic,cases];
];
]; 
While[ListQ[pos] \[And] Length[pos]>0,
pos=First[pos];
];
If[AtomQ[pos],
model=ReplacePart[m,Global`SBMLIC-> ic,pos];,
model=Append[m,Global`SBMLIC-> ic]//Sort;
];
Return[model];
];
resetIC[a_,Rule[b_,c_]]:= resetIC[a,b,c];
resetIC[a_,r_?ListQ]:= Fold[resetIC,a,r];
resetIC[a___]:= Print["Error: resetIC: invalid argument sequence."];



resetParameter[m_?ListQ, var_, value_]:= Module[{name,model,pos,v,cases,time,ctxt,argument,vars, voriginal, dbg=False},
argument[x_[y_]]:= y;
If[!SameQ[Union[Head/@m], {Rule}], 
Print["Error: resetParameter: first argument must be the output of SBMLRead."];
 Abort[];
];

ctxt=Global`SBMLContext/.m/.{Global`SBMLContext-> "None"};
debugPrint[dbg, "resetParameter: ctxt", ctxt]; 

name =contextify[ var,ctxt];
debugPrint[dbg, "resetParameter: name", name]; 

(* there was an extra semicolon after this statement that caused a break-down in version *)

voriginal=Global`SBMLConstants/.m/.{Global`SBMLConstants-> {}};
vars=First/@voriginal;
debugPrint[dbg, "resetParameter: voriginal", voriginal]; 
debugPrint[dbg, "resetParameter: vars(1)", vars]; 
vars=Union[Append[vars,name]];
debugPrint[dbg, "resetParameter: vars(2)", vars]; 
v=MapThread[Rule,{vars, vars/.{name-> value}/.voriginal}];
debugPrint[dbg, "resetParameter: v", v];

pos = Position[First/@m,Global`SBMLConstants]; 
debugPrint[dbg, "resetParameter: pos", pos];


While[ListQ[pos] \[And] Length[pos]>0,
pos=First[pos];
];
If[AtomQ[pos],
model=ReplacePart[m,Global`SBMLConstants-> v,pos];,
model=Append[m,Global`SBMLConstants-> v]//Sort;
];
Return[model];
];
resetParameter[a_,Rule[b_,c_]]:= resetParameter[a,b,c];
resetParameter[a_,r_?ListQ]:= Fold[resetParameter,a,r];
resetParameter[a___]:= Print["Error: resetParameter: invalid argument sequence."];



If[$$LoadBug, Print["Loading:private usage"]];


$SBML$CompartmentNames::usage="$SBML$CompartmentNames contains a list of compartments in the current SBML model.";
$SBML$CompartmentUnits::usage="$SBML$CompartmentUnits contains a list of the units of the compartments listed in $SBML$CompartmentNames";
$SBML$CompartmentVolumes::usage="$SBML$CompartmentVolumes contains a list of the volumes of the compartments listed in $SBML$CompartmentNames";
$SBML$CompartmentOutsides::usage="$SBML$CompartmentOutsides contains a list of the outside compartments corresponding to the compartments listed in $SBML$ComparatmentNames. Note that outsides are ignored in this version of the SBML reader.";

$SBML$FrozenVariables::usage="$SBML$FrozenVariables is a list of frozen variables in the current model, i.e., those with \"boundaryCondition\"\[Rule]\"true\".";



$Debug$DebugColor=RGBColor[1,0,0];
$Debug$MessageColor=RGBColor[0.133305`,0.545106`,0.133305`];
$Debug$ValueColor=RGBColor[0.5`,0.164693`,0.164693`];
$Warning$Color=RGBColor[1.`,0.5`,0.`];
$Warning$Color::usage="$Warning$Color is a global parameter that sets the color used to print warning messages.";


\[Cent]Header$Alignment="Center";
\[Cent]Header$Alignment::usage="\[Cent]Header$Alignment is a global parameter that sets the alignment value used to print headers. See TextAlignment.";
$Column\[Cent]Header$Color=RGBColor[0.415693`,0.352901`,0.803903`];
\[Cent]Header$Color = RGBColor[0.`,0.`,0.501999`];

\[Cent]Header$Title$Color=\!\(\*
TagBox[
StyleBox[
RowBox[{"RGBColor", "[", 
RowBox[{"0.239998`", ",", "0.569994`", ",", "0.250008`"}], "]"}],
ShowSpecialCharacters->False,
ShowStringCharacters->True,
NumberMarks->True],
FullForm]\);

\[Cent]Header$Color::usage="\[Cent]Header$Color is a global parameter that sets the color of headers used to print headers. See FontColor.";

\[Cent]Header$Size=16;
\[Cent]Header$Size::usage="\[Cent]Header$Size is a global parameter that sets the font size used to print headers.See FontSize";

\[Cent]Header$Weight="Bold";
\[Cent]Header$Weight::usage ="\[Cent]Header$Weight is a global parameter that sets the font weight used to print headers. See FontWeight";

\[Cent]Header$Font="Times";
\[Cent]Header$Font::usage="\[Cent]Header$Font is a global parameter that sents the font used to print headers. See FontFamily.";

$Column\[Cent]HeaderSize=14;


$Compartment$ID::usage="$Compartment$ID is a string that is concatenated to the front of all compartment names specified in the sbml model. By including a non-xml character in $Compartment$ID this will reduce the liklihood of compartment names duplicating any Mathematica variable. For example, with $Compartment$ID set to \"CID$\" a compartment name \"cytoplasm\" in the xml will be named \"CID$cytoplasm\" in the Mathematica model.";
$Universal$OutsideCompartment::usage="$Universal$OutsideCompartment is the name of the default \"outside\" compartment before it is prepended with $Compartment$ID. Its default value is the infinity symbole (\[Infinity], or \\[Infinity]), which will be preprended with $Compartment$ID to give $CID\[Infinity]";


$Compartment$ID = "";
$Universal$OutsideCompartment="\[Infinity]";
$Species$ID="$";


debugPrint::usage="debugPrint[flag,x1,x2,...] does nothing and returns Null if flag is false, and prints a debug message with the values of x1,x2,.. if flag is true.";


getSBMLparameters::usage="getSBMLparameters[m] returns a list of the global parameters found in the SBML model m. The return value is {list-of-parameters, list-of-parameter-rules} where list-of-parameters is a list of the parameter names and list-of-parameter-rules is a list of replacement rules {name->value,...}";


getSBMLspecies::usage="getSBMLspecies[m] returns a list of species found in the SBML model m. Species v in compartment j are renamed as v[j]. The name of the compartment is controlled by $Compartment$ID. The following list is returned: {list-of-species, list-of-initial-condtitions, list-of-frozen-variable-rules}  where list-of-species is a list of (possibly indexed) variable names; list-of-initial-conditions has the form {var[0]==value,...}; and list-of-frozen-variable-rules has the form {var-> value,...}";


headerPrint::usage="headerPrint[x] prints x as a header string using the attributes \[Cent]Header$Size, \[Cent]Header$Color, \[Cent]Header$Weight,\[Cent]Header$Font, and \[Cent]Header$Alignment.";


extractXMLOptions::usage="extractXMLOptions[XMLElement[tag, optionlist,stuff] returns the option list.";


extractSBMLtag::usage="extractSBMLtag[xml,tag,level] returns a list of all the occurances of of XMLElement[tag,...] in xml on a given level. The parameter tag is a string.\nextractSBMLtag[xml,tag] extracts the occurances of XMLElement[tag,...] at every level (i.e., Infinity).";


fromEForm::usage="fromEForm[s] translates a e-format-style real number into a Mathematica real number, e.g, 5.9e-17 is translated into 5.9*10^-17.  The only allowed separator is a lower case e; other separators, such as E, D,and Q are not allowed. The input s may be either a string or an expression; if it is an expression it is translated into a string.";


getAttributeValue::usage="getAttributeValue[attr, val,unk,opt] where opt is a list of option lists, looks for a sublist of opt that contains attr\[Rule]value; within that sublist, the value of option unk is returned.For example, \ngetAttributeValue[x, 5, y, \n{{x\[Rule] 4, y\[Rule] 4}, {x\[Rule] 5, y\[Rule] 40}, {x\[Rule] 6, y\[Rule] 400}}]\n returns the number 40.\nIf attribute attr accurs in more than one sub-list, and error message is printed and only the last value of unk is returned. To obtain all occurances use getAttributeValues";
getAttributeValues::usage="getAttributevalues[attr,val,unk,opt] where opt is a list of option lists, returns all occurances of option unk corresponding to attr\[Rule]val in the list of lists.See also getAttributeValue.";


getSBMLcompartments::usage="getSBMLcompartments[model] returns a list of option lists corresponding to each compartment in the model, where m is an xml model of the fomr XMLElement[model,...].  The return value has the form\n{{\"name\"\[Rule]value, \"volume\"\[Rule]value,\"units\"\[Rule]value,\"outside\"\[Rule]value}, {\"name\"\[Rule]value,...},...}";


getSBMLreactions::usage="getSBMLreactions[m,options] returns a list of ODEs corresponding to the reactions. The format of the input and output are yet to be determined. ";


list2CommaSeparatedString::usage="list2CommaSeparatedString[{x1,x2,...,xn}] returns the string \"x1,x2,...,xn\".\nlist2CommaSeparatedString[x], where x is an atom returns a string \"x\".\nOptions:\ncomma\[Rule]string means use the designated string as a comma, e.g.,\nlist2CommaSeparatedString[{x1,x2,x3},comma->\";\"]\n returns \"x1;x2;x3\". ";


NDSolveSBMLModel::usage="NDSolveSBMLModel[model, tmax, options] evaluates NDSolve on an SBML model, where model is the ouptput of getSBML, tmax is the duration of the NDSolve run, and options are any valid options for NDSolve";


printWarning::usage="printWarning[x_] prints x as a warning message using the global attribuites Warning$Color as \">>Waring:: x\".\nprintWarning[test, x] prints x as a waring message only if test is True.";


printTable::usage="printTable[data] prints data in TableForm.\nOptions are:\ntitle->sting title of table\ncolumnHeaders->{h1,h2,...} where h1,h2 are strings to be printed at the top of each column. The number of column headers must be the same number as the number of columns in the table";


reactionForm::usage="reactionForm[{rn1,rn2,...}, {rs1,rs2,...},{pn1,pn2,...},{ps1,ps2,...}] returns a string of the form \nrs1*rn1+rs2*rn2 +... \[Rule]  ps1*p11 + ps2*pn2 + ...\nHere rni,pni refer to the reactant and product names and rsi and psi refer to the reactant and product stoichiometries. Stoichiometries may be fractional or symbolic.Thus reactionForm[{A,B,C},{1,2,1},{F,Q},{3/5,2}] returns \"A + 2B + C \[Rule] (3F)/5 + 2Q\". If the reaction is reversible, the arrow \[RightArrowLeftArrow] (\ [RightArrowLeftArrow] )is used instead of \[Rule] ( ->) ";


removeUnderscore::usage="removeUnderscore[x], where x is a string, returns a string identical to x with all occurences of the underscore character \"_\" replaced with the value of the global string $SBML$Underscorecharacter (the default value is the \\[UnderBracket] or \[EscapeKey]u[\[EscapeKey] character \"\[UnderBracket]\").\nremoveUnderscore[x, replaceWith\[Rule]char replaces the underscore with the specified character or character string.\nIf x is not a string it is converted to a string.\nA string value is always returned.";


If[$$LoadBug, Print["Loading:private functions"]];



Contexts2IgnoreCollisions={};
IgnoreCollisions[context_]:= AppendTo[Contexts2IgnoreCollisions,context];
IgnoreCollisions[]:= (Contexts2IgnoreCollisions={}); 
IgnoreCollisions["Global`"];

previouslyDefinedNamesInTheMathematicaEnvirnoment=Names["*"];
previouslyDefinedContextsInTheMathematicaEnvironment=Contexts[];

checkForSybmolCabollision[var_?StringQ]:= checkForSymbolCollision[var,"symbol"];
checkForSymbolCollision[var_?StringQ,type_?StringQ]:=Module[{u,contexts},
contexts=Complement[previouslyDefinedContextsInTheMathematicaEnvironment,Contexts2IgnoreCollisions];

If[MemberQ[previouslyDefinedNamesInTheMathematicaEnvirnoment,var], 
If[MemberQ[contexts,Context[var]],
Print["Warning: "//boldRed, "The "//boldBlack,type<>" "//boldBlack,var//boldBlue," may collide with the previously defined symbol "//boldBlack,Context[var]<>var//boldRed, " and cause unexpected results."//boldBlack];

u=ToExpression[var<>"::usage"];
If[StringQ[u],
If[StringLength[u]>80, u=StringTake[u,75]<>"... (use ?"<>var<>" for more information)."];
 Print[MyStyle[u,FontColor-> Purple]]];
]; 
];
]; 


If[$$LoadBug, Print["Loading:private: File-checking functions"]];


fileExists[fname_, opt___?OptionQ]:= Module[{f},
f = If[StringQ[fname], fname, ToString[fname]];
Return[Length[FileNames[f, opt]]>0];
];


validInputFile[in_?StringQ]:= Module[{ok},
ok = fileExists[in];

If[!ok,
Print[boldOrange["Error: "],
boldRed["The requested input file: \""],
boldBlack[ in ], 
boldRed["\" does not exist. No file read."]
];
]; 
Return[ok];
];
validInputFile[x___]:= Print[boldOrange["Error:"],boldRed[" the argument to validInputFile must be a string."]];



availableOutputFile[out_?StringQ]:= Module[{ok,fn},
ok=!fileExists[out, IgnoreCase-> True];
If[!ok,
fn = FileNames[out, IgnoreCase-> True];
If[MemberQ[fn,out], 
Print[boldRed["Error: "],
boldBlack["The requested output file: "],
boldBlue[ out ], 
boldBlack[" already exists. No file written."]
];
,
Print[boldRed["Error: "],
boldBlack["The requested output file: "],
boldBlue[ out ], 
boldBlack[" is similar in name to the existing file: "],
boldBlue[First[fn]],
boldBlack[". No file written."]
];
]; 
]; 
Return[ok];
]; 
availableOutputFile[x___]:=Print[boldRed["Error:"],boldBlack[" the argument to availableOutputFile must be a string."]];


validateOutputFileName[out_?StringQ]:= Module[{ok,fn,vout,itry,maxtry=100000, dot,front,rear,debug=False},
vout = out;
ok=!fileExists[vout, IgnoreCase-> True];
If[debug, Print["validateOutputFileName: ok:",ok]]; 
If[ok, Return[out]];
itry=1;
dot=StringPosition[out,"."];
If[debug, Print["validateOutputFileName: dot:",dot]]; 
If[Length[dot]>0,
dot=First[Last[dot]];
front = StringTake[out,dot-1];
rear = StringDrop[out,dot];
,
front=out;
rear="";
];
If[debug, Print["validateOutputFileName: {front,rear}:",{front,rear}]]; 

While[!ok \[And] itry<maxtry,
vout = front<>ToString[itry]<>"."<>rear;
ok=!fileExists[vout, IgnoreCase-> True];
itry++;
];
If[debug, Print["validateOutputFileName: vout:",vout]]; 

If[ok,

Print[boldRed["Warning: "],
boldBlack["The requested output file: "],
boldBlue[ out ], 
boldBlack[" already exists. The following file name was used instead: "], boldBlue[vout]
];
Return[vout];
];
Print[boldOrange["Error: "],
boldBlack["Unable to create the file: "],
boldBlue[ out ]];
Return["$Failed"];
]; 


(* If[$$LoadBug, Print["Loading:checkForFullInstallation"]]; *)


(* $SBMLValidatorInstalled=False;
$SBMLValidate=Indeterminate;
checkForFullInstallation:= Block[{base=$UserBaseDirectory,f, checkfor, ok},

checkfor[q_]:= Module[{ok}, 
ok=fileExists[q];
If[!ok, Print["Warning: ",q," not installed."]];
Return[ok];
];
f=ToFileName[base,"Applications"];
checkfor[f];

(* check for SBMLValidator Installation *)

f=ToFileName[f,"SBMLValidator"];
If[!fileExists[f], 
checkfor[f];
,
ok=checkfor[ToFileName[f,"SBMLValidator.class"]] \[And]
checkfor[ToFileName[f,"MultipartPost.class"]];
If[ok,
InstallJava[];
AddToClassPath[f];
$SBMLValidatorInstalled=True;
$SBMLValidate=JavaNew["SBMLValidator"]
];
];
];

checkForFullInstallation; *) 



(* If[$$LoadBug, Print["Loading:SBMLValidate"]]; *)


(* SBMLValidate[file_]:=SBMLValidate[file,"text"];
SBMLValidate[file_,format_?StringQ]:=Module[{ok},

If[$SBMLValidatorInstalled,
ok=fileExists[file];

If[!ok, 
Print["Error: unable to find ",file];
Return[Indeterminate];
];


Switch[format,
"text",
ok=$SBMLValidate@validateSBML[file,format];,

"xml",  
ok=$SBMLValidate@validateSBML[file,format];
ok=ImportString[ok,"xml"];
,
_, Print["Warning: SBMLValidate: requested format ",format," not recognized - valid formats are \"xml\",\"text\""];
ok=Indeterminate;
];

Return[ok];
];
Print["Error: one or more validator components are not installed. An error message indicating the missing component should be displayed when you load MathSBML."];
checkForFullInstallation;
] *)


checkOptions[module_, {requestedoption__}, allowedoptions_]:= Module[{req},
req = {requestedoption}//Flatten;
Apply[
And,
checkOptions[module,#,allowedoptions]&/@req
]];
checkOptions[module_,requestedoption_, allowedoptions_]:= Module[{allowedopts,requestedopt},

allowedopts = Flatten[{allowedoptions}]; 
allowedopts = Map[If[OptionQ[#], First[#], #]&, allowedopts];
allowedopts = stringer/@allowedopts;

requestedopt=requestedoption;
If[requestedopt=={}, Return[True]];
If[OptionQ[requestedopt], requestedopt=First[requestedopt]]; 
requestedopt=stringer[requestedopt];

If[MemberQ[allowedopts, requestedopt], Return[True]];
Print["Warning: "//boldRed,requestedopt//boldBlue," is not an option for "//boldBlack,module// boldBlue," -- "," allowed options are: "//boldBlack, list2CommaSeparatedString[allowedopts]//boldBlue ];
Return[False];
];



If[$$LoadBug, Print["Loading:XMLOut"]];


XMLOut[symbolicXML_]:= sunderscore[ExportXMLString[symbolicXML]];


makeString[x_?StringQ]:= x;
makeString[x_]:= ToString[InputForm[x]];


boldRed[x_]:= MyStyle[x, FontColor-> RGBColor[1,0,0], FontWeight->"Bold"];
 
boldOrange[x_]:= MyStyle[x, FontColor-> RGBColor[1,0.5, 0],FontWeight-> "Bold"];boldBlue[x_]:= MyStyle[x, FontColor-> RGBColor[0, 0, 1], FontWeight->"Bold"]; 
boldBlack[x_]:= MyStyle[x, FontColor-> GrayLevel[0], FontWeight-> "Bold"];
boldGray[x_]:= MyStyle[x, FontColor-> GrayLevel[0.5], FontWeight-> "Bold"]; 
boldGreen[x_]:= MyStyle[x, FontColor-> RGBColor[.2,0.9,.6], FontWeight-> "Bold"]; 
hiBlackOnYellow[x_]:= MyStyle[x, Background-> \!\(\*
TagBox[
StyleBox[
RowBox[{"RGBColor", "[", 
RowBox[{"1", ",", "1", ",", "0"}], "]"}],
ShowSpecialCharacters->False,
ShowStringCharacters->True,
NumberMarks->True],
FullForm]\),FontColor-> GrayLevel[0], FontWeight-> "Bold"];
hiRedOnYellow[x_]:= MyStyle[x, Background-> \!\(\*
TagBox[
StyleBox[
RowBox[{"RGBColor", "[", 
RowBox[{"1", ",", "1", ",", "0"}], "]"}],
ShowSpecialCharacters->False,
ShowStringCharacters->True,
NumberMarks->True],
FullForm]\),FontColor->RGBColor[1,0,0], FontWeight-> "Bold"];


stringulate[s_?StringQ]:= s;
stringulate[s_?ListQ]:= stringulate/@s;
stringulate[s_]:= ToString[InputForm[s]];


cpuPush[]:= Module[{},
$SBML$CPU= Prepend[$SBML$CPU, TimeUsed[]]; 
];
cpuPop[]:= Module[{f},
f=First[$SBML$CPU]; 
$SBML$CPU=Rest[$SBML$CPU];
Return[f]; 
];
cpuGet[]:=Module[{}, If[$SBML$ReportCPU, Return[TimeUsed[]-cpuPop[]], Return[0.0]]];

cpuSet[]:= If[$SBML$ReportCPU, cpuPush[]]; 
cpuReport[msg_]:= Module[{c},
If[$SBML$ReportCPU,
c= cpuPop[];
Print[">>>CPU = ",TimeUsed[]-c," ", msg]; 
];
]; 


cpuObserver[msg_]:= Module[{},
If[$CPU$Trace,
$CPULast=$CPU;
$CPU=TimeUsed[];
Print[$CPU-$CPULast," Seconds for ",msg];
];
];


saveCPU[]:= Module[{},
$CPU$Last$Saved=$CPULast;
$CPU$Saved = $CPU;
];
retrieveCPU[]:= Module[{},
$CPULast=$CPU$Last$Saved;
$CPU=$CPU$Saved;
];


If[$$LoadBug, Print["Loading:resetSBMLGlobals"]];


resetSBMLGlobals[]:= Module[{},
$SBML$modelcount=0; 
$SBML$SessionWarnings = 0; 
$SBML$SessionStartTime=TimeUsed[];
$SBML$CompartmentNames={};
$SBML$CompartmentVolumes={};
$SBML$CompartmentUnits={};
$SBML$CompartmentOutsides={};
$SBML$FrozenVariables = {};
$SBML$Algebraic$Rules={};
$SBML$Constraints={};
$SBML$InitialAssignments={};
$Compartment$ID = "";
$Species$ID = "$";
$SBML$warnings=True;
];


If[$$LoadBug, Print["Loading:preprocessSBML"]];


preprocessSBML[sbml_]:= Module[{m, myrule, myXMLElement},
(* remove underscores in rules of the form string1-> string2 *)
myrule[x_?StringQ, y_?StringQ]:= Module[{x1,y1},
x1 = StringReplace[x, {"_"-> MathSBML`Private`$SBML$Underscorecharacter}];
y1 = StringReplace[y, {"_"-> MathSBML`Private`$SBML$Underscorecharacter}];
Return[x1-> y1];
];
myrule[x_,y_]:= Rule[x,y];

myXMLElement[x_, y_,z_]:= Module[{x1, z1},
x1 = StringReplace[x, {"_"-> MathSBML`Private`$SBML$Underscorecharacter}];

z1 = 
Map[If[StringQ[#], StringReplace[#, {"_"-> MathSBML`Private`$SBML$Underscorecharacter}],#]&,z];
Return[XMLElement[x1, y, z1]];
];
myXMLElement[x___]:= XMLElement[x]; 


m = sbml/.{Rule-> myrule};
m = m/.{XMLElement-> myXMLElement};

(*7-27-2004: 2.3.31: *) 

m = fixXMLeNotation[m]; 

m=itemcheck[m,"math"];
Return[m];
];

itemcheck[m_, item_]:= Module[{sbml, XMLStuff,XMLObj, mathrule, myrule, mprime,debug},
debug=False;

If[debug, Print["dbg:itemcheck: ",item]]; 

XMLStuff["sbml", a_, b_]:= {a};
XMLStuff[a___]:= {};
XMLObj["Document"][{declaration_},stuff_, morestuff_]:= {stuff};
myrule[{xmlns_,item},mathns_]:= {mathns};
myrule[{xmlns_, anythingelse_}, otherns_]:= {};
myrule[other_,stuff_]:= {}; 

sbml=m/.{XMLElement-> XMLStuff, XMLObject-> XMLObj};
sbml=Flatten[sbml];

mathrule=sbml/.{Rule->myrule};
mathrule= Flatten[mathrule];


Clear[XMLStuff];
mprime=m;
If[Length[mathrule]>0,
Block[{nextmath,restmath},
restmath=mathrule;
While[Length[restmath]>0,
nextmath=First[mathrule];
restmath=Rest[restmath];
If[debug, Print["dbg:itemcheck: checking ",nextmath]];

(* For each {xmlns, "math"}->mathmlns, replace all XMLElement[{xmlns,operator}...] with the XMLElement[operator,...] itself
*)

XMLStuff[{nextmath, y_},x___]:= XMLElement[y, x];
XMLStuff[z___]:= XMLElement[z];

mprime = mprime/.{XMLElement-> XMLStuff};

];
];
]; 
Return[mprime];

];


If[$$LoadBug, Print["Loading:fixXMLeNotation"]];


fixXMLeNotation[xml_]:= Module[{myxml,f},

f["cn",{"type"->"e-notation"},{mantissa_,XMLElement["sep",{},{}],exponent_}]:=Module[{man, exp,fxml},
man = Xpression2SymbolicMathML[ToExpression[mantissa]][[3,1]];

exp = Xpression2SymbolicMathML[ToExpression[exponent]][[3,1]];

fxml = XMLElement["apply",{},{XMLElement["times",{},{}],XMLElement["apply",{},{XMLElement["power",{},{}],XMLElement["cn",{"type"->"integer"},{"10"}],exp}],man}];
Return[fxml];
];
f[x___]:= XMLElement[x];

myxml = xml/.{XMLElement-> f};
Return[myxml];
]


If[$$LoadBug, Print["Loading:postprocessSBML"]];


postprocess[sbml_]:= Module[{m, myrule, myXMLElement},
(* remove underscores in rules of the form string1-> string2 *)
myrule[x_?StringQ, y_?StringQ]:= Module[{x1,y1},
x1 = StringReplace[x, {MathSBML`Private`$SBML$Underscorecharacter-> "_"}];
y1 = StringReplace[y, { MathSBML`Private`$SBML$Underscorecharacter-> "_"}];
Return[x1-> y1];
];
myrule[x_,y_]:= Rule[x,y];

myXMLElement[x_, y_,z_]:= Module[{x1, z1},
x1 = StringReplace[x, {MathSBML`Private`$SBML$Underscorecharacter-> "_"}];

z1 = 
Map[If[StringQ[#], StringReplace[#, { MathSBML`Private`$SBML$Underscorecharacter-> "_"}],#]&,z];
Return[XMLElement[x1, y, z1]];
];
myXMLElement[x___]:= XMLElement[x]; 


m = sbml/.{Rule-> myrule};
m = m/.{XMLElement-> myXMLElement};

Return[m];
];


If[$$LoadBug, Print["Loading:getSBML"]];


Options[getSBML]={verbose-> True};
getSBML[file_,opt___?OptionQ]:= Module[{s1,s,sbml,filename, sbmloptions,level,version,cpu,hf,dbg=False},
If[dbg, Print["getSBML: file:"//boldRed,file//boldBlue]];
hf = stringer[Head[file]];
hf = StringReplace[hf,"\""-> ""]; 
Switch[hf (* stringer[Head[file]]*)      ,
"String",
If[!fileExists[ file],
Print["Error: "//boldRed,"The file "//boldBlack,file//boldBlue," does not exist."//boldBlack];
Abort[];
];
s1 = Import[file,"XML"]; filename=file;,
"XMLObject[Document]",s1=file;filename="Internal Model";,
_, Print["Error: "//boldOrange," SBMLRead: first argument must be either a file name or Symbolic Obj SBML."//boldBlack];
Abort[];
];
s = preprocessSBML[s1]; 
cpuObserver["Import"];
dbg=Global`debug/.{opt}/.{Global`debug-> False};

sbml = Cases[s,XMLElement["sbml",___],3]; 
If[dbg, Print["getSBML:sbml:",sbml]];
cpuObserver["sbml/Cases"];

abortIfNoTag[sbml, "sbml"];

cpuObserver["abortIfNoTag"];

sbml = {First[sbml]}; (* ignore multiple sbml *) 
sbmloptions = extractXMLOptions[First[sbml]];
{level,version} = determineSBMLVersion[sbmloptions];

If[dbg, Print["getSBML: Level,Version=",level,",",version]];


(* need to figure out model id & name here as well *)
(* move this to getSBMLlevel2 *)
(*
If[level>1,
If[MB$Load, 

newModel[Global`level-> level,Global`version-> version, Global`echo-> MB$Echo];
MB$SBMLAnnotation=getAnnotations[sbml]//Flatten; 
MB$SBMLNotes=getNotes[sbml]//Flatten;

];
,
MB$Load=False;
]; 
If[dbg, Print["getSBML:MB$Load:",MB$Load,", MB$SBMLNotes:",MB$SBMLNotes ]];
*)





cpuObserver["determineVersion"];

Switch[level,
1,
Switch[version,

1,Return[getSBMLlevel1[sbml,filename, opt]],

2,Return[getSBMLlevel1[sbml,filename, opt]],

(* other versions of level 1 *) 
_, 
Print["SBML Level ", level , " version ",version," is not currently supported."];Abort[];
];
(* end of level 1 *)
,
2,
If[dbg, Print["getSBML:Calling getSBMLLevel2:" ]];
Switch[version,

1,Return[getSBMLlevel2[sbml,filename, opt]],

2,Return[getSBMLlevel2[sbml,filename, opt]],

3,
Return[getSBMLlevel2[sbml,filename, opt]],

(* other versions of level 2 *) 
_, 
Print["Error: MathSBML: "//boldRed, "SBML Level "//boldBlack, level//boldBlue , " version "//boldBlack,version//boldBlue," is not currently implemented in MathSBML."//boldBlack];Abort[];
];
(* end of level 2 *)

,
(* other levels *) 

_, Print["Error: MathSBML:"//boldRed, "SBML Level "//boldBlue,level//boldBlue," is not currently supported."//boldBlack]; Abort[];

];

Print["Error: MathSBML: "//boldRed, "SBML version "//boldBlack, version//boldBlue, " is not currently implemented in MathSBML."//boldBlack];
]


getSBMLNotes[sbml_]:=Module[{},
$SBML$Notes =Cases[sbml,XMLElement["notes",___],5];
If[Length[$SBML$Notes]>0, 
$SBML$Notes= $SBML$Notes//First//extractXMLSubElements];
If[Length[$SBML$Notes]>0, $SBML$Notes=First[$SBML$Notes]];
];



getSBMLlevel1[sbml_,filename_, opt___?OptionQ]:= Module[{ models, modeloptions,modelnames,modelName,   statistics, importedModel,modelCounterString, numericalSolution
},
dbg = $SBML$debug;


$SBML$UnitAssociations={};
$SBML$ODES={};
$SBML$SpeciesCompartmentAssociations={};

debugPrint[dbg,"SBML level.version = ", $SBML$Level$Version ];
If[$SBML$printModelName,
modelCounterString=" ********** Model "<>ToString[$SBML$modelcount]<>" ********** \n",
modelCounterString="";
];
If[saveVerboseData,
 verboseSave[modelCounterString<>"File Name:"<> filename<>"\nSBML Level "<>ToString[$SBML$Level]<>" Version "<>ToString[$SBML$Version],
{},{}];
]; 
getSBMLNotes[sbml]; 
 
(***** Models *****)
cpuSet[]; 

models = Cases[sbml,XMLElement["model",___],3]; 
cpuReport["models"];


abortIfNoTag[models, "model"];
modeloptions = Map[extractXMLOptions,models];
modelnames=Map["name"/.#/.{"name"-> "Unnamed\[UnderBracket]Model"}&, modeloptions];
printWarning[Length[modelnames]>1,
"Only one model is permitted; additional models ignored."];


modelname = First[modelnames] // removeUnderscore;

If[saveVerboseData, 
verboseSave["Model: "<>modelname, {}, {}];
]; 

debugPrint[dbg,"getSBML:: modelname:",modelname];

setModelContext[modelname];

models={First[models]};
$SBML$Models = models; 

(***** Units *****)
cpuSet[];
getSBMLunits[opt];
cpuReport["units"];

(***** Compartments *****)
cpuSet[];
getSBMLcompartments[opt];
cpuReport["compartments"];

(***** Species *****)
cpuSet[];
getSBMLspecies[opt]; 
cpuReport["species"];

(***** Parameters *****)
cpuSet[];
getSBMLparameters[opt];
cpuReport["parameters"];

(***** Rules *****)
cpuSet[];
getSBMLrules[opt];
cpuReport["rules"];


(***** Reactions *****)
cpuSet[];
getSBMLreactions[opt];
cpuReport["reactions"];

If[$SBML$verbose, verbosePrint[]]; 

(* reportUnassignedParameters[];
reportMisingIC[]; *) 
printStatistics[];
 

$SBML$UnitAssociations = Select[$SBML$UnitAssociations, ToString[Last[#]]!= ToString[$SBML$IndeterminateValue]&];


importedModel = {};



If[SBMLRead$return,

If[SBMLRead$returnODES, importedModel=Append[importedModel,Global`SBMLODES-> $SBML$ODES]];

If[SBMLRead$returnContext, importedModel=Append[importedModel,Global`SBMLContext-> $SBML$Context]];


If[SBMLRead$returnIC, importedModel=
Append[importedModel,
Global`SBMLIC->ToExpression[initialize[SBMLVariables]]
]];

If[SBMLRead$returnConstants, importedModel=Append[importedModel,Global`SBMLConstants->(SBMLReplacementRules)]];

If[SBMLRead$returnSpecies, importedModel=Append[importedModel,
Global`SBMLSpecies->functionate[$SBML$Species$IDs]
]];

If[SBMLRead$returnGlobalParameters, importedModel=Append[importedModel,
Global`SBMLParameters->SBMLGlobalParameters
]];

If[SBMLRead$returnModelVariables, importedModel=Append[importedModel,
Global`SBMLModelVariables->ToExpression[functionate[SBMLVariables]]
]];

If[SBMLRead$returnAlgebraicRules, importedModel=Append[importedModel,Global`SBMLAlgebraicRules-> $SBML$Algebraic$Rules]];

If[SBMLRead$returnUnitDefinitions, importedModel=Append[importedModel,Global`SBMLUnitDefinitions-> $SBML$UnitRules]];

If[SBMLRead$returnUnitAssociations, importedModel=Append[importedModel,Global`SBMLUnitAssociations-> $SBML$UnitAssociations]];

If[SBMLRead$returnReactions, importedModel=Append[importedModel,Global`SBMLReactions-> $SBML$Reactions]];

If[SBMLRead$returnModelName,
importedModel = Append[importedModel,Global`SBMLModelName-> modelname];
];

If[SBMLRead$returnCompartments,
importedModel = Append[importedModel,
Global`SBMLCompartments->( ToExpression/@$SBML$CompartmentNames)];
]; 

If[SBMLRead$returnSpeciesCompartmentAssociations,
importedModel = Append[importedModel,Global`SBMLSpeciesCompartmentAssociations-> $SBML$SpeciesCompartmentAssociations];
];

If[SBMLRead$returnSolution>0, 
numericalSolution = SBMLNDSolve[importedModel, SBMLRead$returnSolution,
Sequence[SBML$NDSolveOptions]
]; 
importedModel = Append[importedModel, Global`SBMLNumericalSolution-> numericalSolution];
];

];

importedModel=Append[importedModel, Global`SBMLLevelVersion-> ToExpression[$SBML$Level$Version]];
importedModel=Sort[importedModel];
Return[importedModel];
];


If[$$LoadBug, Print["Loading:setModelContext"]];


(* If[Length[Names["PreviousModelContexts"]]>0,
PreviousModelContexts=Flatten[{PreviousModelContexts}],
PreviousModelContexts={};
];
*) 
PreviousModelContexts={};

setModelContext[name_]:= Module[{},
If[$SBML$Context=="Automatic",
$SBML$Context=name<>"`",

If[StringTake[$SBML$Context,-1]!= "`", 
$SBML$Context=$SBML$Context<>"`"
];


];
If[$SBML$Context=="None`", 
$SBML$UnitsContext="Units`", 
$SBML$UnitsContext=$SBML$Context<>"Units`"
];

PreviousModelContexts=Union[AppendTo[PreviousModelContexts,$SBML$Context]];

]; 


If[$$LoadBug, Print["Loading:printStatistics"]];


printStatistics[]:= Module[{},
If[$SBML$Stats,
statistics = {
{"Compartments",$SBML$NCompartments},
{"Species",Length[SBMLVariables]},
{"ODES",Length[$SBML$ODES]},
{"Global Parameters", $SBML$NGlobalParameters},
{"Local Parameters",$SBML$NLocalParameters},
{"Rules",$SBML$NRules},
{"Reactions",$SBML$NReactions}

};

If[$SBML$Level>1, 
statistics = Append[statistics,
{"Events",$SBML$NEvents}];
];
statistics = Join[statistics,{{"CPU Used",TimeUsed[]-$SBML$InitialCPU},
{"Warnings", $SBML$FileWarnings}}];

printTable[statistics,title-> "File Statistics",columnHeaders->{"Description","Value"}];
];
];


If[$$LoadBug, Print["Loading:determineSBMLVersion"]];


determineSBMLVersion[{opt___}]:= Module[{lev,ver,options,xmlns,expectedXMLNS,
$XMLNS={"http://www.w3.org/2000/xmlns/","xmlns"}
},
options = Flatten[{opt}];
lev = "level"/.options/.{"level"-> "0"}//ToString//ToExpression;
ver = "version"/.options/.{"version"-> "0"}//ToString//ToExpression;


$SBML$Level = lev;
$SBML$Version=ver;
$SBML$Level$Version = ToString[$SBML$Level]<>"."<>ToString[$SBML$Version];

Switch[$SBML$Level$Version,
"1.1",expectedXMLNS="http://www.sbml.org/sbml/level1";,
"1.2",expectedXMLNS="http://www.sbml.org/sbml/level1";,
"2.1",expectedXMLNS="http://www.sbml.org/sbml/level2";,
"2.2",expectedXMLNS="http://www.sbml.org/sbml/level2/version2";,
"2.3", expectedXMLNS="http://www.sbml.org/sbml/level2/version3";,
_,expectedXMLNS="??-UNKNOWN-NAMESPACE-Level-"<>stringer[$SBML$Level]<>"-Version-"<>stringer[$SBML$Version]<>"-??";
]; 

xmlns =$XMLNS/.options/.{$XMLNS->expectedXMLNS};

If[xmlns!= expectedXMLNS,
Print["Error: "//boldRed,
"Specified Namespace = "//boldBlack,"'"<>xmlns<>"'"//boldBlue, "is not consistent with SBML Level "//boldBlack, $SBML$Level//boldBlue, " Version "//boldBlack, $SBML$Version//boldBlue,"\nThe correct namespace is "//boldBlack,
"'"<>expectedXMLNS<>"'"//boldBlue
]];

Return[{lev,ver}];
]


reportMisingIC[]:= Module[{variablesWithoutIC},

variablesWithoutIC = 
Select[SBMLVariables,SBMLIC[#]==ToString[$SBML$IndeterminateValue]&];

If[Length[variablesWithoutIC]>0, 
If [$SBML$UseDefaultIC, 
printWarning["The following variables do not have initial conditions: "<>list2CommaSeparatedString[variablesWithoutIC]<>". They have  been assigned a default value of "<>$SBML$DefaultIC];

Map[definef[SBMLIC,#,ToString[$SBML$DefaultIC]]&, variablesWithoutIC];


,
printWarning["The following variables do not have initial conditions: "<>variablesWithoutIC<>". A default value may be assigned using the option defaultIC."];

]; 
]; 
Return[];
]


reportUnassignedParameters[]:= Module[{},

If[Length[SBMLUndefinedConstants]>0,

If[$SBML$UseDefaultParameterValue,
printWarning["The following parameters were not defined in the model: "<>list2CommaSeparatedString[SBMLUndefinedConstants]<>". These parameters were assigned a default value of "<>$SBML$DefaultParameterValue];

,printWarning["The following parameters were not defined in the model: "<>list2CommaSeparatedString[SBMLUndefinedConstants]<>". You can use the option defaultParameterValue to define a global default value."];
];
]; 



];


If[$$LoadBug, Print["Loading:definef"]];


definef[f_,x_,value_]:= Module[{debug=False, useval},
useval = value;
If[f===SBMLIC \[And] stringer[decontextify[ x ]]== "t"  \[And] value=="Indeterminate", 
useval = "0"
]; 

If[debug, Print["definef: {f, x, value}:", {f, x, useval}]];

f[x]=useval
];


ReplaceRuleListPart[opt_-> value_, oldOptList_]:= Module[{old,i,new},
old = Flatten[{oldOptList}]; 
i = Flatten[Position[First/@old, opt]]; 
If[Length[i]>0, 
i = First[i]; 
new = ReplacePart[old, opt-> value, i];
,
new = Append[old, opt-> value];
]; 
Return[new];
];


If[$$LoadBug, Print["Loading:getSymbols"]];


getSymbols[exp_]:= Module[{v,expr,myxml, dbg=False},

expr=exp;
If[StringQ[expr],expr=ToExpression[expr]];

myxml["ci",{___},{x_}]:= x;
myxml["csymbol",___]:= {}; 

myxml[_, {___}, {z___}]:= {z};


v =Xpression2SymbolicMathML[expr];

If[dbg, Print["getSymbols: v(1):", v]]; 

v =ToExpression/@(( v/.{XMLElement-> myxml})//Flatten//Union);
v = Select[v, !(NumberQ[#])&];
v=Complement[v,{If}];

If[dbg, Print["getSymbols: exp: ", exp, " v: ", v]; 
]; 

Return[v];
];


getInterpolatingFunction[InterpolationSet[t1_, t2_, if_]]:= if;


NDSolveSBMLWithEvents[inputSystem_, tmax_,ievents_,iconstraints_, opt___?OptionQ]:= Module[{modelvariables, r,ic,vars,triggeredvars,dbg=True,n="Not Implemented", triggers,test, tevent,triggeredEvents,t,tstart,tstop,actions,triggeredActions,nonTriggeredVars,solution,ievent,triggeredNames, eventNames,trace,delays,triggeredDelays,badeventdt,iclose,dtevent, values, eventLast,maxclose,maxevents,fs,triggeredValues,delayed,currentDelayValues,remappedEvents, events,eventflags,delayedNames,delayAmounts,havedelays,delayedActions,currentlyDelayedActions,savedEvents,newEvents,constants,flagvariables,
icalready,ic2use,ic4flags,constraints,triggeredConstraints,constraintMessages,
interpolateForEventTime,intInterval, remapEvents, updateEvents, constraintsToEvents
},

dbg = Global`debug/.{opt}/.{Global`debug-> False};
If[dbg, Print["NDSolveSBMLWithEvents:events:",ievents];
Print["NDSolveSBMLWithEvents:constraints:",iconstraints];
];

flagvariables={};

trace = (Global`trace/.Flatten[{opt}])/.{Global`trace-> False};
maxevents = (Global`MaxEvents/.Flatten[{opt}])/.{Global`MaxEvents-> 100};
maxclose=(Global`MaxCloseEvents/.Flatten[{opt}])/.{Global`MaxCloseEvents-> 10};
eventLast=-Infinity;
badeventdt =(Global`BadEventTimePrecision)/.Flatten[{opt}]/.{Global`BadEventTimePrecision->10.^-7};

ievent=0;iclose=0;
r = inputSystem;
solution={};
n={};
fs = Global`SBMLFunctions/.r;
constants = Global`SBMLConstants/.r; (* added 2.5.13 4 May 06 *) 

If[dbg,
 Print["NDSolveSBMLWithEvents:"//boldBlue," ievents: "//boldOrange,ievents//boldBlue]; Print["NDSolveSBMLWithEvents:"//boldBlue," fs: "//boldOrange,fs//boldBlue];
 Print["NDSolveSBMLWithEvents:"//boldBlue,
" r (input): "//boldOrange,r//boldBlue]; 

]; 

constraintsToEvents[constraints_]:= Module[{events,dbg=False,i, constraintToEvent},

If[ToExpression[$SBML$Level$Version]<2.2, Return[{}]]; 
i=0;

If[dbg,Print["constraintsToEvents: "//boldBlue,"constraints: "//boldBlack, constraints//boldRed]];

constraintToEvent[c_]:= Module[{event,trigger,eventID},
trigger =First[c];
If[dbg, Print["constraintToEvent: trigger: ", trigger]]; 
 trigger=stringer[trigger]; 
i++;
eventID="Constraint\[UnderBracket]"<>ToString[i]<>"\[UnderBracket]$Violation"//contextify;
event=(eventID-> {"trigger"-> trigger,"delay"-> "0","events"-> {}});
Return[event];
];(* end of constraintToEvent *)

events = constraintToEvent/@constraints;

If[dbg,Print["constraintsToEvents: "//boldBlue,"mapped events: "//boldBlack, events//boldRed]];


Return[events];

];(* end of constraintsToEvents *)


(* Replace SBML Events with Mathematica Events defined as follows (rev. 10/28/04 2.4.3)

Each event e in E has a trigger expression Te and assignments Ae.
For each event e we create in mathematica 
(1) a variable Ve with initial value false
(2) a mathematica event with trigger (NOT Ve) AND Te and assignments Ae and Ve=true 
(3) a mathematica event with trigger Ve AND (NOT Te) and assignment Ve=false

*) 

remapEvents[evlist_,currentTime_]:= Module[{remapEvent, i,nev,flags, updatedEvents,ic,vars,odes,initialFlagVals},
If[dbg, Print["remapEvents:evlist:",evlist]]; 
i=0; 
(* nev=Length[evlist]; *) 
flags={};

remapEvent[evid_-> evdata_]:= Module[{tr,tr1,tr2,
de,ev,ev1, ev2,op, flag,ev1n,ev2n, new,delayedevents},
op = {evdata}//Flatten;
tr=ToExpression["trigger"/.op ];
de = "delay"/.op;
ev = "events"/.op;
If[stringer[de]!= "0", 
delayedevents=ev;
ev={},
delayedevents={}];


flag = Symbol[stringer[evid]<>"\[UnderBracket]$flag"];
flags = Append[flags, flag];
AppendTo[flagvariables, functionate[flag]];

ev1n=stringer[evid]<>"\[UnderBracket]$eventSet";
(* AppendTo[flagvariables, Symbol[functionate[ev1n]]]; *)

tr1=stringer[And[flag[Global`t]<0,tr]];
ev1 = Append[ev, stringer[flag[Global`t]-> 1]];
ev1 = {"trigger"-> tr1,"delay"-> de,"events"-> ev1,"delayedevents"-> delayedevents};

ev2n=stringer[evid]<>"\[UnderBracket]$eventReset";
(* AppendTo[flagvariables, Symbol[functionate[ev2n]]]; *)

tr2=stringer[And[flag[Global`t]>0, Not[tr]]];
ev2 = {stringer[flag[Global`t]-> -1]};
ev2 = {"trigger"-> tr2, "delay"-> "0", "events"-> ev2,"delayedevents"-> {}};

new = {ev1n-> ev1, ev2n-> ev2};
Return[new]; 
]; 
remapEvent[x___]:= Module[{},Print["Error:"//boldOrange, " remapEvent:"//boldRed," invalid input data format: "//boldBlack,{x}//boldRed];
Abort[];
];

(* end of remapEvent *) 


updatedEvents = remapEvent/@evlist;
updatedEvents = Join@@updatedEvents;

(* new initial values for event flags: save preset values, and assign -1 to new flags *)

eventflags = stringer/@flags; 
initialFlagVals = (SBMLIC/@eventflags);
initialFlagVals=initialFlagVals/.{"Indeterminate"-> "-1"};
MapThread[definef[SBMLIC, #1, #2]&, {eventflags,initialFlagVals}]; 

If[dbg, Print["remapEvents:",eventflags,initialFlagVals]; ]; 

(* add variable, IC values for eventflags *)

modelvariables=Global`SBMLModelVariables/.r ;
modelvariables=Global`SBMLModelVariables/.inputSystem;

(* of existing ic, use only those from the model, not for the flags *)

icalready=Global`SBMLIC/.r;
ic2use=Select[icalready,MemberQ[Head/@modelvariables,Head[First[#]]]&];

(* assign new ic for flags based on values found above *)
ic4flags=MapThread[
(( #1[currentTime]==#2)&), {flags, ToExpression/@initialFlagVals}];

ic = Join[ic2use,ic4flags];

r=ReplaceRuleListPart[Global`SBMLIC-> ic,r];


vars = Join[modelvariables,(#[Global`t])&/@flags];
r = ReplaceRuleListPart[Global`SBMLModelVariables-> vars, r];

If[dbg, Print["SBMLIC/.input:",Global`SBMLIC/.inputSystem,
"\nSBMLIC/.r (new):",Global`SBMLIC/.r,"\n-------------------------"];];



Return[updatedEvents];

];(* end of remapEvents *) 


interpolateForEventTime[tfirst_, tlast_, precision_]:= Module[{ta,tb,tc, dt,result, nsteps},
ta = tfirst; tb = tlast;dt = tb-ta;
If[dbg, 
Print["interpolateForEventTime: {tfirst,tlast},triggers:",{tfirst,tlast},triggers];
Print[triggers/.n/.{Global`t-> tlast}];
];

(* check to see if set at tfirst 3/4/05 2.4.9*)
result = (test/.n)/.{Global`t-> ta};
If[tfirst>0,
If[result,
result=Map[(#/.n)/.{Global`t-> ta}&,triggers];

Return[{ta,result}];
];
]; 

(* In Version 5.1, Method-> EventLocator will have already found the event time *)
(* If[$VersionNumber>5,
result=Map[(#/.n)/.{Global`t-> tb}&,triggers];
Return[{tb,result}];
];
*) 

nsteps=0;
While[dt>precision,
tc = (tb+ta)/2;
result = (test/.n)/.{Global`t-> tc};
If[dbg,
Print[
"interpolateForEventTime: "//boldBlue,"{ta,tc,tb},result:"//boldOrange,
{ta,tc,tb}//boldBlue,","//boldBlue,
result//boldBlue," triggers:"//boldOrange,(triggers/.n/.{Global`t-> tc})//boldBlue]
];
If[result,tb=tc,ta =tc];
dt = tb-ta;
nsteps++;
]; 

If[dbg,Print["interpolateForEventTime: iterations:",nsteps]];

(* check to see if it should really be at tlast 2.4.9 *)
If[tb>= tlast-precision,tb=tlast];

(* check for individual condition at stopping time *)

result=Map[(#/.n)/.{Global`t-> tb}&,triggers];
Return[{tb,result}];
];  (* end of interpolateForEventTime *)

intInterval[]:= Module[{c,int},
c=Cases[n,InterpolatingFunction[___][___],Infinity];
int[InterpolatingFunction[domain_, table___][t___]]:= Flatten[{domain}];
Return[int[First[c]]];
]; (* end of intInterval *)

updateEvents[currentEvents_, updateTime_]:= Module[{dbg=False},
savedEvents=currentEvents;
(* Print["currentEvents:",currentEvents]; *)

remappedEvents= remapEvents[currentEvents, updateTime];
(* Print["remappedEvents:",remappedEvents]; *) 

If[dbg,
 Print["NDSolveSBMLWithEvents:"//boldBlue,
" remappedEvents: "//boldOrange,remappedEvents//boldBlue,"\nNDSolveSBMLWithEvents:"//boldBlue,
" eventflags: "//boldOrange,eventflags//boldBlue,"\nNDSolveSBMLWithEvents:"//boldBlue,
" r (revised): "//boldOrange,r//boldBlue]; 
]; 

events = remappedEvents;

triggers = Map["trigger"/.#&,Last/@events];
triggers = Map[StringReplace[#, "[t]"-> "[Global`t]"]&, triggers];
triggers =  ToExpression/@triggers;
triggers = triggers//.fs;
triggers = triggers/.constants; (* added 5/4/06 2.5.13 *)


If[dbg, Print["NDSolveSBMLWithEvents: triggers:", triggers]];

test=Or@@triggers;


eventNames=First/@events;
actions = Map["events"/.#&,Last/@events];
ic = Global`SBMLIC/.r;
vars =Head/@( First/@ic);
values = Last/@ic;
delayedActions=Map["delayedevents"/.#&,Last/@events];


delays = ToExpression/@Map["delay"/.#&,Last/@events];
havedelays = ToString[#]!="0"&/@delays;



If[dbg, 
Print["updateEvents:\n","names:",eventNames,"\nactions:",actions,"\ndelays:",delays,"\nhavedelays:",havedelays,"\ndelayedActions:",delayedActions];Print["NDSolveSBMLWithEvents:"//boldBlue," triggers: "//boldOrange,triggers//boldBlue,
"\nNDSolveSBMLWithEvents:"//boldBlue, "actions: "//boldOrange,actions//boldBlue,
"\nNDSolveSBMLWithEvents:"//boldBlue, "vars: "//boldOrange,vars//boldBlue,
"\nNDSolveSBMLWithEvents:"//boldBlue, "actions: "//boldOrange,actions//boldBlue,
"\nNDSolveSBMLWithEvents:"//boldBlue, "ic: "//boldOrange,ic//boldBlue,
"\nNDSolveSBMLWithEvents:"//boldBlue, "vars: "//boldOrange,vars//boldBlue,"\nNDSolveSBMLWithEvents:"//boldBlue, "values: "//boldOrange,values//boldBlue];
]; 

(* reset SBMLIC because this might not be the first time this model has been run since it was loaded, and an event might have reset an IC - 2.3.33 *)

MapThread[definef[SBMLIC, #1, #2]&, {stringer/@vars,stringer/@ values}]; 

]; (* end of updateEvents *)

If[dbg, Print["ievents:", ievents]]; 

If[dbg, Print["iconstraints: ",iconstraints]];
constraints=constraintsToEvents[iconstraints];
If[dbg, Print["constraints: ",constraints]];

(* convert message to something useful*) 
Block[{totext},
totext[x_]:= Module[{y,xml},
xml["message",{}, {z__}]:= First[{z}]; 
xml["message",{},z_]:=z;
xml["body",_, {z__}]:= First[{z}]; 
xml["bocy",_, z_]:= z; 
xml[z___]:= XMLElement[z]; 
y=x//.{XMLElement-> xml};
Return[y];
];

constraintMessages= Map[Rule[#[[1]], totext[#[[2]]]]&, iconstraints];
If[dbg, Print["constraintMessages: ",constraintMessages]];
];

t=0;
updateEvents[Join[ievents,constraints], t];

While[t<tmax,

If[dbg,
Print["NDSolveSBMLWithEvents:"//boldBlue,
"t:"//boldOrange,t//boldBlue,"*********************"//boldRed];
Print["NDSolveSBMLWithEvents:"//boldBlue,
"ic:"//boldOrange,ic//boldBlue];
Print["NDSolveSBMLWithEvents:"//boldBlue,"test:"//boldOrange,test//boldBlue];
];


n=NDSolveSBMLModel[r,t, tmax, StoppingTest-> test, opt];
If[ToString[n]=="$Failed", Return[$Failed]]; 


n = Flatten[n];
If[dbg,Print["NDSolveSBMLWithEvents:"//boldBlue,"n: "//boldOrange,n//boldBlue]];
 

{tstart,tstop}=intInterval[];

If[dbg,Print["NDSolveSBMLWithEvents:"//boldBlue,"{tstart,tstop}: "//boldOrange,{tstart,tstop}//boldBlue]];

{  tevent,triggeredEvents}=interpolateForEventTime[tstart,tstop,10^(-7)];

If[dbg,Print["NDSolveSBMLWithEvents:"//boldBlue,"{tevent,triggeredEvents}: "//boldOrange,{tevent,triggeredEvents}//boldBlue]];

(* Add solution to set only if it has a non-zero duration -
might be a set/reset situation and don't need a separate interpolation curve) 
-- added test 3-4-05 2.4.9 *)

(* Replace MemberQ[modelvariables,First[#]] with Not[MemberQ[flagvariables,First[#]]] -- 2.5.25 8/1/06
 *)


If[tevent>tstart,
solution = Append[solution,InterpolationSet[t,tevent,Select[n, Not[MemberQ[flagvariables,First[#]]]&]
]];
];

triggeredDelays=Last/@Select[ {triggeredEvents,delays}//Transpose, First];

If[dbg,Print["NDSolveSBMLWithEvents:"//boldBlue,"revised solution: "//boldOrange,solution//boldBlue]];


currentDelayValues=triggeredDelays/.n/.{Global`t-> tevent};
delayed=Positive/@currentDelayValues;
triggeredNames =Last/@Select[ {triggeredEvents,eventNames}//Transpose, First];


If[dbg,Print["triggeredNames:",triggeredNames,"\ntriggeredDelays:",triggeredDelays,"\ncurrentDelayValues:",currentDelayValues,"\ndelayed:",delayed]];

(* check for triggered constraints *)
triggeredConstraints = decontextify/@triggeredNames;
triggeredConstraints=Select[triggeredConstraints,And[StringTake[#,10]=="Constraint",StringTake[#,-9]=="$eventSet"]&];
If[Length[triggeredConstraints]>0,
triggeredConstraints=StringDrop[#,11]&/@triggeredConstraints; (* drop "Constraint\[UnderBracket]" *) 
triggeredConstraints=StringDrop[#,-21]&/@triggeredConstraints; (* dropt "\[UnderBracket]$Violation\[UnderBracket]$EventSet *)
triggeredConstraints=ToExpression/@triggeredConstraints; (* should be a list of integers now *)

Print["Constraint violation: "//boldRed,constraintMessages[[#,2]]//boldBlue,"\nConstraint violated at t = "//boldBlack,tevent//boldBlack]&/@triggeredConstraints;

]; 

MapThread[
If[#1< 0, 
Print["Warning:"//boldRed,"A negative delay of "//boldBlack,#1//boldBlue," for event "//boldBlack,#2//boldBlue," was set at t = "//boldBlack,tevent//boldBlue]
]&,
{currentDelayValues,triggeredNames}];


newEvents={};
If[And@@delayed,
delayedNames=Last/@Select[{delayed,triggeredNames}//Transpose,First];
delayAmounts=
Last/@Select[{delayed,currentDelayValues}//Transpose,First];
currentlyDelayedActions=
Last/@Select[ {triggeredEvents,delayedActions}//Transpose, First];

If[dbg, MapThread[
Print["Delayed Event:",#1," delay:",#2," actions:",#3]&,{delayedNames,delayAmounts, currentlyDelayedActions}];
]; 

newEvents=stringer/@Table[Unique[stringer[$SBML$Context]<>"delayed\[UnderBracket]event\[UnderBracket]"], {Length[delayedNames]}];

newEvents=MapThread[Rule[#1, 
{
"trigger"-> stringer[(Global`t>=(tevent+ #2))], 
"delay"-> "0",
"events"->(stringer/@ #3)
}]&,
{newEvents, delayAmounts, currentlyDelayedActions}];

If[dbg, Print["newEvents:",newEvents];];
];


ievent++;

If[trace,
If[tevent<tmax,
(* Print["Event Trace: "//boldRed,"("//boldBlack,ievent//boldBlue,") t:"//boldBlack,tevent//boldBlue," Event(s): "//boldBlack,list2CommaSeparatedString[decontextify/@ToString/@triggeredNames]//boldBlue," Delay(s):"//boldBlack,
list2CommaSeparatedString[ToString/@currentDelayValues]//boldBlue];*)

MapThread[
Print["Event Trigger: "//boldRed, ievent//boldBlue," t="//boldBlack,tevent//boldBlue, " Event = "//boldBlack,#1//boldBlue, " Delay = "//boldBlack ,#2//boldBlue]&,
{decontextify/@ToString/@triggeredNames, ToString/@currentDelayValues}
];
If[dbg,Print["{tstart, tevent, tstop}:",{tstart,tevent,tstop}]];
,
Print["Event Trigger: "//boldRed,"t:"//boldBlack,tevent//boldBlue," Event: "//boldBlack,"RequestedEndOfSimulation"//boldBlue];
];
]; 

If[ievent>maxevents, 
Print["Error: "//boldRed,"Possible bad event structure; more than "//boldBlack,maxevents//boldBlue," events (MaxEvents) have occurred.  by t="//boldBlack,tevent//boldBlue,"(To inhibit this check set MaxEvents\[Rule]Infinity)."//boldBlack]; 
Abort[]
];

dtevent = t-eventLast; eventLast=t;
If[dtevent<badeventdt,
iclose++;
If[iclose>= maxclose, 
Print[
">>Error Abort: "//boldOrange,"Possible Bad Event (MaxCloseEvents). The event(s): "//boldBlack,list2CommaSeparatedString[ToString/@triggeredNames]//boldRed, 
" has (have) occurred "//boldBlack,
maxclose//boldBlack," (MaxCloseEvents) times within a very a time interval of "//boldBlack,
badeventdt//boldBlack," (BadEventTimePrecision) at t="//boldBlack,tevent//boldBlack]; 
Abort[];
];
,
iclose=0;
]; 


(* make a list of all the actions that need to occur *)
triggeredActions =Flatten[
Last/@Select[
Transpose[{triggeredEvents,actions}],
First]
];

triggeredActions=ToExpression/@triggeredActions;


If[dbg,
Print["NDSolveSBMLWithEvents:"//boldBlue,
"{tstart,tstop}:"//boldOrange,{tstart,tstop}//boldBlue];
];


(* some initial conditions will be based on actions *)
triggeredActions=triggeredActions/.{Rule-> List};
triggeredvars=Head/@First/@triggeredActions;

(* 2.3.33 - make sure SBMLIT is reset correctly *) 
triggeredvalues = (Last/@triggeredActions)/.n/.{Global`t-> tevent};
If[dbg, 
Print["NDSolveSBMLWithEvents:"//boldBlue," triggeredvars: "//boldOrange,triggeredvars//boldBlue];
Print["NDSolveSBMLWithEvents:"//boldBlue," triggeredActions(1): "//boldOrange,triggeredActions//boldBlue];
Print["NDSolveSBMLWithEvents:"//boldBlue," triggeredvalues: "//boldOrange,triggeredvalues//boldBlue];

]; 
MapThread[definef[SBMLIC, #1, #2]&, {stringer/@triggeredvars,stringer/@ triggeredvalues}]; 
(* end of 2.3.33 fix *) 


triggeredActions=MapThread[#1[Global`t]==#2&,{triggeredvars, triggeredvalues}];
triggeredActions = triggeredActions/.{Global`t-> tevent};

If[dbg,
Print["NDSolveSBMLWithEvents:"//boldBlue,
"triggeredActions(2):"//boldOrange,triggeredActions//boldBlue];
];

(* determine remainder of initial conditions *)
nonTriggeredVars= Complement[vars, triggeredvars];
If[dbg,
Print["NDSolveSBMLWithEvents:"//boldBlue,
"nonTriggeredVars:"//boldOrange,nonTriggeredVars//boldBlue];
];

ic = Map[
Equal[
#[tevent],
(#[Global`t]/.n)/.{Global`t-> tevent}
]&,
nonTriggeredVars];
ic = Join[ic,triggeredActions];
If[dbg,
Print["NDSolveSBMLWithEvents:"//boldBlue,
"modified ic:"//boldOrange,ic//boldBlue];
];

r=ReplaceRuleListPart[Global`SBMLIC-> ic,r];

t=tevent;

(* and the new events for delayed events  *)

If[And@@delayed,updateEvents[Join[savedEvents,newEvents], t]];

]; (* end While t < tmax *)

(* reset the event flags and other IC so they don't persist for another run, as they have been changed 2.5.13, 4 May 06 *)

Clear[SBMLIC];
SBMLIC[unknownVariable_]:=ToString[$SBML$IndeterminateValue];

Return[solution];
];


If[$$LoadBug, Print["Loading:solveUntil"]];


solveUntil[condition_,equations_, variables_, {t_, tmin_,tmax_}, 
opt___?OptionQ]:= Module[{n,tstop,thalt,dbg=False,options,legacyEvent},

If[dbg,
Print[">>>debug solveUntil: {opt}:"//boldRed,{opt}]
];

legacyEvent=(($VersionNumber<5.0 )\[And] (ToString[condition]!= "True"));

If[$VersionNumber<5.1,
If[legacyEvent, Off[InterpolatingFunction::"inhr"]];
(* turning off this message does not appear to work in 4.2
even though it is guaranteed to occur. *)
n=NDSolve[equations,variables,{t,tmin,tmax},StoppingTest-> condition,opt];
If[legacyEvent, On[InterpolatingFunction::"inhr"]];
Return[{tmax, n}];
]; 

(* use throw/catch instead *)
n=Catch[
NDSolve[equations,variables,{t,tmin,tmax},StepMonitor:> 
(If[condition \[Or] (t>= tmax), Throw[t]]),opt
]
];
If[ListQ[n], Return[{t, n}]];
tstop = n;
If[dbg,
Print[">>>debug solveUntil: Event located at "//boldRed," tstop:"//boldBlack,tstop//boldBlue]
];

thalt=Min[tstop,tmax];

If[dbg,
Print[">>>debug solveUntil: thalt "//boldRed,thalt]
];

n=NDSolve[equations,variables,
{t,tmin,thalt},opt];

Return[{thalt, n}];
]



neededCompartmentSizesDefined[x_]:= Module[{r,rules,arulevars,  defunct,odevars,ic, decont,debug=False, uninitializedCompartments, initialassignments},
defunct[a_[b_]]:= a[b];
defunct[a_'[b_]]:= a[b];
decont[Rule[a_,b_]]:= Rule[decontextify[a],decontextify[b]];

If[False, Print["neededCompartmentSizesDefined: x, ",x]]; 

r= Global`SBMLSpeciesCompartmentAssociations/.x;
If[debug, Print["neededCompartmentSizesDefined: r, ",r]]; 

(* remove compartments that have constant volumes assigned *)
r= expressionate/@r;
If[debug, Print["neededCompartmentSizesDefined: r (2):",r]]; 
rules=(Global`SBMLConstants/.x);
If[debug, Print["neededCompartmentSizesDefined: rules:",rules]]; 


r=Rule[First[#], Last[#]/.rules]&/@(r/.{Rule-> List});
If[debug, Print["neededCompartmentSizesDefined: r (2.5):",r]]; 

r=Select[r,!NumberQ[Last[#]]&];
If[debug, Print["neededCompartmentSizesDefined: r (3):",r]]; 

(* remove compartments that have assignment rules *)
arulevars =First/@( (Global`SBMLAssignmentRules/.x/.Global`SBMLAssignmentRules-> {}));
arulevars = defunct/@arulevars;
If[debug, Print["neededCompartmentSizesDefined: arulevars:",arulevars]]; 

r=Select[r, !MemberQ[arulevars,Last[#]]&];
If[debug, Print["neededCompartmentSizesDefined: r (4):",r]]; 

(* remove compartments that have rate rules *)

odevars = (Global`SBMLODES/.x/.{Global`SBMLODES-> {}});
odevars =defunct/@(First/@odevars);
If[debug, Print["neededCompartmentSizesDefined: odevars:",odevars]]; 
r=Select[r, !MemberQ[odevars,Last[#]]&];
If[debug, Print["neededCompartmentSizesDefined: r (5):",r]]; 

r=decont/@r;
If[debug, Print["neededCompartmentSizesDefined: r (6):",r]]; 

(* remove compartments that have initial conditions defined *)
(* these are compartments with constant->false but do not have rules *)
ic =First/@(Global`SBMLIC/.x);
(* added 2.7.4  because otherwise the ics were ignored !! *) 
ic= decontextify/@ic;
If[debug, Print["ic: ", ic]]; 


r=Select[r, !MemberQ[ic,Last[#]/.{Global`t-> 0}]&];
If[debug, Print["neededCompartmentSizesDefined: r (7):",r]]; 

r=(r/.{Rule-> List}); 
If[Length[r]>0, 
uninitializedCompartments=Union[Last/@r], 
Return[{}]
]; 

If[debug, Print["uninitializedCompartments:", uninitializedCompartments]]; 

(* remove initial assignments  - added 2.7.4 *)
initialassignments = Global`SBMLInitialAssignments/.x/.{Global`SBMLInitialAssignments-> {}}; 
initialassignments=decontextify/@First/@(initialassignments/.{Rule-> List});
initialassignments=functionate/@Map[If[SameQ[Head[#], Symbol], #, Head[#]]&, initialassignments];

If[debug, Print["initialassignments: ", initialassignments]]; 
uninitializedCompartments = Complement[uninitializedCompartments, initialassignments]; 


If[Length[uninitializedCompartments]>0, 

(* set remaining compartments to 1 *)

r=Rule[contextify[#],1]&/@uninitializedCompartments; 

Print["Error: "//boldRed, "SBMLNDSolve: uninitialized compartment: "//boldBlack, "\""<>stringer[#]<>"\""//boldBlue, " -- A default value of 1 will be used; this may be different from the intent of the model. "//boldBlack]&/@ uninitializedCompartments;
If[debug, Print["neededCompartmentSizesDefined: r (8):", r]]; 
Return[r];
];
Return[{}]; 
]


NDSolveSBMLModel[r_, tstart_, tmax_, opt___?OptionQ]:= Module[{s,odes,ic,rules,vars,fs,system, addedDummyVariable,
varsWithoutODES, ODESWithoutVars,devars,varsindes,vars2remove, varsinic, ic2add,sodes,ic2,indic, extraodes,dbg, systemvars, definedvars, undefinedvars,p, ars,asrs,haveAlgebraicRules, haveAssignmentRules,namesofvars2remove, pgoal, asrules, arvars,retry,NDSolveOptions,solver, test,algic,fluxes,sars,sppecies, compartments, hasAlgebraicRule,hasAssignmentRule, varname, texit, whatis, whatsitsname, nameItIfNecessary, udcrs, constants
},

dbg = Global`debug/.{opt}/.{Global`debug-> False};

whatsitsname[uin_]:= Module[{nids, itsname}, 

nids=$SBML$NameIDAssociations;
nids = Rule[decontextify[First[#]], Last[#]]&/@nids;
itsname = uin/.nids/.{uin-> ""};
Return[itsname];
]; 

whatis[uin_]:= Module[{s, p, u},

u=defunctionate[stringer[uin]]; 
s=stringer/@defunctionate/@decontextify/@(Global`SBMLSpecies/.r);

If[MemberQ[s, u], Return["species"]]; 
p =stringer/@defunctionate/@decontextify/@( Global`SBMLParameters/.r);
If[MemberQ[p, u], Return["parameter"]]; 


Return["variable"]; 
];

nameItIfNecessary[uin_]:= Module[{itsname}, 
itsname=whatsitsname[uin];
If[stringer[itsname]!= stringer[uin], 
Return[ " ("<>stringer[itsname]<>") "]
]; 
Return[""]; 
];

debugPrint[dbg, "NDSolveSBMLModel:: tstart,tmax ", {tstart,tmax}];

varname[u_'[arg_]]:= u;

(* catch return value for undefined compartments 2.7.0.5 29 Nov 07 *)
udcrs = neededCompartmentSizesDefined[r];
debugPrint[dbg, "NDSolveSBMLModel: udcrs", udcrs]; 

odes = Global`SBMLODES/.r;
ic= Global`SBMLIC/.r;

(* include undefined compartment rules here 2.7.0.5 29 Nov 07 *)
rules=(Global`SBMLConstants/.r);
rules=Join[rules, udcrs];

vars = Global`SBMLModelVariables/.r;
fs = (Global`SBMLFunctions/.r)/.(Global`SBMLFunctions-> {});
ars = (Global`SBMLAlgebraicRules/.r/.Global`SBMLAlgebraicRules-> {}); 
asrs = (Global`SBMLAssignmentRules/.r/.Global`SBMLAssignmentRules-> {}); 

(* turn fluxes into assignment rules 2.5.25 1-Aug-06 *)
fluxes = Global`SBMLKineticLaws/.r/.{Global`SBMLKineticLaws-> {}};
asrs = Join[asrs, fluxes];
asrs = asrs//.rules;

asrules = asrs/.{Equal-> Rule};
arvars = First/@asrules;

(* removes variables with assignment rules 2.4.4 1-Nov-04 *) 

vars = Complement[vars,arvars];
odes = odes//.asrules;

If[Length[odes]<1, 
odes = Append[odes, differentize[addedDummyVariable]==0]; 
ic =Append[ic,addedDummyVariable[tstart]==1];
vars = Append[vars, functionate[addedDummyVariable]];
];

If[dbg, 
debugPrint[dbg, "NDSolveSBMLModel:: odes", odes];
debugPrint[dbg, "NDSolveSBMLModel:: ic", ic];
debugPrint[dbg, "NDSolveSBMLModel:: vars", vars];
debugPrint[dbg, "NDSolveSBMLModel:: asrules", asrules];
debugPrint[dbg, "NDSolveSBMLModel:: arvars", arvars];
]; 

hasAlgebraicRule[x_]:=( Length[Position[ars, x]]>0); 
hasAssignmentRule[x_]:= MemberQ[First/@(asrs),x];

(****** Check for Poorly formed system *****) 

(* devars is a list of variables like x'[t] *) 
devars = Map[ToString,vars]; 
devars =Map[StringReplace[#,"[t]"-> "'[t]"]&,devars];
devars = Map[ToExpression,devars]; 


(* remove any excess variables *) 
(* varsindes is the lhs of the odes, x'[t] *)
varsindes = Map[First,odes];
varsWithoutODES = Complement[devars,varsindes]; 

debugPrint[dbg, "NDSolveSBMLModel:: devars", devars];
debugPrint[dbg, "NDSolveSBMLModel:: varsindes", varsindes];

If[Length[varsWithoutODES]>0,

vars2remove = Map[ToExpression[StringReplace[ToString[#],"'[t]"-> "[t]"]]&,varsWithoutODES];

(* check to see if any of the variables have algebraic rules -- if so, not necessary to add an ODE  - don't check Mathematica Version here, because it is checked elsewhere in this function. Added 7-31-03  *) 

debugPrint[dbg, "NDSolveSBMLModel:: vars2remove", vars2remove];
haveAlgebraicRules= Select[vars2remove, hasAlgebraicRule];
haveAssignmentRules= Select[vars2remove, hasAssignmentRule];
vars2remove = Complement[vars2remove, haveAlgebraicRules  ,haveAssignmentRules  ]; 
debugPrint[dbg, "NDSolveSBMLModel:: haveAlgebraicRules", haveAlgebraicRules];
debugPrint[dbg, "NDSolveSBMLModel:: haveAssignmentRules", haveAssignmentRules];
debugPrint[dbg, "NDSolveSBMLModel:: vars2remove", vars2remove];


vars2remove = Complement[vars2remove,{ Global`t[Global`t]}];

Block[{notAFlag, notFlags},

notAFlag[v_]:= Not[StringMatchQ[stringer[v], RegularExpression["(.+)\[UnderBracket]\$(.+)"]]];
notFlags=Select[vars2remove,notAFlag];

If[Length[vars2remove]>0  (* \[And] TrueQ[$VersionNumber< 5  ] *) ,

(* add odes of the form x'[t]=0 for extra variables if prior to version 5 *)
(* extraodes=ToExpression/@Map[StringReplace[#,"[t]"-> "'[t]==0"]&, ToString/@vars2remove]; *)
extraodes=ToExpression/@Map[StringReplace[#,"[t]"-> "'[t]==0"]&, ToString/@vars2remove]; 

odes = Join[odes, extraodes]; 
varsindes = Map[First,odes];


notFlags = ToString/@notFlags;
notFlags=decontextify/@notFlags;
Module[{dbg=False},
debugPrint[dbg, "NDSolveSBMLModel::extraodes ", extraodes]; 
debugPrint[dbg, "NDSolveSBMLModel:: odes", odes];
debugPrint[dbg, "NDSolveSBMLModel:: varsindes", varsindes];
debugPrint[dbg, "NDSolveSBMLModel:: notFlags", notFlags];
debugPrint[dbg, "NDSolveSBMLModel:: vars2remove", vars2remove]
]; 




If[$ReportMissingODE,

Map[Print[
"Warning: "//boldRed,whatis[#]//boldBlack," ", 
#//boldBlue, 
" appears to be constant. "//boldBlack
]&,
notFlags];
$ReportMissingODE=False;
];
]; 
];
];
(* remove excess initial conditions *) 
(* change varsindes to be like x[0] instead of x'[t] *) 
varsindes = varname/@varsindes;
ic = Select[ic, MemberQ[varsindes,Head[First[#]]]&];

(* supply insufficent initial conditions *)
 (* varsinic is like x[0] *)
varsinic =Head/@First/@ic;
ic2add = Complement[varsindes, varsinic];

If[Length[ic2add]>0, 

If[$ReportMissingIC,
printWarning["No initial condition provided for "<>list2CommaSeparatedString[decontextify[ToString/@ic2add, $SBML$Context]]<>"; zeros assumed for missing values. "];
$ReportMissingIC=False;
]; 

ic2add = Map[#==0&, ic2add];
ic = Join[ic, ic2add];
];

(* check for indeterminates *)
ic2add = Select[ic, ToString[Last[#]]=="Indeterminate"&];
If[Length[ic2add]>0,
indic = Map[First, ic2add];
indic = Map[ToString,indic];
indic= Map[StringReplace[#,"["<>ToString[tstart]<>"]"->""]&, indic];
If[$ReportMissingIC,
Print["Warning: "//boldRed, whatis[#]//boldBlack," ",   (#<>nameItIfNecessary[#])//boldBlue, " has indeterminate initial conditions."//boldBlack]&/@decontextify[indic,$SBML$Context];
$ReportMissingIC=False;
]; 
ic = ic/.{Indeterminate-> 0};
];


If[$InitialRun, 

(* Process the Initial Assignments *)

If[ToExpression[$SBML$Level$Version]>2.15, 
Block[{debug=False, iass, arzero, ialhs, iarhs, arulesrhs, aruleslhs, icvars, icrules, icvals, checkRepeated, hasrules, ia2consts, ia2constsvals, rulevars, rulevals},
iass = Global`SBMLInitialAssignments/.r/.{Global`SBMLInitialAssignments-> {}}; 
If[Length[iass]>0, 
arzero = asrules/.{Global`t-> 0};
hasrules = Length[arzero]>0; 
{ialhs, iarhs}=Transpose[iass/.{Rule-> List}];
If[hasrules,
{aruleslhs, arulesrhs}=Transpose[arzero/.{Rule-> List}],
{aruleslhs, arulesrhs}={{},{}} 
]; 
icrules = ic/.{Equal-> Rule};
icvars = First/@(icrules/.{Rule-> List});
If[debug, 
Print["initialAssignments:", iass]; 
Print["ialhs=", ialhs];
Print["iarhs=", iarhs];
Print["assignmentRules: ", asrules];
Print["aruleslhs:", aruleslhs];
Print["arulesrhs:", arulesrhs]; 
Print["arzero:", arzero];
Print["icrules:", icrules]; 
Print["icvars:", icvars];
Print["vars:", vars];
Print["arvars:", arvars];
];

checkRepeated[u_, v_]:= Module[{},
Check[ReplaceRepeated[u,v, MaxIterations-> 256], 
(Print["Error: "//boldRed, " Suspected loop in assignmentRules and initialAssignments"//boldBlack];Abort[])
]
];

iarhs = checkRepeated[iarhs, iass]; 

iass=MapThread[Rule, {ialhs, iarhs}]; 
arulesrhs = checkRepeated[arulesrhs, arzero];
arzero=MapThread[Rule, {aruleslhs, arulesrhs}]; 

iass=Join[iass,arzero];

icvals =checkRepeated[icvars, iass];
icvals =checkRepeated[icvals, icrules];

ic = MapThread[Equal, {icvars, icvals}];

If[debug,
Print["initialAssignments:", iass]; 
Print["arzero:", arzero];
Print["icvals:", icvals]; 
Print["ic:", ic];
Print["rules: ", rules]; 
]; 

(* check for initial assignments to constants *)

ia2consts =  Complement[ialhs, icvars];

If[Length[ia2consts]>0, 
ia2constsvals = ia2consts/.iass; 

(* remove the[0] from the initial assignments *)
ia2consts = Map[
If[SameQ[Head[#], Symbol], #, Head[#]]&, 
ia2consts];

ia2consts = MapThread[Rule, {ia2consts, ia2constsvals}]; 

(* modify rules to account for initial assignments to cosntants *)

rulevars = Transpose[rules/.{Rule-> List}][[1]]; 
rulevals = rulevars/.ia2consts/.rules; 
rules = MapThread[Rule, {rulevars, rulevals}]; 

If[debug, 
Print["ia2consts: ", ia2consts , " (Constants with init assignments)"]; 
Print["{rulevars, rulevals}: ", {rulevars, rulevals}]; 
Print["rules (revised): ", rules]; 
];

] (* End If Length[ia2consts] > 0 *)
]  (* End if Length[iass]>0 ... *)
] (* end Block *) 
]; (* end > 2.15 *)

$InitialRun=False

]; (* end initial run *)



(* Join the initial conditions to the system of odes *)

system = ((Join[odes,ic]//.fs)//.rules); 


(* add ode-less variables as algebraic conditions *)
 
(* Block[{isAFlag, areFlags, flagnames},

isAFlag[v_]:= StringMatchQ[stringer[v], RegularExpression["(.+)\[UnderBracket]\$(.+)"]];
areFlags=Select[vars2remove,isAFlag];


If[Length[areFlags]>0 \[And] TrueQ[$VersionNumber>=  5],
areFlags = stringer/@areFlags;
flagnames = StringReplace[#,"[t]"-> ""]&/@areFlags;

(* Add check here to make sure none of the added SBMLIC are INDETERMINATE *) 
algic=SBMLIC/@flagnames;


MapThread[If[#2=="Indeterminate",
If[$FirstIteration, 
Print["Warning: "//boldOrange, " no initial condition was specified for "//boldBlack,#1//boldRed," -- a value of zero will be used instead."//boldBlack];
]; 
]&,
{areFlags,algic}
];
If[$FirstIteration, $FirstIteration=False];

algic = algic/.{"Indeterminate"-> "0"};

areFlags=ToExpression/@MapThread[#1<>"=="<>#2&,{areFlags, algic}]; 

areFlags = (areFlags//.fs)//.rules;

debugPrint[dbg, "NDSolveSBMLModel:: fs: ", fs];
debugPrint[dbg, "NDSolveSBMLModel:: rules: ", rules];
debugPrint[dbg, "NDSolveSBMLModel:: added to system: ", areFlags];
system = Join[areFlags,system];

,
Print["This model contains events. Events required Mathematica version 5.0++ and not "<>$Version];
Abort[];
];
];
*)

(* Add algebraic rules - 7/31/03 *) 
If[Length[ars]>0,
If[$VersionNumber>= 5.0, 
ars = ((ars//.fs)//.rules);
system = Join[system, ars];
,
PrintWarning["This model contains algebraic rules. The solution of Differential-Algebraic equations requires Mathematica 5.0 or greater. You have version "<>$Version];
Abort[]; 
]; 
]; 

(* add assignment rules to DAE system in version 2.3.20 *)
(* don't add assignment rules starting in 2.4.4 *) 
(*
If[Length[asrs]>0 \[And] TrueQ[$VersionNumber>= 5],
asrs = Map[Equal[First[#],( Last[#]//.fs)//.rules]&,asrs];
system = Join[system, asrs];
];
*) 

(* check to see if there are any undefined symbols and print error message if so - added 7/31/03 -- this will catch potential NDSolve crashes *) 

systemvars = getSymbols[Last/@system]; (* just look at RHS of odes *) 
definedvars = getSymbols[vars];
undefinedvars = Complement[systemvars, definedvars];

debugPrint[dbg, "NDSolveSBMLModel:: undefinedVars: ", undefinedvars];  

If[Length[undefinedvars]>0,
If[MemberQ[undefinedvars, Global`delay], Print["Sorry: "//boldRed, "This model appears to contain the csymbol "//boldBlack, "delay"//boldBlue, " which has not been implemented in SBMLNDSolve."//boldBlack];
Return[$Failed];
]; 
Print[
boldRed["Error: "], 
boldBlack["The symbol "],#//boldBlue, 
boldBlack[" does not appear to have a numerical value.  NDSolve may be unable to produce numerical results."]
]&/@Map[decontextify[#,$SBML$Context]&, undefinedvars];
];
(********* end of check for poorly formed system *********)


debugPrint[dbg, "NDSolveSBMLModel:: system", system];
debugPrint[dbg, "NDSolveSBMLModel:: vars", vars];
debugPrint[dbg, "NDSolveSBMLModel:: {opt}", {opt}];

NDSolveOptions=MyFilterOptions[NDSolve,opt];

test=StoppingTest/.{opt}/.{StoppingTest-> False};

debugPrint[dbg, "NDSolveSBMLModel:: NDSolveOptions", NDSolveOptions];


(* solve & retry if error in accuracy/precision 2.3.37*)
solver[options___?OptionQ]:= Module[{n,ops,dbg=False, failmsg}, 

debugPrint[dbg, "NDSolveSBMLModel:: solver:", "Calling NDSolve"];
debugPrint[dbg, "NDSolveSBMLModel:: solver: system: ", system];
debugPrint[dbg, "NDSolveSBMLModel:: solver: vars: ", vars];
debugPrint[dbg, "NDSolveSBMLModel:: solver: tstart: ", tstart];
debugPrint[dbg, "NDSolveSBMLModel:: solver: tmax: ", tmax];
debugPrint[dbg, "NDSolveSBMLModel:: solver: {options}: ", {options}];


failmsg[]:= Module[{errors, nexterror},
errors=$MessageList;
While[Length[errors]>0, 
nexterror=First[errors];
errors=Rest[errors];
Switch[ToString[nexterror],
"NDSolve::mxst", 
Print["Error: "//boldRed, "Numerical integration could not converge because the maximum number of steps were exceeded.\nTry increasing the value of the option MaxSteps in your call to SBMLNDSolve."//boldBlack],
"NDSolve::icfail",
Print["Error: "//boldRed, "Numerical integration failed. The initial conditions appear to be inconsistent with the differential and/or algebraic equations in the model. \nThis will sometimes occur if an invalid set of initial conditions are specified in the model (e.g., all values equal to zero)."//boldBlack],
"NDSolve::nderr",
Print["Error: "//boldRed,"Numerical integraton failed. \nThis message sometimes indicates a singularity in the solution (e.g., dividing by zero)."];,
"NDSolve::ndsz",
Print["Error: "//boldRed,"Numerical integraton failed. The solver could not determine a step size that would work, no matter how small it tried. This sometimes indicates that the system is stiff. \nTry looking for singularities or a wide variation in the time constants within your model; or try changing PrecisionGoal or AccuracyGoal."//boldBlack];,
_,
Print["Error:"//boldRed, "Numerical integration error: "//boldBlack, nexterror//boldBlue," (a message for this error has not been written yet: Check help > built-in-functions > Warning messages > Numerical Computation > Equation Solving > message) "//boldBlack]; 
]; 
]; 

Abort[];
];





{texit, n}=Check[
solveUntil[test,system,vars,{Global`t,tstart,tmax},options],
failmsg[],
NDSolve::stopt, NDSolve::mxst, NDSolve::icfail, NDSolve::ndsz
];

Return[ n];
]; (* end of solver *)



retry:= Block[{s},
Print["Warning: SBMLNDSolve: "//boldOrange, "Attempting Error Recovery: "//boldRed," NDSolve is unable to solve the system. Trying again with "//boldBlack,"PrecisionGoal\[Rule]Automatic, AccuracyGoal\[Rule]Automatic."//boldRed];
s=Check[solver[PrecisionGoal->Automatic,AccuracyGoal->Automatic, NDSolveOptions], giveUp];
Return[s];
];

giveUp:= Block[{},

Print["Unable to find a solution."]; Abort[];
];

debugPrint[dbg, "NDSolveSBMLModel:: Calling Check"," "];
s = Check[solver[NDSolveOptions], retry, NDSolve::nderr, NDSolve::icfail] ;

debugPrint[dbg, "NDSolveSBMLModel:: Returned from Check"," "];

p = Position[Flatten[s], addedDummyVariable]; 
If[Length[p]>0,
While[ListQ[p] \[And] Length[p]>0, p = First[p]]; 
s ={ Drop[Flatten[s], {p, p}]}; 
];


(* put variables defined by assignment rules back in *)
s=Flatten[s];
sars=(Last/@asrules)//.asrules;
sars = sars/.s;
sars=sars//.fs; (* don't forget about functions !! 2.5.13 5/4/06 *) 


(* replaced rule by interpolation 2.4.14 5/8/05 Tokyo Hackathon so its compatible with SBMLPlot, dataTable, etc. *)
(* sars = MapThread[Rule[#1,#2]&,{arvars,sars}]; *)
sars = MapThread[#1->Interpolation[{{tstart,#2},{texit,#2}}, InterpolationOrder-> 1][Global`t]&, {arvars, sars}];

(* Print["sars(2)=", sars]; 

Print[Table[#/.sars, {Global`t, tstart, texit, (texit-tstart)/5.0}]&/@arvars];
*)

s = Join[s, sars]//List; 


debugPrint[dbg, "NDSolveSBMLModel:: s",s];
debugPrint[dbg, "NDSolveSBMLModel:: sars",sars];

vars = defunctionate/@(First/@(Flatten[s]));
(* include undefined compartments in "constants" 2.7.0.5 11.29.07*)
constants=Join[(Global`SBMLConstants/.r), udcrs];
species=defunctionate/@(Global`SBMLSpecies/.r);
compartments=defunctionate/@(Global`SBMLCompartments/.r);

(* some constants may have initial assignments *)
constants = Join[rules, constants]; 


(* retrieve the compartments & species that were constant and make them "plot-a-ble" *)



compartments=Complement[compartments, vars];
species=Complement[species, vars];

If[dbg,
Print["vars=",vars];
Print["constants=",constants];
Print["compartments=",compartments];
Print["species=",species];
];


compartments=Map[
Rule[functionate[#],
Interpolation[{{tstart,#/.constants},{texit, #/.constants}}, InterpolationOrder-> 1][Global`t]
]&
,
compartments
];
s=Join[s, compartments];

species=Map[
Rule[functionate[#],
Interpolation[{{tstart,#/.constants},{texit, #/.constants}}, InterpolationOrder-> 1][Global`t]
]&
,
species
];
s=Join[s, species];

s=Flatten[s]; (* 2.6.2 *)

Return[s];
];


If[$$LoadBug, Print["Loading:getSBMLreactions"]];


getSBMLreactions[opt___]:= Module[
{dbg, ODEs, species,  parameters, r,reactions, kineticLaw,law,chead,shortdes,myShort,reactionNumbers,reactionExpression,dODEs
},

cpuSet[]; 
reactionCPUProfile={}; 
aggregatereactionCPUProfile={}; 

reactionExpression[str_]:= Module[{s},
printWarning[!(StringQ[str]), "Input to reactionExpression must be a string, not '"<>ToString[str]<>"'."];
s = "("<>str<>")";
s = StringReplace[s, "\[Rule]"-> ")\[Rule]("];
Return[ToExpression[s]];
]; (* end reactionExpression *)


dbg = $SBML$debug;

law =$SBML$KineticLaw;
shortdes = $SBML$shortenODES;
myShort[x_]:= If[shortdes, Short[x], x];

$ReactionCounter = 0;

r = Cases[$SBML$Models,XMLElement["listOfReactions",___],3]; 
r = Cases[r,XMLElement["reaction",___],3]; 

$SBML$NReactions = Length[r];
cpuReport["getReactions initialization"];

cpuSet[];
Map[getSBMLreaction,r];
cpuReport["all calls to getSBMLreaction"];

cpuSet[];

reactionNumbers=Range[$ReactionCounter];
ODEs=Apply[Join, Map[$ReactionODEs, reactionNumbers]];
species =Apply[ Join, Map[$ReactionSpecies,reactionNumbers]]//Union;
reactions =Map[$Reactions, reactionNumbers] ;
$SBML$Reactions =Map[reactionExpression,Map[Last, reactions//Flatten]];


kineticLaw = Map[$ReactionLaws,reactionNumbers]; 

cpuObserver["getSBMLreaction: reactions: joining Stuff"];

debugPrint[dbg, "getSBMLreactions:: kineticLaw: ",kineticLaw];
debugPrint[dbg, "getSBMLreactions:: ODEs: ",ODEs];
debugPrint[dbg, "getSBMLreactions:: species: ",species];debugPrint[dbg, "getSBMLreactions:: reactions: ",reactions];

(* Combine the reaction ODE terms into complete ODEs *) 
(* eliminate frozen (boundary condition) species *) 
species = Select[species,(!SBMLParameterQ[ToString[#]])& ]; 

lastest[x_]:= Map[Last,x];
ODEs=Map[Cases[ODEs, #'[Global`t]==___]&, species];

ODEs= Map[lastest,ODEs];
ODEs = Map[Apply[Plus,#]&,ODEs];
ODEs  = MapThread[#1'[Global`t]==#2&, {species,ODEs}];

cpuReport["combining reaction terms into ODE's"];

If[saveVerboseData, 
cpuSet[]; 

reactions = (reactions/.{Rule-> List});
reactions =Map[Flatten, reactions];
If[!$SBML$verboseContext,reactions = decontextify[reactions, $SBML$Context]]; 
chead = {"Name", "Reaction"};

If[$SBML$ShowReactionParameters,
chead = Append[chead,"Parameters"];
parameters=Map[$ReactionParameters, reactionNumbers];
parameters=Map[Map[ToString,#]&,parameters];
parameters=Map[MathSBML`Private`parameterate, parameters];

If[!$SBML$verboseContext,parameters = Map[decontextify, parameters]; ]; 

reactions =MapThread[Append[#1,#2]&,{reactions,parameters}];
]; 

If[law, 
chead = Append[chead,"Kinetic Law"];
If[!$SBML$verboseContext,
kineticLaw = Map[ToString[InputForm[#]]&, kineticLaw];
kineticLaw = decontextify[kineticLaw, $SBML$Context];  
]; 

reactions =MapThread[Append[#1,#2]&,{reactions,Map[myShort,kineticLaw]}];
]; 

verboseSave["Reactions",chead, reactions];

If[$SBML$verboseContext,
verboseSave["Differential Equations from Reactions", 
{"Species", "Differential Equations"}, 
Transpose[{species,Map[myShort,ODEs]}]
]; 
,
species = decontextify[Map[ToString,species]];
dODEs=Map[ToString[InputForm[#]]&, ODEs]; 
dODEs= decontextify[dODEs, $SBML$Context];
dODEs=MapThread[StringReplace[#1,"Derivative[1]["<>#2<>"]"-> #2<>"'"]& ,{dODEs,species}];  
verboseSave["Differential Equations from Reactions", 
{"Species", "Differential Equations"},
Transpose[{species,Map[myShort,dODEs]}]
]; 
cpuReport["verbose listing"]; 
];
];
$SBML$ODES = Join[$SBML$ODES, ODEs];
If[$SBML$ReportCPU,
ReactionCPUsummary[];
ReactionCPUplot[]; 
]; 
Return[];
];


combineReactions[ODEs_, species_]:= Module[{r,dbg=True, lastest},
lastest[x_]:= Map[Last,x];
debugPrint[dbg,"combineReactions:: ODEs", ODEs];
r=Map[Cases[ODEs, #'[Global`t]==___]&, species];
debugPrint[dbg,"combineReactions:: r", r];
r= Map[lastest,r];
debugPrint[dbg,"combineReactions:: r", r];
r = Map[Apply[Plus,#]&,r];
debugPrint[dbg,"combineReactions:: r", r];
r  = MapThread[#1'[Global`t]==#2&, {species,r}];
debugPrint[dbg,"combineReactions:: r", r];

Return[r];
];


reactionForm[reactants_, reactantStoichiometry_, products_, 
productStoichiometry_, reversible_:False]:= Module[{rhs,lhs,reaction, dbg=False},

debugPrint[dbg, "reactionForm: input: reactants:", reactants];
debugPrint[dbg, "reactionForm: input: reactantStoichiometry:", reactantStoichiometry];
debugPrint[dbg, "reactionForm: input: products:", products];
debugPrint[dbg, "reactionForm: input: productStoichiometry:", productStoichiometry];
debugPrint[dbg, "reactionForm: input: reversible:", reversible];

If[Length[reactants]>0,
lhs = (ToExpression/@stringer/@reactants).(ToExpression/@stringer/@reactantStoichiometry);
,
lhs =Global`\[EmptySet];
];
(*lhs = ToString[InputForm[lhs]];*)
lhs = stringer[lhs];

If[Length[products]>0,
rhs = (ToExpression/@stringer/@products).(ToExpression/@stringer/@
productStoichiometry),
rhs = Global`\[EmptySet];
];
(* rhs = ToString[InputForm[rhs]]; J*)
rhs = stringer[rhs];

reaction = If[reversible,
 lhs<>"\[RightArrowLeftArrow]"<>rhs,
 lhs<>"\[Rule]"<>rhs
];
reaction = StringReplace[reaction,{" "-> ""}];
reaction = StringReplace[reaction,{"\[Rule]"->" \[Rule]  ","*"-> "","+"-> " + ", "\[RightArrowLeftArrow]"-> " \[RightArrowLeftArrow] "}];
debugPrint[dbg, "reactionForm: return value: ", reaction];

Return[reaction];

]


getSBMLreaction[r_]:=Module[{dbg=False,
opts, reactants, products, kineticlaw,parameters,reactantStoichiometry,
productODEs,reactantODEs,  keepSpecies, ODEs,
  species, theReactionInformation, eval, unkSpecies,reactionName,last,first,pstoic,rstoic,rspecies, pspecies, reaction, localparameters,globalparameters,shadowedparameters, rateEquation, parameterNames, parameterValues, cpu0,cpu1,cpu2,cpu3,cpu4,cpu5,cpu6, cpu7, cpu8, cpu9, cpu10,undefinedLocalParameters,  getSpeciesReference, localContext,localParameterReplacementRules, variables, cpudata, rvars, pvars, cpuRecord, reversibleReaction
},
$ReactionCounter++; 
If[Mod[$ReactionCounter, 50]==0, cpuSet[]]; 

cpuRecord[n_]:=Module[{},
If[$SBML$ReportCPU, 
cpudata=Prepend[cpudata, {n, cpuGet[]} ]; 
]; 
]; 

cpuSet[]; (* initialize *) 
cpudata={}; 

last[x_]:= If[Length[x]>0,Last[x],x];
first[x_]:= If[Length[x]>0, First[x],x];

keepSpecies[{x_, n_}]:=
If[MemberQ[$SBML$FrozenVariables, x],{},{x,n}];

getSpeciesReference[x_ ] := Module[{s, info,
stoichiometries, names,uniqueNames, denominators,i,lens,
dbg=False},
debugPrint[dbg,"getSpeciesReference: input",x];


s="Indeterminate";
Switch[$SBML$Level$Version,
"1.1",
s = Cases[x,XMLElement["specieReference",___],3]; 
,
"1.2",
s = Join[
Cases[x,XMLElement["specieReference",___],3],
Cases[x,XMLElement["speciesReference",___],3]]; 
,

_,
badSBMLVersionAbort["getSBMLreaction::getSpeciesReference:"];

];

info =Map[ extractXMLOptions,s];
info = info/.{"specie"-> "species"};
debugPrint[dbg,"getSpeciesReference: info", info];

names = Map["species"/.#/.{"species"-> "Indeterminate"}&, info];
names = Map[removeUnderscore, names]; 
names = contextify[names];

names = Map[Symbol, names];

denominators = Map["denominator"/.#/.{"denominator"-> "1"}&, info];
denominators=Map[ToExpression,denominators];

stoichiometries=Map[("stoichiometry"/.#)/.{"stoichiometry"-> "1"}&, info];
stoichiometries=Map[ToExpression,stoichiometries];
printWarning[Length[denominators]!= Length[stoichiometries], "Program Bug: Incompatible lengths in denominators and stoichiometries, "<>ToString[denominators]<>ToString[stoichiometries]
];

stoichiometries = stoichiometries/denominators;

debugPrint[dbg,"getSpeciesReference: {names,stoichiometries/denominators}", {names, stoichiometries}];

uniqueNames = Complement[Union[names],{"Indeterminate"}];

  
i = Map[Flatten[Position[names,#]]&, uniqueNames];
lens = Map[Length,i]; 

MapThread[printWarning[#1>1, "Duplicate <speciesReference> tags "<>" for '"<>ToString[#2]<>"' on same side of reaction '"<>ToString[reactionName]<>"'.  Stoichiometry is set to the sum of (stoichimetry/denominator) over all the duplicate references.  "]&,
{lens,uniqueNames}];



debugPrint[dbg,"getSpeciesReference: {uniqueNames,i,lens}", {uniqueNames,i,lens}];

stoichiometries = Map[Apply[Plus,stoichiometries[[#]]]&, i];

debugPrint[dbg,"getSpeciesReference: {uniqueNames,stoichiometries}", {uniqueNames,stoichiometries}];

debugPrint[dbg,"getSpeciesReference: output", s];

Return [{uniqueNames,stoichiometries}];

];(* end getSpeciesReference*)

cpuRecord[1];

cpuSet[];
opts = extractXMLOptions[r];
reactionName = "name"/.opts/.{"name"->"UnNamedReaction$"<>ToString[$ReactionCounter]};
reactionName=removeUnderscore[reactionName]; 

reversibleReaction = ToUpperCase[ToString["reversible"/.opts/.{"reversible"-> "False"}]]; 
reversibleReaction= Switch[reversibleReaction,
"TRUE", True,"FALSE",False,_, False]; 

(* define a local context for reaction parameters *) 

If[$SBML$Context=="None" \[Or]$SBML$Context== "None`", 

localContext=$SBML$Context;
, 

localContext=$SBML$Context;
If[StringTake[$SBML$Context,-1]!= "`", localContext=localContext<>"`"]; 
localContext=localContext<>reactionName<>"`";
]; 

cpuRecord[2];
cpuSet[]; 

reactants = Cases[r,XMLElement["listOfReactants",___],3]; 
{reactants, rstoic}  = getSpeciesReference[reactants];

debugPrint[dbg,"getSBMLReaction: reactants returned from getSpeciesReference",reactants];

cpuRecord[3];
cpuSet[]; 

products = Cases[r,XMLElement["listOfProducts",___],3]; 
{products, pstoic}  = getSpeciesReference[products];

cpuRecord[4];
cpuSet[]; 

kineticLaw = Cases[r,XMLElement["kineticLaw",___],3]; 
If[Length[kineticLaw]<1, 
kineticLaw=
{XMLElement["kineticLaw",{"formula"->"Indeterminate"},{}]}
];

debugPrint[dbg,"getSBMLreaction:: kineticLaw in SBML",kineticLaw ];
parameters = Cases[kineticLaw,XMLElement["listOfParameters",___],3]; 
parameters = Cases[parameters,XMLElement["parameter",___],3]; 
parameters = Map[extractXMLOptions,parameters];

cpuRecord[5];
cpuSet[]; 

parameterNames = Map[removeUnderscore[("name"/.#)]&,parameters];

(* localParameterReplacementRules=Map[contextify, parameterNames]; *)

localParameterReplacementRules=contextify[parameterNames];
cpuRecord[5.2];
cpuSet[]; 
(* parameterNames has the form {model`reaction`k1,...} *) 
parameterNames = Map[contextify[#,localContext]&,parameterNames];

(* localParameterReplacementRules has rules of the form model`k->model`reaction`k: These rules replace the NAMES of the parameters with NAMES in a local (to the individual reaction) context. THEY DO NOT REPLACE THE VALUES!! *)

cpuRecord[5.3];
cpuSet[]; 

localParameterReplacementRules=MapThread[ToString[#1]<>"\[Rule]"<>ToString[#2]&, 
{ localParameterReplacementRules,  parameterNames}];
localParameterReplacementRules=Map[ToExpression, localParameterReplacementRules]; 

cpuRecord[5.5];
cpuSet[]; 

(* Why would this next line be necessary if $SBML$evaluateParameters is False?? *) 

(* If[\[Not]$SBML$evaluateParameters, defineParameter[parameterNames]]; *) 
defineParameter[parameterNames];

cpuRecord[6];
cpuSet[]; 

 parameterValues = Map[ fromEForm[("value"/.#/.{"value"-> $SBML$IndeterminateValue})]&,parameters];

parameterValues=makeString/@parameterValues; 


$SBML$NLocalParameters += Length[parameters];

MapThread[definef[SBMLIC,#1,#2]&, {parameterNames, parameterValues}];

cpuRecord[7];
cpuSet[]; 

(* check for undefined local parameters *) 

undefinedLocalParameters = Select[parameterNames, SBMLIC[#]==
makeString[$SBML$IndeterminateValue]&];
If[Length[undefinedLocalParameters]>0, 

SBMLUndefinedConstants = Join[SBMLUndefinedConstants, undefinedLocalParameters]; 
If[$SBML$UseDefaultParameterValue,
Map[definef[SBMLIC,#,$SBML$DefaultParameterValue]&, undefinedLocalParameters];
];
]; 

cpuRecord[8];
cpuSet[]; 

If[\[Not]$SBML$evaluateParameters, 
addReplacementRule[parameterNames]];

cpuRecord[8.2];
cpuSet[]; 


kineticLaw = Apply[extractXMLOptions,kineticLaw];

cpuRecord[8.3];
cpuSet[]; 

kineticLaw = removeUnderscore["formula"/.kineticLaw];

cpuRecord[9];
cpuSet[]; 

If[dbg,
debugPrint[dbg,"getSBMLreaction::reactionName ",reactionName]; 
debugPrint[dbg,"getSBMLreaction:: opts",opts ];
debugPrint[dbg,"getSBMLreaction:: reactants",reactants ];
debugPrint[dbg,"getSBMLreaction:: rstoic",rstoic ];

debugPrint[dbg,"getSBMLreaction:: products",products ];
debugPrint[dbg,"getSBMLreaction:: pstoic",pstoic ];


debugPrint[dbg,"getSBMLreaction:: kineticLaw",kineticLaw ];
debugPrint[dbg,"getSBMLreaction:: parameters",parameters ];
];

(* here is the big cpu hog *) 
(*
rateEquation=ToExpression[kineticLaw]/.$Species2FunctionRules;
*) 

rateEquation = translateFormula[kineticLaw];

cpuRecord[10];
cpuSet[]; 

rateEquation = ToExpression[rateEquation]/.localParameterReplacementRules;

cpuRecord[10.5];
cpuSet[]; 

If[$SBML$evaluateParameters, 
rateEquation =evaluateConstantValues[rateEquation];
]; 

cpuRecord[11];
cpuSet[]; 

debugPrint[dbg,"getSBMLreaction:: rateEquation(3)",rateEquation ];

cpu5=TimeUsed[];

variables = {products, pstoic}//Transpose;
(*variables = Select[variables,!(MemberQ[$SBML$FrozenVariables,#[[1]]])&]; *)
variables = Select[variables,!(SBMLParameterQ[ToString[#[[1]]]])&];

If[Length[variables]>0, variables=Transpose[variables]]; 

cpuRecord[12];
cpuSet[]; 

productODEs=If[
Length[pstoic]>0,
 MapThread[(#1'[Global`t]==#2*(rateEquation))&, variables] , {}];

variables =  {reactants,rstoic}//Transpose;
(* variables = Select[variables,!(MemberQ[$SBML$FrozenVariables,#[[1]]])&]; *)
variables = Select[variables,!(SBMLParameterQ[ToString[#[[1]]]])&];

If[Length[variables]>0, variables=Transpose[variables]]; 

reactantODEs=If[
Length[rstoic]>0, 
MapThread[(#1'[Global`t]==(-1)*#2*(rateEquation))&,variables] , {}];
ODEs = Join[reactantODEs, productODEs];

cpuRecord[13];
cpuSet[]; 

(* species =Complement[ Union[Join[reactants, products]],$SBML$FrozenVariables]; *) 

species =Union[Join[reactants, products]]; 
species = Select[species, (\[Not]SBMLParameterQ[#])&]; 


cpuRecord[14];
cpuSet[]; 

If[$SBML$evaluateParameters, 
printWarning[MemberQ[{rateEquation},Infinity]\[Or] MemberQ[{rateEquation},ComplexInfinity] \[Or] MemberQ[{rateEquation},Indeterminate],
"Indeterminate form (0/0, 1/0, Infinity) occurs in reaction '"<>reactionName<>"'; unexpected results could occur. This model should be read with evaluateParameters\[Rule]False. " 
];

]; 

cpuRecord[15];
cpuSet[]; 

reaction = reactionForm[reactants, rstoic,products,pstoic,reversibleReaction];

reaction = {reactionName-> reaction};

cpuRecord[16];
cpuSet[]; 

$ReactionODEs[$ReactionCounter]=ODEs;
$ReactionSpecies[$ReactionCounter]=species;
$ReactionParameters[$ReactionCounter]= parameterNames//ToExpression;
$Reactions[$ReactionCounter]=reaction;
$ReactionLaws[$ReactionCounter]=rateEquation; 

cpuRecord[17];

If[$SBML$ReportCPU,

cpudata = Transpose[Reverse[cpudata]]; 
If[Length[reactionCPUProfile]<1,
reactionCPUProfile = cpudata;
aggregatereactionCPUProfile = cpudata;
,
aggregatereactionCPUProfile = Append[aggregatereactionCPUProfile, 
Last[cpudata] + Last[aggregatereactionCPUProfile]
];
reactionCPUProfile = Append[reactionCPUProfile, Last[cpudata]]; 
]; 

(* Print[">>>getReaction ("<>ToString[$ReactionCounter]<>")\n",
TableForm[cpudata]];
*)
]; 

If[Mod[$ReactionCounter, 50]==0,
cpuReport[" reaction "<>ToString[$ReactionCounter]<>", name = "<>reactionName];
]; 
];


ReactionCPUsummary[]:= Module[{r,h},
r=MathSBML`Private`reactionCPUProfile;
h = First[r];
r = Rest[r];
r = Transpose[r];
r = Map[Apply[Plus,#]&, r];
r={h,r};
Print[TableForm[r]]
];


ReactionCPUplot[]:= Module[{r,h,p},
r=MathSBML`Private`reactionCPUProfile;
h = First[r];
r = Rest[r];
r = Transpose[r];
p=MapThread[ListPlot[#1,PlotLabel-> #2,DisplayFunction-> Identity]&, {r,h}];
p = Partition[p, 5,5,{1,1},{}];
Show[GraphicsArray[p]];


r=MathSBML`Private`aggregatereactionCPUProfile;
h = First[r];
r = Rest[r];
r = Transpose[r];
p=MapThread[ListPlot[#1,PlotLabel-> #2,DisplayFunction-> Identity,PlotJoined-> True]&, {r,h}];
p = Partition[p, 5,5,{1,1},{}];
Show[GraphicsArray[p]];

]


badSBMLVersionAbort[msg_]:= Module[{},
Print[msg, " Unknown or unsupported SBML Version: ",$SBML$Level$Version];Abort[];
];


getSBMLparameters[opt___]:= Module[
{dbg,p,names,values, units,undefinedParameters,unitsNotOK,derivedUnits,tbl
},

dbg=$SBML$debug;

p = Cases[$SBML$Models,XMLElement["listOfParameters",___],3]; 
p = Cases[p,XMLElement["parameter",___],3]; 

p = Map[extractXMLOptions,p]; 
debugPrint[dbg, "getSBMLparameters:: p:: ",p];

names = Map["name"/.#&, p];


debugPrint[dbg,"getSBMLparameters:: names:: ",names];

values = Map[getAttributeValue["name",#,"value",p]&,names];
values = (values/.{"value"-> $SBML$IndeterminateValue });

debugPrint[dbg,"getSBMLparameters:: values:: ",values];

units = Map[getAttributeValue["name",#,"units",p]&,names];
units = (units/.{"units"-> $SBML$IndeterminateValue});
units=unitsContextify/@units;

debugPrint[dbg,"getSBMLparameters:: units:: ",units];

unitsNotOK = Select[units,(!unitDefinedQ[#])&]; 
If[Length[unitsNotOK]>0,Print["Warning: "//boldOrange,
"Invalid units specified in <parameter> definition: "//boldBlack,
list2CommaSeparatedString[unitsNotOK]//boldRed
];
]; 

$SBML$NLocalParameters =0;
$SBML$NGlobalParameters = Length[names];
SBMLGlobalParameters=names;

values = Map[fromEForm, values];
names=Map[contextify[removeUnderscore[#]]&,names];
defineParameter[names];

If[saveVerboseData,
derivedUnits=units/.$SBML$UnitRules;
If[$SBML$verboseContext, 
tbl =Transpose[{names, values, units ,derivedUnits}], tbl =Transpose[{names//decontextify, values, units ,derivedUnits}]
]; 

verboseSave["Global Parameters", 
{"Name","Value", "Units","Derived Units"}, 
tbl
]; 

];

debugPrint[dbg,"getSBMLparameters:: names:: ",names];
debugPrint[dbg,"getSBMLparameters:: values:: ",values];

(* 2.7.0.3 - added InputForm so that this works with e format also *)

MapThread[definef[SBMLIC,#1,#2]&, {names, Map[ToString[InputForm[#]]&,values]}];

(* check for missing values *)

SBMLUndefinedConstants = Select[SBMLConstants, SBMLIC[#]==ToString[$SBML$IndeterminateValue]&];
If[Length[SBMLUndefinedConstants]>0, 
If[$SBML$UseDefaultParameterValue,
Map[definef[SBMLIC,#,$SBML$DefaultParameterValue]&, SBMLUndefinedConstants];
];
]; 

Map[addReplacementRule,names]; 
debugPrint[dbg,"getSBMLparameters:: SBMLReplacementRules:: ",SBMLReplacementRules];

names = Map[ToExpression,names];

$SBML$UnitAssociations=Join[$SBML$UnitAssociations,MapThread[ToExpression[#1]-> ToExpression[#2]&, {names,units}]];


Return[];
];


getSBMLrules[opt___]:= Module[{
dbg=False,ruletable,r,interpretRule,
getRuleEquation, addODE
},
r = Cases[$SBML$Models,XMLElement["listOfRules",___],3]; 
debugPrint[dbg,"getSBMLrules: r(1)",r];
$SBML$Algebraic$Rules={};


addODE[ODE_?StringQ]:= Module[{},
$SBML$ODES=Append[$SBML$ODES,ToExpression[ODE]];
];
addODE[x___]:= printWarning["addODE: program Error: argument must be a string: \""<>ToString[x]<>"\""];

getRuleEquation[name_, opts_]:= Module[{v,rhs,ruletype,lhs,eqn},



v=name/.opts/.{name-> "Indeterminate"};
v= removeUnderscore[v]; 
v=contextify[v];
rhs = "formula"/.opts/.{"formula"-> "Indeterminate"};
rhs = removeUnderscore[rhs];

rhs = translateFormula[rhs];
rhs = evaluateReplacementRules[rhs];
ruletype="type"/.opts/.{"type"-> "scalar"};

debugPrint[dbg,"getRuleEquation: v:", v]; 
debugPrint[dbg,"getRuleEquation: ruletype:", ruletype]; 

If[ruletype=="rate",
If[SBMLParameterQ[v], removeReplacementRule[v]];
defineVariable[v];
lhs=functionate[v<>"'"];
eqn = lhs<>"=="<>rhs;
addODE[eqn];
,
(* otherwise assume a "scalar" *) 
printWarning[ruletype!= "scalar","invalid rule type =\""<>ToString[ruletype]<>"\" treated as \"scalar\"."];
defineParameter[v];
SBMLIC[v]=rhs;
addReplacementRule[v]; 
lhs = v;
eqn = lhs<>"\[Rule]"<> rhs;

debugPrint[dbg,"getRuleEquation: SBMLReplacementRules:", SBMLReplacementRules]; 
];
Return[{v,eqn}];
]; (* end of getRuleEquation *) 

interpretRule["parameterRule"-> opts_]:= Module[{v,eqn},
{v,eqn}=getRuleEquation["name",opts];

Return[{v,"parameterRule",eqn}];
];
interpretRule["specieConcentrationRule"-> opts_]:= Module[{v, eqn},
{v,eqn}=getRuleEquation["specie",opts];

Return[{v,"specieConcentrationRule",eqn}];
];
interpretRule["speciesConcentrationRule"-> opts_]:= Module[{v,eqn},
{v,eqn}=getRuleEquation["species",opts];

Return[{v,"speciesConcentrationRule",eqn}];
];

interpretRule["compartmentVolumeRule"-> opts_]:= Module[{v,eqn},
{v,eqn}=getRuleEquation["compartment",opts];

Return[{v,"compartmentVolumeRule",eqn}];
];

interpretRule["algebraicRule"-> opts_]:= Module[{eqn},
eqn = "formula"/.opts/.{"formula"-> "Indeterminate"};
eqn = removeUnderscore[eqn];
eqn ="0=="<>translateFormula[eqn];
$SBML$Algebraic$Rules = Append[$SBML$Algebraic$Rules,ToExpression[eqn]];
Return[{"** None **", "algebraicRule",eqn}];
];

interpretRule[unknown___]:=Module[{},printWarning["interpretRule: programError: unknown or invalid rule format "<>ToString[unknown]];
Return[{"Indeterminate","Indeterminate","Indeterminate"}];];

If[Length[r]>0, 

(* check for multiple sets of rules *) 
If[
Length[r]>1,printWarning[ "getSBMLrules: Only one listOfRules tag is permitted; "<>ToString[Length[r]]<>" sets were found. Additional sets ignored."];
];

(* processs the first or only set of rules *) 
r= First[r];
debugPrint[dbg,"getSBMLrules: r(1.5)",r];
r=extractXMLSubElements[r];
debugPrint[dbg,"getSBMLrules: r(2)",r];

r=Map[getXMLElement,r];
debugPrint[dbg,"getSBMLrules: r(3)",r];

r  = Map[interpretRule,r];
debugPrint[dbg,"getSBMLrules: r(4)",r];
$SBML$NRules = Length[r];
,
$SBML$NRules = 0;
];


debugPrint[dbg, "getSBMLrules: SBMLReplacementRules",SBMLReplacementRules]; 
If[saveVerboseData,
If[!$SBML$verboseContext,
If[Length[r]>0, r = Transpose[r]; 
r = ReplacePart[r,decontextify[r[[1]]] ,1];
r = ReplacePart[r, decontextify[r[[3]], $SBML$Context], 3]; 
r = Transpose[r]; 
]; 
]; 

verboseSave["Rules",{"Variable", "Type of Rule in SBML","Mathematica Translation"}, r];
]; 

];


getSBMLspecies[opt___]:= Module[{dbg,
 species,speciesoptions,speciesNames,speciesIC, speciesICRules, speciesCompartment, compartments,unknownCompartments,  speciesBC, variables, variableic, frozenIC, speciesunits,speciescharge,rr,derivedunits,unitsNotOK, BCorNot
},

dbg = $SBML$debug;

species = Cases[$SBML$Models,XMLElement["listOfSpecies",___],3]; 

(* get each species *) 

Switch[$SBML$Level$Version,
(* 1.1 only allows <specie ...> tags *) 
"1.1",
species = Cases[species,XMLElement["specie",___],3]; 
,

(* 1.2 allows <specie ...> or <specie ...> tags *) 
"1.2",
species = Join[
Cases[species,XMLElement["specie",___],3],Cases[species,XMLElement["species",___],3]
];
,
_,
printWarning["getSBMLspecies:: unknown $SBML$Level$Version: "<>ToString[$SBML$Level$Version]];
];
speciesoptions=Map[extractXMLOptions,species];
speciesNames=Map["name"/.#&,speciesoptions];
speciesIC=Map["initialAmount"/.#/.{"initialAmount"-> $SBML$IndeterminateValue}&,speciesoptions];
speciesIC= Map[fromEForm, speciesIC];

(* just in case some loser names his/her compartments "compartment" *)
 
rr= {("compartment"-> "compartment")-> ("compartment"-> "\[RightPointer]compartment\[LeftPointer]holder")};

speciesCompartment=Map["compartment"/.#/.{"compartment"->$SBML$IndeterminateValue}&,
speciesoptions/.rr];


speciesCompartment = speciesCompartment/.{"\[RightPointer]compartment\[LeftPointer]holder"-> "compartment"};

speciesCompartment=Map[removeUnderscore, speciesCompartment];
speciesCompartment = Map[contextify, speciesCompartment];

speciesunits = Map["units"/.#&,speciesoptions];
speciesunits = speciesunits/.{"units"-> "substance"};
speciesunits = unitsContextify/@speciesunits;

unitsNotOK = Select[speciesunits,(!unitDefinedQ[#])&]; 
printWarning[Length[unitsNotOK]>0,
"Invalid units specified in <species> definition: "<>
list2CommaSeparatedString[unitsNotOK]
];

speciescharge = Map["charge"/.#&, speciesoptions];
speciescharge = (speciescharge/.{"charge"-> "0"});


speciesBC:=Map[(("boundaryCondition"/.#)/.{"boundaryCondition"-> "False"})&,speciesoptions];
BCorNot = Map[If[#=="true","Bound. Cond.", "Variable"]&, speciesBC];


speciesNames=Map[contextify[
removeUnderscore[#]]&,speciesNames];
defineVariable[speciesNames];

speciesNames=Map[Symbol,speciesNames];

speciesICRules=MapThread[#1-> ToExpression[#2]&,{speciesNames,speciesIC}];


debugPrint[dbg, "getSBMLspecies:: speciesCompartment", speciesCompartment];
debugPrint[dbg, "getSBMLspecies:: speciesICRules",speciesICRules];
debugPrint[dbg, "getSBMLspecies:: speciesBC", speciesBC];
debugPrint[dbg,"getSBMLspecies:: speciesNames",speciesNames];

(* 2.7.0.3 - recover species names for output of SBMLSpecies *)
$SBML$Species$IDs = speciesNames;

$SBML$SpeciesCompartmentAssociations=MapThread[Rule,{speciesNames,ToExpression/@speciesCompartment}];

compartments = Union[speciesCompartment];
unknownCompartments=Complement[compartments,$SBML$CompartmentNames];

printWarning[Length[unknownCompartments]>0,
"Unknown compartments specified in specie definition: "<>list2CommaSeparatedString[unknownCompartments]
];

If[saveVerboseData,

derivedunits = speciesunits/.$SBML$UnitRules;
If[$SBML$verboseContext,

verboseSave["Species",
 {"Name","I.C.","Units", "Derived Units", "Charge", "Compartment","Var/B.C."},Transpose[{speciesNames, speciesIC,speciesunits,derivedunits, speciescharge,speciesCompartment,BCorNot}]
];

,

verboseSave["Species", 
{"Name","I.C.","Units", "Derived Units", "Charge", "Compartment","Var/B.C."},
Transpose[{Map[ToString,speciesNames]//decontextify, speciesIC,speciesunits,derivedunits, speciescharge,speciesCompartment//decontextify,BCorNot}]
];
]; 
]; 
speciesoptions=MapThread[{"name"-> #1, "boundaryCondition"-> #2}&,
{speciesNames,speciesBC}];

$SBML$FrozenVariables=getAttributeValues["boundaryCondition","true","name",speciesoptions];

defineParameter[Map[ToString,$SBML$FrozenVariables]];
MapThread[definef[SBMLIC,ToString[#1],ToString[InputForm[#2]]]&, {speciesNames, speciesIC}];

addReplacementRule[Map[ToString,$SBML$FrozenVariables]];

$SBML$UnitAssociations=Join[$SBML$UnitAssociations,MapThread[ToExpression[#1]-> ToExpression[#2]&, {speciesNames,speciesunits}]];


Return[];
];


getSBMLcompartments[opt___?OptionQ]:= Module[{m, c,cc,names,volumes, units,derivedunits, outsides, outside,notok,dbg, unitsNotOK ,defaultAttributes={"volume"-> "1", "units"-> "volume"}},
dbg = $SBML$debug;

m = $SBML$Models; 

c = Cases[$SBML$Models,XMLElement["listOfCompartments",___],3]; 

cc= Cases[c,XMLElement["compartment",___],3]; 
If[Length[c]<1  \[Or] Length[cc]<1,
Switch[$SBML$Level$Version ,
"1.1",printWarning["SBML level 1.1 must contain at least one compartment"];Abort[];
,
"1.2",
names = {ToString[$SBML$IndeterminateValue ]};
volumes={"1"};
units = {"volume"};
outsides={ ToString[$SBML$IndeterminateValue ]};
,
_,printWarning["SBML level"<>ToString[$SBML$Level$Version]<>"must contain at least one compartment"];Abort[];
];

(* this is the else clause, i.e, Length[c]>= 1 *) 
,

c = cc;
c = Map[extractXMLOptions, c];

(* get names and check outsides for consistency *) 

names = Map["name"/.#&,c];
outsides = Map["outside"/.#&,c];
outside = outsides; 
outsides = Complement[outsides, {"outside"}]; 

(* check names of outside compartments *) 
notok=Complement[outsides,names];
printWarning[Length[notok]>0, 
"Unknown outside compartment "<>list2CommaSeparatedString[notok]
];

(* convert names and outside names to mathematica names *) 

names = Map[removeUnderscore, names];
outsides = Map[removeUnderscore, outside/.{"outside"-> ToString[$SBML$IndeterminateValue (* $Universal$OutsideCompartment*) ] }];

names = contextify[names];
outsides = Map[If[ToString[#]!= ToString[$SBML$IndeterminateValue], contextify[#], #]&, outsides];

defineParameter[names];
defineParameter[Complement[outsides, {ToString[$SBML$IndeterminateValue]}]];

(* get volumes and units *) 
volumes = Map["volume"/.#/.{"volume"-> 1} &, c];

(* volumes= Map[fromEForm, volumes];
debugPrint[dbg,"getSBMLcompartments:: volumes",volumes];
volumes = Map[ToString,volumes];
*) 
volumes = fromEForm/@volumes;

debugPrint[dbg,"getSBMLcompartments:: volumes",volumes];

units = Map["units"/.#/.{"units"-> "volume"}&,c];
units = unitsContextify/@units;


unitsNotOK = Select[units,(!unitDefinedQ[#])&]; 
printWarning[Length[unitsNotOK]>0,
"Invalid units specified in <compartment> definition: "<>
list2CommaSeparatedString[unitsNotOK]
];

$SBML$UnitAssociations=Join[$SBML$UnitAssociations,MapThread[ToExpression[#1]-> ToExpression[#2]&, {names,units}]];

]; (* end of if Length[c]<1 ...*) 

(* save globals *) 
$SBML$CompartmentNames=names; 
$SBML$CompartmentVolumes=MapThread[Symbol[#1]-> ToExpression[#2]&,{names,volumes}]; 
$SBML$CompartmentUnits=units; 
$SBML$CompartmentOutsides=outsides;

debugPrint[dbg,"getSBMLcompartments:: $SBML$CompartmentNames",$SBML$CompartmentNames];
debugPrint[dbg,"getSBMLcompartments:: $SBML$CompartmentVolumes",$SBML$CompartmentVolumes];


c=MapThread[
{"name"-> #1, "volume"-> #2, "units"-> #3, "outside"-> #4}&,
{names, volumes, units, outsides}
];
$SBML$NCompartments = Length[c];
debugPrint[dbg,"getSBMLcompartments:: c",c];


If[saveVerboseData,
derivedunits=units/.$SBML$UnitRules;
If[$SBML$verboseContext,
verboseSave["Compartments",
{"Name","Volume","Units","Derived Units", "Outside"},
Transpose[{names,volumes,units,derivedunits,outsides}]
];

,
verboseSave[ "Compartments",
 {"Name","Volume","Units","Derived Units", "Outside"},
Transpose[{decontextify[names],volumes,units,derivedunits,decontextify[outsides]}]];
];
]; 

MapThread[definef[SBMLIC,#1,#2]&, {names,ToString/@InputForm/@volumes}];


Map[addReplacementRule, names];
If[dbg, Print["getSBMLcompartments - done"]]; 

Return[];
];



removeVariable[z_]:= Module[{p},

SBMLVariables=Complement[SBMLVariables,{z}];
SBMLVariableQ[z]=False;
(* Print[z, " no longer a variable"]; *) 
]; (* end removeVariable *) 


defineParameter[x_?StringQ]:= Module[{},
If[SBMLVariableQ[x], removeVariable[x]]; 
SBMLParameterQ[x]=True; 
SBMLVariableQ[x]=False;
SBMLConstants=Append[SBMLConstants,x]; 
];
defineParameter[x_?ListQ]:= Map[defineParameter,x];
defineParameter[x_]:= Module[{},
printWarning["defineParameter: program error: argument not a String or List: "<>ToString[x]];
];


defineVariable[x_?StringQ]:= Module[{removeConstant, dbg=False},
removeConstant[z_]:= Module[{p},
p=Position[SBMLConstants, z];
While[Length[p]>0,
p = Map[First,p];
p =First[p]; 
SBMLConstants= Drop[SBMLConstants, {p}];
p=Position[SBMLConstants, z];
];
]; (* end removeConstant *) 


If[dbg, Print["defineVariable: x: ", x]]; 
If[stringer[decontextify[x]]=="t", Return[]]; 

If[SBMLVariableQ[x], Return[]]; (* already a variable *) 

(* SBMLConstants = Complement[SBMLConstants,{x}]; *) 
If[SBMLparameterQ[x], removeConstant[x]]; 

SBMLParameterQ[x]=False; 
SBMLVariableQ[x]=True;
SBMLVariables = Append[SBMLVariables, x];
(* Print[x, " added as a variable"]; *)
];

defineVariable[x_?ListQ]:= Map[defineVariable,x];
defineVariable[x_]:= Module[{},
printWarning["defineVariable: program error: argument not a String or List: "<>ToString[x]];
];


getSBMLunits[opt___?OptionQ]:= Module[{
c,cc,dbg=False,defaultUnitsNeeded,defaultUnitRules,
defaultSpecTable5={"substance"-> "mole","volume"-> "liter", "time"-> "second"}, 
specTable5, 
defaultbuiltInQuantities={"substance","volume","time"},
builtInQuantities,
getSBMLUnitDefinition,
unitDefinitions,names,defs,
defaultAllowedKinds={"ampere","becquerel","candela","celsius","coulomb","dimensionless","farad","gram","gray","henry","hertz","item","joule","katal","kelvin","kilogram","liter","litre","lumen","lux","meter","metre","mole","newton","ohm","pascal","radian","second","siemens","sievert","steradian","tesla","volt","watt","weber"},
allowedKinds
},

allowedKinds = unitsContextify/@defaultAllowedKinds;
builtInQuantities=unitsContextify/@defaultbuiltInQuantities;
specTable5 = Map[unitsContextify[#[[1]]]-> unitsContextify[#[[2]]]&, defaultSpecTable5]; 
debugPrint[dbg, "getSBMLunits: specTable5 ",specTable5];


getSBMLUnitDefinition[z_]:= Module[{opts,units,listofunits,name, unitspecs,kinds,exponents, scales,disallowedKinds,unitdef,unitdefinition,dbg=True},

unitdef[{kind_, exp_, scale_}]:=
ToExpression["10^"<>ToString[scale]<>"*("<>ToString[kind]<>")^"<>ToString[exp]];

opts = extractXMLOptions[z];
name = "name"/.Flatten[{opts}]/.{"name"-> "Indeterminate"};
name = unitsContextify[name]; 
debugPrint[dbg, "getSBMLUnitDefinition: input ",z];
debugPrint[dbg, "getSBMLUnitDefinition: opts ",opts];

listofunits = Cases[z,XMLElement["listOfUnits",___],3]; 
debugPrint[dbg, "getSBMLUnitDefinition: listofunits ",listofunits];

If[Length[listofunits]>0,
units =Cases[listofunits,XMLElement["unit",___],3];
debugPrint[dbg, "getSBMLUnitDefinition: units ",units];

If[Length[units]>0, 
unitOptions = Map[extractXMLOptions,units];

unitspecs = Map[{"kind","exponent","scale"}/.#/.{"kind"-> "Indeterminate","exponent"-> "1", "scale"-> "0"}&, unitOptions]//ToLowerCase;
{kinds,exponents,scales}=Transpose[unitspecs];
kinds = unitsContextify/@kinds;
unitspecs = Transpose[{kinds, exponents,scales}]; 

disallowedKinds=Complement[kinds,allowedKinds];

printWarning[Length[disallowedKinds]>0,
"Invalid Kinds :"<>list2CommaSeparatedString[disallowedKinds]<>" in unitDefinition for '"<>ToString[name]<>"'."];
,
unitOptions={};
kinds={ToString[name]/.specTable5/.{ToString[name]-> "Indeterminate"}};
exponents={"1"};
scales={"0"};
unitspecs = Transpose[{kinds,exponents,scales}];
printWarning["no <unit> tags given in unitDefinition for '"<>ToString[name]<>"'."];
];
debugPrint[dbg, "getSBMLUnitDefinition: unitspecs ",unitspecs];
debugPrint[dbg, "getSBMLUnitDefinition: unitOptions ",unitOptions];
debugPrint[dbg, "getSBMLUnitDefinition: kinds ",kinds];


unitdefinition=Apply[Times,Map[unitdef,unitspecs]]//InputForm//ToString;
debugPrint[dbg, "getSBMLUnitDefinition: unitdefinition ",unitdefinition];

,

printWarning["No listOfUnits given in the unitDefinition for '"<>ToString[name]<>"'."];
unitdefinition="Indeterminate";
]; 

Return[{name,unitdefinition}];
]; (* end getSBMLUnitDefinition *)


$SBML$UnitsDefined =allowedKinds;
debugPrint[dbg, "getSBMLunits: $SBML$UnitsDefined ",$SBML$UnitsDefined];

c = Cases[$SBML$Models,XMLElement["listOfUnitDefinitions",___],3]; 
cc= Cases[c,XMLElement["unitDefinition",___],3]; 

debugPrint[dbg, "getSBMLunits: listOfUnitDefinitions: ",c];
debugPrint[dbg, "getSBMLunits: unitDefition's: ",cc];

unitDefinitions=Map[getSBMLUnitDefinition,cc];
debugPrint[dbg, "getSBMLunits: unitDefinitions ",unitDefinitions];

If[Length[unitDefinitions]>0, {names, defs} = Transpose[unitDefinitions];
$SBML$UnitsDefined = Join[$SBML$UnitsDefined, names]//Union;
debugPrint[dbg, "getSBMLunits: $SBML$UnitsDefined ",$SBML$UnitsDefined];

$SBML$UnitRules=MapThread[#1->#2&,{names,defs}];

(* remove indeterminate rules *) 

$SBML$UnitRules = Select[$SBML$UnitRules,Last[#]!= "Indeterminate"&]; 
debugPrint[dbg, "getSBMLunits: $SBML$UnitRules ",$SBML$UnitRules];

defaultUnitsNeeded = Complement[builtInQuantities,names];
debugPrint[dbg, "getSBMLunits: defaultUnitsNeeded ",defaultUnitsNeeded];


defaultUnitRules=Map[#-> (#/.specTable5)&,defaultUnitsNeeded];
debugPrint[dbg, "getSBMLunits: defaultUnitRules ",defaultUnitRules];

debugPrint[dbg,"getSBMLUnits: defaultUnitRules ",defaultUnitRules];
$SBML$UnitRules=Join[$SBML$UnitRules, defaultUnitRules];

,
$SBML$UnitRules= specTable5;
];
$SBML$UnitsDefined=Join[$SBML$UnitsDefined,builtInQuantities]//Union;

debugPrint[dbg, "getSBMLunits: $SBML$UnitsDefined ",$SBML$UnitsDefined];
debugPrint[dbg, "getSBMLunits: $SBML$UnitRules ",$SBML$UnitRules];

If[saveVerboseData,
verboseSave["Unit Definitions",{"Name", "Formula"}, unitDefinitions];
];

Return[];
];


unitDefinedQ[x_]:= (x==  "Indeterminate") \[Or] (MemberQ[$SBML$UnitsDefined, x]);


extractXMLOptions[
XMLElement[x_, optionList_, stuff___]]:= Module[{}, Return[optionList]];


extractXMLSubElements[XMLElement[_, {___}, x_]]:=x;


getXMLElement[XMLElement[name_, {opt___},x_]]:= (name->{opt});


extractSBMLtag[xml_, tag_, level_:Infinity]:= 
Cases[xml,XMLElement[ToString[tag],___],level];


contextify[x_?StringQ,context_:""]:=Module[{s,c},
If[x=="" \[Or] x=="Indeterminate", Return[x]];

(* reversed the following two lines in 2.7.0.2 10-15-07 *)
(* and add check for ValueQ of $SBML$Context *)
(* possible for external program to set $SBML$Context to a non-string! *)

c=context;
If[c=="", 
If[ValueQ[$SBML$Context],
c=$SBML$Context,
Print["Warning:"//boldRed, " contextify: "//boldBlue, " $SBML$Context has not been initialized. x = "//boldBlack, x//boldBlue]; 
c="None"
]
];
c = ToString[c];

If[c=="None" \[Or] c=="None`", Return[x]]; 
If[StringTake[c,-1]!= "`", 
s=c<>"`"<>x,
s=c<>x;
];
Return[s];
];
contextify[x_-> y_, context_:""]:= (contextify[x,context]-> contextify[y,context]);

contextify[x_?ListQ,context_:""]:= Map[contextify[#,context]&, x];
contextify[x_[y___],context_:""]:= contextify[x,context][y];
contextify[x_, context_:""]:= Module[{},
If[ToString[Head[x]]=="Symbol",
contextify[ToString[x],context]//ToExpression//Return;
];
Print["Error: "//boldRed, "contextify: "//boldBlue, "The argument to contextify must be a string or a symbol; argument used: "//boldBlack, x//boldRed];
Return[x];
] ;

unitsContextify[x_]:= contextify[x, $SBML$UnitsContext]; 


decontextify::usage="decontextify[x] returns the symbol or string x representing a symbol with all context references removed.\ndecontextify[{x1,x2,...}] applies decontextify to each of x1, x2, .. and returns a list with the context removed from  each symbol or string. ";
decontextify[x_?StringQ]:= Module[{p,q},
p = StringPosition[x,"`"];
If[Length[p]<1, Return[x]];
p=Map[First,p];
p = Last[p];
q= StringDrop[x,p];
Return[q];
];
decontextify[x_?ListQ]:= Map[decontextify,x];
decontextify[x_]:= Module[{s},
decontextify[ToString[InputForm[x]]]//ToExpression//Return;
(* mod 7/29/03 *) 
(*
If[ToString[Head[x]]=="Symbol",decontextify[ToString[x]]//ToExpression//Return];
 printWarning["The argument to decontextify must be a string, symbol, or list thereof: "<>ToString[InputForm[x]]];
Return[x];
*) 
];

decontextify[x_?StringQ, context_?StringQ]:= StringReplace[x, {context-> ""}]; 
decontextify[x_?ListQ, context_?StringQ]:= Map[decontextify[#,context]&,x]; 
decontextify[x_, context_?StringQ]:= Module[{},
decontextify[ToString[InputForm[x]],context]//ToExpression//Return;
(* mod 7/29/03 *) 
(*
If[ToString[Head[x]]=="Symbol",decontextify[ToString[x],context]//ToExpression//Return];
printWarning["The argument to decontextify must be a string, symbol, or list thereof: "<>ToString[InputForm[x]]];
Return[x];
*) ]; 

unitsDecontextify[x_]:= decontextify[x, $SBML$UnitsContext]; 



functionate[f_?StringQ, arg_:"t"]:=Module[{tvariable},
tvariable = ToString[arg];
Return[f<>"["<>tvariable<>"]"];
];
functionate[f_?ListQ,arg_:"t"]:= Map[functionate[#,arg]&, f];

 functionate[f_, arg_:"t"]:= Module[{g},
(* If[ToString[Head[f]]=="Symbol", *)
g=functionate[ToString[f], ToString[arg]];
Return[ToExpression[g]];
(* ];
 Print["Warning: "//boldRed, "functionate: "//boldBlack, " input must be a string or symbol. Actual input: "//boldBlack, f//boldBlue, " Notify developer of possible program bug."//boldRed]; 
Return[f]; *)
];



defunctionate[f_[t_]]:=f;
defunctionate[f_?StringQ]:=StringReplace[f, "["~~___~~"]"-> ""];
defunctionate[f_]:=f;

functionize[f_?StringQ]:= functionize[f, "t"];
functionize[f_?StringQ, arg_?StringQ]:= f<>"\[LeftDoubleBracket]"<>arg<>"\[RightDoubleBracket]"; 
defunctionize[f_?StringQ]:= StringReplace[f, {"\[LeftDoubleBracket]"-> "[", "\[RightDoubleBracket]"-> "]"}];


initialize[x_?StringQ]:=functionate[x,"0"]<>"=="<> SBMLIC[x];
initialize[x_?ListQ]:= Map[initialize,x];
initialize[x___]:= printWarning["initialize:: program error: argument must be string or list of strings: \""<>ToString[x]<>"\""];


parameterate[x_?StringQ]:= x<>"\[Rule]"<>SBMLIC[x]; 
parameterate[x_?ListQ]:= Map[parameterate, x];
parameterate[x___]:= printWarning["parameterate:: program error: argument must be string or list of strings: \""<>ToString[x]<>"\""];


differentize[f_, arg_:"t"]:= Module[{g},
g= StringReplace[functionate[stringer[f], arg], "["-> "'["]; 
If[StringQ[f], Return[g]];
Return[ToExpression[g]]; 
]; 


addReplacementRule[x_?StringQ]:= Module[{newrule},
(* if its there, remove old rule *) 

removeReplacementRule[x]; 

(* don't create a replacement rule unless there is something to replace - don't add rules of the form x->Indeterminate *) 
(* Print["x=",x," ic=", SBMLIC[x]]; *) 
If[SBMLIC[x]!= ToString[$SBML$IndeterminateValue], 
newrule =parameterate[x];
SBMLReplacementRules=Append[SBMLReplacementRules, ToExpression[newrule]];
(* Print["replacement rule: ",newrule]; *) 
(* Print[newrule," added."]; *) 
];
];
addReplacementRule[x_?ListQ]:= Map[addReplacementRule,x];

addReplacementRule[x___]:= printWarning["addReplacementRule: program error: argument must be a string: \""<>ToString[InputForm[x]]<>"\""];

addLocalReplacementRule[x_?StringQ]:= Module[{newrule},
newrule =parameterate[x];
SBMLReplacementRules=Append[SBMLReplacementRules, ToExpression[newrule]];
];
addLocalReplacementRule[x___]:= printWarning["addLocalReplacementRule: program error: argument must be a string: \""<>x<>"\""];

removeReplacementRule[y_?StringQ]:= Module[{p,x},
(* following line added 7-28-03; previously, x was argument; but SBMLReplacementRules are all expressions and not strings*) 
x= ToExpression[y];
(* inefficient but elegant algorithm *) 
(* SBMLReplacementRules=Select[SBMLReplacementRules,(ToString[First[#]]!= x)&]; *) 

(* inelegant but optimized algorithm *) 
(* while loop is used because there may be more than one rule! *) 
p=Position[First/@SBMLReplacementRules,x];
(* Print["removeReplacementRule before:",y,",",SBMLReplacementRules,",",p]; *) 
While[Length[p]>0,
p=Map[First,p];
p = First[p]; 
(* following line changed 7-28-03 from Drop[r,{p}]; r is undefined??!? *)
SBMLReplacementRules=Drop[SBMLReplacementRules,{p}];
p=Position[First/@SBMLReplacementRules,x];
];
(* Print["removeReplacementRule after:",SBMLReplacementRules]; *) 

]; 


removeReplacementRule[x___]:= printWarning["removeReplacementRule: program error: argument must be a string: \""<>x<>"\""
];

evaluateReplacementRules[expression_?StringQ]:= Module[{s},
If[$SBML$evaluateParameters, 
s= ToExpression[expression];
s = (s/.SBMLReplacementRules);
s=ToString[InputForm[s]];
Return[s]; 

];
Return[expression];
];

evaluateReplacementRules[expression_]:= Module[{s},
If[$SBML$evaluateParameters, 
s = (expression/.SBMLReplacementRules);
Return[s]; 
]; 
Return[expression]; 
];


evaluateConstantValues[expression_]:= Module[{ConstantValue,s,v},
ConstantValue[x_]:= Module[{v,sx},
sx =If[StringQ[x], x,  ToString[x]]; 
If[!MathSBML`Private`SBMLParameterQ[sx], Return[x]]; 
v= MathSBML`Private`SBMLIC[sx];

If[v=="Indeterminate",
Return[x]]; 
Return[ToExpression[v]]; 
]; 

s= ToString[InputForm[expression]];
s = StringReplace[s, {"*"-> ",","/"-> ",", "^"-> ",", "+"-> ",", "-"-> ",","("-> ",", ")"-> ",", "["-> ",", "]"-> ","}];
While[StringTake[s,1]==",", s = StringDrop[s,1]];
While[StringTake[s,-1]==",",s=StringDrop[s,-1]];
s="{"<>s<>"}";
s= StringReplace[s," "-> ""]; 

While[Length[StringPosition[s,",,"]]>0,
s=StringReplace[s,",,"-> ","]; 
]; 

s = ToExpression["{"<>s<>"}"]//Flatten;
s = Select[s, !NumberQ[#]&]//Union;
s = Select[s, MathSBML`Private`SBMLParameterQ[ToString[#]]&]; 
v = Map[ConstantValue,s];
r= MapThread[#1-> #2&, {s,v}];
expression/.r
]; 



translateFormula[f_]:= translateFormula[f, $SBML$Context]; 
translateFormula[f_,context_]:=  Module[
{dbg=False,
s,p,p1,sbmlSymbols={"(",")","-","^","*","/","+",","},
level1pdf={"abs","acos","asin","atan","ceil","cos","exp","floor","log","log10","pow","sqr","sqrt","sin","tan","mass","uui","uur","uuhr","isouur","hilli","hillr","hillmr","hillmmr","usii","usir","uai","ucii","ucir","unii","unir","uuci","uucr","umi","umr","uaii","uar","ucti","uctr","umai","umar","uhmi","uhmr","ualii","ordubr","ordbur","ordbbr","ppbr"},
allowedCharacters = {"A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z","a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z","0","1","2","3","4","5","6","7","8","9","(",")","-","^","*","/","+",",","."},
exponentCharacters={"E","e","D","d","Q","q"},
isAFunction,
isANumber,
isASymbol,
symbolRules,ctxt,punctuation,bracketLocations,n,findMatch,closing, isAVariable, badCharacters, cc,isTime,endsWithExponentCharacter,possiblemantissaQ,i,ch,cnext,pnext
},
(* cpuSet[]; *) 

isAFunction[x_]:= MemberQ[level1pdf,x];
isANumber[x_]:= MemberQ[CharacterRange["0","9"],StringTake[x,1]];
isTime[x_]:= (x=="t"); 
isASymbol[x_]:= \[Not](isAFunction[x] \[Or]isANumber[x]\[Or]isTime[x]);
isAVariable[x_]:= (isASymbol[x] \[And] SBMLVariableQ[x]);
endsWithExponentCharacter[x_]:= MemberQ[exponentCharacters,StringTake[x,-1]];
possiblemantissaQ[x_]:= isANumber[x] \[And] endsWithExponentCharacter[x]; 

ctxt = context;
If[StringTake[ctxt,-1]!= "`", ctxt = ctxt<>"`"];

ff=StringReplace[f," "-> ""];

(* Check for bad characters*) 
cc = Characters [ff]; 
badCharacters = Complement[cc, allowedCharacters];
badCharacters = Complement[badCharacters, {$SBML$Underscorecharacter}];  
If[Length[badCharacters]>0,
printWarning["translateFormula: the formula \""<>f<>"\" contains the following invalid characters: "<>list2CommaSeparatedString[badCharacters]];
];

(* make sure that there are at least some delimiters! *) 

ff="("<>ff<>")";

(* determine where the non-punctuation characters are *)
p= Flatten[Map[Union,StringPosition[ff,sbmlSymbols]]];
p1= Partition[p,2,1];
p1 =Prepend[ Append[p1, {Last[p],1+StringLength[ff]}],{0,First[p]}];
p1= Select[p1,(Last[#]-First[#]>1)&];
p1 = Map[{First[#]+1, Last[#]-1}&,p1];
debugPrint[dbg,"translateFormula: p1",p1];
s = Map[StringTake[ff,#]&,p1];
debugPrint[dbg,"translateFormula: s",s,Length[s]];

(* determine where the punctuation characters are *) 
punctuation = Append[Prepend[Flatten[p1],0],1+StringLength[ff]];
punctuation = Partition[punctuation,2];
punctuation = Map[{1+First[#],Last[#]-1}&, punctuation];
punctuation=Map[StringTake[ff,#]&, punctuation];
debugPrint[dbg,"translateFormula: punctuation",punctuation];

(* add context and function-dependence *) 
s=Map[If[isASymbol[#],contextify[#,ctxt],#]&, s];
debugPrint[dbg,"translateFormula: contextified s=",s];

s=Map[If[isAVariable[#],functionize[#],#]&, s];
debugPrint[dbg,"translateFormula: functionized s=",s];

(* check for split exponential: 1.5E-17 will be split into 1.5E, -, 17. Repalce the 1.5E with 1.5E-17 and the 17 with zero.  *) 

cnext=s[[1]];
For[i=1,i< Length[s],i++, 
cn = cnext;
cnext=s[[i+1]];
pnext = punctuation[[i+1]];
If[pnext== "+" \[Or] pnext== "-", 
If[possiblemantissaQ[cn] \[And] isANumber[cnext],
s= ReplacePart[s, cn<>pnext<>cnext,i];
s=ReplacePart[s,"0",i+1]; 
cnext = "0"; (* replace with +0 or -0 *) 
]; 
]; 
]; 

(* take care of E-form constants *) 
s=Map[If[isANumber[#],ToString[InputForm[fromEForm[#]]],#]&, s];
debugPrint[dbg,"translateFormula: Eformed s=",s];


(* add opening function brackets *) 
s = Map[If[isAFunction[#], #<>"[",#]&, s];
debugPrint[dbg, "translateFormula: leading [ s=",s];

(* turn formula back into a single string *)

s=Append[Transpose[{Drop[punctuation,-1],s}],Last[punctuation]]//Flatten//StringJoin;
(* the only place there could have been a [ is if we just put it there. If there is not a parenthesis right away then the formula is ill-formed *)
s = StringReplace[s,"[("-> "["];

bracketLocations= StringPosition[s,"["];
bracketLocations=Map[First,bracketLocations];
debugPrint[dbg,"translateFormula: brackets at ", bracketLocations];
n=StringLength[s];

(* for each function opening, find the function closing, and replace the parenthesis with a bracket *)
findMatch[istart_]:= Module[{i,pcount},
pcount = 1;
i = istart;
While[i<n,
i++;
Switch[StringTake[s,{i}],
"(",pcount++,
"[",pcount++,
")",pcount--
];
If[pcount==0,Return[i]];
];
Return[n];
]; (* end findMatch *) 

closing = Map[findMatch,bracketLocations];
closing = Transpose[{closing,closing}];

s = StringReplacePart[s,"]",closing];
debugPrint[dbg,"translateFormula: closing brackets", s];
s = defunctionize[s];
debugPrint[dbg, "------------ translateFormula: return value: ",s];
(* cpuReport["translateFormula"];  *) 

s=applyLevel1MathFunctions[s];

Return[s];
];


applyLevel1MathFunctions[formula_]:=Module[{ mylog10,mysquare, r={Global`abs-> Abs, Global`acos-> ArcCos, Global`asin-> ArcSin, Global`atan-> ArcTan,Global`ceil-> Ceiling, Global`cos-> Cos, Global`exp-> Exp, Global`floor-> Floor, Global`log-> Log ,Global`log10-> mylog10, Global`pow-> Power, Global`sqr-> mysquare,Global`sqrt-> Sqrt, Global`sin-> Sin, Global`tan-> Tan },f},

mylog10[x_]:= Log[10.,x];
mysquare[x_]:= x*x;
f=stringer[formula];
f=ToExpression[f];
f=(f/.r);
f=stringer[f];
Return[f];
];


abortIfNoTag[xml_, tag_]:= If[Length[xml]<1,
Print["Error: "//boldRed, "No "//boldBlack,quote[ stringer[tag]]//boldBlue, " found."//boldBlack];
 Abort[] 
];


list2CommaSeparatedString[l_,opt___?OptionQ]:= Module[{ll,commaValue,lcomma},
commaValue = (comma/.{opt}/.{comma-> ","})//ToString;
lcomma = StringLength[commaValue]; 

ll = Flatten[{l}];
If[Length[ll]<1, Return[""]];
ll = Map[ToString, ll];
ll = Map[StringJoin[#,commaValue]&,ll];
ll = Apply[StringJoin,ll];
ll = StringDrop[ll,-1*lcomma];
Return[ll];
]


getAttributeValue[desiredAttribute_, 
valueOfDesiredAttribute_, 
unknownAttribute_, 
opt___?OptionQ]:= Module[{c, valueOfUnknownAttribute},
c = Cases[opt,{___,desiredAttribute-> valueOfDesiredAttribute,___}];
If[Length[c]>1,
Print["Warning: The attribute\[Rule]value pair "<>ToString[desiredAttribute]<>"\[Rule]"<>ToString[valueOfDesiredAttribute]<>" occurs more than once." ];
c = Last[c];
];
c=Flatten[c];
valueOfUnknownAttribute=unknownAttribute/.c;
Return[valueOfUnknownAttribute];
]


getAttributeValues[desiredAttribute_, 
valueOfDesiredAttribute_, 
unknownAttribute_, 
opt___?OptionQ]:= Module[{c, valueOfUnknownAttribute},
c = Cases[opt,{___,desiredAttribute-> valueOfDesiredAttribute,___}];
valueOfUnknownAttribute=Map[
unknownAttribute/.#&, c];
Return[valueOfUnknownAttribute];
]


SBMLLogPlot[q_?InterpolationSetListQ,   opt___?OptionQ]:= Module[
{dbg=False, vars, data, getvars, times, tbegin, tend, legends, colors, n, p, selectRealPositives},
getvars[InterpolationSet[t1_,t2_,sol_]]:= Module[{vars},
vars = First/@sol;
vars = StringReplace[stringer/@vars,"[t]"-> ""]//ToExpression;
If[dbg, Print["SBMLLogPlot: Interpolation Set: getVars: "//boldBlue,"{t1,t2}="//boldBlack,{t1,t2}//boldRed, "vars="//boldBlack,vars//boldRed]];

Return[{{t1,t2}, vars}];
];
vars = getvars/@q;
times = First/@vars;
vars = Last/@vars;
tbegin = Min[times]; tend = Max[times]; 
vars = Intersection[vars]//Flatten; (* might loose variables if the sets are different *) 
legends = decontextify[stringer/@vars];
n=Length[legends];
colors = Map[Hue,Range[n]/(1.0*n)];
MultiPlot$Colors=colors;
MultiPlot$Styles=colors;
MultiPlot$Legends = legends;



If[dbg, 
Print["SBMLLogPlot: Interpolation Set:"//boldBlue, "vars="//boldBlack,vars//boldRed];
Print["SBMLLogPlot: Interpolation Set:"//boldBlue, "times="//boldBlack,times//boldRed, " tbegin="//boldBlack, tbegin//boldRed, " tend="//boldBlack, tend//boldRed];
];

data = dataTable[#,{Global`t,tbegin, tend, (tend-tbegin)/50.}, q]&/@vars;
data = Rest/@data; 

selectRealPositives[z_]:= 
Select[z, (Im[Last[#]]==0 && Re[Last[#]]>SBML$LogPlotZero)&];
data = selectRealPositives/@data;


Off[Graphics::gptn];
p=MapThread[
Graphics`Graphics`LogListPlot[#1,opt, PlotJoined-> True, PlotStyle-> #2, DisplayFunction-> Identity]&, {data, colors}];
On[Graphics::gptn];
Return[Show[p, opt, PlotRange-> All]];
];



SBMLLogPlot[soln_,var_?ListQ, {tbegin_, tend_},opt___?OptionQ]:= Module[{n,p,colors, legend, autoscale, man,mans,exps, dbg=False},

(* add autoscaling 6-2-04 *) 
(* figure out the max & minimum value plotted *)

plottable=var;
autoscale=findMiniMax[soln, #, {tbegin,tend}, filterNonPositives-> True,opt]&/@var;
autoscale = Select[Flatten[autoscale],Positive];
autoscale = {Min[autoscale], Max[autoscale]};
n = Length[plottable]; 
colors = Map[Hue,Range[n]/(1.0*n)];

(* now round off the mantissa *)

man = MantissaExponent/@autoscale;
{mans,exps} = Transpose[man];

mans = 10*mans;
mans = {Floor[mans[[1]]], Ceiling[mans[[2]]]};
mans = mans/10.;
man = Transpose[{mans,exps}];

autoscale = #[[1]]*(10^#[[2]])&/@man;

If[autoscale[[2]]<0 ,
Print["Warning:"//boldOrange, " unable to autoscale logarithmic plot due to all data values being negative. Range of data values is "//boldBlack, autoscale//boldRed];
autoscale={autoscale[[1]], 1};
];

If[autoscale[[1]]<0, 
Print["Warning:"//boldOrange, " unable to fully autoscale logarithmic plot due to negative data value. Range of data values is: "//boldBlack, autoscale//boldRed];
autoscale={autoscale[[2]]*0.1, autoscale[[2]]};
];


If[dbg, Print["SBMLLogPlot: autoscale = ", autoscale]]; 
If[dbg, Print["SBMLLogPlot: opt = ", {opt}]]; 

p = MapThread[SBMLLogPlot[soln, #1[Global`t], {tbegin,tend}, PlotStyle-> #2, DisplayFunction-> Identity, opt, PlotRange-> autoscale]&,{plottable,colors}];

If[dbg, Print["SBMLLogPlot: p generated."]]; 

p=Show[p];
legend ={MapThread[{Graphics[{#1,Line[{{0,0},{1,0}}]}],decontextify[ToString[#2]]}&,{colors,plottable}]};
legend = Append[legend, LegendPosition-> {1,-.5}]; 
p=ShowLegend[
p,
legend
]; 
Return[p];
]; 

SBMLLogPlot[soln_, var_, {tbegin_, tend_},opt___?OptionQ]:= Module[{dbg=False},
If[dbg, Print["SBMLLogPlot: SBMLogPlot-var: opt ", {opt}]]; 

Graphics`Graphics`LogPlot[Evaluate[var/.soln], {Global`t,tbegin,tend},opt]//Return;
]; 


findMiniMax[n_, var_, {tbegin_, tend_}, opt___?OptionQ]:= Module[{npts,ops, dt, max,min,i,x,times,if,positiveOnly,msave},

ops = Flatten[{opt}];

positiveOnly = filterNonPositives/.ops/.{filterNonPositives-> False};

npts = (PlotPoints/.ops/.{PlotPoints-> 50});
dt =Abs[ (tbegin-tend)/(1.0*npts)];
times = Range[Min[tbegin, tend], Max[tbegin,tend], dt];
if = var[Global`t]/.n;
max = Evaluate[if/.{Global`t-> #}]&/@times;
max = Flatten[max];

If[positiveOnly,
msave=max;
max = Select[max,Positive];
If[Length[max]<1, Print["Warning:"//boldOrange," unable to plot the variable "//boldBlack,var//boldRed," on a logarithmic scale because it never takes on a positive value."//boldBlack]; max=msave;
plottable=Complement[plottable, {var}];
];
If[Length[max]!= Length[msave],
Print["Warning:"//boldOrange, " Some values of the variable "//boldBlack,var//boldRed," can not be plotted on a logarithmic scale because they do not evaluate to a positive number."//boldBlack]
]; 

];

min = Min[max];
max = Max[max];
Return[{min,max}];
]


debugPrint[flag_, str_, value_]:= Module[{msg,s},
If[flag,
s= ToString[str]<>":: ";
Print[
MyStyle[">>>debug:: ",FontColor->$Debug$DebugColor, FontWeight-> "Bold"],
MyStyle[s, FontColor->$Debug$MessageColor,
FontWeight-> "Bold"],
MyStyle[value,FontColor-> $Debug$ValueColor, FontWeight-> "Bold"]
];
];
];
debugPrint[flag_, str_]:= Module[{msg,s},
If[flag,
s= ToString[str]<>":: ";
Print[
MyStyle[">>>debug:: ",FontColor->$Debug$DebugColor, FontWeight-> "Bold"],
MyStyle[s, FontColor->$Debug$MessageColor,
FontWeight-> "Bold"]
];
];
];


printWarning[x_]:= Module[{s},

(* Increment counters even if printing is inhibited to keep a record of the fact that a warning was issued *)

$SBML$SessionWarnings++;
$SBML$FileWarnings++;

If[$SBML$warnings,

Print[
MyStyle[">>Warning: "<>ToString[x],
FontColor-> $Warning$Color, 
FontWeight-> "Bold"]
];
];
];
printWarning[test_,x_]:= If[test, printWarning[x]];


headerPrint[x_]:= MyStylePrint[x,
Background-> GrayLevel[.929688],
TextAlignment->$SBML$VerboseAlign,
FontSize-> \[Cent]Header$Size,
FontFamily-> \[Cent]Header$Font,
FontColor-> \[Cent]Header$Color,
FontWeight-> \[Cent]Header$Weight];


verboseSave[title_,columnHeaders_,  table_]:= Module[{new},
new=table/.{"Indeterminate"-> "\[CenterEllipsis]",""-> "\[CenterEllipsis]",{}-> "\[CenterEllipsis]", $SBML$IndeterminateValue-> "..."};
SBML$VerboseData = Append[SBML$VerboseData, {title, columnHeaders, new}];
];


verbosePrint[]:= Module[{headerOnly,prtable},
headerOnly[{x_, y_, z_}]:= (Length[y]<1) \[And] (Length[z]<1);
prtable[{x_, y_, z_}]:= If[headerOnly[{x,y,z}],
headerPrint[x],
printTable[z,columnHeaders-> y, title-> x]
];
prtable[x_]:= prtable[{x[[1]], x[[2]], x[[3]]}];
Map[prtable, SBML$VerboseData];
];



printTable[data_, opt___?OptionQ]:= Module[{t,h,ncol},
t=title/.{opt}/.{title-> "Table Header"};
headerPrint[t];
If[Length[data]<1,
MyStylePrint["----- None -----",  FontFamily-> "Times", (* FontSize-> $Column\[Cent]HeaderSize, *) FontColor->RGBColor[0.`,0.`,0.`], TextAlignment->$SBML$VerboseAlign];
 Return[]
];

ncol = Length[data[[1]]];

h = columnHeaders/.{opt}/.{columnHeaders-> {}};
h = PadRight[h,ncol,"column header"];
t=Prepend[data,Map[MyStyle[#,FontWeight->"Bold", FontVariations-> {"Underline"-> True}, FontFamily-> "Times",FontColor->$Column\[Cent]Header$Color, FontSize-> $Column\[Cent]HeaderSize]&,h]];
MyStylePrint[TableForm[t, TableAlignments-> {Left,Top}],TextAlignment-> $SBML$VerboseAlign];


];


makeIntoValidSId[inputString_?StringQ, hold___]:= Module[{inputCharacters, outputCharacters,replacement,replacements, changedCharacters,interestingChange,outputString,letterOrUnderscore, held},

If[StringLength[inputString]== 0, Return[inputString]]; 
held = {hold,"\[NumberSign]",$SBML$Underscorecharacter  }//Flatten; 

replacement[x_]:= Module[{},
If[DigitQ[x], Return[x]];
If[LetterQ[x],Return[x]];
If[x=="_", Return[$SBML$Underscorecharacter]]; 
If[MemberQ[held,x], Return[x]]; 
Return["\[NumberSign]"<>ToString[First[ToCharacterCode[x]]]<>"\[NumberSign]"]; 
]; (* end replacement *) 

letterOrUnderscore[x_]:= LetterQ[x] \[Or] (x==MathSBML`Private`$SBML$Underscorecharacter);

inputCharacters = Characters[inputString];
outputCharacters=Map[replacement,inputCharacters];

If[!letterOrUnderscore[outputCharacters[[1]]], 
outputCharacters=ReplacePart[outputCharacters,MathSBML`Private`$SBML$Underscorecharacter<>outputCharacters[[1]],1];
];

outputString = Apply[StringJoin,outputCharacters];
changedCharacters = MapThread[(#1!= "_")\[And](#1!= #2)&, {inputCharacters,outputCharacters}];
interestingChange = Apply[Or, changedCharacters]; 
If[interestingChange,
Print["Warning:"//boldRed, " The invalid identifier "//boldBlack, inputString//boldBlue," has been replaced with "//boldBlack, outputString//boldBlue,"\nThis may violate the model's intent."//boldRed]
];
Return[outputString]; 
];


removeUnderscore[x_, opt___?OptionQ]:= Module[{replacement, result,cc,badCharacters,replacements,rr,
allowedCharacters = {"A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z","a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z","0","1","2","3","4","5","6","7","8","9","(",")","-","^","*","/","+",",","."," "}
},
replacement =  replaceWith/.{opt}/.{replaceWith->$SBML$Underscorecharacter}; 
result = StringReplace[ToString[x], "_"-> replacement];

cc = Characters [result]; 
badCharacters = Complement[cc, allowedCharacters];
badCharacters = Complement[badCharacters, {$SBML$Underscorecharacter}];  

If[Length[badCharacters]>0,
replacements = Map["\[NumberSign]"<>ToString[First[ToCharacterCode[#]]]<>"\[NumberSign]"&,badCharacters];
rr = MapThread[#1->#2&, { badCharacters,replacements}]; 
result = StringReplace[result,
MapThread[#1->#2&, { badCharacters,replacements}]]; 

printWarning["\""<>x<>"\" contains the following characters that are not permitted in SBML: "<>list2CommaSeparatedString[badCharacters]<>".  The following string has been used instead: \""<>result<>"\""];
];


Return[result];
];


fromEForm[x_]:= Module[{},
If[$VersionNumber>5, Return[getEForm[stringer[x]]]];
Return[getEFormV4[x]];
];




rationalNumberFormQ[x_?StringQ]:= StringMatchQ[x, RegularExpression["-?\\d+/\\d+"]];
rationalNumberFormQ[x___]:= False;

SNFormQ[x_?StringQ]:= StringMatchQ[x, 
RegularExpression["(\\d*\\.?\\d*\\*)?(10)?\\^-?\\d+"]
]
SNFormQ[x___]:= False;


mantissaForm="(\\-?\\d*\\.?\\d*|\\+?\\d*\\.?\\d*)";
exponentForm="(\\-?\\d+|\\+?\\d+)";
mantissaFormQ[x_?StringQ]:= StringMatchQ[x,RegularExpression[mantissaForm]];
mantissaFormQ[x___]:=False;
exponentFormQ[x_?StringQ]:= StringMatchQ[x, RegularExpression[exponentForm]];
exponentFormQ[x___]:=False;
(* eFormQ[x_?StringQ]:= StringMatchQ[x,RegularExpression["("<>mantissaForm<>"e"<>exponentForm<>")"]]; *)
eFormQ[x_?StringQ]:= Or[eFormQ[x,"e"], eFormQ[x,"E"]];
eFormQ[x_?StringQ,sep_?StringQ]:= StringMatchQ[x,RegularExpression[mantissaForm<>sep<>exponentForm]];
eFormQ[x___]:=False;
FortranEFormQ[x_?StringQ]:= Or@@(eFormQ[x,#]&/@{"d","D","q","Q"});
FortranEFormQ[x___]:= False;
numericalFormQ[x_?StringQ]:=mantissaFormQ[x]\[Or]exponentFormQ[x]\[Or]eFormQ[x];
numericalFormQ[x_]:= NumberQ[x];
numberFormQ[x_]:= mantissaFormQ[x]\[Or]exponentFormQ[x];
IntegerFormQ[x_]:= exponentFormQ[x];
isanumber[x_]:= numberFormQ[x] \[Or] eFormQ[x]; 
notanumber[x_]:= !isanumber[x]; 


eForm2MantissaExponent[x_?eFormQ]:= Module[{m,e,p,p1,p2,sep="e"},
p=StringPosition[x,sep];
If[Length[p]==0, Print["Error: "//boldRed," eForm2MantissaExponent: separator "//boldBlack,sep//boldBlue," not found in string "//boldBlack,x//boldBlue];
Return[{0,0}];
];
If[Length[p]!= 1, Print["Error: "//boldRed," eForm2MantissaExponent: separator "//boldBlack,sep//boldBlue," found in multiple locations in string "//boldBlack,x//boldBlue];
Return[{0,0}];
];
p=First[p];
{p1,p2}=p;
m=StringTake[x,p1-1];
e=StringDrop[x,p2];
Return[{m,e}];
];
eForm2MantissaExponent[x_?FortranEFormQ]:= eForm2MantissaExponent[FortranEFormToEform[x]];

eForm2MantissaExponent[x___]:= Print["Error: "//boldRed," eForm2MantissaExponent: invalid argumment:  "//boldBlack,x," is not a string in e-format "//boldBlack]

getEForm["Indeterminate"]:= Indeterminate; 

(* convert rationals to reals v. 2.7.5 *) 
getEForm[x_?rationalNumberFormQ]:= Module[{v},
v= getEForm[ToString[InputForm[1.0*ToExpression[x]]]];
Return[v]; 
]; 
 

getEForm[x_?mantissaFormQ]:= ToExpression[x];

getEForm[xin_?eFormQ]:= Module[{e,x,y,m,exp},
x=StringReplace[xin,"E"-> "e"]; 
e=StringPosition[x,"e"]//Flatten//Union//First;
m=StringTake[x,e-1]//ToExpression;
exp=StringDrop[x,e]//ToExpression;
y=m*10^exp;
If[Head[y]===Rational, y=1.*y];
Return[y];
];

FortranEFormToEform[x_?FortranEFormQ]:= StringReplace[
x,{"E"-> "e","d"-> "e","D"-> "e","Q"-> "e","q"-> "e"}
];
FortranEFormToEform[x___]:= x;

getEForm[x_?SNFormQ]:= Module[{y}, 
y=ToExpression[x]; 
y=1.0*y;
y=deFortranize[y]; 
Return[y];
]

getEForm[x___]:= Module[{y=Indeterminate},
If[FortranEFormQ[x],
y=FortranEFormToEform[x];
Print["Error:"//boldRed," getEForm: the expression "//boldRed,x//boldBlue," appears to be a FORTRAN scientific notation that is not supported by MathML. Scientific notation in MathML only permits the lower case \"e\" to be used as the exponential separator. Attempting recovery as "//boldBlack, y//boldBlue ];
y=getEForm[y];
Return[y];
];

(* At this point assume its some form of string number and try to convert  *)

Print["Error: "//boldRed," getEForm: the expression "//boldRed, x//boldBlue," is not a valid string numeric expression and was replaced with "//boldBlack, y//boldBlue, " \nPlease check to make sure all numbers in scientific notation were expressed as real numbers, e.g., 3.0*10^-16 rather than rationals, e.g., 3*10^-16"//boldBlack];
Return[y];
];





getEFormV4[str_]:= Module[{s,p,np,ns,v, maybeFortran},

If[(ToString[str]==ToString[$SBML$IndeterminateValue]), v=ToString[$SBML$IndeterminateValue];
v=StringReplace[v,{"\""-> ""}];
Return[v];
];

maybeFortran[x_]:=Module[{c},
c=Intersection[Characters[x],{"E","d","D","q","Q"}];
Return[Length[c]==1];
];

If[maybeFortran[ToString[str]],
Print["Error: "//boldRed," getEFormV4: The expression "//boldBlack,str//boldBlue," appears to be a Fortran-formatted scientific notation, which is not permitted in MathML. Scientific notation requires the use of the character \"e\" to delimit the exponent and does not allow \"E\",\"d\",\"D\",\"q\",or\"Q\"."//boldBlack];
Return[str];
];

(* s=StringReplace[ToString[str],{"e"-> ",", "E"-> ",", "d"-> ",","D"-> ",","q"-> ",", "Q"-> ","}]; *)
s=StringReplace[ToString[str],{"e"-> ","}];

(* q, Q is Fortran quadruple precision *) 

(* This won't catch all errors *) 
p=StringPosition[s,","];
np=Length[p];
ns=StringLength[s];
p=Map[First,p];
(* check for too many e's or exponents (mantissas) w/o mantissas (exponents) *)
If[np> 1 \[Or] MemberQ[p,1] \[Or] MemberQ[p,ns], 
Print["Error: "//boldRed,"getEFormV4: The value "//boldBlack,str//boldBlue," does not appear to be a correctly formated value, and was replaced with "//boldBlack,ToString[$SBML$IndeterminateValue]//boldRed
];

Return[$SBML$IndeterminateValue];
];


s = "{"<>s<>"}";
s=ToExpression[s];
s = PadRight[Flatten[s],2,0];

(* check for aEb where either a or b or non-numeric *) 
If[ ! Apply[And,Map[NumberQ,s]],
Print["Error: "//boldRed,"getEFormV4: The value "//boldBlack,str//boldBlue," does not appear to be a correctly formated value, and was replaced with "//boldBlack,ToString[$SBML$IndeterminateValue]//boldRed];
Return[$SBML$IndeterminateValue];
];

(* Multiply 1.0 so that 5e-3 = 0.005 and not 1/200 *)

s =s[[1]]*(10^s[[2]]);

If[s==Round[s], Return[Round[s]]]; (* keep as an integer added 2.3.36*)
If[!$SBML$Rationals, s=1.0*s];  (* force to be real and not a fraction *)

Return[s]

]


deFortranize[s_?StringQ]:= fromEForm[s];
deFortranize[x_?NumberQ]:= 1.0*x; 
deFortranize[x_]:= x;


(* mathSBMLHelpReference[opt___?OptionQ]:= Module[{usg,usgstr,pdfusg,
predef={"mass","uui","uur","uuhr","isouur","hilli","hillr","hillmr","hillmmr","usii","usir","uai","ucii","ucir","unii","unir","uuci","uucr","umi","umr","uaii","uar","ucti","uctr","umai","umar","uhmi","uhmr","ualii","ordubr","ordbur","ordbbr","ppbr"},
modelBuilder={"addCompartment", "addEvent", "addFunction","addParameter","addReaction", "addRule","addSpecies",
"annotationToSBML", "annotationToSymbolicSBML",
"compartmentToSBML","compartmentToSymbolicSBML","eventToSBML","eventToSymbolicSBML","functionToSBML","functionToSymbolicSBML", "InfixToMathML", "loadModelBuilder","loadSimulator","MathMLToInfix","modifyCompartment","modifyEvent","modifyFunction","modifyModel","modifyParameter","modifyReaction","modifyRule", "modifySpecies","newModel","parameterToSBML","parameterToSymbolicSBML","reactionToSBML","reactionToSymbolicSBML","removeCompartment","removeEvent", "removeFunction", "removeParameter", "removeReaction","removeRule", "removeSpecies","ruleToSBML","ruleToSymbolicSBML","setAnnotationNamespace","setAnnotationPackage","showModel", "speciesToSBML","speciesToSymbolicSBML","unitToSBML", "unitToSymbolicSBML"},
mbusg},
usg=Map[{#,ToExpression[#<>"::usage"]}&,Names["MathSBML`*"]];
usgstr=Select[usg,StringQ[Last[#]]&];

pdfusg = Map[{#,ToExpression[#<>"::usage"]}&,predef];
mbusg = Map[{#,ToExpression[#<>"::usage"]}&,modelBuilder];


If[Global`pdf/.{opt}/.{Global`pdf-> False},
usgstr = pdfusg, 
If[Global`modelBuilder/.{opt}/.{Global`modelBuilder-> False},
usgstr = mbusg,
usgstr =Complement[ Complement[usgstr, pdfusg],mbusg];
]
];

Map[(MyStylePrint[First[#],"Section"];
Print[Last[#]])&,usgstr];
];
*)



Jacob[f_?ListQ, vars_?ListQ]:= Module[{row,J},
row[x_]:= Map[D[x,#]&, vars];
J=Map[row,f];
Return[J];
];


If[$$LoadBug, Print["Loading:SBMLWrite output file formats"]];


htmlPrint[model_, opt___?OptionQ]:= Module[{html,pagetitle, headerOnly, prtable, t, v,name, citation,notes, vd, vdheader,ss,id,inlinestylesheet, writenotes, dbg=False},


inlinestylesheet="\n<style type=\"text/css\">\n<!--\n"<>"body{\nfont-family:verdana,arial,helvetica,sans-serif;\nfont-size:small;\nbackground-color:#c0c0c0;\n}\n\n"<>"td.sbml-tag-title{\ntext-align:center;\nbackground-color:white;\nfont-size:medium;\nfont-variant:small-caps;\nfont-weight:bold;\nfont-style:normal;\ncolor:black;\n}\n\n"<>"td.sbml-model-notes{\ncolor:purple;\nfont-size:small;\nbackground-color:#c0c0c0;\nborder:thin solid black;\npadding:3;\n}\n\n"<>"td.sbml-column-data{\ntext-align:left;\nfont-size:small;\nbackground-color:white;\ncolor:black;\npadding-left:3;\npadding-right:3;\nvertical-align:top;\nborder:thin solid black;}\n\n"<>"td.sbml-column-head{\nfont-size:small;\nfont-weight:bold;\nfont-variant:small-caps;\nfont-style:normal;\ncolor:purple;\nbackground-color:#c0c0c0;\ntext-align:left;\nvertical-align:top;\nborder-top:thin solid black;\nborder-bottom:thin solid black;\npadding-left:5;\npadding-right:5;\n}\n\n\n"<>"table.sbml-table{\nmargin:0 auto;\nbackground-color:white;\nborder:thin solid black;\nborder-collapse:collapse;\n}\n\n"<>"p.file-information{\nfont-size:large;\nfont-variant:small-caps;\ncolor:purple;\ntext-align:center;\nfont-style:normal;\nfont-weight:bold;\n\n}\n\n\n"<>"span.file-information-label{\ncolor:black;\nfont-style:normal;\nfont-weight:bold;\n}\n\n"<>"div{\nbackground-color:#c0c0c0;\n}\n.main{\nbackground-color:#c0c0c0;\n}\n-->\n</style>";

ss = (Global`stylesheet/.{opt}/.{Global`stylesheet-> "inline"})//stringer;

headerOnly[{x_, y_, z_}]:= (Length[y]<1) \[And] (Length[z]<1);
prtable[{x_, y_, z_}]:= If[headerOnly[{x,y,z}],
htmlHeader[x],
htmlTable[z,columnHeaders-> y, title-> x]
];
prtable[x_]:= prtable[{x[[1]], x[[2]], x[[3]]}];

vdheader = Take[SBML$VerboseData,2]; (* first two lines have model file name and model name *) 
vd = Drop[SBML$VerboseData, 2];

If[dbg, Print["htmlPrint: vdheader: ", vdheader]]; 
If[dbg, Print["htmlPrint: vd: ", vd]]; 


html="<!doctype html public \"-//w3c//dtd html 4.0 Transitional//en\">\n<html>\n<head>\n";

html=html<>"<meta http-equiv=\"Content-Type\" content=\"text/html; charset=iso-8859-1\">\n";

t=ToString[MathSBML`Private`now[]];
v=ToString[$MathSBML$Version];
name =  Global`SBMLModelName/.model/.{Global`SBMLModelName-> ""};
id= Global`SBMLModelid/.model/.{Global`SBMLModelid-> ""}; 
id = StringReplace[id,{"\[UnderBracket]"-> "_"}];
(* If[StringLength[name]==0,name = "Unnamed Model"]; *) 
name = StringReplace[name,{"\[UnderBracket]"-> "_"}]; 

html = html 
<>"<!-- SBML Model Name: "<>name<>"\n"
<>"     Generated by MathSBML "<>v<>"\n"
<>"     Creation Time: "<>t<>"\n"
<>"     Mathematica Version: "<>$Version<>"\n"
<>"     User:          "<>$UserName<>"\n"
<>"     Machine:       "<>$MachineName<>"\n"
<>"     Processor:     "<>$ProcessorType<>"\n"
<>"     Machine type:  "<>$MachineType<>"\n"
<>"     Oper. System:  "<>$OperatingSystem
<>"\n-->\n";


citation = "Generated at "<>t<>" by "<>$UserName<>" on "<>$MachineName<>" using MathSBML "<>v<>" [Mathematica Version "<>$Version<>"]"
<>" Processor/Type/OS="<>$ProcessorType<>"/"<>$MachineType<>"/"<>$OperatingSystem ;

(* determine model notes *) 

writenotes=Global`notes/.{opt}/.{Global`notes-> False};
If[writenotes,

If[ToString[Head[$SBML$Notes]]=="XMLElement", 
notes = ExportXMLString[$SBML$Notes];
(* the following requires 5.1 *)
(* notes=StringReplace[notes,"<body"~~Except[">"]..~~">"->""];
*) 
If[$VersionNumber>5,
notes=StringReplace[notes,\!\(\*
TagBox[
StyleBox[
RowBox[{"StringExpression", "[", 
RowBox[{"\"\<<body\>\"", ",", 
RowBox[{"Repeated", "[", 
RowBox[{"Except", "[", "\"\<>\>\"", "]"}], "]"}], ",", "\"\<>\>\""}], "]"}],
ShowSpecialCharacters->False,
ShowStringCharacters->True,
NumberMarks->True],
FullForm]\)->""];
notes = StringReplace[notes, "</body>"-> ""];
];
notes ="\n<table class=\"sbml-table\" width='75%'>"<>"\n\t<tr>\n\t\t<td class=\"sbml-tag-title\">\n\t\tModel Notes Contained in the XML\n\t\t</td>\n\t</tr>\n"<>
"\t<tr>\n\t\t<td class=\"sbml-model-notes\">\n"<>notes<>"\n\t\t</td>\n\t</tr>\n</table>\n\n";,

If[StringQ[$SBML$Notes],
notes=$SBML$Notes;
(* notes=StringReplace[notes,"<body"~~Except[">"]..~~">"->""];
*) 
If[$VersionNumber>5,
notes=StringReplace[notes,\!\(\*
TagBox[
StyleBox[
RowBox[{"StringExpression", "[", 
RowBox[{"\"\<<body\>\"", ",", 
RowBox[{"Repeated", "[", 
RowBox[{"Except", "[", "\"\<>\>\"", "]"}], "]"}], ",", "\"\<>\>\""}], "]"}],
ShowSpecialCharacters->False,
ShowStringCharacters->True,
NumberMarks->True],
FullForm]\)->""];
notes = StringReplace[notes, "</body>"-> ""];
]; 
notes ="\n<table class=\"sbml-table\" width='75%'>"<>"\n\t<tr>\n\t\t<td class=\"sbml-tag-title\">\n\t\tModel Notes\n\t\t</td>\n\t</tr>\n"<>
"\t<tr>\n\t\t<td class=\"sbml-model-notes\">\n"<>notes<>"\n\t\t</td>\n\t</tr>\n</table>\n";
,
notes=""
];

];
,
notes="";
];

(* generate the body of the web page *) 

pagetitle =name; 
html = html<>"<title>"<>pagetitle<>"</title>\n";

Switch[ToUpperCase[ss],
"INLINE", ss=inlinestylesheet,
"NONE", ss="",
_, ss="<link rel=\"stylesheet\" href=\""<>ss<>"\" type=\"text/css\">\n"
];

html = html<>ss;

html = html<>"</head>\n<body>\n";

html = html<>"<div class=\"main\">";

html = html<>"\n<p class=\"file-information\"><span class=\"file-information-label\">File name:</span> "<>stringer[$SBML$Inputfile]<>"<br>";
html = html<>"\n<span class=\"file-information-label\">SBML Level</span> "<>stringer[$SBML$Level]<>" <span class=\"file-information-label\">Version </span>"<>stringer[$SBML$Version]<>"<br>";
If[StringLength[name]>0,
html = html<>"\n<span class=\"file-information-label\">Model name:</span> "<>stringer[name]<>"<br>";
]; 
html = html<>"\n<span class=\"file-information-label\">Model id:</span> "<>stringer[id]<>"</p>";

html = html <>notes;
html = html<>Map[prtable, vd];





html = html<>"<br/><br/>\n<hr>\n<div style=\"font-style:italic;text-align:left; font-size:8pt;\">"<>citation;
html = html<>"</td></tr></table>\n";
html = html<>"</div>";
html = html<>"\n</div>";


html = html<>"</body>\n</html>";

If[dbg, Print["htmlprint: html: ", html]]; 
Return[html];


];


htmlHeader[str_]:= Module[{r,s},

r =
"<br/>\n<table border=1 cellpadding=\"5\">\n\t<tr>\n\t\t<td style=\"font-weight: bold; font-size:medium; color:black; background-color:#A0FFA0;text-align:center;\">\n\t\t\t<div style=\"font-size:larger;\">\n";

s = StringReplace[str,{"\n"-> "<br/>","\[UnderBracket]"-> "_" }]; 
r= r<>"\t\t\t"<>s<>"\n\t\t\t<div>\n\t\t</td>\n\t</tr>\n</table>\n"; 


Return[r];

];


htmlTable[data_, opt___?OptionQ]:= Module[{t,h,ncol,html, tableRowForm,tableData, blankline, processValue, dbg=False},

If[dbg, Print["htmlTable: data: ", data]]; 

t=title/.{opt}/.{title-> "Table Header"};

(* If[dbg, Print["htmlTable: data: ",data]]; *) 

processValue[xin_?StringQ, class_]:= Module[{x},

(* It is possible that xin = "symbol=value" and this will evaluate to a number!!! *)

x=StringReplace[xin, {":="-> ":equal"}];
x=StringReplace[x, "="-> " equals "];
x = StringReplace[x, ":equal"-> ":="];
If[isanumber[x], 
(* NumberQ[ToExpression[x]], *)
x=ToExpression[x];
x=processValue[x,class];
x=stringer[x];
Return[x];
];
x=StringReplace[xin, {"\n"-> "<br>"}];
Return[x];
];


processValue[x_?ListQ, class_]:= Module[{y,z},
If[Length[x]==1 \[And] ListQ[First[x]],
y=First[x],
y=x
];


y=processValue[#,class]&/@y;
z=Map[stringer[#]<>"; "&, y];
z=(StringJoin@@z)<>",";
z=StringReplace[z, ",; "-> ","];
Return[z];
];

processValue[x_, class_]:= Module[{y,sp},
y=ToString[InputForm[x]]; 
sp = StringPosition[y,"*^"];

(* this will work only if the input is really a number with a single exponent in it; an expression with multiple exponents will cause a failure.*)
If[Length[sp]==1, 
y=StringReplace[y,{"*^"-> "&times;10<sup>"}]<>"</sup>";
]; 
Return[y];
]; 

tableRowForm[x_, tdclass_:""]:= Module[{y,z, class},

class=stringer[tdclass];


If[class!= "", 
  class= " class='"<>class<>"'";
];

y =processValue[#, class]&/@x;  


z= "\t<tr>\n"<>Apply[StringJoin,Map["\t\t<td"<>class<>">"<>#<>"</td>\n"&, y]]<>"\t</tr>\n";

z = StringReplace[z, { "[t]"-> "","=="-> "=","\""-> "", "\[UnderBracket]"-> "_","{"-> "", "}"-> "", ","-> "<br/>"}];


z = StringReplace[z, "@COMMA"-> ","]; 


Return[z];

If[dbg, Print["tableRowForm: z:", z]]; 

];

If[Length[data]<1,
html = "";
 Return[html]
];

ncol = Length[data[[1]]];

h = columnHeaders/.{opt}/.{columnHeaders-> {}};
h = PadRight[h,ncol,"column header"];

(* style=\"text-align:center;background-color:#a0ffa0;font-size:larger;\" *)

blankline="\n\t<tr><td colspan=\""<>ToString[ncol]<>"\" class=\"sbml-column-head-space\"></td></tr>";

blankline="";


If[dbg, Print["htmlTable: calling tableRowForm:"]]; 

h = "\t<tr>\n\t\t<td class='sbml-tag-title' colspan=\""<>ToString[ncol]<>"\">\n\t\t"<>t<>"\n\t\t</td>\n\t</tr>\n"<>blankline<>
tableRowForm[h, "sbml-column-head"]<>blankline;

If[dbg, Print["htmlTable: returning from tableRowForm: h:", h]]; 



html = "<br/><br/>\n<table class=\"sbml-table\" >\n";
html = html<>"<thead>\n";
html = html<>h<>"</thead>\n";
html = html<>"<tbody>\n";

tableData = Map[tableRowForm[#, "sbml-column-data"]&, data];

If[dbg, Print["htmlTable: tableData:", tableData]]; 

tableData = Apply[StringJoin,tableData];

html = html<>tableData;
 
html = html<>"</tbody>\n</table>\n";

If[dbg, Print["htmlTable: html:", html]]; 


Return[html]; 
];


toXPPForm[model_, file_?StringQ,opt___?OptionQ]:= Module[{m,f},
m = toXPPForm[model,opt];
Export[file,m,"text"];
Return[file];
];

toXPPForm[model_,opt___?OptionQ]:= Module[{odes, ic, par,lhs, rhs,xpp,name,t,v,fcns,odelhs,oderhs},

printWarning[!OptionQ[model],"toXPPForm: argument does not appear to be a MathSBML model."];

xpp = ""; 

(* extract odes from the MathSBML model *)
odes = Global`SBMLODES/.model;
ic = Global`SBMLIC/.model;
par = Global`SBMLConstants/.model;
name = Global`SBMLModelName/.model/.{Global`SBMLModelName-> ""};
fcns = Global`SBMLFunctions/.model/.{Global`SBMLFunctions-> {}};  

(* apply functions *) 

oderhs = Map[Last,odes]//.fcns;
odelhs = Map[First,odes];

(* evaluate parameters *) 
If[evaluateParameters/.{opt}/.{evaluateParameters-> False},
 oderhs = oderhs//.par;
];

odes = MapThread[#1==#2&, {odelhs,oderhs}]; 

t=ToString[MathSBML`Private`now[]];
v=ToString[$MathSBML$Version];
xpp=             "# Model Name:    "<>name<>"\n#\n";
xpp=xpp<>"# Creation Time: "<>t<>"\n";
xpp=xpp<>"# User:          "<>$UserName<>"\n";
xpp=xpp<>"# Machine:       "<>$MachineName<>"\n";
xpp=xpp<>"# System:        "<>$ProcessorType<>" "<>$MachineType<>" "<>$OperatingSystem<>"\n";
xpp=xpp<>"# Generated by MathSBML "<>v<>"\n";


(* convert the "Derivative[1][variable][t]" to "variable'" for each variable *) 
lhs = Map[ToString[InputForm[First[#]]]&, odes];
lhs = Map[StringReplace[#,{"Derivative[1]["-> "", "][t]"-> ""}]&,lhs];
lhs = Map[StringReplace[#,{" "-> "","`"-> "_"}]&, lhs];

(* convert the right hand side of each ode into xpp-compatible string form *) 
rhs = Map[ToString[InputForm[Last[#]]]&, odes];
rhs = Map[StringReplace[#,"[t]"-> ""]&, rhs];
rhs = Map[StringReplace[#,{" "-> "","`"-> "_"}]&, rhs];

(* combine the lhs and rhs's of the odes together and join into a single file-writeable string, including embedded newline characters *) 
odes ={lhs,rhs}//Transpose;
odes = Map[#[[1]]<>"'="<>#[[2]]<>"\n"&, odes];
odes = Apply[StringJoin,odes];
odes = "# \n# Differential Equations\n# \n"<>odes<>"# ";
xpp = xpp<>odes;

If[Length[par]>0,
par = Map["par "<>ToString[First[#]]<>"="<>ToString[Last[#]]<>"\n"&, par];
par = Apply[StringJoin,par]; 
par = StringReplace[par, {"`"-> "_"}];
par = "\n# \n# Parameters\n# \n"<>par<>"# ";
xpp = xpp<>par;
]; 
If[Length[ic]>0, 
ic = Map[ToString,ic];
ic = Map[StringReplace[#,{"[0]"-> "", " "-> "", "=="-> "="}]&, ic];
ic = Map["init "<>#<>"\n"&,ic];
ic = Apply[StringJoin, ic];
ic = StringReplace[ic, {"`"-> "_"}];
ic = "\n# \n# Initial Conditions\n# \n"<>ic<>"# ";
xpp = xpp<>ic;
];
xpp = xpp<>"\ndone";


Return[xpp];
]


toBerkeleyMadonnaForm[model_, file_?StringQ,opt___?OptionQ]:= Module[{m,f},
m = toBerkeleyMadonnaForm[model,opt];
Export[file,m,"text"];
Return[file];
];

toBerkeleyMadonnaForm[model_,opt___?OptionQ]:= Module[{odes, ic, par,lhs, rhs,bmdata,name,t,v,fcns,odelhs,oderhs, startimevalue, stoptimevalue, dtvalue,method,debug=False,srules,srulereplace},

printWarning[!OptionQ[model],"toBerkeleyMadonnaForm: argument does not appear to be a MathSBML model."];

srules= {
RegularExpression["Abs\\[(.*)\\]"]:>  "ABS[$1]",
RegularExpression["ArcCos\\[(.*)\\]"]:>  "ARCCOS[$1]",
RegularExpression["ArcCosh\\[(.*)\\]"]:>  "ARCCOSH[$1]",
RegularExpression["ArcSin\\[(.*)\\]"]:>  "ARCSINH[$1]",
RegularExpression["ArcTan\\[(.*)\\]"]:>  "ARCTAN[$1]",
RegularExpression["ArcTanh\\[(.*)\\]"]:>  "ARCTANH[$1]",
RegularExpression["Cos\\[(.*)\\]"]:>  "COS[$1]",
RegularExpression["Cosh\\[(.*)\\]"]:>  "COSH[$1]",
RegularExpression["Erf\\[(.*)\\]"]:>  "ERF[$1]",
RegularExpression["Erfc\\[(.*)\\]"]:>  "ERFC[$1]",
RegularExpression["Floor\\[(.*)\\]"]:>  "INTEGER[$1]",
RegularExpression["Log\\[10,(.*)\\]"]:>  "LOG10[$1]",
RegularExpression["Log\\[(.*)\\]"]:>  "LOGN[$1]",
RegularExpression["Max\\[(.*)\\]"]:>  "MAX[$1]",
RegularExpression["Mean\\[(.*)\\]"]:>  "MEAN[$1]",
RegularExpression["Sin\\[(.*)\\]"]:>  "SIN[$1]",
RegularExpression["Sinh\\[(.*)\\]"]:>  "SINH[$1]",
RegularExpression["Sqrt\\[(.*)\\]"]:>  "SQRT[$1]",
RegularExpression["Tan\\[(.*)\\]"]:>  "TAN[$1]",
RegularExpression["Tanh\\[(.*)\\]"]:>  "TANH[$1]"};
srulereplace[x_]:= FixedPoint[StringReplace[#,srules]&, x];

bmdata = ""; 
(* extract odes from the MathSBML model *)
odes = Global`SBMLODES/.model;
ic = Global`SBMLIC/.model;
par = Global`SBMLConstants/.model;
name = Global`SBMLModelName/.model/.{Global`SBMLModelName-> ""};
fcns = Global`SBMLFunctions/.model/.{Global`SBMLFunctions-> {}};  

starttimevalue =stringer[ Global`STARTTIME/.{opt}/.{Global`STARTTIME-> 0}];
stoptimevalue = stringer[Global`STOPTIME/.{opt}/.{Global`STOPTIME-> 10}];
dtvalue =stringer[ Global`DT/.{opt}/.{Global`DT-> 0.02}];
method = stringer[Global`METHOD/.{opt}/.{Global`METHOD-> "RK4"}]; 

(* apply functions *) 

oderhs = Map[Last,odes]//.fcns;
odelhs = Map[First,odes];

If[debug, Print["toBerkeleyMadonnaFormat: oderhs:",oderhs]];

(* evaluate parameters *) 
(* If[evaluateParameters/.{opt}/.{evaluateParameters-> False},
 oderhs = oderhs//.par;
];
*) 


odes = MapThread[#1==#2&, {odelhs,oderhs}]; 

t=ToString[MathSBML`Private`now[]];
v=ToString[$MathSBML$Version];
bmdata=             "{ Model Name:    "<>name<>" }\n";
bmdata=bmdata<>"{ Creation Time: "<>t<>" }\n";
bmdata=bmdata<>"{ User:          "<>$UserName<>" }\n";
bmdata=bmdata<>"{ Machine:       "<>$MachineName<>" }\n";
bmdata=bmdata<>"{ System:        "<>$ProcessorType<>" "<>$MachineType<>" "<>$OperatingSystem<>"    }\n";
bmdata=bmdata<>"{ Generated by MathSBML "<>v<>" }\n";

bmdata = bmdata<>"METHOD "<>method<>"\nSTARTTIME = "<>starttimevalue<>"\nSTOPTIME = "<>stoptimevalue<>"\nDT = "<>dtvalue<>"\n";
(* convert the "Derivative[1][variable][t]" to "variable'" for each variable *) 
lhs = Map[ToString[InputForm[First[#]]]&, odes];
lhs = Map[StringReplace[#,{"Derivative[1]["-> "", "][t]"-> ""}]&,lhs];
lhs = Map[StringReplace[#,{" "-> "","`"-> "_"}]&, lhs];
lhs = Map[StringReplace[#,{"$_"-> ""}]&, lhs];

(* convert the right hand side of each ode into bmdata-compatible string form *) 



rhs=Last/@odes;
rhs = Map[ToString[InputForm[#]]&, rhs];
rhs=srulereplace/@rhs;
rhs = Map[StringReplace[#,"[t]"-> ""]&, rhs];
rhs = Map[StringReplace[#,{" "-> "","`"-> "_"}]&, rhs];
rhs = Map[StringReplace[#,{"$_"-> ""}]&, rhs];
rhs = Map[StringReplace[#, {"*^"-> "*10^"}]&, rhs]; 
rhs = Map[StringReplace[#, {"["-> "(", "]"-> ")"}]&, rhs]; 


(* combine the lhs and rhs's of the odes together and join into a single file-writeable string, including embedded newline characters *) 
odes ={lhs,rhs}//Transpose;
odes = Map[
"d/dt ("<>#[[1]]<>") = "<>#[[2]]<>"\n"&, 
odes];
odes = Apply[StringJoin,odes];
odes = "{ Differential Equations }\n"<>odes;
bmdata = bmdata<>odes;

If[Length[par]>0,
par = Map[ToString[First[#]]<>" = "<>ToString[Last[#]]<>"\n"&, par];
par = Apply[StringJoin,par]; 
par = StringReplace[par, {"`"-> "_"}];
par=StringReplace[par,{"$_"-> ""}]; 
par = "{ Parameters }\n"<>par;
par = StringReplace[par, {"Indeterminate"-> "0"}]; 
bmdata = bmdata<>par;
]; 
If[Length[ic]>0, 
ic = Map[ToString,ic];
ic = Map[StringReplace[#,{"[0]"-> "", " "-> "", "=="-> " = "}]&, ic];
ic = Map["init "<>#<>"\n"&,ic];
ic = Apply[StringJoin, ic];
ic = StringReplace[ic, {"`"-> "_"}];
ic = StringReplace[ic, {"$_"-> ""}];

ic = "{ Initial Conditions }\n"<>ic;
ic = StringReplace[ic, {"Indeterminate"-> "0"}]; 
bmdata = bmdata<>ic;
];


Return[bmdata];
]


fortranize[model_,opt___?OptionQ]:= Module[{vars,varules,odes,oderhs,odevars,orderedVars, varsWithoutODES,algRules,nodes, nalg, nvars, var2NumberedVar, resids,nresids, parameters, Fortran,name,  key,dbg=False,neq, adda,jac,allfunctions,allvars,jacobian,y,s,p,i,j,tab , evts,nevts,eventFortran,eventNames, eventDelays,yrule,FortranEventSubroutine,FortranEventActivateFunction,FortranEventTestFunction, activities, eventControl,flagNames,timeNames, header, subroutinesGenerated, generateIndex, icvals, icfor, srule},

subroutinesGenerated = {{"res (subroutine)", "Calculate Residuals - required by lsodi"},{"addp (subroutine)", "Add A to any matrix - required by lsodi"}, {"jac (subroutine)", "Compute Jacobian - required by lsodi"},
{"init (subroutine)", "Set initial conditions"}}; 

yrule = ToString[FortranForm[y]]->"y";
srule = ToString[FortranForm[s]]-> "s";

debugPrint[dbg,"fortranize: {yrule, srule}:", {yrule,srule}]; 

name =  Global`SBMLModelName/.model/.{Global`SBMLModelName-> ""};
If[StringLength[name]==0,
name = Global`SBMLModelid/.model/.{Global`SBMLModelid-> "Unnamed SBML Model"};
]; 
name = StringReplace[name,{"\[UnderBracket]"-> "_"}]; 

Fortran ="C\nC --------------------------------------------------------\nC\n"<>"      subroutine res(neq,t,y,s,r,ires)\n"<>"      double precision r,s,t,y\n"<>"C\n"<>"C This is subroutine res for lsodi\n"<>"C This function computes the residuals r(i)=g(t,y)- A(t,y)(dy/dt)\n"<>"C for the linear-implicit system system (A)*(dy/dt)=g(t,y)\n"<>"C where A is a constant, possibly singular, matrix.\n"<>"C\n"<>"C Here A is diagonal with (restriction imposed by SBML, not lsodi)\n"<>"C       A(i,i)=1, i=1,...,m, where m=# of odes in the SBML Model\n"<>"C       A(i,i)=0, i=m+1,...,m+nrules, where nrules =# of algebraic rules\n"<>"C       A(i,i)=0, i=nrules+1,...,nvars, where nvars is the total number\n"<>"C                 of variables in the system and nvars-nrules-m>0 is the\n"<>"C                 number of variables controlled purely by events\n";

Fortran = Fortran<>"C\nC If the system is purely differential"<>
"\nC the right-hand side of the system dydt = g(y,t) will "<>
"\nC be returned if s is zero-filled.\nC\n";


 debugPrint[dbg,"Fortran:",model];  

(* put model parts into local variables *) 
vars = Global`SBMLModelVariables/.model;
nvars = Length[vars]; 

odes = Global`SBMLODES/.model;
nodes = Length[odes]; 

algRules = Global`SBMLAlgebraicRules/.model; 
nalg = Length[algRules]; 


parameters = Global`SBMLConstants/.model;

(* create rules to remove the [t] from the variable names *) 
varules = MapThread[#1-> #2&, {vars,(Head/@vars)}]; 

(* oderhs gives the rhs of the odes, w/o the [t], and evaluate any parameters *) 
oderhs = (Last/@odes)/.varules;
oderhs = (oderhs//.parameters); 

(* vars gives the variable symbols, w/o the [t], that are in the model *) 
vars = Head/@vars;

(* odevars gives the variable symbols, w/o the [t] in order of ode, of the variables that have odes; the ode for odevar[k] is in oderhs[k] *) 
odevars = ToString/@(First/@odes);
odevars = ToExpression/@Map[StringReplace[#,{"'[t]"-> ""}]&, odevars];

(* varsWithoutODES gives the variables that do not have odes *) 
varsWithoutODES = Complement[vars, odevars]; 

(* orderedVars has the ode-based vars first, followed by the non-ode-based vars *) 
orderedVars = Join[odevars, varsWithoutODES];
var2NumberedVar = MapThread[#1-> y[#2]&, {orderedVars,Range[nvars]}];

(* determine initial conditions for variables *)
icvals =ToString/@ FortranForm/@ToExpression/@SBMLIC/@ToString/@orderedVars; 

(* define variables in comments  *)
key = MapThread["C y("<>#1<>") = "<>#2<>"\n"&,
{ToString/@Range[nvars],ToString/@decontextify[orderedVars]}];
key = Apply[StringJoin,key];
Fortran = Fortran<>"C Representation of Model Variables by the array y\n";
Fortran = Fortran<>"C ------------------------------------------------\n";
Fortran = Fortran<>key;
Fortran = Fortran<>"C\n";

(* algebraic rules are always of the form 0 = expression; get rhs without the [t], and evaluate any parameters *)
algRules = (Last/@algRules)/.varules; 
algRules = (algRules//.parameters); 

debugPrint[dbg,"Fortran: vars:",vars];
debugPrint[dbg,"Fortran: odevars:",odevars];
debugPrint[dbg,"Fortran: varsWithoutODES:",varsWithoutODES];
debugPrint[dbg,"Fortran: orderedVars:", orderedVars]; 
debugPrint[dbg,"Fortran: var2NumberedVar:", var2NumberedVar]; 

debugPrint[dbg,"Fortran: varrules:", varules]; 
debugPrint[dbg,"Fortran: odes:",odes];
debugPrint[dbg,"Fortran: oderhs:",oderhs]; 
debugPrint[dbg,"Fortran: algRules:", algRules];
If[dbg,Print[">>>debug: Fortran: nvars = ", nvars,"; nodes = ", nodes,"; nalg = ", nalg]]; 


oderhs = (oderhs/.var2NumberedVar); 
algRules = (algRules/.var2NumberedVar);
resids = Join[oderhs, algRules]; 

resids = PadRight[resids,nvars]; (* additional vars may be set by events *) 

allfunctions = resids ; (* save for later *)
nresids = Length[resids];
resids = resids-(s/@Range[nresids]); 

debugPrint[dbg,"Fortran: oderhs (numbered):",oderhs]; 
debugPrint[dbg,"Fortran: algRules (numbered):", algRules];
debugPrint[dbg,"Fortran: residuals:", resids];

(* convert to Fortran Form *) 
resids = FortranForm/@resids;
resids = ToString/@resids;


(* resids = Map[StringReplace[#,
{ToString[FortranForm[s]]->"s", 
yrule}]&, resids];
*) 
resids = Map[StringReplace[#,
{srule, 
yrule}]&, resids];



(* turn into equations like r(n) = g(t,y)-A(t,y)*(dy/dt)  *) 
resids = MapThread["r("<>#2<>")="<>#1&,{resids,ToString/@Range[nresids]}]; 
resids = FortranWrap/@resids;
resids = Map[#<>"\n"&,resids]; 
resids = Apply[StringJoin,resids];
debugPrint[dbg,"Fortran: residuals:", resids];

neq = ToString[nresids]; 

Fortran=Fortran<>"      dimension "<>list2CommaSeparatedString[Map[#<>"("<>neq<>")"&, {"r","s","y"}]]<>"\n";

Fortran = Fortran<>resids;
Fortran = Fortran<>"      return\n      end\nC\n";

(* end of res *)
(* beginning of adda *)

adda = "C\nC --------------------------------------------------------\nC\n"<>"      subroutine addp(neq, t, y, ml, mu, p, nrowp)\n"<>
"C\nC Subroutine addp required by lsodi\nC\n"<>
"      double precision p, t, y\n"<>
"      dimension y("<>neq<>"), p(nrowp,"<>neq<>")\n"<>"      integer i\n"<>
"      Do i = 1,"<>ToString[nodes]<>"\n"<>
"         p(i,i) = p(i,i)+1\n"<>
"      End Do\n"<>
"      return\n"<>
"      end\n";

Fortran = Fortran<>adda;

(* end of adda *)
(* beginning of jac *)

jac = "C\nC --------------------------------------------------------\nC"<>"\n      subroutine jac (neq,t,y,s,ml,mu,p,nrowp)\n"<>
"C\nC Subroutine jac required by lsodi, computes jacobian\nC\n"<>
"      dimension y("<>neq<>"), s("<>neq<>"),p(nrowp,"<>neq<>")\n\n";

(* calculate jacobian matrix *)
jacobian = Jacob[allfunctions, y/@Range[nresids]];
jacobian = Flatten[jacobian]; 
tab=list2CommaSeparatedString/@Partition[Table[{i,j},{i,1,nresids}, {j,1,nresids}]//Flatten,2];
jacobian = MapThread["p("<>#1<>")="<>StringReplace[ToString[FortranForm[#2]],{yrule}]&,{tab,jacobian}];
jacobian = Map["      "<>#<>"\n"&,jacobian];
jacobian = Apply[StringJoin,jacobian];
jac = jac<>jacobian; 

jac = jac<>"\n      return\n      end\n";

Fortran = Fortran<>jac;
(* Determine initial conditions *)

icfor="C\nC --------------------------------------------------------\nC\n"<>"      Subroutine init(neq,y)"<>"\n      double precision y\n"<>"      dimension y("<>ToString[nvars]<>")\n";
icfor = icfor<>Apply[StringJoin,MapThread["      y("<>ToString[#1]<>")="<>#2<>"\n"&, {Range[nvars], icvals}]]<>"      return\n      end\n";
Fortran = Fortran<>icfor;

(* process events *) 

evts = Global`SBMLEvents/.model;
nevts = Length[evts]; 
debugPrint[dbg,"Fortran: evts = ", evts];

eventFortran=""; 

FortranEventSubroutine[evname_->evopt_]:= Module[{f="", trigger, evdelay, eventName, triggername, activatename},
eventName=StringReplace[decontextify[evname],"\[UnderBracket]"-> "_"]; 
triggername = "trigger_"<>eventName;
activatename="activate_"<>eventName;
subroutinesGenerated = Join[subroutinesGenerated, {
{triggername<>" (function)", "Trigger event "<>eventName},{activatename<>" (subroutine)", "Perform activity required by event "<>eventName}}
];

debugPrint[dbg, "FortranEventSubroutine: eventName",eventName];
debugPrint[dbg, "FortranEventSubroutine: evopt",evopt];
f="C\nC --------------------------------------------------------\n"<>"C\nC ***** Test to see if event "<>eventName<>" has been triggered\nC\n";
f=f<>FortranWrap[
 "logical function "<>triggername<>"(neq, y)\n"]<>"      double precision y\n"<>
"      integer neq\n"<>
"      dimension y("<>ToString[nvars]<>")\n"<>
"      logical triggered\n";

trigger = "trigger"/.evopt/.{"trigger"->""};
printWarning[trigger =="", "No event trigger supplied for event "<>evname];
trigger= StringReplace[trigger,{"[t]"-> ""}];
trigger = ToExpression[trigger]/.var2NumberedVar; 
trigger = ToString[trigger];
trigger = decontextify[trigger,$SBML$Context];
trigger = ToString[FortranForm[ToExpression[trigger]]]; 
trigger=StringReplace[trigger,yrule];
f = f<>FortranWrap["triggered="<>trigger<>"\n"];
f = f<>"      return(triggered)\n      end\n"; 
f=f<>"C\nC ***** Activate event: "<>eventName<>" *****\nC\n";
f=f<>FortranWrap[
 "subroutine "<>activatename<>"(neq, y)\n"]<>"      double precision y\n"<>
"      integer neq\n"<>
"      dimension y("<>ToString[nvars]<>")\n";


activities = "events"/.evopt/.{"events"-> {}};
printWarning[activities =="", "No event activities supplied for event "<>evname];
activities= Map[StringReplace[#,{"[t]"-> ""}]&, activities];
activities =ToExpression/@activities; 
activities = Map[#/.var2NumberedVar&, activities]; 
activities = ToString/@activities;
activities = Map[decontextify[#, $SBML$Context]&, activities]; 
activities = ToExpression/@activities; 
activities = Map[
ToString[FortranForm[First[#]]]<>"="<>ToString[FortranForm[Last[#]]]&,
activities]; 
activities=Map[StringReplace[#,yrule]&, activities];
activities = Map[#<>"\n"&, activities];
activities = Apply[StringJoin,FortranWrap/@activities];


debugPrint[dbg, "Fortran: activities:", activities]; 

f = f<>activities<>"      return\n      end\n"; 

f = StringReplace[f,{"\[UnderBracket]"->"_"}]; 

evdelay =  "delay"/.evopt/.{"delay"->"0"};
evdelay = StringReplace[evdelay,{"[t]"-> "", "\[UnderBracket]"->"_"}]; 

Return[{f, eventName, evdelay}]; 

];
FortranEventSubroutine[x___]:= printWarning["FortranEventSubroutine: invalid event format: "<>ToString[InputForm[x]]]; 
(* end of FortranEventSubroutine *)  

If[nevts>0,
eventFortran = FortranEventSubroutine/@evts;

{eventFortran, eventNames, eventDelays} = Transpose[eventFortran]; 

eventFortran = Apply[StringJoin,eventFortran]; 
 debugPrint[dbg,"eventFortran",eventFortran]; 
debugPrint[dbg,"eventNames",eventNames];
debugPrint[dbg,"eventDelays",eventDelays];


Fortran = Fortran<>eventFortran;
];



generateIndex[]:= Module[{lmax ,l2max, stringpad},
subroutinesGenerated = Sort[subroutinesGenerated]; 
stringpad[s_?StringQ, n_?IntegerQ, char_]:= Module[{s1}, 
s1 = s;
While[StringLength[s1]<n,s1=s1<>char];
Return[s1];
];
stringpad[s_?StringQ, n_?IntegerQ]:= stringpad[s, n, " "]; 

lmax = Map[StringLength[First[#]]&, subroutinesGenerated]//Max; 
l2max = Map[StringLength[Last[#]]&, subroutinesGenerated]//Max; 

subroutinesGenerated = Map[{stringpad[#[[1]], 1+lmax], #[[2]]}&, subroutinesGenerated];
subroutinesGenerated=
StringJoin@@
Map["C "<>Apply[StringJoin,#]<>"\n"&, subroutinesGenerated];


subroutinesGenerated = "C SBML Model Name:  "<>name<>"\nC\n"<>"C Generated by MathSBML "<>$MathSBML$Version<>"\n"
<>"C Creation Time: "<>now[]<>"\n"
<>"C User:          "<>$UserName<>"\n"
<>"C Machine:       "<>$MachineName<>"\n"
<>"C Processor:     "<>$ProcessorType<>"\n"
<>"C Machine type:  "<>$MachineType<>"\n"
<>"C Oper. System:  "<>$OperatingSystem<>"\n"
<>"C --------------------------------------------------------\n"
<>"C\nC lsodi compliant SBML model\n"
<>"C Reference: http://netlib.org/alliant/ode/prog/lsodi.f\n"
<>"C\nC --------------------------------------------------------\n"<>"C\nC This file contains the following modules:\nC\nC "<>stringpad["Module Name",lmax+1]<>stringpad["Description",l2max]<>"\nC "<>stringpad["",lmax,"-"]<>" "<>stringpad["",l2max,"-"]<>"\n"<>subroutinesGenerated;




Return[subroutinesGenerated]; 
]; 

header = generateIndex[];
Fortran = header<>Fortran; 

Return[Fortran];
];


FortranWrap[inputString_?StringQ]:= Module[{outputString, wrk,nextchunk, width=66,
sixBlanks="      ", continuation = "     &",first=True},
wrk = inputString;
outputString="       ";
While[StringLength[wrk]>width,
nextchunk = StringTake[wrk, width];
wrk = StringDrop[wrk, width];
If[first, 
outputString=sixBlanks<>nextchunk;
first=False;,
outputString=outputString<>"\n"<>continuation<>nextchunk;
];
];
If[StringLength[wrk]>0,
If[first,
outputString=sixBlanks<>wrk;
,
outputString=outputString<>"\n"<>continuation<>wrk;
];
];
Return[outputString];
];
FortranWrap[x_]:= FortranWrap[ToString[FortranForm[x]]];


If[$$LoadBug, Print["Loading:predefined functions"]];


mass[x___]:= Apply[Times,{x}];


uui[S_, Vm_, Km_]:= (Vm*S)/(Km+S);


uur[S_, P_, Vf_, Vr_, Kms_, Kmp_]:= (Vf (S/Kms)-Vr (P/Kmp))/(1+S/Kms+P/Kmp)


uuhr[S_,P_,Vf_,Km1_,Km2_,Keq_]:= (Vf/Km1)(S-P/Keq)/(1+S/Km1+P/Km2)


isouur[S_, P_, Vf_, Kms_, Kmp_, Kii_, Keq_]:= Vf (S-P/Keq)/(S (1+P/Kii)+Kms (1+P/Kmp))


hilli[S_, V_, K_,h_]:= V*S^h/(K^h+S^h)


hillr[S_, P_, Vf_, Shalf_, Phalf_, h_, Keq_]:= ((Vf*S/Shalf)(1-P/(S*Keq))(S/Shalf+P/Phalf)^(h-1))/(1+(S/Shalf+P/Phalf)^h);


hillmr[S_,P_, M_, S05_, P05_, M05_,Vf_, Keq_, h_, \[Alpha]_]:= Module[{K1, K2,v},
K1=((S/S05)+(P/P05))^h;
K2=(1+(M/M05)^h)/(1+\[Alpha] (M/M05)^h);
v=(Vf*S/S05)(1-P/(S *Keq))(S/S05+P/P05)^(h-1)/(K1+K2);
Return[v];];


hillmmr[S_, P_, M_,S05_, P05_, M05_, Ma_, Ma05_, Mb_, Mb05_, Vf_, Keq_, h_, a_, b_, \[Alpha]1_, \[Alpha]2_, \[Alpha]12_]:= Module[{K1, K2, v},
K1 = (S/S05 + P/P05)^h;
K2 = (1+(Ma/Ma05)^h+(Mb/Mb05)^h)/(1+\[Alpha]1 (Ma/Ma05)^h + \[Alpha]2 (Mb/Mb05)^h + \[Alpha]1*\[Alpha]2*\[Alpha]12 *(Ma/Ma05)^h * (Mb/Mb05)^h);
v = (Vf * S/S05)(1-P/(S*Keq))*(S/S05 + P/P05)^(h-1)/(K1+K2);
Return[v]; 
]


usii[S_, V_, Km_, Ki_]:= (V*S/Km)/(1+S/Km+S^2/Ki);


usir[S_, P_, Vf_, Vr_, Kms_, Kmp_, Ki_]:= (Vf*S/Kms  + Vr*P/Kmp)/(1+S/Kms + P/Kmp + S^2/Ki);


uai[S_, V_, Ksa_, Ksc_]:=V*(S/Ksa)^2/(1+S/Ksc+(S/Ksa)^2+S/Ksa);


ucii[S_,Inh_, V_,Km_, Ki_]:=(V*S/Km)/(1+S/Km+Inh/Ki);


ucir[S_,P_, Inh_, Vf_, Vr_, Kms_, Kmp_, Ki_]:= ((Vf*S/Kms)-(Vr*P/Kmp))/(1+S/Kms+P/Kmp+Inh/Ki);


unii[S_, Inh_, V_, Km_, Ki_]:= (V*S/Km)/(1+Inh/Ki+(S/Km)(1+Inh/Ki));


unir[S_, P_, Inh_, Vf_, Vr_, Kms_, Kmp_, Ki_]:= ((Vf*S/Kms)-(Vr*P/Kmp))/(1+Inh/Ki + (S/Kms+P/Kmp)(1+Inh/Ki));


uuci[S_, Inh_, V_, Km_, Ki_]:= (V*S/Km)/(1+(S/Km)(1+Inh/Ki));


uucr[S_, P_, Inh_, Vf_, Vr_, Kms_, Kmp_, Ki_]:=( (Vf*S/Kms)-(Vr*P/Kmp))/(1+(S/Kms+P/Kmp)(1+Inh/Ki));


umi[S_, Inh_, V_, Km_, Kis_, Kic_]:= (V*S/Km)/(1+Inh/Kis +(S/Km)(1+Inh/Kic));


umr[S_, P_, Inh_, Vf_, Vr_, Kms_, Kmp_, Kis_, Kic_]:= (Vf*S/Kms - Vr*P/Kmp)/(1+Inh/Kis + (S/Kms+P/Kmp)(1+Inh/Kic));


uaii[S_, Ac_, V_, Km_, Ka_]:= (V*S/Km)/(1+S/Km + Ka/Ac);


uar[S_, P_, Ac_, Vf_, Vr_, Kms_, Kmp_, Ka_]:= (Vf*S/Kms - Vr*P/Kmp)/(1+S/Kms+P/Kmp+Ka/Ac);


ucti[S_, Ac_, V_, Km_, Ka_]:= (V*S/Km)/(1+Ka/Ac + (S/Km)(1+Ka/Ac));


uctr[S_, P_, Ac_, Vf_, Vr_, Kms_, Kmp_, Ka_]:= (Vf*S/Kms - Vr*P/Kmp)/(1+Ka/Ac + (S/Kms + P/Kmp)(1+Ka/Ac));


umai[S_, Ac_, V_, Km_, Kas_, Kac_]:= (V*S/Km)/(1+Kas/Ac +( S/Km )(1+Kac/Ac))


umar[S_, P_, Ac_, Vf_, Vr_, Kms_, Kmp_, Kas_, Kac_]:= (Vf*S/Kms - Vr*P/Kmp)/(1+(Kas/Ac) + (S/Kms+P/Kmp)(1+Kac/Ac));


uhmi[S_, M_, V_, Km_, Kd_, a_, b_]:= ((V*S/Km)*(1+b*M/(a*Kd)))/(1+M/Kd + (S/Km)(1+M/(a*Kd)));


uhmr[S_, P_, M_, Vf_, Vr_, Kms_, Kmp_, Kd_, a_, b_]  := (Vf*S/Kms - Vr*P/Kmp)*(1+b*M/(a*Kd))/(1+M/Kd + (S/Kms+P/Kmp)(1+M/(a*Kd)));


ualii[S_, Inh_, V_, Ks_, Kii_, n_, L_]:= V *(S/Ks)* (1+S/Ks)^(n-1) / (L*(1+Inh/Kii)^n+(1+S/Ks)^n)


ordubr[A_, P_, Q_, Vf_, Vr_, Kma_, Kmq_, Kmp_, Kip_, Keq_]:= (Vf*(A-P*Q/Keq))/(Kma + A*(1+P/Kip) + (Vf/(Vr*Keq))(Kmq*P+Kmp*Q+P*Q))


ordbur[A_, B_, P_, Vf_, Vr_, Kma_, Kmb_, Kmp_, Kia_, Keq_]:= (Vf * (A*B - P/Keq))/ (A*B + Kma*B + Kmb*A + (Vf / (Vr*Keq))*(Kmp + P * (1+A/Kia)))


ordbbr[A_, B_, P_, Q_, Vf_, Vr_, Kma_,Kmb_,  Kmp_,Kmq_,  Kia_, Kib_, Kip_, Keq_]:= Module[{v,K1, K2}, 
K2 = Kmp * (1+Kma*B/(Kia*Kmb) +P*(1+B/Kib)); 
K1= (Vf/(Vr*Keq))(Kmq*P*(1+A/Kia)+Q*K2);
v = (Vf*(A*B - P*Q /Keq ))/(A*B*(1+P/Kip)+Kmb*(A+Kia)+Kma*B+K1);
Return[v]
];


ppbr[A_, B_, P_, Q_, Vf_, Vr_, Kma_, Kmb_, Kmp_, Kmq_, Kia_, Kiq_, Keq_]:= Module[{K1, v},

K1= (Vf /(Vr*Keq))(Kmq*P (1+A/Kia)+ Q (Kmp+P));
v = (Vf*(A*B-P*Q/Keq))/(A*B+Kmb*A + Kma*B*(1+Q/Kiq) +K1); 
Return[v];
];


getSBMLlevel2[sbml_,filename_, opt___?OptionQ]:= Module[{ models, modelid,   statistics,modelCounterString, modelName,importedModel={}, numericalSolution, dbg=False, addConstantSpeciesBackIn,expressRule,sm,t0,cpu,modelmetaid
},
dbg=Global`debug/.{opt}/.{Global`debug-> False};

expressRule[Rule[a_?StringQ, b_?StringQ]]:= Rule[ToExpression[a], ToExpression[b]];

addConstantSpeciesBackIn[id_]:= Module[{s},
removeReplacementRule[id]; 
defineVariable[id]; 
addDummyODE[id];

];
addConstantSpeciesBackIn[x___]:= Module[{}, Print["Error: getSBMLLevel2: addConstantSpeciesBackIn: x=",x]];


SBML$Trace = (Global`trace/.{opt}/.{Global`trace-> False});

$SBML$UnitAssociations={};
$SBML$ODES={};
$SBML$NameIDAssociations={};  
$SBML$ConstantSpecies={}; 
$SBML$SpeciesThatAreAmounts={};
$SBML$SpeciesThatAreConcentrations={};
$SBML$Species$IDs={};
$SBML$StoichiometryMatrix={};
$SBML$IDTable={};
$SBML$MetaIDTable={};
$SBML$LocalReactionParameterTable={};
$SBML$KineticLaws={};
$SBML$MetaIDAssociations={};

Clear[hasOnlySubstanceUnitsIndicator];
hasOnlySubstanceUnitsIndicator[x_]:= False;
Clear[SBMLSpeciesCompartment];
SBMLSpeciesCompartment[x_]:=Indeterminate;




debugPrint[dbg\[Or] SBML$Trace,"getSBMLevel2: SBML level.version = ", $SBML$Level$Version ];
If[$SBML$printModelName,
modelCounterString=" ********** Model "<>ToString[$SBML$modelcount]<>" ********** \n",
modelCounterString="";
];
If[saveVerboseData,
 verboseSave[modelCounterString<>"File Name:"<> filename<>"\nSBML Level "<>ToString[$SBML$Level]<>" Version "<>ToString[$SBML$Version],
{},{}];
]; 

getSBMLNotes[sbml]; 

(* check for extraneous objects in file *)

Block[{s, objects},
s=First[sbml];
objects[XMLElement["sbml",a_, b_]]:= b; 
s=objects[s]/.{XMLElement-> List};
s=First/@s;
s= Complement[s, {"model", "notes", "annotation"}];

Print["Error: "//boldRed,
" Unknown or invalid object:"//boldBlack, #//boldBlue, " in SBML container. Allowed objects are: "//boldBlack, 
"annotation, "//boldBlue, "notes, "//boldBlue, "model"//boldBlue
]&/@s;

];

(***** Models *****)

$SBML$Model = Cases[sbml,XMLElement["model",___],3]; 
{modelid, modelName, modelmetaid}=getLevel2ModelName[]; 
If[MB$Load, 
MB$ID=modelid; 
MB$Name=modelName;
MB$MetaID=modelmetaid;

newModel[Global`level-> $SBML$Level,Global`version-> $SBML$Version, Global`echo-> MB$Echo, Global`id-> MB$ID, Global`name-> MB$Name, Global`metaid-> MB$MetaID];
MB$ModelAnnotation=getAnnotations[$SBML$Model]//Flatten; 
MB$ModelNotes=getNotes[$SBML$Model]//Flatten;
]; 

If[dbg, Print["getSBMLlevel2: MB$Load:",MB$Load]];
If[dbg, Print["getSBMLlevel2: MB$ModelNotes:",MB$ModelNotes]];


$SBML$Model = First[$SBML$Model]; 

checkModelOrder[$SBML$Model];

debugPrint[dbg\[Or] SBML$Trace,"getSBMLlevel2:: modelid, modelName",{modelid,modelName}];
debugPrint[dbg,"$SBML$Model: ",$SBML$Model];

t0=TimeUsed[];
debugPrint[ SBML$Trace,"Trace>> Calling getLevel2Functions"];
getLevel2Functions[]; 
cpu=TimeUsed[]-t0;
debugPrint[SBML$Trace,"CPU: ",cpu];

debugPrint[ SBML$Trace,"Trace>> Calling getLevel2units"];
getLevel2units[];
cpu=TimeUsed[]-t0;
debugPrint[SBML$Trace,"CPU: ",cpu];

debugPrint[ SBML$Trace,"Trace>> Calling getLevel2compartmentTypes"];
t0=TimeUsed[];
getLevel2compartmentTypes[]; 
cpu=TimeUsed[]-t0;
debugPrint[SBML$Trace,"CPU: ",cpu];

debugPrint[ SBML$Trace,"Trace>> Calling getLevel2speciesTypes"];
t0=TimeUsed[];
getLevel2speciesTypes[]; 
cpu=TimeUsed[]-t0;
debugPrint[SBML$Trace,"CPU: ",cpu];

debugPrint[ SBML$Trace,"Trace>> Calling getLevel2compartments"];
t0=TimeUsed[];
getLevel2compartments[]; 
cpu=TimeUsed[]-t0;
debugPrint[SBML$Trace,"CPU: ",cpu];

debugPrint[ SBML$Trace,"Trace>> Calling getLevel2species"];
t0=TimeUsed[];
getLevel2species[];
cpu=TimeUsed[]-t0;
debugPrint[SBML$Trace,"CPU: ",cpu];

debugPrint[ SBML$Trace,"Trace>> Calling getLevel2parameters"];
t0=TimeUsed[];
getLevel2parameters[];
cpu=TimeUsed[]-t0;
debugPrint[SBML$Trace,"CPU: ",cpu];

SBMLBoundaryConditionQ[unknownX_]:= False;
SBMLConstantQ[unknownX_]:= False;

getLevel2InitialAssignments[];

debugPrint[ SBML$Trace,"Trace>> Calling getLevel2rules"];
t0=TimeUsed[];
getLevel2rules[];
cpu=TimeUsed[]-t0;
debugPrint[SBML$Trace,"CPU: ",cpu];

getLevel2constraints[];

debugPrint[ SBML$Trace,"Trace>> Calling getLevel2reactions"];
t0=TimeUsed[];
getLevel2reactions[];
cpu=TimeUsed[]-t0;
debugPrint[SBML$Trace,"CPU: ",cpu];

checkParameterShadowing[];

debugPrint[ SBML$Trace,"Trace>> Calling getLevel2events"];
getLevel2events[];

 
(* addConstantSpeciesBackIn/@$SBML$ConstantSpecies; *) 

(***** Verbose Listing *****)
debugPrint[ SBML$Trace,"Trace>> Handling Verbose data"];
If[$SBML$verbose, verbosePrint[]]; 

(***** Return Data *****)
debugPrint[ SBML$Trace,"Trace>> Handling Return data"];
If[SBMLRead$return,

If[SBMLRead$returnContext, importedModel=Append[importedModel,Global`SBMLContext-> $SBML$Context]];

If[SBMLRead$returnODES, importedModel=Append[importedModel,Global`SBMLODES-> $SBML$ODES]];

If[SBMLRead$returnIC, importedModel=
Append[importedModel,
Global`SBMLIC->ToExpression[initialize[SBMLVariables]]
]];

If[SBMLRead$returnConstants, importedModel=Append[importedModel,Global`SBMLConstants->(SBMLReplacementRules)]];
If[SBMLRead$returnBoundaryConditions, importedModel=Append[importedModel,Global`SBMLBoundaryConditions->(SBMLBoundaryConditions)]];



If[SBMLRead$returnGlobalParameters, importedModel=Append[importedModel,Global`SBMLParameters->(SBMLGlobalParameters)]];

If[SBMLRead$returnSpeciesTypes,
If[ToExpression[$SBML$Level$Version]>2.15,
importedModel=Join[importedModel, {Global`SBMLSpeciesTypes->$SBML$SpeciesTypes ,
Global`SBMLSpeciesTypeAssociations-> $SBML$SpeciesTypeAssociations
}];
];
];


If[SBMLRead$returnMetaIDAssociations, importedModel=Append[importedModel,Global`SBMLMetaIDAssociations->($SBML$MetaIDAssociations)]
];

If[SBMLRead$returnCompartmentTypes,
If[ToExpression[$SBML$Level$Version]>2.15,
importedModel=Join[importedModel, {Global`SBMLCompartmentTypes->$SBML$CompartmentTypes,Global`SBMLCompartmentTypeAssociations-> $SBML$CompartmentTypeAssociations} ];
];
];


If[SBMLRead$returnSpecies, importedModel=Append[importedModel,
Global`SBMLSpecies->functionate[$SBML$Species$IDs]
]];

If[SBMLRead$returnModelVariables, 
importedModel=Append[importedModel,
Global`SBMLModelVariables->ToExpression[functionate[SBMLVariables]]
];
];



If[SBMLRead$returnAssignmentRules, importedModel=Append[importedModel,Global`SBMLAssignmentRules-> $SBML$Assignment$Rules]];

If[SBMLRead$returnAlgebraicRules, importedModel=Append[importedModel,Global`SBMLAlgebraicRules-> $SBML$Algebraic$Rules]];

If[ToExpression[$SBML$Level$Version]>2.15,
If[SBMLRead$returnConstraints, importedModel=Append[importedModel,Global`SBMLConstraints-> $SBML$Constraints]];
If[SBMLRead$returnInitialAssignments, importedModel=Append[importedModel,Global`SBMLInitialAssignments-> $SBML$InitialAssignments]];
];

If[SBMLRead$returnReactions, importedModel=Append[importedModel,Global`SBMLReactions-> $SBML$Reactions]];

If[SBMLRead$returnKineticLaws, importedModel=Append[importedModel,Global`SBMLKineticLaws-> $SBML$KineticLaws]];

If[SBMLRead$returnStoichiometryMatrix,
importedModel=Append[importedModel, Global`SBMLStoichiometryMatrix->$SBML$StoichiometryMatrix ];
];

If[SBMLRead$returnConservationMatrix,
If[MatrixQ[$SBML$StoichiometryMatrix],
importedModel=Append[importedModel, Global`SBMLConservationMatrix->conservationMatrix[$SBML$StoichiometryMatrix ]],
importedModel=Append[importedModel, Global`SBMLConservationMatrix->{}]
];
];


If[SBMLRead$returnMassBalanceEquations,
importedModel=Append[importedModel, Global`SBMLMassBalanceEquations->SBML$MassBalanceEquations ];
];
If[SBMLRead$returnMassActionEquations, importedModel=Append[importedModel, Global`SBMLMassActionEquations-> SBML$MassAction$Equations];
importedModel=Append[importedModel,Global`SBMLMassActionVariables->$SBML$MassActionVariables ];
];

If[SBMLRead$returnFunctions,importedModel= Append[importedModel,Global`SBMLFunctions-> $SBML2$Functions];]; 

If[SBMLRead$returnUnitDefinitions, importedModel=Append[importedModel,Global`SBMLUnitDefinitions-> $SBML$UnitRules]];
If[SBMLRead$returnUnitAssociations,importedModel=Append[importedModel,Global`SBMLUnitAssociations-> $SBML$UnitAssociations]];


If[SBMLRead$returnNameIDAssociations,
importedModel = Append[importedModel, Global`SBMLNameIDAssociations-> $SBML$NameIDAssociations]; 
];


If[SBMLRead$returnEvents,
importedModel = Append[importedModel,Global`SBMLEvents-> $SBML$Events];
]; 

If[SBMLRead$returnModelName,
importedModel = Append[importedModel,Global`SBMLModelName-> modelName];
importedModel = Append[importedModel, Global`SBMLModelid-> modelid];
];
If[SBMLRead$returnCompartments,
importedModel = Append[importedModel,Global`SBMLCompartments-> ToExpression/@$SBML$Compartmentids];
];

If[SBMLRead$returnSpeciesCompartmentAssociations,
importedModel = Append[importedModel,Global`SBMLSpeciesCompartmentAssociations-> expressRule/@$SBML$SpeciesCompartmentAssociations];
];

If[SBMLRead$returnSolution>0, 

debugPrint[ SBML$Trace,"Trace>> Determining Numerical Solution, duration = "<>ToString[SBMLRead$returnSolution]<>" NDSolveOptions-> "<>ToString[SBML$NDSolveOptions]];
numericalSolution = SBMLNDSolve[importedModel, SBMLRead$returnSolution, SBML$NDSolveOptions]; 
importedModel = Append[importedModel, Global`SBMLNumericalSolution-> numericalSolution];
];


];

importedModel=Append[importedModel, Global`SBMLLevelVersion-> ToExpression[$SBML$Level$Version]];

printStatistics[];

If[MB$Load \[And] MB$Echo, 
Print["SMBL Model "//boldGreen, modelid//boldBlue," loaded into Model Builder "//boldGreen];
];

Return[importedModel];


];


checkModelOrder[XMLElement["model", stuff_, morestuff_]]:=Module[{s, so, types, order, bad, number, numbers,lv},

lv = ToExpression[$SBML$Level$Version];

If[lv < 2.15,
types={"listOfFunctionDefinitions",
"listOfUnitDefinitions",
"listOfCompartments", 
"listOfSpecies",
"listOfParameters",
"listOfRules",
"listOfReactions", 
"listOfEvents"
};
,
types={"listOfFunctionDefinitions",
"listOfUnitDefinitions",
"listOfCompartmentTypes",
"listOfSpeciesTypes",
"listOfCompartments", 
"listOfSpecies",
"listOfParameters",
"listOfInitialAssignments",
"listOfRules",
"listOfConstraints",
"listOfReactions", 
"listOfEvents"
};
];

order[x_]:=Position[types,x][[1, 1]];



s=morestuff/.{XMLElement-> List};
s=First/@s;
s=Select[s, !MemberQ[{"notes", "annotation"}, #]&];

(* see if there are unknown model elements *)

bad = Complement[s, types];
Print["Error: "//boldRed, "The model contains an unknown top level element "//boldBlack, #//boldBlue]&/@bad;
s = Select[s, MemberQ[types, #]&]; 

(* see if there are duplicated elements *)

number[object_]:= Length[Position[s, object]];
numbers = number/@types;

MapThread[If[#1>1, 
Print["Error: "//boldRed, "The model contains multiple "//boldBlack, #2//boldBlue]
]&, {numbers, types}];


(* see if the elements are in the correct order *)

so = order/@s;

Block[{i,type1, type2, i1, i2},
For[i=2, i<= Length[s], i++,
i1=so[[i-1]]; 
i2=so[[i]];
If[i1>i2,
type1=types[[i1]]; 
type2=types[[i2]]; 
Print["Error: "//boldRed,
" The model contains objects that are not in the proper order: "//boldBlack,
type2//boldBlue , " is not allowed to follow "//boldBlack, type1//boldBlue, "\nThe proper order is:\n"//boldBlack, 
(StringJoin@@("\t\t"<>#<>"\n"&/@types))
//boldBlue
];

];
];

];

];


checkModelOrder[u_]:=Print["Error: "//boldRed, "checkModelOrder: not a model:"//boldBlack, u//boldBlue]; 


If[$$LoadBug, Print["Loading: level-2 specific functions"]];


$SBML$IDTable={}; (* force initialization at load time *)
$SBML$MetaIDTable={}; (* force initialization at load time *)

identifyID[id_]:=Module[{type}, 
p = Position[$SBML$IDTable, id];
If[Length[p]>0, 
p=p[[1,1]];
type=$SBML$IDTable[[p, 2]];
Return[type];
];
Return["Unknown"]; 
]

addID[id_, kind_, check_:True]:= Module[{did, dbg=False},

If[dbg, Print["addID: adding: kind: ", kind, " id: ", id]; ]; 

did = decontextify[id]; 
If[check,collisionCheck[did,kind,True]];
$SBML$IDTable=Append[$SBML$IDTable, stringer/@{did,kind}];
Return[id];
];
addMetaID[meta_, id_, kind_, check_:True]:= Module[{did, dbg=False},

If[dbg, Print["addMetaID: meta(in): ", meta]];

did = decontextify[meta]; 
If[check,metacollisionCheck[did,id,kind,True]];
AppendTo[$SBML$MetaIDTable, stringer/@{did,kind}];
AppendTo[$SBML$MetaIDAssociations, 
Rule[did, stringer[id]]
]; 
If[dbg, Print["addMetaID: meta(out): ", meta-> id]];

Return[meta];
];
removeID[id_, kind_]:= Module[{did, matches, meta, dbg=False},

If[dbg, Print["removeID:", {id , kind}]];
did=decontextify[id];
If[!MemberQ[$SBML$IDTable, stringer/@{did,kind}], 
matches = Select[$SBML$IDTable, Equal[stringer[id], First[#]]&]; 
Print["Warning: "//boldRed, "removeID: "//boldBlack, #[[1]]//boldBlue, " is listed as a "//boldBlack, #[[2]]//boldBlue, " and not as a "//boldBlack,  kind//boldBlue," in the symbol table."//boldBlack]&/@matches;
];

If[dbg, Print[ "removeID:  stringer/@{did,kind}: ", stringer/@{did,kind}]]; 

$SBML$IDTable=Complement[$SBML$IDTable, {stringer/@{did,kind}}];

(* remove any metaid's that are pointing to this id!! *)


meta = Select[$SBML$MetaIDAssociations, 
Equal[id, decontextify[Last[#]]]&];

 
If[Length[meta]>0, 
meta = First/@meta;

If[dbg, Print["removeID: meta: ", meta]];
removeMetaID[#, kind]&/@meta;

$SBML$MetaIDAssociations=Complement[$SBML$MetaIDAssociations, meta];
If[dbg, Print["removeID: $SBML$MetaIDAssociations: ", $SBML$MetaIDAssociations]];
If[dbg, Print["removeID: $SBML$MetaIDTable: ", $SBML$MetaIDTable]];
 
]; 


];
removeMetaID[id_, kind_]:= Module[{did, matches, dbg=False, sel},
did=decontextify[id];
If[!MemberQ[$SBML$MetaIDTable, stringer/@{did,kind}], 
matches = Select[$SBML$MetaIDTable, Equal[stringer[id], First[#]]&]; 
Print["Warning: "//boldRed, "removeMetaID: "//boldBlack, #[[1]]//boldBlue, " is listed as a "//boldBlack, #[[2]]//boldBlue, " and not as a "//boldBlack,  kind//boldBlue," in the symbol table."//boldBlack]&/@matches;
];


$SBML$MetaIDTable=Complement[$SBML$MetaIDTable,{ stringer/@{did,kind}}];

If[dbg, Print["removeMetaID: kind: ", kind]]; 
If[dbg, Print["removeMetaID: did: ", did]]; 

$SBML$MetaIDAssociations= Select[$SBML$MetaIDAssociations, (First[#] != did )&];
 

];
collisionCheck[id_, kind_, msg_:True]:= Module[{matches,found},
matches = Select[$SBML$IDTable, Equal[stringer[id], First[#]]&]; 
found = Length[matches]>0;
If[msg, 
Print["Error:"//boldRed,kind//boldBlue, ":"//boldBlack, id//boldBlue," collides with previously defined "//boldBlack,#[[2]]//boldBlue,":"//boldBlack,#[[1]]//boldBlue]&/@matches;
]; 
Return[matches];
];
metacollisionCheck[metaid_,id_, kind_, msg_:True]:= Module[{matches,found},
matches = Select[$SBML$MetaIDTable, Equal[stringer[metaid], First[#]]&]; 
found = Length[matches]>0;
If[msg, 
Print["Error:"//boldRed,kind//boldBlue, " metaid:"//boldBlack, metaid//boldBlue," (id="//boldBlack, decontextify[id]//boldBlue, 
") collides with previously defined "//boldBlack,#[[2]]//boldBlue," metaid:"//boldBlack,#[[1]]//boldBlue, 

" (id = "//boldBlack ,boldBlue[ decontextify[#[[1]]/.($SBML$MetaIDAssociations)]], ")"//boldBlack
]&/@matches;
]; 
Return[matches];
]


getLevel2ModelName[]:= Module[{modeloptions, modelid, modelName, meta,sbo, header},
abortIfNoTag[$SBML$Model, "model"];
modeloptions = Map[extractXMLOptions,$SBML$Model];
modelid=Map["id"/.#/.{"id"-> "Model"<>ToString[$SBML$modelcount]}&, modeloptions];
modelName=Map["name"/.#/.{"name"-> ""}&, modeloptions];
meta=Map["metaid"/.#/.{"metaid"-> ""}&, modeloptions];
sbo=Map["sboTerm"/.#/.{"sboTerm"-> ""}&, modeloptions];

If[Length[modelid]<1, 
Print["Error: "//boldRed, "no "//boldBlack, "model"//boldBlue, " found in SBML."//boldBlack];
];

Print["Error: "//boldRed, "The SBML contains multiple models.\nThe model "//boldBlack,
First[modelid]//boldBlue," will be used."//boldBlack,
"\nThe model "//boldBlack, #//boldBlue, " will be ignored."//boldBlack]&/@Rest[modelid];


modelid = First[modelid] // makeIntoValidSId;
meta = First[meta]//makeIntoValidSId;
sbo=First[sbo];

(* *)
If[SBML$CheckModelContext, 
If[MemberQ[Contexts[],modelid<>"`"],
If[!MemberQ[PreviousModelContexts,modelid<>"`"],
Print["Warning: "//boldRed, "The model id "//boldBlack,modelid//boldBlue," collides with an existing Mathematica context [this could occur if the model has been previously read during the same Mathematica session]."//boldBlack];
];
];
];
(* *) 

modelName = First[modelName]; 
saveNameIDAssociation[modelName,modelid]; 

If[saveVerboseData, 
header="Model id: "<>modelid; 
If[modelName!= "", header = "Model name: "<>modelName<>"\n"<>header]; 
If[meta!= "", header = header<>"\nModel metaid: "<>meta]; 
If[sbo!= "", header = header<>"\nModel sboTerm: "<>sbo]; 
verboseSave[header, {}, {}];
]; 



setModelContext[modelid]; 
Return[{modelid, modelName, meta}];
];


saveNameIDAssociation[name_, id_]:= Module[{},
If[((name!= "") \[And]( name!= id) \[And]( id!= "Indeterminate")), 
$SBML$NameIDAssociations=Append[$SBML$NameIDAssociations, id-> name]; 
]; 
];


getLevel2Functions[]:= Module[{f,dbg=False, getFunction,id, name,opts,args,functionDefinition,htmlfunctiondef, fdef, farg,fid,fname},

getFunction[functionXML_]:= Module[{f,math,meta,sboTerm, id, sym},

f= functionXML;
debugPrint[dbg,"getFunction: f:", f];

opts = extractXMLOptions[f];
id = "id"/.Flatten[{opts}]/.{"id"-> "Indeterminate"}; 
meta = "metaid"/.Flatten[{opts}]/.{"metaid"-> ""}; 
sboTerm="sboTerm"/.Flatten[{opts}]/.{"sboTerm"-> ""}; 

(* addID[id, "function"]; *)

id = makeIntoValidSId[id];
If[stringer[id]=="Indeterminate",
id = "function"<>ToString[MB$functioncounter++];
Print["Error: "//boldOrange,"Required function id missing from <functionDefinition../>. Assigned "//boldBlack,id//boldRed];
];

If[MB$Load,addFunction[f]];

name = "name"/.Flatten[{opts}]/.{"name"-> ""};
id = contextify[id]; 

checkForSymbolCollision[id,"function"];

debugPrint[dbg,"getFunction: {id, name}:", {id, name}];
math= Cases[f,XMLElement["math",___],3]; 
If[Length[math]>0, 
math = First[math],
Print["Error:"//boldRed, " getLevel2Functions: functionDefintion for "//boldBlack, id//boldBlue, " is missing the <math> element:\n"//boldBlack,
Sequence@@XMLHighlightForm[f,Purple, "functionDefinition"]
];
Print[f];
 Abort[]; 
]; 
debugPrint[dbg,"getFunction: math:", math];

(* 2.5.24 added the next line *)
math =checkMathMLElements[math];
 
functionDefinition = SymbolicSBMLMathMLToExpression[math];

(* 2.3.36 check for any symbols that are not arguments, and assume that they are defined somewhere in the model, such as other functions, and contextify them 
*)
sym =getSymbols[functionDefinition];

sym=Complement[sym,{ Global`t}]; 

sym=decontextify/@sym;
debugPrint[dbg,"getFunction: sym:", sym];

(* list of {XMLElement[bvar,...] } *) 
args = Cases[functionXML,XMLElement["bvar",___], Infinity]; 

(*  list of {XMLElement[ci,{},variable],... } *) 
args = Flatten[extractXMLSubElements/@args]; 
(*  list of variable names *) 
args =extractXMLSubElements/@args; 
args = ToExpression/@Flatten[args];
sym = Complement[sym,args];
sym = Map[Rule[#, contextify[#]]&, sym];

debugPrint[dbg,"getFunction: args:", args];
debugPrint[dbg,"getFunction: sym:", sym];


functionDefinition = (functionDefinition//.sym)//InputForm//ToString;
debugPrint[dbg,"getFunction: functionDefinition:", functionDefinition];
 
$SBML2$Functions = Append[$SBML2$Functions,ToExpression[id<>"->"<>functionDefinition]];
saveNameIDAssociation[name,id]; 

If[saveVerboseData,
If[!$SBML$verboseContext, id = decontextify[id]];
]; 

If[ToExpression[$SBML$Level$Version]>2.15, 
Return[{id,meta, name, functionDefinition,sboTerm}],
Return[{id,meta, name, functionDefinition}]
];
]; (* end of getFunction *) 
$SBML2$Functions = {}; 

f = Cases[$SBML$Model,XMLElement["listOfFunctionDefinitions",___],3]; 
debugPrint[dbg,"getLevel2Functions: f(1): ",f];


f= Cases[f,XMLElement["functionDefinition",___],3]; 
debugPrint[dbg,"getLevel2Functions: f(2): ",f];

f = Map[getFunction, f];
debugPrint[dbg,"getLevel2Functions: f(3): ",f];

htmlfunctiondef[z_]:=Module[{f,fdef,fid,fmeta, fname},
f=z;
fdef = f[[4]];
fid=f[[1]];
fmeta=f[[2]];
fname=f[[3]];
fdef=StringReplace[fdef,{"Function"-> ""} ];
fdef = "{"<>StringDrop[StringDrop[fdef,1],-1]<>"}";
fdef = ToExpression[fdef];
farg =fid<>"["<>StringDrop[StringDrop[ First[fdef]//stringer,1],-1]<>"]:=";
fdef = StringDrop[StringDrop[Rest[fdef]//stringer,1],-1];
fdef = farg<>fdef;
fdef = StringReplace[fdef,","-> "@COMMA"];
Return[{fname,fmeta, fdef}];
];

If[saveVerboseData,
If[ToExpression[$SBML$Level$Version]>2.15,
(* Move SBOTerm from part 5 to part 3*) 
If[Length[f]>0,
Block[{f1,f2,f3,f4,f5},
{f1,f2,f3,f4,f5} = Transpose[f];
f = Transpose[{f1,f2,f5,f3,f4}];
];
]; 


If[$SBML$OutputFormatIsHTML, 
f=htmlfunctiondef/@f;
verboseSave["Function Definitions", {"Name","MetaID","SBOTerm", "Definition (id[arguments]:=def)"}, f]
,
verboseSave["Function Definitions", {"ID", "MetaID","SBOTerm","Name", "Function Definition"}, f]
];
,
If[$SBML$OutputFormatIsHTML, 
f=htmlfunctiondef/@f;
verboseSave["Function Definitions", {"Name","MetaID", "Definition (id[arguments]:=def)"}, f]
,
verboseSave["Function Definitions", {"ID", "MetaID","Name", "Function Definition"}, f]
];

];
];

]


getLevel2units[opt___?OptionQ]:= Module[{u,
dbg=False,defaultUnitsNeeded,defaultUnitRules,checkBuiltInRedef,
specTable3={"substance"-> "mole","volume"-> "litre", "time"-> "second","area"-> "metre^2", "length"-> "metre"}, 
L2V1AllowedScalableDefaultUnits={
"substance"-> {"mole", "item"},
"volume"-> {"litre", "metre^3"},
"area"-> {"metre^2"}, 
"length"-> {"metre"},
"time"-> {"second"}
}, 
L2V2AllowedScalableDefaultUnits={
"substance"-> {"dimensionless","mole", "item", "gram", "kilogram"},
"volume"-> {"dimensionless","litre", "metre^3"},
"area"-> {"dimensionless","metre^2"}, 
"length"-> {"dimensionless","metre"},
"time"-> {"dimensionless","second"}
}, 
allowedScaling, 
builtInQuantities={"substance","volume","time","area", "length"},
builtInDefs,comment,
commonMisspellings={"meter","liter"},cms,
correctSpellings={"meter"-> "metre", "liter"-> "litre"},
getSBMLUnitDefinition,
unitDefinitions,names,defs,ids,
allowedKinds={"ampere","becquerel","candela","Celsius","coulomb","dimensionless","farad","gram","gray","henry","hertz","item","joule","katal","kelvin","kilogram","litre","lumen","lux","metre","mole","newton","ohm","pascal","radian","second","siemens","sievert","steradian","tesla","volt","watt","weber"},
unitsDefinedInThisModel,inherentKinds, unitOptions, metas
},
names={}; ids={}; defs={}; metas={};
allowedScaling=Switch[
$SBML$Level$Version,
"2.1",L2V1AllowedScalableDefaultUnits,
"2.2",L2V2AllowedScalableDefaultUnits,
"2.3",L2V2AllowedScalableDefaultUnits,  (* no changes here in L2V3 so use same variable *)
_, Print["Error: "//boldRed, "getLevel2Units: Table 3 Values undefined for SBML Level.Version = "//boldBlack, $SBML$Level$Version//boldBlue]
];

(* Set flags used elsewehere for checking to see if units are scaled properly*)
$ScalableUnits$Substance="substance"/.allowedScaling;
$ScalableUnits$Volume="volume"/.allowedScaling;
$ScalableUnits$Area="area"/.allowedScaling;
$ScalableUnits$Length="length"/.allowedScaling;
$ScalableUnits$Time="time"/.allowedScaling;


inherentKinds=Join[allowedKinds,builtInQuantities]; 
specTable3= unitsContextify[specTable3];
builtInQuantities=unitsContextify[builtInQuantities]; 
commonMisspellings=unitsContextify[commonMisspellings];
correctSpellings= unitsContextify[correctSpellings];
allowedKinds = unitsContextify[allowedKinds];
unitsDefinedInThisModel={};
debugPrint[dbg,"getLevel2units: inherentKinds:",inherentKinds]; 

getLevel2UnitDefinition[z_]:= Module[{opts,units,listofunits,name, unitspecs,kinds,exponents,levelVersion,scales,disallowedKinds,unitdef,unitdefinition,dbg=False,id,meta, rawid, multipliers, getUnitFields, offsets},


debugPrint[dbg,"--->getLevel2UnitDefinition:z ",z]; 
getUnitFields[x_]:= Module[{k,e,s,m,o},
k = "kind"/.x/.{"kind"-> "Indeterminate"};
k = unitsContextify[k];

e="exponent"/.x/.{"exponent"-> "1"};
s = "scale"/.x/.{"scale"-> "0"};
m="multiplier"/.x/.{"multiplier"-> "1"};

levelVersion=ToExpression[$SBML$Level$Version]; 

(* revised in version 2.9.0 to only check for 2.1 & lower vers 2.2 & higher rather than specific versions *)

If[levelVersion< 2.15,  o="offset"/.x/.{"offset"-> "0"};,
o="offset"/.x;
If[o!= "offset",
Print["Error:"//boldRed, "getLevel2Units: the "//boldBlack,
"offset"//boldBlue, " field in a unit definition is not allowed in SBML Level 2 Version 2:\n"//boldBlack,
Sequence@@XMLHighlightForm[z, Purple, "offset=\""<>o<>"\""]
];
];
o="0"; (* small letter oh = quote zero *)
If[decontextify[k]== "Celsius",
Print["Error:"//boldRed, "getLevel2Units: the value "//boldBlack,
"Celsius"//boldBlue, " is not an allowed unit kind in SBML Level 2 Version 2:\n"//boldBlack,
Sequence@@XMLHighlightForm[z, Purple, "kind=\"Celsius\""]
];
];
];
Return[{k,e,s,m,o}];
];

unitdef[{kind_, exp_, scale_,multiplier_, offset_}]:=Module[{v},
(* v=ToExpression[multiplier<>"* 10^"<>scale<>"*("<>kind<>")^"<>exp<>" +"<>offset]; *) 
(* revised version 4/25/05 v2.4.13 based on L2v1 errata *)

v=ToExpression["("<>multiplier<>"* 10^"<>scale<>"*("<>kind<>"))^"<>exp<>" +"<>offset];

debugPrint[dbg, "\!\(\*
StyleBox[\"unitdef\",\nFontColor->RGBColor[0, 0, 1]]\): v ",v];

Return[v];
];


opts = extractXMLOptions[z];
id = "id"/.Flatten[{opts}]/.{"id"-> "Indeterminate"}; 
meta = "metaid"/.Flatten[{opts}]/.{"metaid"-> ""};

(* addID[id, "unit"]; *)

id =  makeIntoValidSId[id];
rawid=id;

id = unitsContextify[id];

checkForSymbolCollision[id,"unit"];

name = "name"/.Flatten[{opts}]/.{"name"-> ""};
If[id=="Indeterminate",
If["name"=="",
 printWarning["<unitDefinition ...> has neither an 'id' nor a 'name'."];
,
id =  unitsContextify[makeIntoValidSId[name]];
printWarning["<unit Definition ...> for unit with name=\""<>name<>"\" has no 'id' specification. An an assignment of id=\""<>id<>"\" has been performed."]; 
]; 
]; 
saveNameIDAssociation[name,id]; 

debugPrint[dbg, "getSBMLUnitDefinition: input ",z];
debugPrint[dbg, "getSBMLUnitDefinition: opts ",opts];

listofunits = Cases[z,XMLElement["listOfUnits",___],3]; 
debugPrint[dbg, "getSBMLUnitDefinition: listofunits ",listofunits];

If[Length[listofunits]>0,
units =Cases[listofunits,XMLElement["unit",___],3];
debugPrint[dbg, "getSBMLUnitDefinition: units ",units];

If[Length[units]>0, 
unitOptions = Map[extractXMLOptions,units];

unitspecs=Map[getUnitFields,unitOptions];

{kinds,exponents,scales,multipliers, offsets}=Transpose[unitspecs];

disallowedKinds=Complement[kinds,allowedKinds];

cms = Intersection[commonMisspellings, disallowedKinds]; 
If[Length[cms]>0,
kinds = kinds/.correctSpellings;
unitspecs = unitspecs/.correctSpellings;
disallowedKinds=Complement[kinds,allowedKinds];
Map[Print["Error: "//boldRed, "getLevel2UnitDefinition: Possible mispelling: "//boldBlack, "Invalid unit kind "//boldBlack, #//boldBlue, " replaced with "//boldBlack, (#/.correctSpellings)//boldBlue
]&,cms];

]; 
Print["Error: "//boldRed, "getLevel2Units: invalid unit kind "//boldBlack, decontextify[#]//boldBlue,"\n",
Sequence@@XMLHighlightForm[z, Purple, "kind=\""<>decontextify[#]<>"\""]
]&/@disallowedKinds;
,
unitOptions={};
kinds={ToString[id]/.specTable3/.{ToString[id]-> "Indeterminate"}};
exponents={"1"};  scales={"0"}; multipliers={"1"};  offsets={"0"}; 
unitspecs = Transpose[{kinds,exponents,scales, multipliers, offsets}];

Print["Error: "//boldRed, "empty "//boldBlack, "<listOfUnits>"//boldBlue," in unitDefinition:\n"//boldBlack,
Sequence@@XMLHighlightForm[z, Purple, "listOfUnits"]
];

];
debugPrint[dbg, "\!\(\*
StyleBox[\"getLevel2UnitDefinition\",\nFontColor->RGBColor[0, 0, 1]]\): unitspecs ",unitspecs];
debugPrint[dbg, "\!\(\*
StyleBox[\"getLevel2UnitDefinition\",\nFontColor->RGBColor[0, 0, 1]]\): unitOptions ",unitOptions];
debugPrint[dbg, "\!\(\*
StyleBox[\"getLevel2UnitDefinition\",\nFontColor->RGBColor[0, 0, 1]]\): kinds ",kinds];

unitdefinition=Apply[Times,Map[unitdef,unitspecs]]//InputForm//ToString;
debugPrint[dbg, "\!\(\*
StyleBox[\"getLevel2UnitDefinition\",\nFontColor->RGBColor[0, 0, 1]]\): unitdefinition ",unitdefinition];

,
unitdefinition="Indeterminate";
Print["Error: "//boldRed, "getLevel2UnitDefinition: no "//boldBlack, "listOfUnits"//boldBlue, " in unit definition:\n"//boldBlack,
Sequence@@XMLHighlightForm[z, Purple, "unitDefinition"]
]; 
];
(* check for nesting  2.4.18; l2v2 nesting removed in 2.5.26 *)
kinds=decontextify/@kinds;
debugPrint[dbg, "\!\(\*
StyleBox[\"getLevel2UnitDefinition\",\nFontColor->RGBColor[0, 0, 1]]\): kinds ",kinds];


Map[If[MemberQ[unitsDefinedInThisModel,#],
Print["Error: "//boldRed," getLevel2Units: Nested unit definitions are not permitted:\n"//boldBlack,
Sequence@@XMLHighlightForm[z, Purple, "kind=\""<>#<>"\""]
];
]&,kinds];


unitsDefinedInThisModel=Append[unitsDefinedInThisModel,rawid];
debugPrint[dbg, "getLevel2UnitDefinition: unitsDefinedInThisModel ",unitsDefinedInThisModel];

checkBuiltInRedef[id_, allowed_, formula_]:= Module[{math,allowable,did,ok},
did=unitsDecontextify[id];
math=unitsDecontextify[formula];
math=ToExpression[math];
allowable=ToExpression/@allowed;
ok=math/allowable;
ok=NumberQ/@ok;
ok=Or@@ok;
If[!ok,
Print["Error: "//boldRed, "getLevel2UnitDefinition: Invalid redefinition of built-in unit "//boldBlack, did//boldBlue, " as "//boldBlack,
math//boldBlue,
"\nAny redefinition of "//boldBlack, did//boldBlue, " must be a rescaling of "//boldBlack, allowed//boldBlue]
];
]; (* end checkBuiltInRedef *)

If[MemberQ[builtInQuantities, id],
checkBuiltInRedef[id, decontextify[id]/.allowedScaling, unitdefinition];
];

Return[{id, meta, name,unitdefinition}];
]; (* end getSBMLUnitDefinition *)



$SBML$UnitsDefined =allowedKinds;

u = Cases[$SBML$Model,XMLElement["listOfUnitDefinitions",___],3]; 

debugPrint[dbg, "getLevel2units: u(1): ",u];
u= Cases[u,XMLElement["unitDefinition",___],3]; 
debugPrint[dbg, "getLevel2units: u(2): ",u];

If[MB$Load, addUnit/@u];
debugPrint[dbg, "getLevel2units: returned from addUnit/@u "];

debugPrint[dbg, "getLevel2units: calling  \!\(\*
StyleBox[\"getLevel2UnitDefinition\",\nFontColor->RGBColor[0, 0, 1]]\) "];

unitDefinitions=Map[getLevel2UnitDefinition,u];



debugPrint[dbg, "getLevel2units: unitDefinitions ",unitDefinitions];


If[Length[unitDefinitions]>0, {ids,metas, names, defs} = Transpose[unitDefinitions];
$SBML$UnitsDefined = Join[$SBML$UnitsDefined, ids]//Union;

$SBML$UnitRules=MapThread[#1->#2&,{Map[ToExpression,ids],
Map[ToExpression,defs]}];

(* remove indeterminate rules *) 

$SBML$UnitRules = Select[$SBML$UnitRules,ToString[InputForm[Last[#]]]!= "Indeterminate"&]; 

defaultUnitsNeeded = Complement[builtInQuantities,ids];
defaultUnitRules=Map[ToExpression[#]->ToExpression[ (#/.specTable3)]&,defaultUnitsNeeded];
debugPrint[dbg,"getSBMLUnits: defaultUnitRules ",defaultUnitRules];
$SBML$UnitRules=Join[$SBML$UnitRules, defaultUnitRules];

,
(* corrected 2.3.35 to return to expressions *) 
$SBML$UnitRules= Map[Rule[ToExpression[First[#]],ToExpression[Last[#]]]&,specTable3];
];

$SBML$UnitsDefined=Join[$SBML$UnitsDefined,builtInQuantities]//Union;

builtInQuantities=ToExpression/@builtInQuantities;
builtInDefs = builtInQuantities//.$SBML$UnitRules;


If[dbg,
debugPrint[True, "getSBMLunits: $SBML$UnitRules ",$SBML$UnitRules];
debugPrint[True, "getSBMLunits: $SBML$UnitsDefined ",$SBML$UnitsDefined];
debugPrint[True, "getSBMLunits: ids ",ids];
debugPrint[True, "getSBMLunits: defs ",defs];
debugPrint[True, "getSBMLunits: builtInQuantities ",builtInQuantities];
debugPrint[True, "getSBMLunits: builtInDefs ",builtInDefs];
debugPrint[True, "getSBMLunits: $SBML$verboseBuiltInUnits ",$SBML$verboseBuiltInUnits];
]; 



If[saveVerboseData,

comment=" (Excluding Built-in Units)";
If[$SBML$verboseBuiltInUnits, 
ids = Join[ids, stringer/@builtInQuantities];
names  = Join[names, unitsDecontextify[stringer/@builtInQuantities]];
defs = Join[defs, stringer/@builtInDefs];
metas = Join[metas,Table["", {Length[builtInDefs]}]];


comment=" (Including Built-in Units)";
debugPrint[dbg, "getSBMLunits: ids ",ids];
debugPrint[dbg, "getSBMLunits: defs ",defs]; 
];

If[!$SBML$verboseContext,
ids =decontextify[ids];
defs = unitsDecontextify[defs];
]; 

verboseSave["Unit Definitions"<>comment,{"ID", "MetaID","Name", "Formula"}, Transpose[{ids,metas,  names,defs}]
];
];


Return[];
];


getLevel2compartmentTypes[]:= Module[{dbg=False,st,ids,metas, names}, 
st= Cases[$SBML$Model,XMLElement["listOfCompartmentTypes",___],3]; 

If[ToExpression[$SBML$Level$Version]<2.15,
If[Length[st]>0,
Print["Error: "//boldRed," listOfCompartmentTypes "//boldBlue, "is not supported in SBML Level "//boldBlack, $SBML$Level$Version//boldBlack];
];
Return[];
];

debugPrint[dbg,"getLevel2compartmentTypes: st(1)", st]; 
st= Cases[st,XMLElement["compartmentType",___],3]; 

debugPrint[dbg,"getLevel2compartmentTypes: st(2)", st]; 
If[MB$Load, addCompartmentType/@st];

st = Map[extractXMLOptions,st];
debugPrint[dbg,"getLevel2compartmentTypes: st(3)", st]; 

ids =makeIntoValidSId/@( Map["id"/.#/.{"id"-> ""}&, st]);
(* addID[#, "compartmentType"]&/@ids; *)

names = Map["name"/.#/.{"name"-> ""}&,st];
metas = Map["metaid"/.#/.{"metaid"-> ""}&,st];

debugPrint[dbg,"getLevel2compartmentTypes: {ids,names}:", {ids,names}]; 


ids=contextify[ids];
$SBML$CompartmentTypes=ToExpression/@ids;
checkForSymbolCollision[#,"compartmentType"]&/@ids;

MapThread[saveNameIDAssociation,{names,ids}];

If[saveVerboseData,
If[!$SBML$verboseContext,ids = decontextify[ids];];
verboseSave["CompartmentTypes",{"ID","MetaID", "Name"},Transpose[{ids,metas, names}]
]; 
]; 

];


getLevel2compartments[opt___?OptionQ]:= Module[{
c,dbg=False,ids,cids, vids, names,spatialDimensions, sizes, units,outsides, constants,ctypes,vctypes,
derivedunits,fixid, fixspatialDimensions, fixUnits, checkConstant, spatialUnits,conversionFactors, normalizedSizes,vdata,vhead, metas
},

debugPrint[dbg,"getLevel2compartments: $SBML$Model", $SBML$Model]; 
c = Cases[$SBML$Model,XMLElement["listOfCompartments",___],3]; 
debugPrint[dbg,"getLevel2compartments: c(1)", c]; 

c= Cases[c,XMLElement["compartment",___],3]; 
debugPrint[dbg,"getLevel2compartments: c(2)", c]; 

If[MB$Load, addCompartment/@c];

If[Length[c]<1  , 
ids = {""}; names = {""}; spatialDimensions={"3"} ; 
sizes={"1"}; units = {unitsContextify["volume"]};
outsides={ ""};
constants={"true"};  $SBML$NCompartments =1; 

(* this is the else clause, i.e, Length[c]>= 1 *) 
,
$SBML$NCompartments=Length[c]; 

c = Map[extractXMLOptions, c];
debugPrint[dbg,"getLevel2compartments: c(3)", c]; 

(* get information *) 

ids = Map["id"/.#/.{"id"-> ""}&, c];
vids = Map[makeIntoValidSId, ids]; 
ids = vids;

metas = Map["metaid"/.#/.{"metaid"-> ""}&, c]; 

(* addID[#, "compartment"]&/@ids; *)

checkForSymbolCollision[contextify[#],"compartment"]&/@ids;

names = Map["name"/.#/.{"name"-> ""}&,c];
spatialDimensions=Map["spatialDimensions"/.#/.{"spatialDimensions"-> "3"}&,c];
sizes = Map["size"/.#/.{"size"-> "Indeterminate"}&, c]; 
units = Map["units"/.#/.{"units"-> "Indeterminate"}&,c];
units=unitsContextify[units];

outsides = Map["outside"/.#/.{"outside"-> ""}&,c];
constants = Map["constant"/.#/.{"constant"-> "true"}&, c]; 

If[ToExpression[$SBML$Level$Version]>2.15,

ctypes=Map["compartmentType"/.#/.{"compartmentType"-> "Indeterminate"}&,c];
ctypes=Map[makeIntoValidSId,ctypes];
vctypes=contextify/@ctypes;

ctypes={contextify/@ids,vctypes}//Transpose;
ctypes=Select[ctypes, (Last[#]!= "Indeterminate")&]//ToExpression;
$SBML$CompartmentTypeAssociations=Rule@@#&/@ctypes;
Map[
If[!MemberQ[$SBML$CompartmentTypes,Last[#]],Print["Error: "//boldRed,"Compartment "//boldBlack,decontextify[First[#]]//boldBlue, " is defined as an unknown compartmentType: "//boldBlack, decontextify[Last[#]]//boldBlue]]&,
ctypes
];
];
]; 

debugPrint[dbg,"getLevel2compartments:{ids,names,spatialDimensions,sizes,units,outsides,constants}(1)",{ids,names,spatialDimensions,sizes,units,outsides,constants}]; 

(* check ids *) 

fixid[id_?StringQ, name_?StringQ, num_?IntegerQ]:= Module[{},
If[id!= "", Return[id]]; 
If[name!= "",Return[makeIntoValidSId[name]]]; 
Return["Compartment"<>ToString[num]];
]; (* end of fixid *) 

ids = MapThread[fixid, {ids, names, Range[$SBML$NCompartments]}]; 
ids = contextify[ids];
(* defineParameter[ids]; *)

debugPrint[dbg,"getLevel2compartments:{ids,names,spatialDimensions,sizes,units,outsides,constants}(2)",{ids,names,spatialDimensions,sizes,units,outsides,constants}]; 

(* save name-id associations where appropriate *) 

MapThread[saveNameIDAssociation, {names, ids}]; 

(* check spatialDimentions *) 

fixspatialDimensions[d_, id_]:= Module[{},
If[MemberQ[CharacterRange["0","3"], d], Return[d]]; 
If[d!= "" \[And] $SBML$warnings,Print["Warning: "//boldOrange,
 "Invalid spatialDimensions of "//boldBlack,
ToString[d]//boldRed," for compartment "//boldBlack,id//boldRed, " set to 3."//boldBlack]
]; 
Return["3"]; 
]; (* end fixspatialDimensions *) 
spatialDimensions = MapThread[fixspatialDimensions,{spatialDimensions,ids}]; 

debugPrint[dbg,"getLevel2compartments:{ids,names,spatialDimensions,sizes,units,outsides,constants}(3)",{ids,names,spatialDimensions,sizes,units,outsides,constants}]; 

(* check sizes *)
 
sizes = stringulate[fromEForm/@sizes];

debugPrint[dbg,"getLevel2compartments:{ids,names,spatialDimensions,sizes,units,outsides,constants}(4)",{ids,names,spatialDimensions,sizes,units,outsides,constants}]; 

(* check units *) 

fixUnits[unit_, compartment_, spatialDimensions_]:= Module[{fixed,derived,allowed,ok,dbg=False, whichallowed, conversionFactor},
allowed=unitsContextify[Switch[spatialDimensions,
"0","dimensionless",
"1", "length",
"2", "area",
"3", "volume"
]]; 

debugPrint[dbg,"getLevel2compartments: fixUnits:{unit,compartment}", {unit , compartment}];
debugPrint[dbg,"getLevel2compartments: allowed", allowed];

If[unit== "Indeterminate", 
allowed = ToExpression[allowed];
derived =allowed//.$SBML$UnitRules;
whichallowed=derived;
conversionFactor=1;
 debugPrint[dbg,"getLevel2compartments: fixUnits: Indeterminate:  {allowed, derived}: ",{allowed,derived}];
 debugPrint[dbg,"getLevel2compartments: fixUnits: Returning: {allowed,derived,whichallowed, conversionFactor}: ",{allowed,derived,whichallowed, conversionFactor}];

Return[{allowed,derived,whichallowed, conversionFactor}]
]; 
If[!MemberQ[$SBML$UnitsDefined,unit] \[And] $SBML$warnings, 
Print["Warning: "//boldOrange,
"Invalid units="//boldBlack,unit//boldRed," in compartment id="//boldBlack,compartment//boldRed," The 'units' field must refer to a previously defined unitDefinition 'id' attribute value."//boldBlack]; 
]; 
fixed = unit/.unitsContextify[{"meter"-> "metre", "liter"-> "litre"}]; 
printWarning[fixed!= unit, "Units '"<>decontextify[unit]<>"' specified for compartment '"<>compartment<>"' assumed to be '"<>decontextify[fixed]<>"'."
];

debugPrint[dbg,"getLevel2compartments: fixUnits: fixed",fixed];
debugPrint[dbg,"getLevel2compartments: fixUnits: $SBML$UnitRules", $SBML$UnitRules];
derived = ToExpression[fixed]//.$SBML$UnitRules;
debugPrint[dbg,"getLevel2compartments: fixUnits: derived",derived];
allowed=unitsContextify[Switch[spatialDimensions,
"0",{"dimensionless"},
"1", {"length", "metre"},
"2", {"area", "metre^2"},
"3", {"volume","metre^3", "litre"}
]]; 
allowed =ToExpression[ allowed]//.$SBML$UnitRules;
debugPrint[dbg,"getLevel2compartments: fixUnits: allowed", allowed];

ok = Map[{derived,#}&, allowed];
ok = Map[#[[1]]/#[[2]]&, ok];
ok = Map[NumberQ, ok];
whichallowed=Position[ok,True]; 
ok = Apply[Or, ok]; 
 debugPrint[dbg,"getLevel2compartments: fixUnits: ok: ",ok];
 
If[(!ok) \[And] $SBML$warnings, Print["Warning: "//boldRed,
"Specified units="//boldBlack,fixed//boldBlue," for compartment "//boldBlack,compartment//boldBlue," do not appear to be valid units for a compartment of spatialDimensions="//boldBlack,spatialDimensions//boldBlue," Valid units are any units derived from one of the following: "//boldBlack,list2CommaSeparatedString[Map[InputForm,allowed]//Union]//boldBlue,"-- the only units that can be derived from "//boldBlack,fixed//boldBlue," are "//boldBlack,ToString[derived]//boldBlue
]]; 
debugPrint[dbg,"getLevel2compartments: fixUnits: return value: ",{fixed,derived}];

While[ListQ[whichallowed]\[And]Length[whichallowed]>0, 
whichallowed=First[whichallowed]];
If[NumberQ[whichallowed],
whichallowed=allowed[[whichallowed]];
conversionFactor=derived/whichallowed;
,
whichallowed=Indeterminate;
conversionFactor=Indeterminate;
];

If[dbg,
Print["getLevel2compartments:fixUnits: compartment:",compartment];
Print["getLevel2compartments:fixUnits: allowed:",allowed];
Print["getLevel2compartments:fixUnits: whichallowed:",whichallowed];Print["getLevel2compartments:fixUnits: derived:",derived];Print["getLevel2compartments:fixUnits: conversionFactor:",conversionFactor];
];

Return[{fixed,derived,whichallowed, conversionFactor}]; 
]; (* end of fixUnits *) 

units = MapThread[fixUnits,{units, ids, spatialDimensions}];
{units,derivedunits,spatialUnits,conversionFactors}=Transpose[units];
normalizedSizes=(ToExpression/@sizes)*conversionFactors;


debugPrint[dbg, "getLevel2compartments: {units,derivedunits,spatialUnits,conversionFactors,normalizedSizes}",{units,derivedunits,spatialUnits,conversionFactors,normalizedSizes}];

$SBML$UnitAssociations=Join[$SBML$UnitAssociations,MapThread[Rule[ToExpression[#1], #2]&, {ids,derivedunits}]];


debugPrint[dbg,"getLevel2compartments:{ids,names,spatialDimensions,sizes,units,outsides,constants}(5)",{ids,names,spatialDimensions,sizes,units,outsides,constants}]; 

(* check constants *) 
constants = Map[If[ToUpperCase[#]=="FALSE",False,True]&,constants]; 

MapThread[definef[SBMLIC,#1,#2]&,{ids,sizes}];
MapThread[definef[SBMLIC\[UnderBracket]SI, ToExpression[#1], #2]&, {ids, normalizedSizes}]; 
cids = ToExpression/@MapThread[If[#1, #2,functionate[ #2]]&,{constants, ids}]; 
MapThread[definef[SBMLCompartmentSize,#1, #2]&, {ToExpression/@ids,(conversionFactors*cids)}]; 

checkConstant[id_, constant_]:= Module[{},
SBMLConstantQ[id]=constant;
If[constant, 
defineParameter[id]; 
addReplacementRule[id]; 
, 
defineVariable[id];
];
]; (* end of checkConstant*) 

MapThread[checkConstant, {ids,constants}];

(* check outsides *) 
outsides = Map[makeIntoValidSId, outsides]; 
outsides = Map[If[#== "", #,contextify[#]]&, outsides];
MapThread[printWarning[(#1!= "")\[And](!MemberQ[ids, #1]),
"Outside compartment \""<>#1<>"\" indicated for compartment \""<>#2<>"\ is not a known compartment."]&,  {outsides, ids}];


$SBML$CompartmentNames=names;

$SBML$Compartmentids=ids; 
$SBML$CompartmentSizes=MapThread[Symbol[#1]-> ToExpression[#2]&,{ids,sizes}]; 
$SBML$CompartmentUnits=MapThread[#1-> #2&, {ids, units}]; 
$SBML$CompartmentOutsides=outsides;
$SBML$CompartmentSpatialDimensions=MapThread[#1-> #2&, {ids,spatialDimensions}];

If[saveVerboseData,

If[!$SBML$verboseContext,
ids = decontextify[ids];
outsides = decontextify[outsides];
units = unitsDecontextify[units];
derivedunits=unitsDecontextify[derivedunits];
derivedunits = ToString/@(InputForm/@derivedunits); 
spatialUnits=stringer/@unitsDecontextify[spatialUnits];
If[ToExpression[$SBML$Level$Version]>2.15,vctypes=decontextify[vctypes]];

];

vhead={"ID","MetaID", "Name"};
If[ToExpression[$SBML$Level$Version]>2.15,AppendTo[vhead,"CompartmentType"]];
vhead=Join[vhead,
{"Dimension","Size","Units","Derived Units", "Outside","Constant"}];
 vdata={ids,metas, names};
If[ToExpression[$SBML$Level$Version]>2.15,AppendTo[vdata,vctypes]];
vdata=Join[vdata,{spatialDimensions,sizes, units,derivedunits,outsides,constants}];

If[$SBML$verboseNormalizedValues,
vhead=Join[vhead,
{"Normalized","Normalized Units"}];
vdata=Join[vdata,{normalizedSizes,spatialUnits}];
]; 
verboseSave["Compartments",vhead,Transpose[vdata]];
]; 

Return[];
];


getLevel2speciesTypes[]:= Module[{dbg=False,st,ids,metas, names}, 
st= Cases[$SBML$Model,XMLElement["listOfSpeciesTypes",___],3]; 

If[ToExpression[$SBML$Level$Version]<2.2,
If[Length[st]>0,
Print["Error: "//boldRed," listOfSpeciesTypes "//boldBlue, "is not supported in SBML Level "//boldBlack, $SBML$Level$Version//boldBlack];
];
Return[];
];

debugPrint[dbg,"getLevel2speciesTypes: st(1)", st]; 
st= Cases[st,XMLElement["speciesType",___],3]; 

debugPrint[dbg,"getLevel2speciesTypes: st(2)", st]; 
If[MB$Load, addSpeciesType/@st];

st = Map[extractXMLOptions,st];
debugPrint[dbg,"getLevel2speciesTypes: st(3)", st]; 

ids =makeIntoValidSId/@( Map["id"/.#/.{"id"-> ""}&, st]);

checkForSymbolCollision[contextify[#],"speciesType"]&/@ids;


names = Map["name"/.#/.{"name"-> ""}&,st];
debugPrint[dbg,"getLevel2speciesTypes: {ids,names}:", {ids,names}]; 

metas = Map["metaid"/.#/.{"metaid"-> ""}&,st];
metas = stringer/@metas;

ids=contextify[ids];

$SBML$SpeciesTypes=ToExpression/@ids;


MapThread[saveNameIDAssociation,{names,ids}];

If[saveVerboseData,
If[!$SBML$verboseContext,ids = decontextify[ids];];
verboseSave["SpeciesTypes",{"ID","MetaID","Name"},Transpose[{ids,metas, names}]
]; 
]; 

];


setCrossProduct[l1_, l2_]:=Module[{f},
f[x_]:= Map[{x,#}&, l2];
Return[Partition[Map[f,l1]//Flatten,2]];
];


getIDandName[opt_, def_]:= Module[{id, vid,name},
id = "id"/.opt/.{"id"-> def};
vid=makeIntoValidSId[id];
id = vid;
id = contextify[id];
defineVariable[id]; 
name ="name"/.opt/.{"name"-> ""};
saveNameIDAssociation[ name,id]; 
Return[{id,name}];
];


getLevel2species[opt___]:= Module[{dbg=False,s, getSpecies,n},


$SBML$SpeciesCompartmentAssociations={};

getSpecies[s_]:= Module[{sp,id,name,compartment,initialAmount,initialConcentration,units,boundaryCondition,charge,constant,isConcentration, isAmount,type,ok, allowedUnitNumerators, allowedUnitDenominators,sd, possibleUnits,ic, tfvalue,substanceConversion,compartmentDerivedUnits,speciesBaseUnits,speciesType,
derivedSubstanceUnits,derivedSpatialSizeUnits,check,vol,normalizedInitialAmount,
substanceUnits, spatialSizeUnits, defSpatialSizeUnits,dim,hasOnlySubstanceUnits, initialSubstanceAmount,fixCubicMetres, conversionFactor,idoft,newrule,comp, returnValue, headers, t0, cpu, t1, CPU,dbg=False,  debug=False},

t0=TimeUsed[];
If[dbg, Print["------> getSpecies:",TimeUsed[]-t0]];

debugPrint[debug, "getSpecies: s ",s]; 

fixCubicMetres[u_]:= Module[{str, s1, s2},
str=ToString[InputForm[u]];
s1 = StringPosition[str, "metre"]//Length;
s2=StringPosition[str, "litre"]//Length;
If[s1>0 \[And] s2>0,Return[(u/.{
Rule[
unitsContextify["litre"]//ToExpression, (unitsContextify["metre"]//ToExpression)^3
]})]];
Return[u];
]; (* end of fixCubicMetres *) 

tfvalue["true"]:= True;
tfvalue["false"]:= False;
tfvalue[___]:= False;

sp = extractXMLOptions[s];
If[dbg, Print["getLevel2Species: getSpecies:XML options extracted:",TimeUsed[]-t0]]; 

debugPrint[debug, "getSpecies: sp ",sp]; 


n++; 

(* getID&Name also has defineVarible in it *)
{id,name} = getIDandName[sp, "species"<>ToString[n]]; 
If[dbg, Print["getLevel2Species: getSpecies:id:", id,":",TimeUsed[]-t0]]; 
checkForSymbolCollision[id,"species"];
If[dbg, Print["getLevel2Species: getSpecies:checked for symbol collision: ",TimeUsed[]-t0]]; 


(* addID[id, "species"]; *)
If[dbg, Print["getLevel2Species: getSpecies:id added:",TimeUsed[]-t0]]; 

$SBML$Species$IDs=Append[$SBML$Species$IDs,ToExpression[id]];

(* replace option checking with getSBMLfield to allow things like "compartment"-> "compartment" etc. 5/17/04
*) 
speciesType=getSBMLfield["speciesType",s];
If[StringLength[speciesType]>0, 

speciesType=makeIntoValidSId[speciesType]; 
speciesType=contextify[speciesType]; $SBML$SpeciesTypeAssociations=Append[
$SBML$SpeciesTypeAssociations,
Rule[ToExpression[id],ToExpression[speciesType]]]; 

If[!MemberQ[$SBML$SpeciesTypes,ToExpression[speciesType]],
Print["Warning: "//boldOrange, "Species "//boldBlack,decontextify[id]//boldBlue, " is defined as an unknown speciesType "//boldBlack,decontextify[speciesType]//boldBlue];
];
];

compartment=contextify[getSBMLfield["compartment",s]];

If[decontextify[compartment]=="",
printWarning["Species \""<>id<>"\" is ="],
If[!MemberQ[$SBML$Compartmentids,compartment], 

Block[{dc}, 
dc=decontextify[compartment]; 
dc=quote[dc];

Print["Error: "//boldRed, "unknown compartment "//boldBlack,decontextify[compartment]//boldBlue," specified for species "//boldBlack, decontextify[id]//boldBlue,"\n",
Sequence@@XMLHighlightForm[s, Purple, "compartment="<>dc]
];
]; 

];



];
dim = compartment/.$SBML$CompartmentSpatialDimensions/.{compartment-> "Indeterminate"};

If[dim == "Indeterminate",
Print["Warning: "//boldRed, " Unable to determine spatial dimensions of compartment "//boldBlack, decontextify[compartment]//boldBlue ]
];

debugPrint[debug, "getSpecies: dim", dim]; 

If[SBMLConstantQ[compartment],
$SBML$SpeciesCompartmentAssociations=Append[$SBML$SpeciesCompartmentAssociations, id-> compartment];
SBMLSpeciesCompartment[functionate[id]//ToExpression]=compartment//ToExpression;

,
$SBML$SpeciesCompartmentAssociations=Append[$SBML$SpeciesCompartmentAssociations, id-> functionate[compartment]];
SBMLSpeciesCompartment[functionate[id]//ToExpression]=functionate[compartment]//ToExpression;

];

type = ""; 
initialAmount="initialAmount"/.sp/.{"initialAmount"->""};
isAmount=(initialAmount!= "");
If[isAmount,
type="initialAmount";
initialAmount = initialAmount//fromEForm//InputForm//ToString;
ic = initialAmount;
];

initialConcentration="initialConcentration"/.sp/.{"initialConcentration"->  ""};
isConcentration = (initialConcentration !="");
If[isConcentration, 
type="initialConcentration";
initialConcentration=initialConcentration//fromEForm//InputForm//ToString;
ic = initialConcentration;
];

If[((id/.$SBML$CompartmentSpatialDimensions) == "0")  \[And] isConcentration,
printWarning["Field \"initialConcentration\" setting for compartment \""<>id<>"\" ignored because the compartment has a \"spatialDimensions\"=\"0\"."];
isConcentration=False;
initialConcentration="";
type="initialAmount";
If[isAmount, ic=initialAmount, ic=$SBML$IndeterminateValue ];
]; 

If[isAmount \[And] isConcentration ,
isAmount=False; 
initialAmount= "";
type="initialConcentration";
ic = initialConcentration; 
printWarning[
"Fields \"initialAmount\" and \"initialConcentration\" are both set for species \""<>id<>"\". These fields are mutually exclusive.  \"initialAmount\" will be ignored."]; 
];

If[!(isAmount \[Or] isConcentration), 
ic = $SBML$IndeterminateValue; 
type="Indeterminate"
];

substanceUnits="substanceUnits"/.sp/.{"substanceUnits"-> "substance"};
substanceUnits=unitsContextify[substanceUnits];
derivedSubstanceUnits=ToExpression[substanceUnits]//.$SBML$UnitRules;
debugPrint[debug, "getlevel2Species: getSpecies: substanceUnits:", substanceUnits];
debugPrint[debug, "getlevel2Species: getSpecies: derivedSubstanceUnits:", derivedSubstanceUnits];
debugPrint[debug, "getlevel2Species: getSpecies: $SBML$UnitRules:", $SBML$UnitRules];

check = (derivedSubstanceUnits/(ToExpression[unitsContextify["substance"]]))//.$SBML$UnitRules;


If[debug, Print["\!\(\*
StyleBox[\"getSpecies\",\nFontColor->RGBColor[0, 0, 1]]\): check="//boldRed,check]];

If[!NumberQ[check],
(* add additional calculations 2.666 because earlier check only checks one of the
ultimate units, not all the possibilities *)
If[dbg, 
Print["$ScalableUnits$Substance:", $ScalableUnits$Substance]; 
Print["derivedSubstanceUnits:", derivedSubstanceUnits]; 
]; 

derivedSubstanceUnits=decontextify[derivedSubstanceUnits]/(ToExpression/@$ScalableUnits$Substance); 
check =Or@@( NumberQ/@derivedSubstanceUnits); 
If[dbg, 
Print["derivedSubstanceUnits:", derivedSubstanceUnits]; 
Print["check=",check]; 
]; 

If[!check, Print["Warning: "//boldRed,"species id="//boldBlack, id//boldBlue," substanceUnits = "//boldBlack,decontextify[substanceUnits]//boldBlue," derived units = "//boldBlack, derivedSubstanceUnits//boldBlue, " do not appear to simplify to units of substance."//boldBlack];
]; 

];

If[$SBML$warnings \[And] !MemberQ[$SBML$UnitsDefined, substanceUnits],
Print["Warning: "//boldRed,
"Unknown substanceUnits = "//boldBlack,decontextify[substanceUnits]//boldRed,
" specified for species "//boldBlack,id//boldRed, "\nKnown units are "//boldBlack,(decontextify/@$SBML$UnitsDefined)//boldBlack];
];


hasOnlySubstanceUnits="hasOnlySubstanceUnits"/.sp/.{"hasOnlySubstanceUnits"-> "false"};
If[!MemberQ[{"true","false"}, hasOnlySubstanceUnits], hasOnlySubstanceUnits="false"]; 

hasOnlySubstanceUnitsIndicator[ToExpression[functionate[id]]]=tfvalue[hasOnlySubstanceUnits];

spatialSizeUnits="spatialSizeUnits"/.sp/.{"spatialSizeUnits"-> "1"};
If[dbg, Print["getLevel2species: spatialSizeUnits(0):",spatialSizeUnits, ":",TimeUsed[]-t0]];
debugPrint[debug, "getSpecies: spatialSizeUnits(0): ", spatialSizeUnits];
debugPrint[debug, "getSpecies: hasOnlySubstanceUnits: ", hasOnlySubstanceUnits];

If[tfvalue[hasOnlySubstanceUnits],
debugPrint[debug, "getSpecies: spatialSizeUnits(1): ", spatialSizeUnits];

If[spatialSizeUnits!= "1",
debugPrint[debug, "getSpecies: spatialSizeUnits(2): ", spatialSizeUnits];

(* spatialSizeUnits should not be specified but were *)
Print["Warning: "//boldOrange, " spatialSizeUnits = "//boldRed,spatialSizeUnits//boldRed," may not be specified for species "//boldBlack, id//boldRed," because hasOnlySubstanceUnits = false."//boldBlack];
spatialSizeUnits="1";
];
 ,

debugPrint[debug, "getSpecies: spatialSizeUnits(3): ", spatialSizeUnits];

If[spatialSizeUnits=="1",
(*spatialSizeUnits should have been given but were not *)
defSpatialSizeUnits=((compartment/.$SBML$CompartmentUnits/.{compartment-> "Indeterminate"})//decontextify)//stringer;
debugPrint[debug, "getSpecies: defSpatialSizeUnits(1): ", defSpatialSizeUnits];

If[defSpatialSizeUnits=="Indeterminate",
defSpatialSizeUnits=Switch[dim,
"0","dimensionless",
"1","length",
"2","area",
"3","volume",
_,"Indeterminate"
]; 
];
debugPrint[debug, "getSpecies: defSpatialSizeUnits(2): ", defSpatialSizeUnits];

spatialSizeUnits="spatialSizeUnits"/.sp/.{"spatialSizeUnits"-> defSpatialSizeUnits};
If[dbg, Print["compartment:",compartment," defSpatialSizeUnits:",defSpatialSizeUnits, " spatialSizeUnits:", spatialSizeUnits];];
debugPrint[debug, "getSpecies: spatialSizeUnits(4): ", spatialSizeUnits];

];

]; 
debugPrint[debug, "getSpecies: spatialSizeUnits(5): ", spatialSizeUnits];


If[dbg, Print["getLevel2species: spatialSizeUnits(1):",spatialSizeUnits, ":",TimeUsed[]-t0]];

If[spatialSizeUnits=="1",
spatialSizeUnits="Indeterminate";
units=substanceUnits;
,
spatialSizeUnits=unitsContextify[spatialSizeUnits];
units="("<>substanceUnits<>")/("<>spatialSizeUnits<>")";
]; 
If[dbg, Print["getSpecies: units (1) :(", id,"),", units, ":",TimeUsed[]-t0]]; 

If[spatialSizeUnits!= "Indeterminate",
If[dbg,Print["getLevel2species: spatialSizeUnits,$SBML$UnitsDefined:",spatialSizeUnits,$SBML$UnitsDefined, ":",TimeUsed[]-t0]];

If[$SBML$warnings \[And] !MemberQ[$SBML$UnitsDefined, spatialSizeUnits],
Print["Error: "//boldRed,
"Unknown spatialSizeUnits = "//boldBlack,decontextify[spatialSizeUnits]//boldBlue,
" specified for species "//boldBlack,decontextify[id]//boldBlue, 
Sequence@@XMLHighlightForm[s, Purple, "spatialSizeUnits="<>quote[decontextify[spatialSizeUnits]]]];
];


derivedSpatialSizeUnits=ToExpression[spatialSizeUnits]//.$SBML$UnitRules;

check = Switch[dim,
"0",unitsContextify["dimensionless"],
"1",unitsContextify["length"],
"2",unitsContextify["area"],
"3",unitsContextify["volume"],
_,"Indeterminate"
]//ToExpression;

vol = check//.$SBML$UnitRules;

check = (derivedSpatialSizeUnits/check)//.$SBML$UnitRules; 
If[dbg,Print["check:",check, ":",TimeUsed[]-t0]];


check = fixCubicMetres[check];
If[dbg, Print["getLevel2species: check=",check, ":",TimeUsed[]-t0]];

If[!NumberQ[check],
Print["Waring: "//boldRed,"spatialSizeUnits = "//boldBlack,spatialSizeUnits//decontextify//boldBlue," for species = "//boldBlack, decontextify[id]//boldBlue, " may be incorrect for compartment "//boldBlack,
decontextify[compartment]//boldBlue, 
" which has spatialDimensions = "//boldBlack, dim//boldBlue ];
];
];

units=ToExpression[units];
If[dbg, Print["getSpecies: units (2) :(", id,"),", units, ":",TimeUsed[]-t0]]; 
derivedUnits = units//.$SBML$UnitRules ;
If[dbg, Print["getSpecies: derivedUnits(1) :(", id,"),", derivedUnits, ":",TimeUsed[]-t0]]; 
derivedUnits = fixCubicMetres[derivedUnits];

compartmentDerivedUnits=(ToExpression[compartment]/.$SBML$UnitAssociations)//.$SBML$UnitRules;

If[dbg, 
Print["getSpecies: derivedSubstanceUnits: (species=",id,"),",derivedSubstanceUnits, ":",TimeUsed[]-t0]; 
Print["getSpecies: derivedUnits (2) : (species=",id,"),",derivedUnits, ":",TimeUsed[]-t0]; 
Print["getSpecies: compartment: (species=",id,"),",compartment, ":",TimeUsed[]-t0]; 
Print["getSpecies: compartment volume: (species=",id,"),",ToExpression[compartment]/.SBMLReplacementRules, ":",TimeUsed[]-t0]; 
Print["getSpecies: compartment derived units: (species=",id,"),",compartmentDerivedUnits, ":",TimeUsed[]-t0]; 
]; 

substanceConversion=derivedSubstanceUnits/derivedUnits;


debugPrint[dbg,"ID: getSpecies: {id,name,compartment,type,ic,substanceUnits,spatialSizeUnits,units}", {id,name,compartment,type,ic,substanceUnits,spatialSizeUnits,units}]; 
definef[SBMLIC, id, ic ];


$SBML$UnitAssociations = Append[$SBML$UnitAssociations, ToExpression[id]-> derivedUnits];
debugPrintPrint[dbg,"getSpecies: $SBML$UnitAssociations:",$SBML$UnitAssociations]; 

speciesBaseUnits = ToExpression[unitsContextify["substance"]]//.$SBML$UnitRules;

If[!tfvalue[hasOnlySubstanceUnits],
speciesBaseUnits =speciesBaseUnits/vol;
];

conversionFactor=fixCubicMetres[derivedUnits/speciesBaseUnits];

If[$SBML$Normalize,
normalizedInitialAmount = ToExpression[ic]*derivedUnits/speciesBaseUnits; 
If[!tfvalue[hasOnlySubstanceUnits],
normalizedInitialAmount =normalizedInitialAmount/ToExpression[SBMLIC[compartment]];
];
normalizedInitialAmount = fixCubicMetres[normalizedInitialAmount]; 

If[dbg, Print["getSpecies: id=",id," normalizedInitialAmount=",normalizedInitialAmount, " speciesBaseUnits: ",speciesBaseUnits, ":",TimeUsed[]-t0] ]; 
 

If[NumberQ[normalizedInitialAmount],
ic = stringer[normalizedInitialAmount];
,
Print["Warning: getSpecies:"//boldOrange, "Unable to numerically normalize initial conditions for species "//boldBlack, id//boldRed," to "//boldBlack, speciesBaseUnits//boldRed, " derived initial amount = "//boldBlack, normalizedInitialAmount//boldRed];
]; 
,
normalizedInitialAmount=ic;
];

If[dbg,
Print["compartment:",compartment," sub:",tfvalue[hasOnlySubstanceUnits]," cf:", conversionFactor, ":",TimeUsed[]-t0];
];

idoft=functionate[id]//ToExpression;
comp = ToExpression[compartment]; 

If[tfvalue[hasOnlySubstanceUnits],
newrule=Rule[idoft,((idoft*conversionFactor)/SBMLCompartmentSize[comp])];
SBMLSpeciesToUnitsOfTheSpecies[idoft]=SBMLCompartmentSize[comp]/conversionFactor;
,
newrule=Rule[idoft, (idoft*conversionFactor*SBMLIC\[UnderBracket]SI[comp]/SBMLCompartmentSize[comp])]; 
SBMLSpeciesToUnitsOfTheSpecies[idoft]=1/conversionFactor;
];
SBMLSpeciesSIConcentration=Append[SBMLSpeciesSIConcentration,newrule]; 



boundaryCondition="boundaryCondition"/.sp/.{"boundaryCondition"-> "false"};
boundaryCondition=(ToUpperCase[boundaryCondition]=="TRUE");

SBMLBoundaryConditionQ[id]=boundaryCondition;

constant="constant"/.sp/.{"constant"-> "false"};
constant=(ToUpperCase[constant]=="TRUE");
SBMLConstantQ[id]=constant;

If[constant, 
defineParameter[id]; 
addReplacementRule[id]; 
(* save for later: want to add them back in as Species for SBMLNDSolve compatibility *) 
$SBML$ConstantSpecies=Append[$SBML$ConstantSpecies,id]; 
];

charge="charge"/.sp/.{"charge"-> ""};
If[charge!= "", 
printWarning[!IntegerQ[ToExpression[charge]], "Species \""<>id<>"\" charge=\""<>charge<>"\" is not an integer."];
];
If[isConcentration,
$SBML$SpeciesThatAreConcentrations=Append[$SBML$SpeciesThatAreConcentrations,id],
$SBML$SpeciesThatAreAmounts=Append[$SBML$SpeciesThatAreAmounts,id]];

cpu=TimeUsed[]-t0;
If[dbg, Print["getSpecies: ",id," cpu:",cpu]];

If[saveVerboseData, 
units = units//InputForm//ToString;
 derivedUnits=derivedUnits//InputForm//ToString; 
If[derivedUnits=="1", derivedUnits="dimensionless"];
If[!($SBML$verboseContext),
id = decontextify[id];
name = decontextify[name];
speciesType=decontextify[speciesType]; 
compartment = decontextify[compartment];
units = unitsDecontextify[units];
derivedUnits=unitsDecontextify[derivedUnits];
speciesBaseUnits=MathSBML`Private`unitsDecontextify[speciesBaseUnits]//InputForm//ToString;
];



returnValue={id,name};
If[ToExpression[$SBML$Level$Version]>2.1, returnValue=Append[returnValue,speciesType]]; 
returnValue=Join[returnValue,{compartment,
type, If[isConcentration,  initialConcentration, initialAmount],
units,derivedUnits, boundaryCondition,constant,charge, normalizedInitialAmount, speciesBaseUnits}];
Return[returnValue];

]; 
debugPrint[dbg,"getSpecies:: SBMLVariables(2)",SBMLVariables];

(* if verbose data is not being saved, no need to return anything!! *) 
Return[{}]; 

];(* end of getSpecies*) 

(* begin main source code for getLevel2species *) 

 n=0; 

s = Cases[$SBML$Model,XMLElement["listOfSpecies",___],3]; 
debugPrint[dbg,"getLevel2species:: s(1)",s];

s = Cases[s,XMLElement["species",___],3];
debugPrint[dbg,"getLevel2species:: s(2)",s];

If[MB$Load, addSpecies/@s ];

s = Map[getSpecies,s]; 
debugPrint[dbg,"getLevel2species:: s(3)",s];

SBMLBoundaryConditions=Pick[$SBML$Species$IDs,
SBMLBoundaryConditionQ[ToString[#]]&/@$SBML$Species$IDs];

If[saveVerboseData,
headers={ "ID", "Name"};
If[ToExpression[$SBML$Level$Version]>2.1, headers=Append[headers,"SpeciesType"];]; 

headers=Join[headers,{"Compartment", 
"initialType", "Value", "Units of the Species", "Derived Units of the Species", "B.C", "Constant", "Charge"}];

If[$SBML$verboseNormalizedValues,
headers=Join[headers,{"Normalized Initial Value", "Normalized Units"}];
verboseSave["Species",headers,s];,
s=Drop[#,-2]&/@s;
verboseSave["Species",headers,s];
];

]; 

If[dbg, Abort[]]; 

Return[];
];


getLevel2parameters[opt___]:= Module[
{dbg=False,p,getParameter,n, lv},

lv=ToExpression[$SBML$Level$Version]; 

getParameter[optList_]:= Module[{name, id, value,units, derivedUnits, metaid,sbo,info, constant},
n++; 
$SBML$NGlobalParameters++; 

{id,name} = getIDandName[optList, "parameter"<>ToString[n]]; 
checkForSymbolCollision[id,"parameter"];
(* addID[id, "parameter"]; *)
defineParameter[id]; 

metaid=stringer["metaid"/.optList/.{"metaid"-> ""}];
sbo=stringer["sboTerm"/.optList/.{"sboTerm"-> ""}];

value = ("value"/.optList/.{"value"-> $SBML$IndeterminateValue}); 
value = value//fromEForm;
value=If[StringQ[value], value,ToString[InputForm[value]]];

definef[SBMLIC,id, value]; 
addReplacementRule[id]; 

units = ("units"/.optList/.{"units"-> $SBML$IndeterminateValue});
units = unitsContextify[units];

$SBML$UnitAssociations = Append[$SBML$UnitAssociations, ToExpression[id]-> ToExpression[units]];

If[units!= $SBML$IndeterminateValue,
If[$SBML$warnings \[And] !MemberQ[$SBML$UnitsDefined, units],
Print["Error: "//boldRed, "Unknown units = "//boldBlack, decontextify[units]//boldBlue, " specified for global parameter "//boldBlack, decontextify[id]//boldBlue];
];
]; 

derivedUnits=ToExpression[units]//.$SBML$UnitRules;
derivedUnits=ToString[InputForm[derivedUnits]];

constant="constant"/.optList/.{"constant"-> "true"};
constant=(ToUpperCase[constant]=="TRUE");
SBMLConstantQ[id]=constant;

(* corrected 7-28-03: to reverse order of following two ifs, otherwise non-constant parameters are decontextified!! *) 

If[!constant,
defineVariable[id];
 removeReplacementRule[id];
];

If[constant,
SBMLGlobalParameters=Append[SBMLGlobalParameters,id],
SBMLGlobalParameters=Append[SBMLGlobalParameters,functionate[id]]
];

If[saveVerboseData,
If[!$SBML$verboseContext, id = decontextify[id];
units=unitsDecontextify[units];
derivedUnits=unitsDecontextify[derivedUnits];
];
]; 

If[lv>2.15, 
info={id,metaid,  sbo, name, value,units, derivedUnits, constant}, 
info={id,metaid,  name, value,units, derivedUnits, constant}
];

Return[info];
]; (* end of getParameter *)
 
$SBML$NGlobalParameters=0; 
n=0; 
p = Cases[$SBML$Model,XMLElement["listOfParameters",___],3]; 
p = Cases[p,XMLElement["parameter",___],3]; 

debugPrint[dbg,"getLevel2parameters","adding Parameters"]; 


If[MB$Load, addParameter/@p];

p = Map[extractXMLOptions,p]; 
debugPrint[dbg,"getLevel2parameters:: p(1)", p]; 

p = Map[getParameter,p]; 
debugPrint[dbg,"getLevel2parameters:: p(2)", p]; 

If[saveVerboseData,
If[lv>2.15,
verboseSave["Global Parameters", 
{"ID", "MetaID","SBOTerm",  "Name", "Value", "Units", "Derived Units", "Constant"}, p]; ,verboseSave["Global Parameters", 
{"ID", "MetaID", "Name", "Value", "Units", "Derived Units", "Constant"}, p]; 
];
]; 

Return[];
];



getLevel2InitialAssignments[opt___?OptionQ]:= Module[{c, info,getAnInitialAssignment},
getAnInitialAssignment[r_]:= Module[{math, sbo, meta, msg, symbol},




addInitialAssignment[r];

sbo=getSBMLfield["SBOTerm",r];
meta=getSBMLfield["metaid",r];
symbol=getSBMLfield["symbol",r];

subXML=extractXMLSubElements[r];

math=Cases[subXML, XMLElement["math",___],1];
math=First[math];

math=contextifyFormula[math];
math = StringReplace[math, "[t]"-> "[0]"];

(* math=XMLOut[math];
math=MathMLToInfix[math];
math = ToString[InputForm[math]]; 
*)
Return[{ToExpression[symbol], meta, sbo, ToExpression[math]}];

];(***** end getAnInitialAssignment *****)

$SBML$InitialAssignments={};
c = Cases[$SBML$Model,XMLElement["listOfInitialAssignments",___],3]; 

If[ToExpression[$SBML$Level$Version]<2.15,
If[Length[c]>0,
Print["Error: "//boldRed," listOfInitialAssignments "//boldBlue, "is not supported in SBML Level "//boldBlack, $SBML$Level$Version//boldBlack];
];
Return[];
];




c = Cases[c,XMLElement["initialAssignment",___],3]; 
info=getAnInitialAssignment/@c;

$SBML$InitialAssignments = Map[Rule[contextify[functionate[#[[1]],0]],#[[4]]]&, info];

verboseSave["Initial Assignments",{"Symbol","Metaid","SBOTerm","Formula"}, info];

]


checkMathMLElements[XMLElement["math",{opt___},formula_]]:= Module[{dbg=False,f,myXML},
myXML["ci",{z___},{id_}]:= Module[{r,v, vid},
If[id=="t", 
v = "Global`t";
,
vid = makeIntoValidSId[id,"`"]; (* don't change context delimiter, added 7/29/03 *) 
v=contextify[vid];
If[MemberQ[SBMLVariables,v],
(* v=functionate[v]; *)(* rev 2.6.2 for version 6 compatibility*)
(* this should work except that there is an ERROR in Mathematica version 6.0 *)
(*
v=XMLElement["apply",{}, {XMLElement["ci",{"type"-> "function"},{ stringer[v]}], XMLElement["ci",{},{"t"}]}];
*)
v=stringer[v]<>"$of$t$";

];
]; 
r=XMLElement["ci",{z},{v}];
Return[r];
]; 

myXML[{xmlns_, "ci"},{z___},{id_}]:= myXML["ci",{z},{id}];

(* "cn" stuff added 2.5.17 6/16/06 *)

myXML["cn",{"type"-> "real"},{x_?mantissaFormQ}]:=XMLElement["cn",{"type"-> "real"},{x}];

myXML["cn",{"type"-> "real"},{numstring_?eFormQ}]:= 
Module[{y,man,exp,instead},
{man,exp}=eForm2MantissaExponent[numstring];
instead=XMLElement["cn",{"type"-> "e-notation"},{man,XMLElement["sep",{},{}],exp}];
Print["Error: "//boldRed," exponential notation is not permitted in "//boldBlack,
XMLElement["cn",{"type"-> "real"},{numstring}]//XMLOut//boldBlue,
" Attempting recovery as "//boldBlack,
instead//XMLOut//boldBlue,
"\nNote:  This is not standard SBML. "//boldRed
];
instead=fixXMLeNotation[instead]; (* because of bug in Mathematica conversion of eformat *)
Return[instead]
];

myXML["cn",{"type"-> "real"},{numstring_?FortranEFormQ}]:= 
Module[{y,man,exp,instead},
{man,exp}=eForm2MantissaExponent[numstring];
instead=XMLElement["cn",{"type"-> "e-notation"},{man,XMLElement["sep",{},{}],exp}];
Print["Error: "//boldRed," FORTRAN-style exponential notation is not permitted in "//boldBlack,
XMLElement["cn",{"type"-> "real"},{numstring}]//XMLOut//boldBlue,
" Attempting recovery as "//boldBlack,
instead//XMLOut//boldBlue,
"\nNote:  This is not standard SBML. "//boldRed
];
instead=fixXMLeNotation[instead]; (* because of bug in Mathematica conversion of eformat *)
Return[instead]
];

myXML["cn",{"type"-> "real"},{x_}]:=Module[{instead,z},
If[StringQ[x],z=x,z=ToString[x]]; 
z=StringJoin@@Prepend[Select[Characters[z],DigitQ],"0"]//ToExpression//ToString;
instead=XMLElement["cn",{"type"-> "real"},{z}];
Print["Error:"//boldRed," invalid floating point number in "//boldBlack,
XMLOut[XMLElement["cn",{"type"-> "real"},{x}]]//boldBlue,"\nThe value has been replaced with "//boldBlack,instead//XMLOut//boldBlue," in the model. "//boldBlack,"Note that this interpretation may not conform to the intent of the original model and could produce unexpected results."//boldRed
];
Return[instead]
];

myXML["cn",{"type"-> "integer"},{x_?IntegerFormQ}]:=XMLElement["cn",{"type"-> "integer"},{x}];

myXML["cn",{"type"-> "integer"},{numstring_?mantissaFormQ}]:= 
Module[{instead},
instead=XMLElement["cn",{"type"-> "real"},{numstring}];
Print["Error: "//boldRed," real numbers are not permitted in "//boldBlack,
XMLElement["cn",{"type"-> "integer"},{numstring}]//XMLOut//boldBlue,
" Attempting recovery as "//boldBlack,
instead//XMLOut//boldBlue,
"Note that this interpretation may not conform to the intent of the original model and could produce unexpected results."//boldRed
];
Return[instead]
];

myXML["cn",{"type"-> "integer"},{numstring_?eFormQ}]:= 
Module[{y,man,exp,instead},
{man,exp}=eForm2MantissaExponent[numstring];
instead=XMLElement["cn",{"type"-> "e-notation"},{man,XMLElement["sep",{},{}],exp}];
Print["Error: "//boldRed," exponential notation is not permitted in "//boldBlack,
XMLElement["cn",{"type"-> "integer"},{numstring}]//XMLOut//boldBlue,
" Attempting recovery as "//boldBlack,
instead//XMLOut//boldBlue,
"\nNote:  This is not standard SBML. "//boldRed
];
instead=fixXMLeNotation[instead]; (* because of bug in Mathematica conversion of eformat *)
Return[instead]
];

myXML["cn",{"type"-> "integer"},{x_}]:=Module[{instead,z},
If[StringQ[x],z=x,z=ToString[x]]; 
z=StringJoin@@Prepend[Select[Characters[z],DigitQ],"0"]//ToExpression//ToString;
instead=XMLElement["cn",{"type"-> "integer"},{z}];
Print["Error:"//boldRed," invalid integer in "//boldBlack,
XMLOut[XMLElement["cn",{"type"-> "integer"},{x}]]//boldBlue,"\nThe value has been replaced with "//boldBlack,instead//XMLOut//boldBlue," in the model. "//boldBlack,"Note that this interpretation may not conform to the intent of the original model and could produce unexpected results."//boldRed
];
Return[instead]
];


myXML[z___]:= XMLElement[z]; 
f=XMLElement["math",{opt}, formula]; 
f = (f/.{XMLElement-> myXML}); 

Return[f];
];
checkMathMLElements[x___]:= Module[{dbg=True},
Print["Warning:"//boldRed,"checkMathMLElements: Invalid formula (not an XMLElement[math...]) = \n"//boldBlack,ToString[InputForm[f]]//boldBlue];
Return[f];
];


contextifyFormula[{f_}]:= contextifyFormula[f];
contextifyFormula[XMLElement["math",{opt___},formula_]]:= Module[{dbg=False,f},

debugPrint[dbg,"contextifyFormula: f(0)",formula]; 
f= XMLElement["math",{opt},formula];

debugPrint[dbg,"contextifyFormula: f(1)",f]; 
f=checkMathMLElements[f];
debugPrint[dbg,"contextifyFormula: f(2)",f]; 

If[dbg, Print["contextifyFormula: Calling SymbolicSBMLMathMLToExpression"]];
f=SymbolicSBMLMathMLToExpression[f]; 
debugPrint[dbg,"contextifyFormula: f(3)",f];

(* the following inserted version 2.3.19 *)
f=f/.{XML`MathML`Symbols`Piecewise->piecewise};
debugPrint[dbg,"contextifyFormula: f(4)",f];

f=(f//InputForm)//ToString; 
debugPrint[dbg,"contextifyFormula: f(5)",f];
Return[f];
];

contextifyFormula[XMLElement[{xmlns_, "math"},{opt___},formula_]]:=
contextifyFormula[XMLElement["math",
{{"http://www.w3.org/2000/xmlns/","xmlns"}-> xmlns},formula]];


contextifyFormula[f_]:= Module[{dbg=True},
Print["Warning:"//boldRed,"contextifyFormula: Invalid formula (not an XMLElement[math...]) = \n"//boldBlack,ToString[InputForm[f]]//boldBlue];
Return[f];
]


getLevel2rules[opt___]:= Module[{lv,
dbg=False,getRule,addODE,r },

$SBML$Algebraic$Rules={};
$SBML$Assignment$Rules={};
$SBML$Constraint$Rules={};

$SBML$NRules=0; 

lv=ToExpression[$SBML$Level$Version]; 


addODE[ODE_?StringQ]:= Module[{},
$SBML$ODES=Append[$SBML$ODES,ToExpression[ODE]];
];

addODE[x___]:= printWarning["addODE: program Error: argument must be a string: \""<>ToString[x]<>"\""];

getRule[XMLElement[type_,opts_,formula_]]:=Module[{r,form,f,fnew,v,g,metaid, isASpecies, comp,hasOnlySubstanceUnits,c,fOFv,irule,hf, sbo, dbg=False},
$SBML$NRules++;
debugPrint[dbg,"getRule: formula", formula];

v="variable"/.opts/.{"variable"-> ""};
debugPrint[dbg,"getRule: v", v];
sbo="sboTerm"/.opts/.{"sboTerm"-> ""}; 


form = Cases[formula,XMLElement["math",__],Infinity];
If[$SBML$warnings \[And] Length[form]<1, 
irule=XMLElement[type,opts,{XMLElement["math",{"xmlns"->"http://www.w3.org/1998/Math/MathML"},{XMLElement["cn",{"type"->"integer"},{"1"}]}]}];
Print["Error: "//boldRed,"getRule: No <math...> found in the following rule:\n"//boldBlack,
XMLPrintForm[XMLElement[type,opts,formula],Purple],
"\nAttempting to recover from the error as\n"//boldBlack,
XMLPrintForm[irule,Purple],
"\nNote: this recovery is not standard SBML and may not be correct."//boldRed
];
Return[getRule[irule]];

];
If[$SBML$warnings \[And]  Length[form]>1, form=First[form];
 Print["Warning:"//boldRed,"Multiple <math ...> blocks in same rule (type="//boldBlack,type//boldBlue,", variable="//boldBlack,v//boldBlue,"): \n"//boldBlack,
Sequence@@XMLHighlightForm[XMLElement[type,opts,formula],Purple,"<math"]

];
]; 


metaid =stringer[ "metaid"/.opts/.{"metaid"-> ""}]; 
If[metaid=="",
metaid="rule"<>ToString[MB$rulecounter++];,
MB$rulecounter++ ];
debugPrint[dbg,"getRule: metaid", metaid];
debugPrint[dbg,"getRule: form", form];


f=contextifyFormula[form];

debugPrint[dbg,"getRule: f", f];

If[$SBML$evaluateParameters,
f=ToExpression[f];
f = f//.SBMLReplacementRules;
f=ToString[InputForm[f]];
];
debugPrint[dbg,"getRule: f", f];


If[StringLength[v]>0, v=contextify[v]]; 
debugPrint[dbg,"getRule: v", v];

debugPrint[dbg,"getRule: type", type];

Switch[type,
"algebraicRule",
g="0=="<>f;
$SBML$Algebraic$Rules = Append[$SBML$Algebraic$Rules,ToExpression[g]];
,

"constraintRule",
g=f;
$SBML$Constraint$Rules=Append[$SBML$Constraint$Rules, ToExpression[g]]; 
,

"assignmentRule",

(* mod 2.3.20 - add add rule structure and treat as DAE *)

g=functionate[v]<>"=="<>f;
$SBML$Assignment$Rules = Append[$SBML$Assignment$Rules,ToExpression[g]];

If[TrueQ[$VersionNumber>= 5.0], 

(* Treat as part of DAE system in Version >= 5.0 *)

removeReplacementRule[v];
defineVariable[v];

,
(*Treat as a replacement rule in Version < 5*)
removeVariable[v];
g=v<>"->"<>f;
defineParameter[v];
SBMLIC[v]=f;
addReplacementRule[v]; 
];

,
"rateRule",
If[SBMLConstantQ[v], 



Print["Error: "//boldRed, "getRule: can not define a rate rule for "//boldBlack,decontextify[v]//boldBlue," because it is 'constant'"//boldBlack,"\n",
Sequence@@XMLHighlightForm[XMLElement[type,opts,formula],Purple,type<>" variable=\""<>stringer[decontextify[v]]<>"\""]
];
g=functionate[v<>"'"]<>"=="<>f<>" (This rule ignored because '"<>v<>"' is a Constant - This is an error in the model.)";
,

(* add in correction for concentration units: when computing the ODE from reactions, the entire right hand side of the equation will be divided by the compartment volume if this is a species with units of the species concentration. We don't want to do this for the rate rule so we need to multiply by the compartment size in advance to cancel out this correction on this term of the ODE only. v 2.5.9 16Mar06 *)

isASpecies=MemberQ[$SBML$Species$IDs,ToExpression[v]];
debugPrint[dbg,"getRule: rateRule: {v,isASpecies} ", {v,isASpecies}];
If[isASpecies,
fOFv=ToExpression[functionate[v]];
hasOnlySubstanceUnits=hasOnlySubstanceUnitsIndicator[fOFv];
debugPrint[dbg,"getRule: rateRule: hasOnlySubstanceUnits ", hasOnlySubstanceUnits];
If[Not[hasOnlySubstanceUnits],
c=SBMLSpeciesCompartment[fOFv];
fnew=ToString[c]<>"*("<>f<>")";
debugPrint[dbg,"getRule: rateRule: {c,f, fnew} ",{ c, f,fnew}];
f=fnew;
];
];

g=functionate[v<>"'"]<>"=="<>f;
defineVariable[v];


addODE[g];
];
,
_,

Print["Error:"//boldRed,"getRule: Unrecognized rule type: "//boldBlack,type//boldBlue," in the following rule:\n"//boldBlack,

Sequence@@XMLHighlightForm[XMLElement[type,opts,formula],Purple,type]
];

];
debugPrint[dbg, "getRule: saveVerboseData:", saveVerboseData]; 

r={}; 
If[saveVerboseData,
If[!$SBML$verboseContext,g=decontextify[g,$SBML$Context];];
If[lv > 2.15, 
r={metaid,sbo, type,g},
r={metaid, type, g}
]
]; 
debugPrint[dbg , "getRule: r", r]; 
Return[r];
] ; (* end of  getRule *)


r = Cases[$SBML$Model,XMLElement["listOfRules",___],3]; 
debugPrint[dbg,"getLevel2rules: r(1)",r];

If[Length[r]>1, 
Print["Error:"//boldRed,"getRules: Multiple 'listOfRules' found. Only the first will be used."//boldBlack]];

If[Length[r]<1,
verboseSave["Rules",{"MetaID", "Type","Formula"}, {}];
 Return[];
];

r=First[r];
r=extractXMLSubElements[r];
debugPrint[dbg,"getLevel2rules: r(2)",r];
debugPrint[dbg,"getLevel2rules: MB$Parameters(2)",MB$Parameters];

If[dbg, Print["getLevel2rules: MB$Load: "//boldRed, MB$Load//boldBlue]];


If[MB$Load, addRule/@r]; 


If[dbg , Print["getLevel2rules: Model Builder loaded."]]; 

r = Map[getRule,r];

debugPrint[dbg,"getLevel2rules: r(3)",r];
debugPrint[dbg,"getLevel2rules: MB$Parameters(3)",MB$Parameters];
If[lv>2.15, 
verboseSave["Rules",{"Metaid","SBOTerm", "Type","Formula"}, r],verboseSave["Rules",{"Metaid", "Type","Formula"}, r]
];

Return[];
];


getLevel2constraints[opt___?OptionQ]:= Module[{c, info,getConstraintInfo},
getConstraintInfo[r_]:= Module[{math, sbo, meta, msg},
addConstraint[r];
sbo=getSBMLfield["SBOTerm",r];
meta=getSBMLfield["metaid",r];
subXML=extractXMLSubElements[r];

math=Cases[subXML, XMLElement["math",___],1];
math=First[math];
math=contextifyFormula[math];


(* math=XMLOut[math];
math=MathMLToInfix[math];
math = ToString[InputForm[math]];  *)

msg = Cases[subXML, XMLElement["message",___],1];
If[Length[msg]>0, msg=msg[[1]]];

Return[{meta, sbo, math, msg}];

];(***** end getConstraintInfo *****)

$SBML$Constraints={};
c = Cases[$SBML$Model,XMLElement["listOfConstraints",___],3]; 

If[ToExpression[$SBML$Level$Version]<2.15,
If[Length[c]>0,
Print["Error: "//boldRed," listOfConstraints "//boldBlue, "is not supported in SBML Level "//boldBlack, $SBML$Level$Version//boldBlack];
];
Return[];
];


c = Cases[c,XMLElement["constraint",___],3]; 
info=getConstraintInfo/@c;

$SBML$Constraints = Map[Rule[#[[3]],#[[4]]]&, info];

info = Most/@info; (* get rid of message *)

verboseSave["Constraints",{"Metaid","SBOTerm","Formula"}, info];


];


makeTF[str_?StringQ]:= Switch[ToUpperCase[str],
"TRUE",True,"FALSE",False,_, False];


ODEfor[var_,odes_:$SBML$ODES, timevar_:Global`t]:=Module[{ode},
ode=Cases[odes,Equal[D[var[timevar],timevar],_]];
If[Length[ode]==0, Return[0]];
If[Length[ode]>1, Print["Warning: ODEfor: multiple differential equations found for ", var]];

While[ListQ[ode], ode=First[ode]];
ode = Last[ode/.{Equal-> List}];
Return[ode]
];



getLevel2reactions[opt___]:= Module[{r, dbg=False, trace=False, i=0, reaction,lhs, rhs, vars,varpositions,DEQs,header={"ID","Name","Reaction","Parameters","Kinetic Law"},
ids, names, fasts, reactions, lps, fs,des, mods, conversionFactors, cfvars,v,s,vsm,spid, reactionContexts,myequal,reactionmetaids, reactantspecies, productspecies, parametas,parasbo,klawsbo,
selectODEs4Variables, getReaction,label, stoichiometryMatrix, unitsOfTheSpeciesCorrection
},


getReaction[XMLElement["reaction",opts_,r_]]:= Module[{id,name,reversible, fast,defaultID,
reactants,products,rspecies={},pspecies={},rstoic={},pstoic={},kineticLaw,modifiers,dbg=False,formula, localParameters,nparameters,ids,names, values,productDEQs={}, reactantDEQs={}, DEQs,rdenoms,pdenoms,productStoicRules, reactantStoicRules, stoichiometryMatrixColumn,netStoichiometry,mbe,marate,productRHS,reactantRHS,thereaction,reactionmetaid, reactantmetaids, productmetaids, modifiermetaids, 
reactantsboterms, productsboterms, modifiersboterms,reactionsboterm, parametermetaids,parametersboterms,kineticlawsboterm,sboterms,cysmbols, 
getStoichiometries, getLocalParameters, sumStoichiometryRules
},
thereaction=XMLElement["reaction",opts,r];

getStoichiometries[XMLElement[listName_,options_,stuff_]]:= Module[{species,vspecies,number,dbg=False, smath},
debugPrint[dbg,"\!\(\*
StyleBox[\"getStoichiometries\",\nFontColor->RGBColor[0, 1, 0]]\): input", XMLElement[listName, options, stuff]];
species = ("species"/.options)/.{"species"-> "Indeterminate"};
printWarning[species=="Indeterminate", 
"No 'species' name specified for reaction '"<>id<>"' '"<>listName<>"'"];
smath = Cases[stuff, XMLElement["stoichiometryMath",___]];
debugPrint[dbg,"\!\(\*
StyleBox[\"getStoichiometries\",\nFontColor->RGBColor[0, 1, 0]]\): smath(1)", smath];
number={};
If[Length[smath]>0,
smath=First[smath]; 
debugPrint[dbg,"\!\(\*
StyleBox[\"getStoichiometries\",\nFontColor->RGBColor[0, 1, 0]]\): smath(2)", smath];
smath=extractXMLSubElements[smath];
debugPrint[dbg,"\!\(\*
StyleBox[\"getStoichiometries\",\nFontColor->RGBColor[0, 1, 0]]\): smath(3)", smath];
number = Cases[smath,XMLElement["math",___]];
debugPrint[dbg,"\!\(\*
StyleBox[\"getStoichiometries\",\nFontColor->RGBColor[0, 1, 0]]\): number(1)", number];
If[Length[number]>0, number=contextifyFormula[number[[1]]],number="1"];
debugPrint[dbg,"\!\(\*
StyleBox[\"getStoichiometries\",\nFontColor->RGBColor[0, 1, 0]]\): number(1.0)", number];
,
debugPrint[dbg,"\!\(\*
StyleBox[\"getStoichiometries\",\nFontColor->RGBColor[0, 1, 0]]\): options", options];
number = "stoichiometry"/.options/.{"stoichiometry"-> "1"};
debugPrint[dbg,"\!\(\*
StyleBox[\"getStoichiometries\",\nFontColor->RGBColor[0, 1, 0]]\): number(1.A)", number];

number = ToExpression[fromEForm[number]];
debugPrint[dbg,"\!\(\*
StyleBox[\"getStoichiometries\",\nFontColor->RGBColor[0, 1, 0]]\): number(2): ", number];

];


vspecies = contextify[species//makeIntoValidSId];
debugPrint[dbg,"\!\(\*
StyleBox[\"getStoichiometries\",\nFontColor->RGBColor[0, 1, 0]]\): vspecies:", vspecies];
species = vspecies;
species = ToExpression[species];
debugPrint[dbg,"\!\(\*
StyleBox[\"getStoichiometries\",\nFontColor->RGBColor[0, 1, 0]]\): species: ", species];

(* moved into earlier if statement 2.5.3 *)
(*
number = ToExpression[fromEForm[number]];
debugPrint[dbg,"getStoichiometries: number(2): ", number];
*)

debugPrint[dbg,"\!\(\*
StyleBox[\"getStoichiometries\",\nFontColor->RGBColor[0, 1, 0]]\): {species, number} [return value]", {species,number}];

Return[{species,number}];
];(* end of getStoichiometries *)
getStoichiometries[x_]:= printWarning["Invalid argument to getStoichiometry: "<>ToString[InputForm[x]]];

getLocalParameters[x_]:= Module[{pid, pname, value,cid, units},
pid = ("id"/.x/.{"id"-> $SBML$IndeterminateValue}); 
pname = "name"/.x/.{"name"-> ""};
value="value"/.x/.{"value"-> $SBML$IndeterminateValue};
value = value//fromEForm//InputForm//ToString;(* remove embedded quotes*) 
value = StringReplace[value,"\""-> ""];

$SBML$LocalReactionParameterTable=Append[$SBML$LocalReactionParameterTable, 
{pid, decontextify[id]}

];

(* fully contextified parameter *) 
cid = contextify[pid//makeIntoValidSId,id];
defineParameter[cid]; 
definef[SBMLIC,cid, value]; 
addReplacementRule[cid]; 

units = ("units"/.x/.{"units"-> $SBML$IndeterminateValue});
units = unitsContextify[units];
$SBML$UnitAssociations = Append[$SBML$UnitAssociations, ToExpression[cid]-> ToExpression[units]];


(* locally contextify parameter *) 
cid = contextify[pid//makeIntoValidSId,decontextify[id]];

Return[(pid-> cid)];

]; (* end of getLocalParameters *)


$SBML$NReactions++;
debugPrint[dbg,"getReaction ===================== reaction #",$SBML$NReactions];
debugPrint[dbg, "getReaction: all species=",$SBML$Species$IDs]; 


defaultID="reaction_"<>ToString[$SBML$NReactions];
{id,name}=getIDandName[opts,defaultID];
(* addID[id, "reaction"]; *)
removeVariable[id];

reactionmetaid="metaid"/.opts/.{"metaid"-> ""}; 

reversible="reversible"/.opts/.{"reversible"-> "true"}; 
reversible = makeTF[reversible];
fast = "fast"/.opts/.{"fast"-> "false"}; 
fast = makeTF[fast];

reactants = Cases[r,XMLElement["listOfReactants",___]]; 
products = Cases[r,XMLElement["listOfProducts",___]]; 
kineticLaw=Cases[r,XMLElement["kineticLaw",___]];
modifiers = Cases[r,XMLElement["listOfModifiers",___]];

reactants=Cases[reactants,XMLElement["speciesReference",___],3];
products=Cases[products,XMLElement["speciesReference",___],3];
modifiers=Cases[modifiers,XMLElement["modifierSpeciesReference",___],3];

reactantmetaids = getSBMLfield["metaid", #]&/@reactants;
productmetaids = getSBMLfield["metaid", #]&/@products;
modifiermetaids = getSBMLfield["metaid", #]&/@modifiers;

reactantsboterms = getSBMLfield["sboTerm", #]&/@reactants;
productsboterms= getSBMLfield["sboTerm", #]&/@products;
modifiersboterms = getSBMLfield["sboTerm", #]&/@modifiers;




reactants = Map[getStoichiometries,reactants];
products = Map[getStoichiometries,products];
modifiers = Map[getStoichiometries,modifiers];



If[Length[reactants]>0, {rspecies,rstoic}=Transpose[reactants];
];

If[Length[products]>0, {pspecies,pstoic}=Transpose[products];
];

If[Length[modifiers]>0, modifiers = Map[First,modifiers]];

reaction = reactionForm[rspecies, rstoic,pspecies,pstoic, reversible];
debugPrint[dbg, "getReaction: reaction(reactionForm):", reaction]; 

debugPrint[dbg,"getReaction: {id,name}",{id,name}];
debugPrint[dbg,"getReaction: reactants",reactants];
debugPrint[dbg,"getReaction: products",products];
debugPrint[dbg,"getReaction: modifiers",modifiers];
debugPrint[dbg,"getReaction: kineticLaw",kineticLaw];

(* sumStoichiometryRules added 2.5.7 2-2-05 to handle files that have the same reactant or product listed more than once in the same reaction, i.e., the SBML files has A+A-> B instead of 2A-> B, etc. *)

sumStoichiometryRules[rules___?OptionQ]:= Module[{lhs,rnew, sums, vars,valuesof},
rnew=Flatten[{rules}];
lhs=First/@rnew;
vars=Union[lhs];
rnew=rnew/.{Rule-> List};
valuesof[var_]:=Plus@@( Last/@(Cases[rnew,{var,_}]));
sums=valuesof/@vars;
rnew=MapThread[Rule,{vars,sums}];
Return[rnew];
];

productStoicRules=sumStoichiometryRules[Map[Apply[Rule,#]&,products]];
reactantStoicRules =sumStoichiometryRules[ Map[Apply[Rule,#]&,reactants]];




debugPrint[dbg,"getReaction: productStoichRules",productStoicRules];
debugPrint[dbg,"getReaction: reactantStoicRules",reactantStoicRules];

netStoichiometry[x_]:= Module[{st,ls,rs},
ls = x/.productStoicRules/.{x-> 0};
rs = x/.reactantStoicRules/.{x-> 0};
st = ls-rs;
Return[st];];

stoichiometryMatrixColumn = netStoichiometry/@$SBML$Species$IDs;
debugPrint[dbg,"getReaction: net stoichiometry: ",stoichiometryMatrixColumn];
stoichiometryMatrix=Append[stoichiometryMatrix,stoichiometryMatrixColumn];


localParameters = Cases[kineticLaw,XMLElement["listOfParameters",___],3];
localParameters = Cases[localParameters,XMLElement["parameter",___],3];
localParameters=Map[extractXMLOptions,localParameters];

parametermetaids=("metaid"/.#/.{"metaid"-> ""})&/@localParameters;
parametersboterms=("sboTerm"/.#/.{"sboTerm"-> ""})&/@localParameters;

nparameters=Length[localParameters];
$SBML$NLocalParameters += nparameters;
localParameters = Map[getLocalParameters,localParameters];

debugPrint[dbg,"getReaction: localParameters",localParameters];

formula = Cases[kineticLaw,XMLElement["math",___],3];
debugPrint[dbg,"getReaction: formula(1)",formula];

Block[{}, 
XML["csymbol",_, x_]:=x;
XML[___]:= {};
csymbols = Cases[formula, XMLElement["csymbol",___], Infinity];
csymbols = csymbols/.{XMLElement-> XML}; 
csymbols=Flatten[csymbols];
debugPrint[dbg, "getReaction: csymbols: ", csymbols];
];

If[Length[formula]>0, 
formula = First[formula];
 If[nparameters>0,
(* localParameters has form k->reaction`form *)
formula = formula/.localParameters;
debugPrint[dbg,"getReaction: formula(1a)",formula];

localParameters = Map[Last,localParameters];
localParameters = contextify[localParameters];
localParameters = parameterate[localParameters]; 
debugPrint[dbg,"getReaction: localParameters",localParameters];
(* local parameters has form "model`reaction`k->value" *)
];
debugPrint[dbg,"getReaction: formula(1.9)",formula];
formula = contextifyFormula[formula];
debugPrint[dbg,"getReaction: formula(2)",formula];
If[ (nparameters>0) \[And] $SBML$evaluateParameters,
lps = Map[ToExpression,localParameters];
lps = Select[lps,ToString[ Last[#]]!="Indeterminate"&];
formula =(ToExpression[formula]/.lps);
debugPrint[dbg,"getReaction: formula(2a)",formula];
formula=ToString[InputForm[formula]]; 
debugPrint[dbg,"getReaction: formula(2b)",formula];
];

,
formula="Indeterminate";
]; 
debugPrint[dbg,"getReaction: formula(3)",formula];
If[$SBML$UseUnits, formula = ToString[InputForm[(ToExpression[formula]/.SBMLSpeciesSIConcentration)]]; ]; 
debugPrint[dbg,"getReaction: formula(4)",formula];
If[ListQ[kineticLaw],

If[Length[kineticLaw]>1, 
Print["Error: "//boldRed, "getLevel2Reaction: multiple kineticLaws in reaction:\n"//boldBlack,
Sequence@@XMLHighlightForm[thereaction,Purple,"kineticLaw"]
];
];

kineticLaw=First[kineticLaw];

];


kineticlawsboterm=getSBMLfield["sboTerm", kineticLaw];


selectODEs4Variables[q_]:= Module[{odes, varname,isvariable},

varname[ode_]:= Module[{DE},
DE = ToExpression[ode];
DE = First[DE]; 
DE = ToString[DE];
DE = StringReplace[DE,{"'[t]"-> ""}];
Return[DE];
];

isvariable[ode_]:=Module[{v},
v = varname[ode];
Return[ \[Not](MathSBML`Private`SBMLBoundaryConditionQ[v] \[Or] MathSBML`Private`SBMLConstantQ[v])]
];

Return[Select[q, isvariable]];
]; (* end of selectODEs4Variables *) 

(* calculate marate even (especially) if there is no kinetic law *)
 
debugPrint[dbg,"getReaction: pstoic",pstoic];
debugPrint[dbg,"getReaction: rstoic",rstoic];
marate = Times@@MapThread[functionate[#1]^#2&, {rspecies,rstoic}];
debugPrint[dbg,"getReaction: marate",marate];

$SBML$MassActionReactionRates=Append[$SBML$MassActionReactionRates,marate];

If[formula== "Indeterminate",
DEQs={},


If[$SBML$evaluateParameters,
formula =( ToExpression[formula]//.SBMLReplacementRules);
formula=ToString[InputForm[formula]]; 
];

debugPrint[dbg,"getReaction: pspecies",pspecies];
debugPrint[dbg,"getReaction: rspecies",rspecies];
debugPrint[dbg,"getReaction: $SBML$SpeciesThatAreConcentrations",$SBML$SpeciesThatAreConcentrations];

pdenoms = Map[If[MemberQ[$SBML$SpeciesThatAreConcentrations,#//stringer], (#//stringer)/.$SBML$SpeciesCompartmentAssociations/.{stringer[#]-> "Indeterminate"},"1"]&,pspecies ];
rdenoms = Map[If[MemberQ[$SBML$SpeciesThatAreConcentrations,#//stringer], (#//stringer)/.$SBML$SpeciesCompartmentAssociations/.{stringer[#]-> "Indeterminate"},"1"]&,rspecies ];

debugPrint[dbg,"getReaction: pdenoms",pdenoms];
debugPrint[dbg,"getReaction: rdenoms",rdenoms];


productDEQs=MapThread[functionate[ToString[#1]<>"'"]<>"== ("<>ToString[#2]<>")*("<>formula<>")/("<>#3<>")"&,{pspecies,pstoic,pdenoms}];
reactantDEQs=MapThread[functionate[ToString[#1]<>"'"]<>"==-("<>ToString[#2]<>")*("<>formula<>")/("<>#3<>")"&,{rspecies,rstoic,rdenoms}];

debugPrint[dbg,"getReaction: productDEQs",productDEQs];
debugPrint[dbg,"getReaction: reactantDEQs",reactantDEQs];

(* select only those odes that are not for constants or boundary conditions *)

DEQs= Join[productDEQs, reactantDEQs];
DEQs =selectODEs4Variables[DEQs];
DEQs=Map[ToExpression,DEQs];

If[$SBML$evaluateParameters,
DEQs = DEQs//.SBMLReplacementRules]; 


]; 

(* This is not done by default because it can sometimes take a LOT of CPU - but you can end up with things in both the numerator and denominator that SHOULD be cancelled if you don't do it*)
If[$SBMLSimplifyRateLaws, 
debugPrint[dbg,"getReaction: Cancelling ... "];
myequal[a_, b_]:= Equal[a,Cancel[b]];
DEQs=DEQs/.{Equal-> myequal};
];

debugPrint[dbg, "getReaction: DEQS (1) :", DEQs]; 
debugPrint[dbg,"getReaction: Joining ... "];

$SBML$ODES = Join[$SBML$ODES, DEQs];


(* convert local DEQs to a convenient form for printing*)
debugPrint[dbg,"getReaction: Converting ... "];
DEQs = Map[ToString[First[#]]<>"=="<>ToString[InputForm[Last[#]]]&, DEQs];
$SBML$Reactions=Append[$SBML$Reactions, reaction];
debugPrint[dbg, "getReaction: DEQS (2) :", DEQs]; 

debugPrint[dbg,"getReaction: calling checkKineticLaw."]; 
Block[{re,p,f, locals,myrule,ok},
myrule[x_,y_]:=x; 
re=stringer/@decontextify/@First/@reactants;
p=stringer/@decontextify/@First/@products;
f=StringReplace[formula,{"[t]"-> "",id<>"`"-> "",$SBML$Context-> ""}];
locals=decontextify/@ToString/@((ToExpression/@localParameters)/.{Rule->myrule}); 
ok=checkKineticLaw[
invokedBy-> "getReaction",
Global`id-> decontextify[id],
Global`reactants-> re,
Global`products-> p,
Global`modifiers->decontextify/@ modifiers,
Global`parameters-> locals,
Global`kineticLaw->ToExpression[f], 
csymbolsused-> csymbols
];
debugPrint[dbg,"getReaction: reaction is ok:",ok];
];

If[trace, Print["getReaction: ",++i,":",id,":",reaction,":",formula]];


Block[{reacts, prods},

(* reactant, modifier, and product information is returned as a triple {id, metaid, sboterm} *)

reacts=decontextify/@First/@reactants;
prods=decontextify/@First/@products;

If[ToExpression[$SBML$Level$Version]>2.15, 

reacts = Transpose[{reacts, reactantmetaids, reactantsboterms}];
prods = Transpose[{prods, productmetaids, productsboterms}]; 
modifiers = Transpose[{modifiers, modifiermetaids, modifiersboterms}];
,

reacts = Transpose[{reacts, reactantmetaids}];
prods = Transpose[{prods, productmetaids}]; 
modifiers = Transpose[{modifiers, modifiermetaids}];

]; (* end if *)

 If[dbg, 
Print["return value from getReaction:",
{"id=",id, "\nmetaid=",reactionmetaid, "\nname=", name,"\nfast=", fast,"\nreaction=",reaction,"\nreacts=",reacts, "\nprods=",prods,"\nmodifiers=", modifiers,"\nlocalParameters=", localParameters,
"\npar meta ids=",parametermetaids,"\npar sbo=",parametersboterms,
"\nformula=",formula,"\nkinetic law sbo=",kineticlawsboterm,
"\nDEQs=",DEQs}
];
]; 


Return[{id, reactionmetaid,  name, fast,reaction,reacts, prods, modifiers, localParameters,
parametermetaids,parametersboterms,
formula,kineticlawsboterm,
DEQs}]

]; (* end Block ..reacts, prods *) 

]; (* end of getReaction normal form*) 

getReaction[r__]:= Module[{},printWarning["Invalid reaction format."]; Return[r]];(* end of getReaction error form *)



$SBML$NReactions=0;
$SBML$NLocalParameters=0;
$SBML$Reactions={};
stoichiometryMatrix={};
$SBML$MassActionReactionRates={};



r = Cases[$SBML$Model,XMLElement["listOfReactions",___],3];

 
printWarning[Length[r]>1, 
"Multiple 'listOfReactions' found. Only the first will be used."];

If[Length[r]<1,verboseSave["Reactions",header, {}]; Return[];
];

r = Cases[r,XMLElement["reaction",___],3]; 
debugPrint[dbg,"getLevel2reactions: r",r];

If[MB$Load, 
MB$reactioncounter = Length[r]+1; 
addReaction/@r];

If[Length[r]<1,verboseSave["Reactions",header, {}]; 
Return[];
];

sboterms=getSBMLfield["sboTerm",#]&/@r;

r = Map[getReaction,r];
debugPrint[dbg,"getLevel2reactions: r(2)",r];

Block[{ids, formulas},
ids = First/@r;
defineVariable/@ids;
formulas = (#[[12]])&/@r;
$SBML$KineticLaws=Map[Equal[functionate[ToExpression[#[[1]]]], ToExpression[#[[12]]]]&, r]//Flatten;
]; 

$SBML$StoichiometryMatrix=Transpose[stoichiometryMatrix];

If[SBMLRead$returnMassBalanceEquations,
v=SBML$RateVectorID;
v = Array[v,Length[r]]; 
v = stringer/@v;
v = contextify/@v;
v=expressionate/@v;
debugPrint[dbg,"getLevel2reactions: v",v];
debugPrint[dbg,"getLevel2reactions: $SBML$StoichiometryMatrix",$SBML$StoichiometryMatrix];
debugPrint[dbg,"getLevel2reactions: $SBML$MassActionReactionRates",$SBML$MassActionReactionRates];

SBML$MassBalanceEquations=$SBML$StoichiometryMatrix.v;
debugPrint[dbg,"getLevel2reactions: SBML$MassBalanceEquations",SBML$MassBalanceEquations];

SBML$MassAction$Equations=$SBML$StoichiometryMatrix.(v*$SBML$MassActionReactionRates);

$SBML$MassActionVariables=functionate/@$SBML$Species$IDs;

s=stringer/@$SBML$Species$IDs;
s=Map[#<>"'"&,s];
s=expressionate/@ functionate/@s;

SBML$MassBalanceEquations=MapThread[#1==#2&,{s,
SBML$MassBalanceEquations}];
SBML$MassAction$Equations=MapThread[#1==#2&, {s, SBML$MassAction$Equations}]; 
];

$SBML$MassActionVariables=functionate/@$SBML$Species$IDs;

(* Combine ODES together *)
debugPrint[dbg, "getLevel2reactions: $SBML$ODES: precombined:\n", $SBML$ODES//Sort];

(* vars gives the unique variables *)
lhs = Map[First, $SBML$ODES];
rhs = Map[Last,$SBML$ODES];
vars = lhs//Union;

(* find positions of unique variables in entire list*) 
varpositions = Map[Position[lhs,#]&, vars];
varpositions=Map[Flatten,varpositions];

debugPrint[dbg, "getLevel2reactions: lhs:", lhs];
debugPrint[dbg, "getLevel2reactions: vars:", vars];
debugPrint[dbg, "getLevel2reactions: varpositions:", varpositions];
debugPrint[dbg, "getLevel2reactions: rhs:", rhs];

(* collect the rhs for each unique variable and add them up *)
rhs = Map[rhs[[#]]&, varpositions];
debugPrint[dbg, "getLevel2reactions: rhs:", rhs];
rhs = Map[Apply[Plus,#]&, rhs]; 
debugPrint[dbg, "getLevel2reactions: rhs:", rhs];

(* check for 0-length list, can happen if no kinetic laws anywhere *)
If[Length[vars]>0,
cfvars = ToExpression[StringReplace[ToString/@vars, "'"-> ""]], cfvars={}];

conversionFactors=(SBMLSpeciesToUnitsOfTheSpecies/@cfvars)/.SBMLReplacementRules;
If[dbg, Print["getLevel2reactions: conversionFactors:", conversionFactors," vars:",vars]]; 
If[$SBML$UseUnits,
$SBML$ODES=MapThread[ #1==(#2)(#3)&, {vars,rhs, conversionFactors}];
,
$SBML$ODES=MapThread[ #1==#2&, {vars,rhs}];
]; 

debugPrint[dbg, "getLevel2reactions: $SBML$ODES: combined\n", $SBML$ODES//Sort];

(* correct for compartment volumes if necessary *)
i=0;
unitsOfTheSpeciesCorrection[ode_]:=Module[{v,vdot, newODE,variableName,hasOnlySubstanceUnits,comp, isASpecies,Cdot,ubug=False},

debugPrint[dbg, "unitsOfTheSpeciesCorrection: "<>ToString[++i]<>":"<>stringer[First[ode]]];  

v=First[ode/.{Equal-> List}];
vdot=v;

variableName[x_'[y_]]:=x[y];
variableName[x__]:=Indeterminate;
v=variableName[v];
isASpecies=MemberQ[$SBML$Species$IDs, defunctionate[v]];
debugPrint[ubug, "getLevel2reactions: unitsOfTheSpeciesCorrection: {v,isASpecies}", {v,isASpecies}];

If[!isASpecies, 
debugPrint[dbg,"not a species: ",v];
Return[ode]];

hasOnlySubstanceUnits=hasOnlySubstanceUnitsIndicator[v];
debugPrint[ubug, "getLevel2reactions: unitsOfTheSpeciesCorrection: hasOnlySubstanceUnits",hasOnlySubstanceUnits];

If[hasOnlySubstanceUnits, 
debugPrint[dbg, "hasOnlySubstanceUnits:",v]; 
Return[ode]];

comp=SBMLSpeciesCompartment[v];
cdot=ODEfor[defunctionate[comp]];
debugPrint[ubug, "getLevel2reactions: unitsOfTheSpeciesCorrection: {comp,cdot}", {comp,cdot}];

(* newODE=Equal[vdot,Last[(ode/.{Equal-> List})]/comp - cdot/comp]; *)
(* revised 2.6.0.14 1/30/07 *)
newODE=Equal[vdot,Last[(ode/.{Equal-> List})] - cdot/comp];

debugPrint[dbg,"getLevel2reactions: newODE calculated for ",v];

debugPrint[ubug, "getLevel2reactions: unitsOfTheSpeciesCorrection:ode, newODE", {ode,newODE}];

(* Simplify/@(A==B) is the same as Simplify[a]==Simplify[B] *)
(* commented out 2.5.18 because of CPU usage for very complicated odes *)
(*
newODE=Simplify/@newODE;
*)

debugPrint[dbg,"getLevel2reactions: simplified newODE calculated for ",v];

Return[newODE];
]; (* end of unitsOfTheSpeciesCorrection *)

(* apply the correction *)
(* *)
 $SBML$ODES=unitsOfTheSpeciesCorrection/@$SBML$ODES;


debugPrint[dbg, "getLevel2reactions: $SBML$ODES: corrected\n", $SBML$ODES//Sort//TableForm];

(* process verbose reaction information *) 

If[saveVerboseData,
label="Reactions";
{ids, reactionmetaids, names, fasts, reactions, reactantspecies, productspecies, mods,lps,parametas,parasbo, fs,klawsbo,des}=Transpose[r];

If[!$SBML$verboseContext,
ids = decontextify[ids];
lps = decontextify[lps,$SBML$Context];
reactions = decontextify[reactions, $SBML$Context];
mods = decontextify[mods, $SBML$Context];
(* mods = list2CommaSeparatedString[mods]; *)

lps = MapThread[decontextify[#2,#1<>"`"]&, {ids,lps}];

fs= decontextify[fs, $SBML$Context];
fs = MapThread[decontextify[#2,#1<>"`"]&, {ids,fs}];

des = decontextify[des, $SBML$Context];
des = MapThread[decontextify[#2,#1<>"`"]&, {ids,des}];

label = label<>", contexts suppressed";

];

If[ToExpression[$SBML$Level$Version]>2.15, 
r={ids, reactionmetaids,sboterms, names,fasts,reactions,reactantspecies, productspecies,  mods};
header={"ID","MetaID","SBOTerm", "Name", "Fast","Reaction","Reactants\nID MetaID SBOTerm", "Products\nID MetaID SBOTerm", "Modifiers\nID MetaID SBOTerm"};
,  
r={ids, reactionmetaids, names,fasts,reactions,reactantspecies, productspecies,  mods};
header={"ID","MetaID", "Name", "Fast","Reaction","Reactants\nID MetaID", "Products\nID MetaID", "Modifiers\nID MetaID"};
]; 

If[$SBML$ShowReactionParameters,
(* following line added 2.3.19 to get reaction parameters to print as equals and not arrows *)
lps=(StringReplace[#,{"\[Rule]"-> "=" }]&/@#&)/@lps;




If[ToExpression[$SBML$Level$Version]>2.15, 
lps =Transpose/@Transpose[ {lps, parametas, parasbo}]; (* include also sbo & metaids 2.5.27*)
header=Append[header,"Parameters\nID=val MetaID SBOTerm"];
,  
lps =Transpose/@Transpose[ {lps, parametas}]; (* include also metaids 2.5.27*)
header=Append[header,"Parameters\nID=val MetaID"];
]; 
r=Append[r,lps];



];
If[$SBML$shortenODES , label=label<>", shortened."];
If[$SBML$KineticLaw,

If[$SBML$shortenODES ,
fs=Map[Short[ToExpression[#]]&, fs]
]; 


If[ToExpression[$SBML$Level$Version]>2.15, 
header=Append[header,"Formula\nSBOTerm"];
r=Append[r,Transpose[{fs, klawsbo}]];
,  
header=Append[header,"Formula\n(Substance/Volume)"];
r=Append[r,fs];
]; 


];

(* 
r=Append[r,des];
header=Append[header,"Contribution to ODEs"]; 
*)

verboseSave[label,header, Transpose[r]]; 
];

If[saveVerboseData,
label = "Differential Equations";
DEQs=$SBML$ODES;
If[$SBML$shortenODES ,
DEQs = Map[ToString[First[#]]<>"=="<>ToString[Short[InputForm[Last[#]]]]&,DEQs];
label = label<>", short form";
 ,
DEQs = Map[ToString[First[#]]<>"=="<>ToString[InputForm[Last[#]]]&,DEQs];
];
If[!$SBML$verboseContext,
(* remove global context *)

DEQs=decontextify[DEQs, $SBML$Context];

(* remove local contexts *)

reactionContexts=#<>"`"&/@ids;
While[Length[reactionContexts]>0,
DEQs=decontextify[DEQs, First[reactionContexts]];
reactionContexts=Rest[reactionContexts];
];
 
label=label<>", contexts suppressed";
];

vars = Map[ToString,vars];
vars = Map[decontextify,vars];
vars = Map[StringReplace[#,"'[t]"-> ""]&, vars]; 
verboseSave[label, 
{"Variable", "ODEs"},{vars,DEQs}//Transpose]; 
];

If[saveVerboseData,
If[$SBML$VerboseStoichiometry,
If[!$SBML$verboseContext,$SBML$Species$IDs=decontextify[$SBML$Species$IDs,$SBML$Context]]; 
vsm=Transpose[$SBML$StoichiometryMatrix];
vsm=Prepend[vsm,$SBML$Species$IDs]//Transpose;
verboseSave["Stoichiometry Matrix based on Reaction Stoichiometries",Prepend[ids,"Species"],vsm];
];

If[$SBML$Verbose$MassBalanceEquations,
mbe = SBML$MassBalanceEquations;
If[!$SBML$verboseContext,mbe=decontextify[mbe,$SBML$Context]]; 
mbe = ToString/@mbe;
mbe ={$SBML$Species$IDs,mbe}//Transpose;

verboseSave["Mass Balance Equations based on Stoichiometry Matrix",{"Species","[Species'[t]]=[Stoichometries][rates]"},mbe];
];

If[$SBML$Verbose$MassActionEquations,
spid = ToString/@(First/@SBML$MassAction$Equations);
mbe =Last/@ SBML$MassAction$Equations;
If[!$SBML$verboseContext,mbe=decontextify[mbe,$SBML$Context]]; 
mbe = ToString/@InputForm/@mbe;
mbe = MapThread[#1<>"=="<>#2&,{spid,mbe}]; 

mbe ={$SBML$Species$IDs,mbe}//Transpose;

verboseSave["Mass Action Equations based on Stoichiometry Matrix",{"Species","[Species'[t]]=[Stoichometries][mass-action-rates]"},mbe];
];


];

Return[];

];



checkParameterShadowing[]:=Module[{gpar,collisions},
gpar = Select[$SBML$IDTable, Last[#]=="parameter"&];
gpar =Complement[Flatten[gpar], {"parameter"}];
collisions = Select[$SBML$LocalReactionParameterTable, MemberQ[gpar,#[[1]]]&];
Print["Warning:"//boldRed, " local parameter "//boldBlack,#[[1]]//boldBlue, " in reaction "//boldBlack, #[[2]]//boldBlue, " shadows a global parameter with the same id."//boldBlack]&/@collisions;
]


check4MissingODES[]:= Module[{v,o,varsWithoutODEs, ODEsWithoutVars},
o=Map[First,MathSBML`Private`$SBML$ODES];

v=MathSBML`Private`SBMLVariables;
v=Map[ToExpression[ToString[#]<>"'"<>"[t]"]&,v];

varsWithoutODEs= Complement[v, o];
ODEsWithoutVars = Complement[o,v];


If[Length[varsWithoutODEs]>0,
printWarning["The following variables are specified in the model but do not have differential equations specified: "<>list2CommaSeparatedString[varsWithoutODEs]];
];

If[Length[ODEsWithoutVars]>0,
printWarning["The following variables have differential equations but are not specified as species or parameters in the model: "<>list2CommaSeparatedString[ODEsWithoutVars]];
];
];


addDummyODE[id_?StringQ]:= Module[{dummyODE},

dummyODE=StringReplace[functionate[id],"["-> "'["]<>"==0";

$SBML$ODES=Append[$SBML$ODES, ToExpression[dummyODE]]]


getLevel2events[]:= Module[{e,title="Events",header,

dbg=False, getEvent},


If[ToExpression[$SBML$Level$Version]>2.15,
header = {"ID", "MetaID","SBOTerm","Name", "Trigger","Delay","TimeUnits","Event\nAssignment", "Assignment\nMetaID", "Assignment\nSBOTerm"},
header = {"ID", "MetaID","Name", "Trigger","Delay","TimeUnits","Event\nAssignment", "Assignment\nMetaID"}
]; 


getEvent[XMLElement["event",opt_,ev_]]:= Module[{id, metaid,sboterm,name,defaultID,trigger, delay, timeUnits, eventAssignment,eventAssignmentMetaids, eventAssignmentSBOTerms, dbg = False,  getEventAssignment },
$SBML$NEvents++;
debugPrint[dbg,"getLevel2events: getEvent: ---------------------------event number: ", $SBML$NEvents];
defaultID="event_"<>ToString[$SBML$NEvents];
{id,name}=getIDandName[opt,defaultID];
checkForSymbolCollision[contextify[id],"event"];
(* addID[id, "event"]; *)
removeVariable[id];
debugPrint[dbg,"getLevel2events: getEvent: {id,name}",{id,name}]; 

metaid="metaid"/.opt/.{"metaid"-> ""}; 
sboterm="sboTerm"/.opt/.{"sboTerm"-> ""}; 

trigger = Cases[ev, XMLElement["trigger",___]];
delay = Cases[ev, XMLElement["delay",___]];
timeUnits="timeUnits"/.opt/.{"timeUnits"-> (unitsContextify["time"]//.$SBML$UnitRules)};
eventAssignment=Cases[ev,XMLElement["listOfEventAssignments",___]];

(* *********** Process Trigger ********** *)
debugPrint[dbg,"getLevel2events: getEvent:trigger",trigger]; 
If[Length[trigger]>1,
printWarning["Multple triggers specified for event '"<>id<>"'; all triggers except for the first one were ignored."];
,
If[Length[trigger]<1, "No trigger found for event '"<>id<>"'"]; 
];
If[Length[trigger]>0,
trigger = First[trigger];
trigger = extractXMLSubElements[trigger];
If[Length[trigger]>0, 
trigger=First[trigger];
debugPrint[dbg,"getLevel2events: getEvent:trigger formula",trigger]; 
 trigger = contextifyFormula[trigger];
,
trigger = "False";
];
, 
trigger="False";
]; 
debugPrint[dbg,"getLevel2events: getEvent:trigger formula",trigger]; 

(* ********* Process Delay ********* *)

debugPrint[dbg,"getLevel2events: getEvent:delay",delay]; 
If[Length[delay]>1,
printWarning["Multple delay fields specified for event '"<>id<>"'; all delay fields except for the first one were ignored."];
];

If[Length[delay]>0,
delay = First[delay]; 
delay = extractXMLSubElements[delay];
If[Length[delay]>0, 
delay = contextifyFormula[delay];,
delay = "0";
]; 
,
delay = "0"
];
debugPrint[dbg, "getLevel2events: getEvent: delay formula", delay]; 

(********* process timeUnits *********)

debugPrint[dbg,"getLevel2events: getEvent:timeUnits",timeUnits]; 

(*********** process event assignments **********)

debugPrint[dbg,"getLevel2events: getEvent:listOfEventAssignments",eventAssignment]; 
If[Length[eventAssignment]>1,
printWarning["Multple listOfEventAssignments specified for event '"<>id<>"'; all listOfEventAssignments except for the first one were ignored."];
,
If[Length[listOfEventAssignments]<1, "No listOfEventAssignments found for event '"<>id<>"'"]; 
];
If[Length[eventAssignment]>0,
eventAssignment = First[eventAssignment];
eventAssignment = extractXMLSubElements[eventAssignment];
eventAssignment = Cases[eventAssignment, XMLElement["eventAssignment",___]];



getEventAssignment[XMLElement["eventAssignment",evopt_, formula_]]:= Module[{v},
f=formula;

f = Cases[f, XMLElement["math",___]];

debugPrint[dbg,"getEventAssignment:evopt",evopt]; 
debugPrint[dbg,"getEventAssignment:f",f]; 

v = contextify["variable"/.evopt];
debugPrint[dbg,"getEventAssignment:v",v]; 
If[Length[f]>0,
f= First[f];
debugPrint[dbg,"getEventAssignment:f",f]; 
f= contextifyFormula[f];
debugPrint[dbg,"getEventAssignment:f",f]; 
,
printWarning["No formula specified for event assignment,even id="<>id<>" variable=",v];
f="Indeterminate";
];
debugPrint[dbg,"getEventAssignment:f",f];


f = functionate[v]<>"->"<>f;
Return[f]; 
]; 
getEventAssignment[x___]:= Module[{},
printWarning["Incorrectly formatted eventAssignment="<>ToString[x]];
]; (* end of getEventAssignment *) 

eventAssignmentMetaids=Map[getSBMLfield["metaid",#]&, eventAssignment];
eventAssignmentSBOTerms=Map[getSBMLfield["sboTerm",#]&, eventAssignment]; 


eventAssignment = Map[getEventAssignment, eventAssignment]; 


debugPrint[dbg,"getLevel2events: getEvent:eventAssignments",eventAssignment]; 


];


$SBML$Events = Append[$SBML$Events,
id-> {"trigger"-> trigger,"delay"-> delay,"events"-> eventAssignment}
];
If[saveVerboseData,
If[!$SBML$verboseContext,
id = decontextify[id];
trigger = decontextify[trigger, $SBML$Context];
timeUnits = decontextify[timeUnits];
eventAssignment=decontextify[eventAssignment, $SBML$Context];
delay = decontextify[delay, $SBML$Context];
];

If[$SBML$OutputFormatIsHTML,
trigger=StringReplace[trigger,","-> "@COMMA"];
eventAssignment=StringReplace[#,","-> "@COMMA"]&/@eventAssignment;
];
];
If[ToExpression[$SBML$Level$Version]>2.15, 
Return[{id,metaid,sboterm, name, trigger, delay,timeUnits, eventAssignment, eventAssignmentMetaids, eventAssignmentSBOTerms}],
Return[{id,metaid, name, trigger, delay,timeUnits, eventAssignment, eventAssignmentMetaids}]
];
];(* end of getEvent *)

$SBML$Events = {}; 
$SBML$NEvents=0;

e= Cases[$SBML$Model,XMLElement["listOfEvents",___],3]; 
printWarning[Length[e]>1, 
"Multiple 'listOfEvents' found. Only the first will be used."];

If[Length[e]<1,verboseSave[title,header, {}]; Return[];
];

e= Cases[e,XMLElement["event",___],3]; 
debugPrint[dbg,"getLevel2events: e",e];

If[MB$Load, 
MB$Events++; 
addEvent/@e];

e = Map[getEvent, e];
debugPrint[dbg,"getLevel2events: e",e];


If[saveVerboseData,verboseSave[title,header, e]; 

];

];



Biomodels$Database$URL="http://www.ebi.ac.uk/compneur-srv/biomodels/models-main/publ/"; 

getBiomodel[n_?IntegerQ, opt___?OptionQ]:= Module[{model, name}, 
name = ToString[n];
While[StringLength[name]<10, name = "0"<>name]; 
name = Biomodels$Database$URL<>"BIOMD"<>name<>".xml";
Print["Reading ", name]; 
model = Import[name, "XML"];
model=SBMLRead[model, opt]; 
Return[model];
];
getBiomodel[x___]:= (Print["Expecting getBiomodel[integer model number]"]; Return[$Failed]);


conservationMatrix[s_]:= Module[{echelon,x,y,location,i, prel0,l0, l0t,\[Gamma]},
(*<<LinearAlgebra`MatrixManipulation` (* Loading MatrixManipulation *) *) 

If[!MatrixQ[s], Print["Error: conservationMatrix: input is not a matrix."]; Return[s];];

If[MatrixRank[s]<Length[s], (* If there exist linearly dependent rows *)

echelon=RowReduce[Transpose[s]];
x=MatrixRank[Transpose[s]];
y=Length[Transpose[s]];
prel0=Drop[echelon, {x+1,y}];

location=0;
For[i=1, i<=Length[prel0],i++, If[prel0[[i,i]]==1, location++;];];

l0t=Drop[prel0, None, location];
l0=Transpose[l0t];

\[Gamma]=AppendRows[-l0, IdentityMatrix[Length[l0]]];,

\[Gamma]=IdentityMatrix[Length[s]];(* Else case *)

];(* End if *)
Return[\[Gamma]]; (* Returning conservation matrix *)
];




piecewise[XML`MathML`Symbols`Piece[ ifclause_,test_], XML`MathML`Symbols`Otherwise[elseclause_]]:= System`If[test, ifclause, elseclause];
piecewise[XML`MathML`Symbols`Piece[ifclause_, test_]]:= System`If[test, ifclause];
piecewise[XML`MathML`Symbols`Piece[ifclause_, test_],otherpieces__,  XML`MathML`Symbols`Otherwise[elseclause_]]:= Module[{therest,f,returnvalue},
therest = piecewise[otherpieces,  XML`MathML`Symbols`Otherwise[elseclause]];
returnvalue=f[test,ifclause,therest];
Return[returnvalue/.{f-> System`If}]
];



piecewiseIf[x___]:= if2piecewise[If[x]];
if2piecewise[If[a_,b_]]:= XML`MathML`Symbols`Piecewise[XML`MathML`Symbols`Piece[a,b]];
if2piecewise[If[a_,b_, If[c__]]]:= Module[{d},
d=if2piecewise[If[c]];
XML`MathML`Symbols`Piecewise[XML`MathML`Symbols`Piece[a,b,d]]//Return
];
if2piecewise[If[a_,b_,c_]]:= XML`MathML`Symbols`Piecewise[XML`MathML`Symbols`Piece[a,b],
XML`MathML`Symbols`Otherwise[c]];


SymbolicSBMLMathMLToExpression[q_]:= Module[{XML,r,
dbg=False},
If[dbg,Print["SymbolicSBMLMathMLToExpression: q:",q]];
XML["csymbol",
{"encoding"->"text","definitionURL"->csymbolTimeURL},{x_}]:= (If[dbg,Print["csymbol: ",x]];XMLElement["ci",{},{"Global`t"}]);
XML["csymbol",
{"definitionURL"->csymbolTimeURL, "encoding"->"text"},{x_}]:= (If[dbg,Print["csymbol: ",x]];XMLElement["ci",{},{"Global`t"}]);
XML[x___]:= (If [dbg,Print["XML:x:",x]];XMLElement[x]); 
r=(q/.{XMLElement-> XML});
If[dbg,Print["SymbolicSBMLMathMLToExpression: r(1):",r]];

checkNames[r]; 

r = XML`MathML`SymbolicMathMLToExpression[r];
If[dbg,Print["SymbolicSBMLMathMLToExpression: r(2):",r]];

(* bug fix for Mathematica Version 6.0 xml bug *)

r=ToExpression[StringReplace[stringer[r], {"$of$t$"-> "[t]"}]];



Return[r];
]


checkNames[xml_]:= Module[{ci,ciG,  varname, varvals, contexts,globalnames, globalvals, mathnames,mathvals,  dbg=False, globaldup, mathdup},
varname["ci", _, {x_}]:= x;  
varname[x___]:= $Failed; 
ci = Cases[xml, XMLElement["ci", ___], Infinity]; 
ci = ci/.{XMLElement-> varname}; 
ci = Union[ci]; 
If[dbg, Print["checkNames: ci(1):" , ci]]; 
ci = decontextify/@ci;
If[dbg, Print["checkNames: ci(2):" , ci]]; 

globalnames=Names["Global`*"]; 
globalnames = Intersection[ci, globalnames]; 
globalvals  =ToString[ ToExpression[#]]&/@globalnames; 
globaldup=MapThread[#1 != #2& ,{globalnames, globalvals} ];
globaldup = Pick[globalnames, globaldup]; 

mathnames = Names["MathSBML`*"]; 
mathnames=Intersection[ci, mathnames];
mathvals = ToString[ToExpression[#]]&/@mathnames;  
mathdup=MapThread[#1 != #2& ,{mathnames, mathvals} ];
mathdup = Pick[mathnames, mathdup]; 

If[dbg, Print[
"checknames: globalnames: ", globalnames, 
"\nchecknames: globalvals: ", Short[globalvals], 
"\nchecknames: globaldup: ", globaldup, 
"\nchecknames: mathnames: ", mathnames,
"\nchecknames: mathvals: ", Short[mathvals], 
"\nchecknames: mathdup: ", mathdup
]]; 

Print["Warning: "//boldRed, "possible conflict of "//boldBlack, ("Global`"<>#)//boldBlue, " with "//boldBlack, identifyID[#]//boldBlue, " ", #//boldBlue, "\nAttempting recovery via "//boldBlack,("Clear["<>#<>"]")//boldBlue,  "  (may produce unexpected results) ..."//boldBlack ]&/@globaldup;
ToExpression [Clear[#]]&/@globaldup;

Print["Warning: "//boldRed, "possible conflict of "//boldBlack, ("MathSBML`"<>#)//boldBlue, " with "//boldBlack, identifyID[#]//boldBlue, " ", #//boldBlue, "\nAttempting recovery via "//boldBlack,("Clear["<>#<>"]")//boldBlue,  " (may produce unexpected results) ..."//boldBlack ]&/@mathdup;
ToExpression[Clear[#]]&/@mathdup;


Return[];

ciG= contextify[#, "Global"]&/@ci; 
If[dbg, Print["checkNames: ciG:" , ciG]]; 

varvals = ToString[ToExpression[#]]&/@ciG; 
varvals = Not/@MapThread[Equal, {varvals, ci}]; 
varvals = Pick[ci, varvals];
contexts =ToString/@( Context/@varvals);

If[dbg, Print["checkNames: varvals:" , varvals, "\ncheckNames: contexts: ", contexts]]; 

(* turn off checking of variables like modelContext`B$of$t$ *)
varvals=Select[varvals, (ToString[Context[#]]=="Global`" \[Or]  ToString[Context[#]]=="MathSBML`")&]; 
contexts = ToString/@( Context/@varvals); 

If[dbg, Print["checkNames: varvals:" , varvals]]; 


MapThread[Print["Warning: "//boldRed,identifyID[#1]//boldBlue, " ", #1//boldBlue, " conflicts with "//boldBlack,(#2<>#1)//boldBlue, "which may cause unexpected results. Use "//boldBlack,("Clear["<> #2<>#1<>"]")//boldBlue, " to avoid unexpected conflicts with this variable. The previous\nAttempting auto-recovery ... this may also cause unexpected results. The following previous value will be cleared:\n "//boldBlack, Short[ToExpression[#2<>#1]]//boldBlue ]&, {varvals, contexts}]; 

(* ToExpression[Clear[#]]&/@varvals; *)
]; 


vis$boxWidth=.15;
vis$boxHeight=.05;
vis$box = 0.5{vis$boxWidth, vis$boxHeight};
vis$radius=0.025;
vis$fontSize=12;
vis$headerFontSize=18;
vis$fontFamily="Times"

vis$data={};
new$visdata[]:= Module[{}, vis$data={}]; 
save$visdata[data___]:= AppendTo[vis$data, {data}];
get$visdata[]:= vis$data;


visualizeSBMLModel[file_, options___?OptionQ]:=  Module[{m,opts, stuff,ids, r, s, getS, getRMP, vis,dbg=False, sbmlrules, rateRules, rateRuleVariables, assignmentRules, assignmentRuleVariables, assignmentRulesForVisualization, rateRulesForVisualization, namerules={}, byname, modelnames, ignore, v, plotlabel},

dbg = "debug"/.{options}/.{"debug"-> False}; 
new$visdata[]; 

f=stringer[file];
If[fileExists[ f],
m = Import[f,"XML"]; 
,
f=ToFileName[Directory[], f];
Print["Error: "//boldRed,"The file "//boldBlack,f//boldBlue," does not exist."//boldBlack];
Return[];
];

(* get options *)
byname =( MathSBML`visualizeByName/.{options})/.{MathSBML`visualizeByName-> False};

ignore = (MathSBML`ignoreSpecies/.{options})/.{MathSBML`ignoreSpecies-> {}};
ignore = stringer/@ignore;

vis$arrowLength= visualizationArrowLength/.{options}/.{visualizationArrowLength-> 15};

If[$VersionNumber<6, 
vis$boxWidth=visualizationBoxWidth/.{options}/.{visualizationBoxWidth-> .15};
vis$boxHeight=visualizationBoxHeight/.{options}/.{visualizationBoxHeight-> .05};
vis$radius=visualizationRadius/.{options}/.{visualizationRadius-> 0.025};
,

vis$boxWidth=visualizationBoxWidth/.{options}/.{visualizationBoxWidth-> 1};
vis$boxHeight=visualizationBoxHeight/.{options}/.{visualizationBoxHeight-> .25};
vis$radius=visualizationRadius/.{options}/.{visualizationRadius-> 0.1};

]; 

vis$box = 0.5{vis$boxWidth, vis$boxHeight};
vis$fontSize=visualizationFontSize/.{options}/.{visualizationFontSize-> 12};
vis$headerFontSize=visualizationHeaderFontSize/.{options}/.{visualizationHeaderFontSize-> 18};
vis$fontFamily=visualizationFontFamily/.{options}/.{visualizationFontFamily-> "Times"};

c=Cases[m, XMLElement["model",_,_],Infinity];
ids = getSBMLfield["id",#]&/@c;
modelnames = getSBMLfield["name",#]&/@c; 
namerules = Join[namerules, MapThread[Rule, {ids, modelnames}]];

(* get the species *)
getS[XMLElement["species", opt_, stuff_]]:= Module[{id,name},
id = "id"/.opt/.{"id"-> "error"};
name="name"/.opt/.{"name"-> "unnamed species"};
id=stringer[id];
AppendTo[namerules, id-> name];
Return[id]; 
];
getS[___]:= "error-reading-species-id";

While[ListQ[c] \[And] Length[c]>0, c=First[c]];
s=Cases[m, XMLElement["listOfSpecies",__], Infinity]; 
If[Length[s]>0, 
s=Cases[s, XMLElement["species", __], Infinity];
s=getS/@s;
]; 
If[dbg, Print["visualizeSBMLModel: s=",s]]; 
If[dbg, Print["visualizeSBMLModel: namerules=", namerules]];
(* get the rules *)

assignmentRules = {};
assignmentRuleVariables={};
assignmentRulesForVisualization={};
rateRules = {};
rateRuleVariables={}; 
rateRulesForVisualization={};

r = Cases[m, XMLElement["listOfRules", __], Infinity];
If[Length[r]>0, 

assignmentRules = Cases[r, XMLElement["assignmentRule", __], Infinity]; 
rateRules = Cases[r, XMLElement["rateRule", __], Infinity]; 

If[Length[assignmentRules] >0 \[Or] Length[rateRules]>0, 
If[dbg, Print[Length[assignmentRules], " assignment rules"]]; 
Block[{v,vv, rhsvars},

rhsvars[u_]:= Module[{m,v,vid},
vid["ci",{},{sid_}]:= {sid};
vid[sid___]:= {}; 
m=Cases[u, XMLElement["math",__], Infinity];
v= Cases[m,XMLElement["ci",__], Infinity];
v = v/.{XMLElement-> vid};
v = Flatten[v];
Return[v];
];

If[Length[assignmentRules]>0, 
(* put assignment rules into a form that can be used to traverse kinetic laws of reactions for hidden modifiers *)

v = getSBMLfield["variable",#]&/@assignmentRules;
assignmentRuleVariables=v;
vv=rhsvars/@assignmentRules;
vv = Intersection[#, s]&/@vv;
assignmentRules = MapThread[Rule, {v, vv}];
If[dbg, Print["visualizeSBMLModel: v=",v]];
If[dbg, Print["visualizeSBMLModel: vv (species):",vv]];
If[dbg, Print["visualizeSBMLModel: assignmentRules (species dependence):",assignmentRules]]; 

(* for visualization of rules, select only pieces that affect species *)

Block[{prepRuleForVisualization},
prepRuleForVisualization[{variable_, {input___}}]:=Rule[#,variable]&/@{input};
assignmentRulesForVisualization = prepRuleForVisualization/@(assignmentRules/.{Rule-> List});
assignmentRulesForVisualization=Flatten[assignmentRulesForVisualization];
assignmentRulesForVisualization= Select[assignmentRulesForVisualization,
And[MemberQ[s, First[#]],MemberQ[s, Last[#]]]& 
];
If[dbg,Print["visualizeSBMLModel: assignmentRulesForVisualization:",assignmentRulesForVisualization ]];
]; (* end Block *)
]; (* end If[Length[assignmentRules]>0 *)


If[Length[rateRules]>0, 
(* put rateRules into a form that can be used to traverse kinetic laws of reactions for hidden modifiers *)

v = getSBMLfield["variable",#]&/@rateRules;
rateRuleVariables=v;
vv=rhsvars/@rateRules;
vv = Intersection[#, s]&/@vv;
rateRules = MapThread[Rule, {v, vv}];

If[dbg, Print["visualizeSBMLModel: rate v=",v]];
If[dbg, Print["visualizeSBMLModel: rate vv (species):",vv]];
If[dbg, Print["visualizeSBMLModel: rateRules (species dependence):",rateRules]]; 

(* for visualization of rules, select only pieces that affect species *)

Block[{prepRuleForVisualization},
prepRuleForVisualization[{variable_, {input___}}]:=Rule[#,variable]&/@{input};
rateRulesForVisualization = prepRuleForVisualization/@(rateRules/.{Rule-> List});
rateRulesForVisualization=Flatten[rateRulesForVisualization];
rateRulesForVisualization= Select[rateRulesForVisualization,
And[MemberQ[s, First[#]],MemberQ[s, Last[#]]]& 
];
If[dbg,Print["visualizeSBMLModel:rateRulesForVisualization:",rateRulesForVisualization ]];
]; (* end Block *)
]; (* end If[Length[rateRules]>0 *)

]; (* end Block *)
]; (* end if there are rules *)
 (* else no rules *) 
(* no else clause right now *)
];
 

(* get the reactions *)

getRMP[XMLElement["reaction",opt_, stuff_]]:= 
Module[{r, m,rm, p,rmp,  reaction, getR, getM, getP, id, rule, dbg=False, kl,klarv,klrrv, vid,name}, 
vid["ci",{},{sid_}]:= {sid};
vid[sid___]:= {}; 

reaction=XMLElement["reaction",opt, stuff];
id="id"/.opt/.{"id"-> "unknown-reaction-id"};
id="$"<>id;
name = "name"/.opt/.{"name"-> "unnamed reaction"};
AppendTo[namerules, id->  name];

If[dbg, Print["**** getRMP: id: ", id]]; 

rule[a_, b_]:= {Rule[a,id], Rule[id, b]};

r=Cases[reaction, XMLElement["listOfReactants",___], Infinity];
r=Cases[r, XMLElement["speciesReference",___], Infinity];
r=getSBMLfield["species",#]&/@r;

m=Cases[reaction, XMLElement["listOfModifiers",___], Infinity];
m=Cases[m, XMLElement["modifierSpeciesReference",___], Infinity];
m=getSBMLfield["species",#]&/@m;

p=Cases[reaction, XMLElement["listOfProducts",___], Infinity];
p=Cases[p, XMLElement["speciesReference",___] , Infinity];
p=getSBMLfield["species",#]&/@p;

kl = Cases[reaction, XMLElement["math",___], Infinity];
kl = Cases[kl, XMLElement["ci", ___], Infinity]; 
kl = kl/.{XMLElement-> vid};
kl = Flatten[kl];
If[dbg, Print["getRMP: kl:", kl]]; 
klarv = Intersection[kl, assignmentRuleVariables];
klrrv = Intersection[kl, rateRuleVariables];
If[dbg, Print["getRMP: klarv:", klarv]];
If[dbg, Print["getRMP: klrrv:", klrrv]];

klarv = Join[klarv, klrrv];
If[dbg, Print["getRMP: klarv:", klarv]];

klarv = klarv//.Join[assignmentRules, rateRules];
klarv = Flatten[klarv];
If[dbg, Print["getRMP: klarv (hidden species):", klarv]];

rm=Join[r,m, klarv];
If[dbg, Print["getRMP: r: ", r]]; 
If[dbg, Print["getRMP: m: ", m]]; 
If[dbg, Print["getRMP: p: ", p]]; 

If[dbg, Print["getRMP: rm: ", rm]]; 
(* rmp= Outer[Rule, rm, p];
rmp=rmp/.{Rule-> rule}; 
rmp=Flatten[rmp];
If[dbg, Print["getRMP: rmp: ", rmp]]; 
*)
Block[{ri, ro},
ri = Rule[#, id]&/@rm;
rm = Rule[id, #]&/@p;
rmp = Join[ri, rm]//Flatten;
];
If[dbg, Print["getRMP: rmp: ", rmp]]; 


Return[rmp];
]; 
getRMP[___]:="error-reading-reaction";

r=Cases[m, XMLElement["listOfReactions", __], Infinity];
If[Length[r]>0, 
r=Cases[r, XMLElement["reaction",___], Infinity];
r=getRMP/@r;
If[dbg, Print["visualizeSBMLModel: next reaction=",#]&/@r]; 
]; 
r=Join[r, assignmentRulesForVisualization, rateRulesForVisualization]; 
r=Flatten[r];

If[Length[r]<1,
Print["Warning: "//boldRed, "This model can not be visualized becauese it does not contain any reactions or rules that define species in terms of other species."//boldBlack];

If[$VersionNumber<6, 
Return[Show[Graphics[Text["*************\nModel cannot \nbe visualized\n*************", {0,0}]], Frame-> True, FrameTicks-> None, Background-> Yellow, TextStyle-> {FontSize-> 22, FontFamily-> Arial}, 
FrameLabel->{None,None,  MyStyleForm[ids[[1]], FontFamily-> vis$fontFamily, FontSize-> vis$headerFontSize],None}]] ,
Return[Show[Graphics[Text["*************\nModel cannot \nbe visualized\n*************", {0,0}]], Frame-> True, FrameTicks-> None, Background-> Yellow, LabelStyle-> {FontSize-> 22, FontFamily-> Arial}, 
FrameLabel->{None,None,  MyStyleForm[ids[[1]], FontFamily-> vis$fontFamily, FontSize-> vis$headerFontSize],None}]]
]
]; 

(* filter out species listed in ignoreSpecies *)
Block[{keep,reactions},
reactions = List@@#&/@r;
keep[{a_, b_}]:= Not[MemberQ[ignore, a] ]\[And] Not[MemberQ[ignore, b]];
reactions = Select[reactions, keep];
reactions = Rule@@#&/@reactions;
r= reactions;
];

If[byname, r =( r/.namerules)]; 
If[dbg, Print["visualizeSBMLModel: r=",r]]; 

(* visualize *)

vis[m_]:=Module[{v,xy, esf, vsf, title,opt},

title  = ids[[1]]; 
If[byname, title  = title/.namerules]; 
v=VertexList[m];
xy=GraphCoordinates[m];

esf[i_,j_]:=
Module[{v, w, arw},

v[p_, q_, f_]:= xy[[p]]+ f*(xy[[q]]-xy[[p]]);
arw[p_, q_, f_]:= If[$VersionNumber<6, 
Arrow[xy[[p]], v[p, q, f], HeadScaling-> Absolute, HeadLength-> 15], 
Arrow[{xy[[p]], v[p, q, f]}]
]; 

save$visdata["arrow", v[i,j, 0], v[i,j, 1]];

If[$VersionNumber<6, Return[

{Blue,Line[{i,j}],arw[i, j, .7]}]]; 

Return[{Blue,Line[{xy[[i]],xy[[j]]}],arw[i, j, .7]}]; 
];


vsf[i_]:=Module[{r, vdata},

vdata[p_]:=Module[{data,rawdata,d, center, r,ISAreaction,s, oval, ovaldisk,rx},

data= v[[p]];


ISAreaction=False;
If[StringPosition[data,"$"]=={{1,1}}, 
data = StringDrop[data,1];
ISAreaction=True;
];

rawdata = data;
data = MyStyleForm[data,FontFamily-> vis$fontFamily, FontSize-> vis$fontSize];




d={};
center = xy[[p]];

If[$VersionNumber<6, 
data =Text[data, i], 
data=Text[data, center]
]; 


If[ISAreaction,
r=Rectangle[center-vis$box, center+vis$box];
s=Line[{
center+{vis$boxWidth/2, vis$boxHeight/2},
center+{vis$boxWidth/2, -vis$boxHeight/2},
center+{-vis$boxWidth/2, -vis$boxHeight/2},
center+{-vis$boxWidth/2, vis$boxHeight/2},
center+{vis$boxWidth/2, vis$boxHeight/2}
}];
d=Join[d,{White,  r, Black, s}];

save$visdata["reaction", rawdata, center];
,
rx=StringLength[v[[p]]];
oval = Circle[center, vis$radius*{rx, 1}]; 
ovaldisk = Disk[center, vis$radius*{rx, 1}]; 
d = Join[d, { White, ovaldisk,Red, oval, Black}];

save$visdata["species", rawdata, center];

]; 

d=Append[d, data];


Return[d];
]; 


r= vdata[i];
Return[r];

];
 
With[{opt=MyFilterOptions[GraphPlot, options]}, 
If[dbg, Print["visualizeSBMLModel: about to call GraphPlot\nm=",m,"\n{opt}=", {opt}, "\nesf=", esf, "\nvsf=", vsf, "\nxy=", xy]]; 
plotlabel= MyStyleForm[title, FontFamily-> vis$fontFamily, FontSize-> vis$headerFontSize]; 
If[$VersionNumber<6, 
v=GraphPlot[m,opt, 
 EdgeStyleFunction-> esf,
VertexStyleFunction->vsf, VertexCoordinates-> xy, PlotLabel-> plotlabel ]; 
, 
erf[{pt1_, pt2_}, u___]:= Module[{i, j, w},
i=Position[xy, pt1]//Flatten//First; 
j=Position[xy, pt2]//Flatten//First;
w=esf[i,j]; 
w=Prepend[w, Arrowheads[Medium]]; 
If[dbg, Print["{i,j}=", {i,j}, " erf=", w, Graphics[w]]]; 
Return[w]; 
]; 
erferr=True; 
erf[u___]:= Module[{}, 
If[erferr, Print["Warning: "//boldRed,"visualizeSBMLModel: "//boldBlue,  " unexpected input to EdgeRenderingFunction: "//boldBlack, u//boldBlue, "\nThis error occurs because of undocumented improvements in Mathematica 6.0 that have erroneously superceded EdgeStyleFunction with EdgeRenderingFunction without backward compatibility or change documentation. IN most cases this error will not affect the output of visualizeSBMLModel, and it is not clear why Mathematica generates this function call. There is currently no workaround for this bug, escept to run MathSBML in Mathematica 5.2. This message will be suppressed for the remainder of this calculation. "//boldBlack]]; 
erferr=False; 
Return[{}];];  

vrf[pos_, u___]:= Module[{i},
i=Position[xy, pos]//Flatten//First; 
Return[vsf[i]]; 
]; 

v=GraphPlot[m, opt,VertexCoordinateRules-> xy , PlotLabel-> plotlabel, 
 EdgeRenderingFunction->( erf[#]&), 
 VertexRenderingFunction-> vrf  ]; 

];
Return[v]
];
]; 

Return[vis[r]];
]; 


variableToParameter[filename_?StringQ, var_, options___?OptionQ]:= Module[{model,m},
model=SBMLRead[filename, options];
m=variableToParameter[model, var];
Return[m];
];

variableToParameter[model_, var_]:= Module[{c, nc, uc, nuc, id, m, opts, odes, nxprime, dbg=False, ic, ics,icvars, icvals, constants, modelvals, parameters, assrule,assignmentrules, algrules,algrule,event, events, trigger, delay,eventid, eventAssignment, evnew, newevent, modelvariables, modelvars, species, speciescomps},
id  = Global`SBMLModelid/.model/.{Global`SBMLModelid-> ""};
If [id=="", Print["Error: "//boldRed, "This does not appear to be a valid SBML model. The model should be the output of SBMLRead."//boldBlue]; Return[$Failed]]; 
c = Cases[model, var[_], \[Infinity]];
nc = Length[c];
uc = Union[c];
nuc = Length[uc];

opts=First/@model;
If[dbg,
Print["variableToParameter: "//boldBlue, "Model: ",id," - the variable ", var, " occurs ", nc, " times, ",nuc, " times uniquely."]; 
Print["variableToParameter: "//boldBlue, " options: ", opts]; 
];


modelvariables = Global`SBMLModelVariables/.model;

If[!MemberQ[modelvariables, var[Global`t]],
Print["Error:"//boldRed, " variableToParameter: requested variable "//boldBlack, var//boldBlue, " is not speicified as a variable in the model. "//boldBlack];
];
modelvars = Complement[modelvariables, {var[Global`t], var}] // Sort;

odes = Global`SBMLODES/.model;
nxprime = Position[odes, var'[Global`t]];
If[dbg, Print["variableToParameter: "//boldBlue, " odes: ", odes]]; 

If[Length[nxprime]>0, 
(* remove ode if necessary *)
(* the following will only work if there is precisely one reference to x'[t] *)
nxprime = nxprime[[1, 1]];
odes = Delete[odes, nxprime];
odes =  odes/.{var[Global`t]-> var};
]; 

If[dbg, Print["variableToParameter: "//boldBlue, " odes: ", odes]]; 

(* Remove initial condition  *)
ics =( Global`SBMLIC/.model/.{Global`SBMLIC-> {}})/.{Equal-> Rule};
ic = var[0]/.ics;  

icvars = First/@ics;
icvars =Complement[icvars, {var[0]}];

icvals = icvars/.ics;
ics = MapThread[Equal, {icvars, icvals}]; 
If[dbg, Print["variableToParameter: "//boldBlue, " ics: ", ics]]; 



(* Add to lists of constants and parameters *)

constants = Global`SBMLConstants/.model;
constants = Append[constants, var-> ic];
parameters = Global`SBMLParameters/.model;
parameters = Append[parameters, var]; 

If[dbg, Print["variableToParameter: "//boldBlue, " parameters: ", parameters]]; 
If[dbg, Print["variableToParameter: "//boldBlue, " constants: ", constants]]; 

(* check to see if it is in an assignment rule *)

assignmentrules=Global`SBMLAssignmentRules/.model;
algrules = Global`SBMLAlgebraicRules/.model;

assrule = Cases[assignmentrules, Equal[var[Global`t], ___], Infinity];

If[Length[assrule]>0,
While[ListQ[assrule], assrule=First[assrule]];
algrule =Equal[0, Last[assrule]-var];
Print["Warning: "//boldRed, "variableToParameter: "//boldBlue," The variable "//boldBlack, var//boldBlue," was found in an assignment rule "//boldBlack, assrule//boldBlue,"\nThis will be replaced by the following algebraic rule, which could make the system over-determined and non-simulatable: "//boldBlack, algrule//boldBlue];
AppendTo[algrules, algrule];
assignmentrules = Complement[assignmentrules, {assrule}];
];
(* events are stored as text rather then expressions so it becomes more complicated *)

evnew = {};
events = Global`SBMLEvents/.model;
If[Length[events]>0, 
If[dbg, Print["variableToParameter: "//boldBlue, "events; ", events];
];

While[Length[events]>0,
event=First[events]; 
events=Rest[events];

eventid= First[event]; 
event=Last[event];

trigger = "trigger"/.event;
trigger = ToExpression[trigger]/.{var[Global`t]-> var};

delay = "delay"/.event;
delay = ToExpression[delay]/.{var[Global`t]-> var};

eventAssignment="events"/.event;
eventAssignment = ToExpression/@eventAssignment;
eventAssignment = (#/.{var[Global`t]-> var})&/@eventAssignment;

If[dbg, 
Print["variableToParameter:"//boldBlue,
"event: id: ", eventid, " trigger: ", trigger, " delay: ", delay, " assignment: ", eventAssignment];
];

(*determine if var is reset by eventAssignment *)

eventAssignment = eventAssignment/.{Rule-> List};
c = Cases[eventAssignment,{var, _}, Infinity];
eventAssignment = Rule@@#&/@eventAssignment;


If[Length[c]>0,
c = Rule@@#&/@c;

Print["Warning:"//boldRed, " variableToParameter: "//boldBlack, " requested variable "//boldBlack, var//boldBlue," is reset by the event assignment "//boldBlack,#//boldBlue ," in event "//boldBlack, eventid//boldBlue, " Removing this eventAssignment could change the intent of the model."//boldBlack]&/@c;

eventAssignment = Complement[eventAssignment, c]; 

If[dbg, Print["variableToParameter: "//boldBlue, " revised eventAssignments: ", eventAssignment];
];

]; (*End if length[c] > 0 *)

(* save the modified event *)

newevent = eventid-> {
"trigger"-> stringer[trigger], 
"delay"-> stringer[delay],
"events"-> (stringer/@eventAssignment)
};
AppendTo[evnew, newevent];

]; (* end while length events > 0 *)

If[dbg, 
Print["variableToParameter:"//boldBlue, " modified events: ", evnew];
]; 

]; (* end if length events > 0 *) 

(* if X is a species remove it from list of species *)

species = Global`SBMLSpecies/.model;
speciescomp = Global`SBMLSpeciesCompartmentAssociations/.model;
speciescomp=speciescomp/.{Rule-> List};

species = Complement[species, {var[Global`t], var}]; 
speciescomp = Select[speciescomp, stringer[First[#]]!= stringer[var]&];
speciescomp = Rule@@#&/@speciescomp;

(* replace X[t] with X throughout the model *)


modelvals =opts/. {Global`SBMLODES-> odes, 
Global`SBMLAlgebraicRules-> algrules, 
Global`SBMLAssignmentRules-> assignmentrules,
Global`SBMLConstants-> constants, 
Global`SBMLEvents-> evnew,Global`SBMLParameters-> parameters, Global`SBMLIC-> ics,
Global`SBMLModelVariables-> modelvars,
Global`SBMLSpecies -> species,
Global`SBMLSpeciesCompartmentAssociations-> speciescomp
}/.model;

m = MapThread[Rule, {opts, modelvals}];
m = m/.{var[Global`t]-> var}; 
m = Sort[m];

Return[m];
];

variableToParameter[x___]:= Print["Error: "//boldRed, "variableToParameter: invalid argument list\nValid syntax is either:\n\tvariableToParameter[filename, variable, options] or \n\tvariableToParameter[model,variable]\nwhere model is the output of SBMLRead."//boldBlack];


parametricScan[filename_?StringQ,  X_, XMIN_, XMAX_, DX_,Y_,  time_,
opt___?OptionQ]:= Module[{model},
model = SBMLRead[filename,evaluateParameters-> False,  opt];
Return[parametricScan[model, X, XMIN, XMAX, DX,Y,  time]];
];
parametricScan[model_, X_, XMIN_, XMAX_, DX_,Y_,  time_]:= Module[{x, results,num, m, value},
results={};
For[
x=XMIN,
x<= XMAX,
x=x+DX,

m=resetParameter[model, X, x];
num = SBMLNDSolve[m, time]; 
num = Flatten[num];
value = Y[Global`t]/.num/.{Global`t-> time};
AppendTo[results, {x, value}];
];
Return[results];
];
parametricScan[x___]:= Print["Error: "//boldRed, "parametricScan: incorrect arguments: correct formats are "//boldBlack,"\n\tparametricScan[filname, p, pmin, pmax, deltap, V, time] or\n\tparametricScan[model, p, pmin, pmax, deltap, V, time]\n"//boldBlack]; 


icScan[filename_?StringQ,  X_, XMIN_, XMAX_, DX_,Y_,  time_,
opt___?OptionQ]:= Module[{model},
model = SBMLRead[filename,evaluateParameters-> False,  opt];
Return[icScan[model, X, XMIN, XMAX, DX,Y,  time]];
];
icScan[model_, X_, XMIN_, XMAX_, DX_,Y_,  time_]:= Module[{x, results,num, m, value},
results={};
For[
x=XMIN,
x<= XMAX,
x=x+DX,

m=resetIC[model, X, x];
num = SBMLNDSolve[m, time]; 
num = Flatten[num];
value = Y[Global`t]/.num/.{Global`t-> time};
AppendTo[results, {x, value}];
];
Return[results];
];
icScan[x___]:= Print["Error: "//boldRed, "icScan: incorrect arguments: correct formats are "//boldBlack,"\n\ticScan[filname, p, pmin, pmax, deltap, V, time] or\n\ticScan[model, p, pmin, pmax, deltap, V, time]\n"//boldBlack]; 


If[$$LoadBug, Print["Loading: Model Builder"]];


(* 
MathMLToInfix[mathml_]:= Module[{s},
s =XML`MathML`MathMLToExpression[mathml]; 
Return[s];
];
*)

MathMLToInfix[mathml_]:= Module[{s,xmlelment,xmlobj},

xmlelement["cn",{"type"->"e-notation"},{m_,XMLElement["sep",{},{}],exp_}]:= 
XMLElement["apply",{},{XMLElement["times",{},{}],XMLElement["apply",{},{XMLElement["power",{},{}],XMLElement["cn",{"type"->"integer"},{"10"}],XMLElement["ci",{},{exp}]}],XMLElement["ci",{},{m}]}];
xmlelement[x___]:= XMLElement[x];

xmlobj["Document"][{},XMLElement[u___],{}]:= XMLElement[u];

s=ImportString[mathml, "SymbolicXML"];
s= s/.{XMLElement-> xmlelement}; 
s=s/.{XMLObject-> xmlobj};

s =XML`MathML`SymbolicMathMLToExpression[s]; 
Return[s];
];


InfixToMathML[infix_]:= Module[{s},
s = XML`MathML`ExpressionToMathML[infix, "Formats"-> {"ContentMathML"}]; 
Return[s];
];


sbmlBoolean[x_]:= Module[{y},
If[x, Return["true"]]; 
y=ToUpperCase[If[StringQ[x], x, ToString[x]]]; 
Return[If[y=="TRUE", "true", "false"]]; 
];


expression2SBML[x__]:= Module[{s},
s = expression2SymbolicSBML[x]; 
s = ExportXMLString[s];
Return[s];
];


reactionToSymbolicSBML[opts___?RuleQ]:= Module[{id, name, reactants, reactantStoichiometry, products, productStoichiometry, modifiers, kineticLaw,parameters, reversible, fast, timeUnits, substanceUnits, reaction, getrp, dbg=True, i, plus,opt,ann,notes,mann,pann,rann,metaid,mnotes,pnotes,rnotes,mmetaids,rmetaids,pmetaids,rsbos, msbos, psbos, sboTerm, n,ksbo,klawmetaid, padNull, getListData, getStringData},

padNull[list_, n_]:= Module[{modifiedList},
modifiedList = list;
While[Length[modifiedList]<n,
modifiedList = Append[modifiedList,{}];
];
Return[modifiedList];
]; (* end of padNull *)

opt=Flatten[{opts}]; 
(* the reaction could be the first option and need to filter this out before checking*)
(* 
checkOptions[reactionToSymbolicSBML, opt, 
{"annotation","fast","id","kineticLaw","kineticLawmetaid", "kineticLawSBOTerm","metaid","modifiers","modifierSBOTerms","name","notes","parameters","productmetaids","products","productSBOTerms","productStoichiometry","reactantmetaids","reactants","reactantSBOTerms","reactantStoichiometry","reaction","reversible","sboTerm","substanceUnits","timeUnits"} ];
*)

dbg = Global`debug/.opt/.{Global`debug-> False};

ann = {Global`annotation/.opt/.{Global`annotation-> {}}}//Flatten//optionToAnnotation;
notes = {Global`notes/.opt/.{Global`notes-> {}}}//Flatten//stringToNotes;

debugPrint[dbg,"reactionToSymbolicSBML: annotations ",ann];

getrp[Plus[r__]-> Plus[p__]]:=Module[{rlist, plist, rstoic, pstoic, getstoic, stoichiometry},

stoichiometry[x_]:=( x/.{Plus-> plus}); 

getstoic[s_* (x_?SIDQ) ]:= {x, s/.{plus-> Plus}};
getstoic[(x_?SIDQ )* s_]:= {x, s/.{plus-> Plus}};
getstoic[x_*y_]:= ( printWarning["Unable to distinguish stoichiometry from identifier in "<>ToString[InputForm[x*y]]]; Abort[];); 
getstoic[x_]:= If[
ToString[Head[x]]=="Symbol", 
Return[{x, 1}], 
Print["Warning: reactionToSymbolicSBML:"//boldRed, "Unable to determine stoichiometry or identifier of reactant "//boldBlack,ToString[InputForm[x]]//boldBlue, " in the reaction "//boldBlack, Plus[r]//boldBlue,"\[Rule]"//boldBlue, Plus[p]//boldBlue ]; 
Abort[];
]; (* end of getstoic *)

rlist = {r}/.{Global`Stoichiometry-> stoichiometry};
rlist = rlist/.{Plus-> List}//Flatten;
plist = {p}/.{Global`Stoichiometry-> stoichiometry};
plist = plist/.{Plus-> List}//Flatten;


rlist = Map[getstoic, rlist];
plist = Map[getstoic, plist];

{rlist, rstoic} = Transpose[rlist]/.{Global`Stoichiometry-> stoichiometry};
{plist, pstoic} = Transpose[plist]/.{Global`Stoichiometry-> stoichiometry}; 

debugPrint[dbg, "getRP: {rlist, rstoic,plist, pstoic}", {rlist, rstoic , plist, pstoic}]; 
Return[{rlist,rstoic, plist, pstoic}];
]; (* end of getrp *)


getrp[x___]:= {"Failed", "Failed","Failed", "Failed"}; 

id = stringer[(Global`id)/.opt/.{Global`id-> " "}];
If[id==" ",id = "reaction"<>ToString[MB$reactioncounter++]; ]; 

name = (Global`name)/.opt/.{Global`name-> id}; 
metaid=Global`metaid/.opt/.{Global`metaid-> ""}; 


sboTerm = Global`sboTerm/.opt/.{Global`sboTerm-> ""}; 
sboTerm = stringer[sboTerm];

debugPrint[dbg, "reactionTOSymbolicSBML opt: id, name:", {id, name}]; 


reaction = Global`reaction/.opt/.{Global`reaction-> {}};

debugPrint[dbg, "reactionToSymbolicSBML opt: reaction:", reaction];

{reactants, reactantStoichiometry, products, productStoichiometry}= getrp[reaction]; 

If[!(ListQ[reactants]&&ListQ[products]), 
debugPrint[dbg,"reactionToSymbolicSBML: !List: ", True]; 
reactants = {(Global`reactants)/.opt/.{Global`reactants-> {}}}//Flatten;
products = {(Global`products)/.opt/.{Global`products-> {}}}//Flatten;

reactantStoichiometry = {(Global`reactantStoichiometry)/.opt/.{Global`reactantStoichiometry-> {}}}//Flatten;
reactantStoichiometry = PadRight[reactantStoichiometry, Length[reactants],1];

productStoichiometry = {(Global`productStoichiometry)/.opt/.{Global`productStoichiometry-> {}}}//Flatten;
productStoichiometry = PadRight[productStoichiometry, Length[products], 1]; 

If[Length[reactants]==0 \[And] Length[products]==0,
reaction =First[opt]; 
{reactants, reactantStoichiometry, products, productStoichiometry}= getrp[reaction]; 
]; 

]; 


debugPrint[dbg, "reactionToSymbolicSBML opt: {reactants, products, reactantStoichimetry, productStoichiometry}", {reactants, products,reactantStoichiometry, productStoichiometry}];


modifiers = {(Global`modifiers)/.opt/.{Global`modifiers-> {}}}//Flatten;
kineticLaw = (Global`kineticLaw)/.opt/.{Global`kineticLaw->Indeterminate};
debugPrint[dbg, "reactionToSymbolicSBML opt: kineticLaw: ", kineticLaw]; 

timeUnits =stringer[ (Global`timeUnits)/.opt/.{Global`timeUnits->"time"}];
substanceUnits =stringer[ (Global`substanceUnits )/.opt/.{Global`substanceUnits ->"substance"}];
klawmetaid =stringer[Global`kineticLawmetaid/.opt/.{Global`kineticLawmetaid-> ""}]; 
ksbo=stringer[Global`kineticLawSBOTerm/.opt/.{Global`kineticLawSBOTerm-> ""}];

parameters=(Global`parameters)/.opt/.{Global`parameters-> {}}; 
If[!ListQ[parameters], parameters={parameters}]; 

reversible = (Global`reversible)/.opt/.{Global`reversible-> True};
reversible = sbmlBoolean[reversible]; 

fast = (Global`fast)/.opt/.{Global`fast-> False};
fast = sbmlBoolean[fast];


getListData[tag_, n_]:= Module[{listData},
listData =tag/.opt/.{tag-> Table[{}, {n}]}; 
listData = padNull[listData,n]; 
listData = Take[listData,n];
Return[listData];
];
getStringData[tag_, n_]:= Module[{listData},
listData =tag/.opt/.{tag-> Table["", {n}]}; 
listData=PadRight[listData,n,""]; 
listData = Take[listData,n];
Return[listData];
];
rann = getListData[Global`reactantannotations, Length[reactants]]; 
pann = getListData[Global`productannotations, Length[products]]; 
mann = getListData[Global`modifierannotations, Length[modifiers]]; 

rnotes = getListData[Global`reactantnotes, Length[reactants]]; 
pnotes = getListData[Global`productnotes, Length[products]]; 
mnotes = getListData[Global`modifiernotes, Length[modifiers]]; 

rmetaids = getStringData[Global`reactantmetaids, Length[reactants]]; 
pmetaids= getStringData[Global`productmetaids,Length[products]]; 
mmetaids= getStringData[Global`modifiermetaids,Length[modifiers]]; 

rsbos = getStringData[Global`reactantSBOTerms, Length[reactants]]; 
psbos= getStringData[Global`productSBOTerms,Length[products]]; 
msbos= getStringData[Global`modifierSBOTerms,Length[modifiers]]; 


Return[reactionToSymbolicSBML[id, name,metaid, reactants,reactantStoichiometry,  products, productStoichiometry, modifiers, kineticLaw,klawmetaid,  parameters,timeUnits, substanceUnits, reversible, fast,rann,pann,mann,ann,rmetaids,pmetaids,mmetaids, notes,rnotes,pnotes,mnotes, sboTerm, rsbos, psbos, msbos, ksbo]];

]; 


reactionToSymbolicSBML[{r_, opt___?OptionQ}]:= reactionToSymbolicSBML[Global`reaction-> r, opt]; 

reactionToSymbolicSBML[rid_, rname_,rmetaid_,  rreactants_, rreactantStoichiometry_, rproducts_,rproductStoichiometry_, rmodifiers_, rkineticLaw_,rklawmetaid_, rparameters_, timeUnits_, substanceUnits_, rreversible_, rfast_,rann_, pann_, mann_,annotation_,rmetaids_,pmetaids_,mmetaids_,notes_,rnotes_, pnotes_, mnotes_, sboTerm_, rsbos_, psbos_, msbos_, ksbo_]:= 
Module[
{id, name, reactants, metaid,reactantStoichiometry, products, productStoichiometry, modifiers,modifierStoichiometry, kineticLaw, reversible, fast, speciesReference, SBML,data, dbg=False, getpar,pars,klawann,klawnotes, klawopts,klawdata,  modifierSpeciesReference},


debugPrint[dbg,"reactionToSymbolicSBML: {rreactants, rproducts}", {rreactants, rproducts}]; 
debugPrint[dbg,"reactionToSymbolicSBML: {rreactantStoichiometry, rproductStoichiometry}", {rreactantStoichiometry, rproductStoichiometry}]; 

debugPrint[dbg,"reactionToSymbolicSBML: reactant annotations", rann]; 
debugPrint[dbg,"reactionToSymbolicSBML: product annotations", pann]; 
debugPrint[dbg,"reactionToSymbolicSBML: modifier annotations", mann]; 

modifierSpeciesReference[sp_, st_, ann_,Notes_,metaid_, sbo_:""]:= speciesReference[sp,st,ann,Notes,metaid, sbo]/.{"speciesReference"-> "modifierSpeciesReference"}; 

speciesReference[species_, stoichiometry_, ann_,Notes_, metaid_, sbo_:""]:= Module[
{s, data, sp,m,u},

sp = If[StringQ[species], species, ToString[species]]; 
If[!SIDQ[sp], 
Print["Warning: reactionToSymbolicSBML:"//boldOrange,
"Invalid species id = "//boldBlack,sp//boldRed];
explainSIDError[sp];
Abort[];
]; 

u={"species"-> sp};
m=stringer[metaid];
If[m!= "", u=Append[u,"metaid"-> m]];

If[StringLength[stringer[sbo]]>0,
If[ToExpression[MB$LevelVersion]>2.15, 
AppendTo[u, "sboTerm"-> stringer[sbo]],
Print["Error: "//boldRed, "reactionToSBML: speciesReference: "//boldBlack, 
" reaction: "//boldBlack, id//boldBlue, 
" species: "//boldBlack, species//boldBlue,
" SBOTerms are not permitted in "//boldBlack, "SBML Level "//boldBlue,MB$Level//boldBlue," Version "//boldBlue, MB$Version//boldBlue]


]
];

(* Revised 2.3.24 to put integer stoichiometry inline; revised 2.3.31 to allow any flotaing point value as well *)
If[NumberQ[stoichiometry] ,
If[stoichiometry !=  1, u = Append[u,"stoichiometry"-> ToString[InputForm[stoichiometry]]];
];
data={};
,
data = {expression2SymbolicSBML[stoichiometry]};
(* modified 5-24-04 to add the following *)
data = {XMLElement["stoichiometryMath", {}, data]}
];


data = Join[Notes, ann, data]//Flatten; 

s = XMLElement["speciesReference", u, data];
Return[s]; 
];(* end of speciesReferece *) 

id = If[StringQ[rid], rid, ToString[rid]]; 
If[SIDQ[id], 
data = {"id"-> id},
Print["Error: "//boldRed, "speciesToSymbolicSBML: reaction id "//boldBlack, id//boldRed, " is not a valid SID."//boldBlack];
Abort[]; 
]; 

name = If[StringQ[rname],rname, ToString[rname]];
If[StringLength[name]>0, data = Append[data, "name"-> name]]; 

metaid= stringer[rmetaid];
If[metaid!= "", data = Append[data,"metaid"-> metaid]];

reactants = {rreactants}//Flatten;
reactantStoichiometry = {rreactantStoichiometry}//Flatten;
reactantStoichiometry=PadRight[reactantStoichiometry, Length[reactants], 1];
reactants = MapThread[speciesReference, {reactants, reactantStoichiometry,rann,rnotes,rmetaids, rsbos} ]; 
reactants = XMLElement["listOfReactants", {}, reactants];

products = {rproducts}//Flatten;
productStoichiometry = {rproductStoichiometry}//Flatten;
productStoichiometry = PadRight[productStoichiometry, Length[products], 1]; 
products = MapThread[speciesReference, {products, productStoichiometry, pann,pnotes,pmetaids, psbos} ]; 
products = XMLElement["listOfProducts", {}, products]; 

modifiers = {rmodifiers}//Flatten;
modifierStoichiometry = Table[1, {Length[modifiers]}];
modifiers = MapThread[modifierSpeciesReference, {modifiers,modifierStoichiometry, mann,mnotes,  mmetaids,msbos} ]; 
modifiers = XMLElement["listOfModifiers", {}, modifiers]; 


getpar[pinput_]:= Module[{n,opts,  p,ann,parnotes,pin},
pin = pinput;
If[!(ToString[Head[pin]]== "Rule"),
pin = Rule[pin,{}];
];
n=First[pin]; opts=Last[pin];
If[ToString[Head[opts]]!= "List", 
opts = {"value"-> opts};
];

If[SameQ[Head[pinput], Rule], 
Block[{o}, 
o=Last[pinput];
o=Flatten[{o}]; 
If[OptionQ[o],
checkOptions[reactionToSymbolicSBML`kineticLaw`parameter, o, 
{"annotation","id","metaid","name", "notes", "sboTerm","value"} ]
];
];
];

opts = stringrule/@opts;
ann = "annotation"/.opts;
If[ToString[ann]=="annotation", ann={}]; 
 
parnotes ="notes"/.opts;
If[ToString[parnotes]=="notes",parnotes={},parnotes=stringToNotes[parnotes]];  
opts = Select[opts,( First[#]!= "annotation")\[And](First[#]!= "notes")&];
 
opts =stringrule/@opts;
opts = Select[opts, First[#]!= "id"&];
opts = Prepend[opts,"id"-> stringer[n]]; 
p=XMLElement["parameter", opts,{parnotes,ann}//Flatten];
Return[p];
]; 

(* end of getpar *) 


If[ToString[rkineticLaw]!= "Indeterminate", 
(* figure out parameters *)
 pars=getpar/@rparameters;
pars = XMLElement["listOfParameters",{},pars];
If[OptionQ[rkineticLaw],
klawann = "annotation"/.rkineticLaw;
If[ToString[klawann]=="annotation",klawann={}]; 
kineticLaw="math"/.rkineticLaw;
klawnotes = "notes"/.rkineticLaw;
If[ToString[klawnotes]=="notes",klawnotes={}]; 
,
kineticLaw=rkineticLaw;
klawann={};
klawnotes={};
]; 

debugPrint[dbg, "reactionToSymbolicSBML: kineticLaw:", kineticLaw];

kineticLaw = expression2SymbolicSBML[kineticLaw];

debugPrint[dbg, "reactionToSymbolicSBML: kineticLaw:", kineticLaw];

If[ToExpression[MB$LevelVersion]>2.25, 

(* timeUnits & substanceUnits outlawed in L2V3 *)
klawopts={};

If[stringer[timeUnits] != "time",Print["Error:"//boldRed, "reactionToSymbolicSBML:"//boldBlack, " reaction: "//boldBlack, id//boldBlue, " - \"timeUnits\" "//boldBlue, "(requested value: "//boldBlack,timeUnits//boldBlue,
") is not a permitted option for  a kineticLaw in "//boldBlack, "SBML Level "//boldBlue,MB$Level//boldBlue," Version "//boldBlue, MB$Version//boldBlue]
]; 
If[stringer[substanceUnits] != "substance", Print["Error:"//boldRed, "reactionToSymbolicSBML:"//boldBlack, " reaction: "//boldBlack, id//boldBlue, " - \"substanceUnits\" "//boldBlue, 
"(requested value: "//boldBlack,substanceUnits//boldBlue,  ") is not a permitted option for  a kineticLaw in "//boldBlack, "SBML Level "//boldBlue,MB$Level//boldBlue," Version "//boldBlue, MB$Version//boldBlue]]; 

,

klawopts={"timeUnits"-> timeUnits, "substanceUnits"-> substanceUnits}
];
If[rklawmetaid!= "", klawopts=Prepend[klawopts,"metaid"-> rklawmetaid]]; 

If[stringer[ksbo]!= "", 
If[ToExpression[MB$LevelVersion]>2.15, 
AppendTo[klawopts, "sboTerm"-> ksbo],
Print["Error: "//boldRed, "reactionToSymbolicSBML: "//boldBlack, " reaction: "//boldBlack, id//boldBlue, "kineticLawSBOTerm "//boldBlue, 
" is not permitted in "//boldBlack, "SBML Level "//boldBlue,MB$Level//boldBlue," Version "//boldBlue, MB$Version//boldBlue
]
]
];

klawdata=Join[{klawnotes},{klawann},{kineticLaw}, {pars}]//Flatten;
kineticLaw = XMLElement["kineticLaw", klawopts, klawdata];, 

kineticLaw = XMLElement["kineticLaw", {}, {}]
]; 

reversible = sbmlBoolean[rreversible]; 
data = Append[data, "reversible"-> reversible]; 

fast =sbmlBoolean[rfast];
data = Append[data, "fast"-> fast]; 

If[StringLength[stringer[sboTerm]]>0,
If[ToExpression[MB$LevelVersion]>2.15,
AppendTo[data, "sboTerm"-> sboTerm],
Print["Error: "//boldRed, "reactionToSymbolicSBML: "//boldBlack,"reaction: "//boldBlack, id//boldBlue, "sboTerm "//boldBlue, 
" is not permitted in "//boldBlack, "SBML Level "//boldBlue,MB$Level//boldBlue," Version "//boldBlue, MB$Version//boldBlue]
]

];

SBML = XMLElement["reaction", data,Join[notes, annotation,{reactants, products, modifiers, kineticLaw}]//Flatten];

Return[SBML];
];


speciesToSymbolicSBML[opts___?OptionQ]:= Module[{SBML, id, name, compartment, initialAmount, initialConcentration, units, boundaryCondition, charge, constant, icset,booleanate,opt,pia,pic, amount,concentration, ann,notes, metaid, arrayDimensions,
substanceUnits,spatialSizeUnits, hasOnlySubstanceUnits,  stype,dbg=False},

opt = Flatten[{opts}];

If[ToExpression[MB$LevelVersion]<2.3, 
checkOptions[speciesToSymbolicSBML, opt, {"id", "name", "speciesType", "compartment", "initialAmount", "initialConcentration", "substanceUnits", "spatialSizeUnits", "hasOnlySubstanceUnits","boundaryCondition", "charge", "constant", "metaid", "annotation", "notes"}]
, 
checkOptions[speciesToSymbolicSBML, opt, {"id", "name", "speciesType", "compartment", "initialAmount", "initialConcentration", "substanceUnits", "hasOnlySubstanceUnits","boundaryCondition", "charge", "constant", "metaid", "annotation", "notes"}]
];


If[Length[opt]>0, 
If[MemberQ[First/@opt, "charge"], 
If[ToExpression[MB$LevelVersion]>2.1, 
Print["Warning: "//boldRed, "The charge field has been deprecated in SBML Level "//boldBlack, MB$Level//boldBlack, " Version "//boldBlack, MB$Version//boldBlack]]
]
]; 

booleanate[x_]:= If[ToUpperCase[stringer[x]]=="TRUE","true","false"];
SBML={};

id = (Global`id/.opt/.{Global`id-> ""})//stringer;
If[id=="", 
id = "species"<>ToString[MB$speciescounter++];
Print["Error: "//boldRed, "speciesToSymbolicSBML: species id not specified. A value of "//boldBlack,id//boldBlue," was used."//boldBlack ];
];
name=stringer[Global`name/.opt/.{Global`name-> id}];


If[!SIDQ[id] , Print["Error: "//boldRed, "speciesToSymbolicSBML: Species "//boldBlack,id//boldBlue," is not a valid SID."//boldBlack ];Abort[];];



ann = {Global`annotation/.opt/.{Global`annotation-> {}}}//Flatten//optionToAnnotation;
notes = {Global`notes/.opt/.{Global`notes-> {}}}//Flatten//stringToNotes;
arrayDimensions = getArrayDimensions[id,opt]; 

constant=booleanate[Global`constant/.opt/.{Global`constant-> "false"}];

boundaryCondition=booleanate[Global`boundaryCondition/.opt/.{Global`boundaryCondition-> "false"}]; 

compartment=stringer[Global`compartment/.opt/.{Global`compartment-> ""}]; 

If[compartment=="", 
compartment="compartment"<>ToString[MB$compartmentcounter++];
Print["Error: "//boldRed, "speciesToSBML: compartment not specified for species "//boldBlack, id//boldBlue, "\nThis is a required field. A value of "//boldBlack,compartment//boldBlue, " was used instead."//boldBlack];
]; 

stype=stringer[Global`speciesType/.opt/.{Global`speciesType-> ""}]; 
SBML = {"id"-> id, "name"-> name, "compartment"-> compartment, "boundaryCondition"-> boundaryCondition, "constant"-> constant};

If[stype!= "",
If[ToExpression[MB$LevelVersion]>2.1,
SBML=Append[SBML,"speciesType"-> stype];
,
Print["Warning:"//boldOrange," speciesType is not allowed in version"//boldBlack, MB$LevelVersion//boldBlack, " but was used for species"//boldBlack, id//boldBlack];
]; 
];




metaid = Global`metaid/.opt/.{Global`metaid-> ""}; 
metaid=stringer[metaid];
If[metaid!= "", SBML = Append[SBML,"metaid"-> metaid]]; 


(* allow initial Amount and concentration to be given either as a number or as a string containing a number *)
initialAmount=(Global`initialAmount/.opt/.{Global`initialAmount-> Indeterminate})//deFortranize;
amount = NumberQ[initialAmount];

initialConcentration=(Global`initialConcentration/.opt/.{Global`initialConcentration-> "Indeterminate"})//deFortranize;
concentration = NumberQ[initialConcentration]; 

If[amount \[And] concentration,
(* determine which is first *)
pia = Position[opt,Global`initialAmount];
While[ListQ[pia], pia = First[pia]]; 
pic = Position[opt,Global`initialConcentration];
While[ListQ[pic], pic = First[pic]];

If[pia<pic, amount=True, amount=False];
concentration = Not[amount];

];

icset = False;
If[amount,
initialAmount=ToString[FortranForm[initialAmount]];
SBML = Append[SBML, "initialAmount"-> initialAmount];
]; 

If[concentration,
initialConcentration = ToString[FortranForm[initialConcentration]]; 
SBML = Append[SBML, "initialConcentration"-> initialConcentration]; 
]; 

(* figure out and debug units *)
(* version 1 emulation *) 

units=stringer[Global`units/.opt/.{Global`units-> "Indeterminate"}];
If[units!= "Indeterminate", SBML = Append[SBML, "units"-> units]]; 

(* version 2 unit specifiers *)

substanceUnits=Global`substanceUnits/.opt/.{Global`substanceUnits-> "substance"};
SBML=Append[SBML, "substanceUnits"-> substanceUnits];

hasOnlySubstanceUnits=Global`hasOnlySubstanceUnits/.opt/.{Global`hasOnlySubstanceUnits->False};
SBML=Append[SBML, "hasOnlySubstanceUnits"-> booleanate[hasOnlySubstanceUnits]];

spatialSizeUnits=Global`spatialSizeUnits/.opt/.{Global`spatialSizeUnits->"Indeterminate"};
spatialSizeUnits=stringer[spatialSizeUnits];

If[dbg, Print["speciesToSymbolicSBML: speciesToSymbolicSBML: spatialSizeUnits: ", spatialSizeUnits]];

If[spatialSizeUnits!= "Indeterminate", SBML = Append[SBML, "spatialSizeUnits"-> spatialSizeUnits]]; 

If[dbg, Print["speciesToSymbolicSBML: speciesToSymbolicSBML: SBML: ", SBML]];

(* don't do any checking with global compartments - that has to be done in addCompartment - because this function may be used as stand-alone *)

charge=Global`charge/.opt/.{Global`charge-> Indeterminate}//deFortranize//Round;

If[NumberQ[charge],
SBML = Append[SBML, "charge"-> ToString[charge]];
If[!IntegerQ[charge],
Print["Warning: "//boldOrange,"charge "//boldBlue," is set to a non integer value for species "//boldBlack, id//boldBlue]
];
, 
If[stringer[charge]!= "Indeterminate", 
Print["Warning: "//boldOrange, "charge \[Rule] "<>stringer[InputForm[charge]]//boldBlue," is not a numeric quantity for species "//boldBlack, id//boldBlue];
];

];
SBML = XMLElement["species", SBML, Join[notes,ann, arrayDimensions]//Flatten];
Return[SBML];
];

speciesToSymbolicSBML[id_,opt___?OptionQ]:= speciesToSymbolicSBML[Global`id-> id, opt];


compartmentTypeToSymbolicSBML[opt___?OptionQ]:= Module[{opts, id, name, value, units, constant, SBML,ann, notes,metaid,fixnotes, arrayDimensions,foreach},

If[ToExpression[MB$LevelVersion]<2.15, 
Print["Error: "//boldRed, "compartmentTypeToSymbolicSBML: compartmentType is not defined in "//boldBlack," SBML Level "//boldBlue, MB$Level//boldBlue," version "//boldBlue, MB$Version//boldBlue ];
];

opts=Flatten[{opt}];

checkOptions[compartmentTypeToSymbolicSBML, opts, {"id", "name", "metaid", "annotation", "notes"}];


id =stringer[ Global`id/.opts/.{Global`id-> ""}];
If[id=="",Print["Error:"//boldRed,"compartmentTypeToSymbolicSBML: A compartmentType id must be specified."//boldBlack];Return[]];
If[!SIDQ[id],
Print["Error: "//boldRed, "compartmentTypeToSymbolicSBML: compartmentType id "//boldBlack, id//boldBlue, " is not a valid SID."//boldBlack];
Abort[];
];
SBML = {"id"-> id}; 
name=stringer[Global`name/.opts/.{Global`name-> ""}];
If[name!= "", SBML =Append[SBML,"name"-> name]]; 

metaid = Global`metaid/.opts/.{Global`metaid-> ""}; 
metaid=stringer[metaid];
If[metaid!= "", SBML = Append[SBML,"metaid"-> metaid]]; 

ann = {Global`annotation/.opts/.{Global`annotation-> {}}}//Flatten//optionToAnnotation; 
notes = {Global`notes/.opts/.{Global`notes-> {}}}//Flatten//stringToNotes;


SBML = XMLElement["compartmentType", SBML, Join[notes,ann]//Flatten];
Return[SBML];
];

compartmentTypeToSymbolicSBML[id_, opt___?OptionQ]:= compartmentTypeToSymbolicSBML[Global`id-> id, opt];


speciesTypeToSymbolicSBML[opt___?OptionQ]:= Module[{opts, id, name, value, units, constant, SBML,ann, notes,metaid,fixnotes, arrayDimensions,foreach},

If[ToExpression[MB$LevelVersion]<2.15, 
Print["Error: "//boldRed, "speciesTypeToSymbolicSBML: speciesType is not defined in "//boldBlack," SBML Level "//boldBlue, MB$Level//boldBlue," version "//boldBlue, MB$Version//boldBlue ];
];


opts=Flatten[{opt}];

checkOptions[speciesTypeToSymbolicSBML, opts, {"id", "name", "metaid", "annotation", "notes"}];

id =stringer[ Global`id/.opts/.{Global`id-> ""}];
If[id=="",Print["Error:"//boldRed,"speciesTypeToSymbolicSBML: A speciesType id must be specified."//boldBlack];Return[]];
If[!SIDQ[id],
Print["Error: "//boldRed, "speciesTypeToSymbolicSBML: speciesType id "//boldBlack, id//boldBlue, " is not a valid SID."//boldBlack];
Abort[];
];
SBML = {"id"-> id}; 
name=stringer[Global`name/.opts/.{Global`name-> ""}];
If[name!= "", SBML =Append[SBML,"name"-> name]]; 

metaid = Global`metaid/.opts/.{Global`metaid-> ""}; 
metaid=stringer[metaid];
If[metaid!= "", SBML = Append[SBML,"metaid"-> metaid]]; 

ann = {Global`annotation/.opts/.{Global`annotation-> {}}}//Flatten//optionToAnnotation; 
notes = {Global`notes/.opts/.{Global`notes-> {}}}//Flatten//stringToNotes;


SBML = XMLElement["speciesType", SBML, Join[notes,ann]//Flatten];
Return[SBML];
];

speciesTypeToSymbolicSBML[id_, opt___?OptionQ]:= speciesTypeToSymbolicSBML[Global`id-> id, opt];


functionToSymbolicSBML[opt___?OptionQ]:= Module[{SBML, name, id,opts,arguments,math,f,x,sx, ann,notes, metaid,sboTerm,  debug= False},(* sx =  StringReplace[ToString[x],"$"-> ""]; *)
sx = "UnusedDummyVariable";
opts = Flatten[{opt}];

If[ToExpression[MB$LevelVersion]>2.15,
checkOptions[functionToSymbolicSBML, opts, {"id", "name","math", "arguments", "sboTerm", "metaid", "annotation", "notes"}]
,
checkOptions[functionToSymbolicSBML, opts, {"id", "name","math","arguments", "metaid", "annotation", "notes"}];
];

id = stringer[( Global`id/.opts)/.{ Global`id-> ""}];
If[id == "", id = "function"<>ToString[MB$functioncounter++]];
If[!SIDQ[id],
Print["Error: "//boldRed, "functionToSymbolicSBML: function id "//boldBlack, id//boldRed, " is not a valid SID."//boldBlack];
Abort[];
];

name = stringer[ Global`name/.opts/.{ Global`name-> id}];

arguments = Global`arguments/.opts/.{ Global`arguments-> {}}//expressionate;
arguments = Flatten[{arguments}];
arguments = destring/@arguments; 

If[Length[arguments]<1, 
(* An argument is required because otherwise Mathematica
will not create a lambda definition *)
arguments={x}; 
]; 

math =  Global`math/.opts/.{ Global`math-> "NONE"};
If[stringer[math]=="NONE", 
Print[
boldRed["Warning: "],
boldBlack["functionToSymbolicSBML: No function definition was specified for the function "],
boldRed[id],
boldBlack["\nA value of 1 will be returned."]
];
math=1;
];
 
math = destring[math]; 

ann = {Global`annotation/.{opt}/.{Global`annotation-> {}}}//Flatten//optionToAnnotation;

metaid = Global`metaid/.{opt}/.{Global`metaid->""};
metaid=stringer[metaid];

sboTerm=stringer[Global`sboTerm/.{opt}/.{Global`sboTerm-> ""}]; 

notes ={ Global`notes/.{opt}/.{Global`notes-> {}}}//Flatten; 
If[debug ,Print["functionToSymbolicSBML: notes:"//boldRed, notes//boldBlue]];
notes =stringToNotes[notes];
If[debug ,Print["functionToSymbolicSBML: notes:"//boldRed, notes//boldBlue]];

SBML = expression2SymbolicSBML[f[arguments, math]/.{f-> Function}, id, name,metaid,ann,notes,sboTerm];
SBML = SBML/.{ToString[x]-> sx};
Return[SBML];
];

functionToSymbolicSBML[x_, opt___?OptionQ]:= functionToSymbolicSBML[Global`id-> x, opt];


parameterToSymbolicSBML[pid_-> (nvalue_?numericalFormQ),opt___?OptionQ]:= parameterToSymbolicSBML[Global`id-> pid, Global`value-> nvalue,opt];

parameterToSymbolicSBML[opt___?OptionQ]:= Module[{opts, id, name, value, units, constant, sbo, SBML,ann, notes,metaid,fixnotes, arrayDimensions,foreach},

opts=Flatten[{opt}];

If[ToExpression[MB$LevelVersion]>2.15, 
checkOptions[parameterToSymbolicSBML, opts, 
{"id", "name", "metaid", "annotation", "notes", "value", "units", "constant","sboTerm"}],
checkOptions[parameterToSymbolicSBML, opts, 
{"id", "name", "metaid", "annotation", "notes", "value", "units", "constant"}]
]; 



id =stringer[ Global`id/.opts/.{Global`id-> ""}];
If[id=="",id = "parameter"<>ToString[MB$parametercounter++]];
If[!SIDQ[decontextify[id]],
Print["Error: "//boldRed, "parameterToSymbolicSBML: parameter id "//boldBlack, id//boldRed, " is not a valid SID, input options: "//boldBlack, {opt}//boldBlue];
Abort[];
];
name=stringer[Global`name/.opts/.{Global`name-> id}];
SBML = {"id"-> id, "name"-> name}; 

metaid = Global`metaid/.opts/.{Global`metaid-> ""}; 
metaid=stringer[metaid];
If[metaid!= "", SBML = Append[SBML,"metaid"-> metaid]]; 

ann = {Global`annotation/.opts/.{Global`annotation-> {}}}//Flatten//optionToAnnotation; 
notes = {Global`notes/.opts/.{Global`notes-> {}}}//Flatten//stringToNotes;
arrayDimensions = getArrayDimensions[id,opts]; 


value=Global`value/.opts/.{Global`value-> "Indeterminate"}//deFortranize; 
If[NumberQ[value], 
 SBML =Append[SBML, "value"-> stringer[FortranForm[value]]]; ];

foreach=(Global`foreach/.opts/.{Global`foreach-> ""})//stringer;
If[foreach!= "",
If[ifArrays[],SBML=Append[SBML,"foreach"-> foreach]];
]; 

units = stringer[Global`units/.opts/.{Global`units-> ""}];
If[units!= "", SBML = Append[SBML, "units"-> units]];

sbo = stringer[Global`sboTerm/.opts/.{Global`sboTerm-> ""}];

If[StringLength[sbo]>0,
If[ToExpression[MB$LevelVersion]>2.15,
SBML=Append[SBML,"sboTerm"-> sbo],
Print["Error: "//boldRed, "parameterToSymbolicSBML: "//boldBlack , "sboTerm"//boldBlue, " is not defined in SBML "//boldBlack,
"Level "//boldBlue, MB$Level//boldBlue," Version "//boldBlue, MB$Version//boldBlue]
];
]; 

constant=stringer[Global`constant/.opts/.{Global`constant-> "true"}];
If[ToUpperCase[constant]!= "TRUE",
If[constant=="false" \[Or] ToUpperCase[constant]=="FALSE",
SBML = Append[SBML, "constant"-> "false"]; 
,
Print["Warning: "//boldOrange, "constant = "//boldBlack, constant//boldRed, " for parameter "//boldBlack, id//boldRed," The constant field must be either \"true\" or \"false\""];
]; 
]; 

SBML = XMLElement["parameter", SBML, Join[notes,ann, arrayDimensions]//Flatten];
Return[SBML];
];

parameterToSymbolicSBML[id_, opt___?OptionQ]:= Module[{dbg=False}, 
If[dbg, Print["parameterToSymbolicSBML: id=", id, " {opt}=", {opt}]]; 
Return[parameterToSymbolicSBML[Global`id-> id, opt]]];


checkUnitKind[id_, kind_]:= Module[{allowedKinds={"ampere","becquerel","candela","Celsius","coulomb","dimensionless","farad","gram","gray","henry","hertz","item","joule","katal","kelvin","kilogram","litre","lumen","lux","metre","mole","newton","ohm","pascal","radian","second","siemens","sievert","steradian","tesla","volt","watt","weber", "substance","volume","time","area", "length"},
nestmsg,ispredefined, isdefined},

nestmsg="";
ispredefined=MemberQ[allowedKinds, stringer[kind]];
isdefined=MemberQ[First/@MB$Units, stringer[kind]];

If[ToExpression[MB$LevelVersion]>2.1,
If[Equal[stringer[kind],stringer[id]],
Print["Error:"//boldOrange," Unit definition "//boldBlack,id//boldOrange," self refers."//boldBlack];
Abort[];
]; 
If[isdefined \[Or] ispredefined, Return[True]];
,
If[ispredefined, Return[True]];
If[isdefined,
nestmsg=boldBlack[" --- Nested unit definitions are not allowed in Level "<>MB$Level<>" Version "<>MB$Version];
];
];
Print["Error:"//boldRed, "Invalid "//boldBlack, "kind"//boldBlue, " = "//boldBlack, stringer[kind]//boldBlue, " specified in listOfUnits for unit "//boldBlack, id//boldBlue,nestmsg, "\nThe allowed values of "//boldBlack, "kind"//boldBlue, " are "//boldBlack, allowedKinds//boldBlue];

Return[False]; 
];



unitToSymbolicSBML[opt___?OptionQ]:= Module[{SBML, name, id,opts,ann,metaid,s,
unit,x, getkind, dbg=False},

If[dbg, Print["unitToSymbolicSBML: {opt}:"//boldRed,{opt}//boldBlue]]; 

checkOptions[unitToSymbolicSBML, Flatten[{opt}], {"id", "name","unit", "metaid", "annotation", "notes"}];

getkind[kind_-> (optin___?OptionQ)]:= Module[{opts,exponent,scale,multiplier,offset,unit,ann, metaid},
opts=Flatten[{optin}]; 

checkOptions[unitToSymbolicSBML`unit, opts,
{"exponent","scale","multiplier", "offset","kind", "annotation", "notes","metaid"}
];

exponent=Global`exponent/.opts/.{Global`exponent-> 1};
scale = Global`scale/.opts/.{Global`scale-> 0}; 
multiplier=Global`multiplier/.opts/.{Global`multiplier-> 1};
offset=Global`offset/.opts/.{Global`offset-> 0};

ann = Global`annotation/.opts/.{Global`annotation-> {}};
ann = Flatten[{ann}]//optionToAnnotation; 

metaid=stringer[Global`metaid/.opts/.{Global`metaid-> ""}]; 

unit={"kind"-> stringer[kind]};
If[metaid!= "", unit=Append[unit,"metaid"->metaid]]; 

If[exponent!= 1, unit=Append[unit,"exponent"-> ToString[FortranForm[exponent]]]];
If[scale!= 0, unit=Append[unit,"scale"->ToString[FortranForm[ scale]]]];
If[multiplier!= 1, unit=Append[unit,"multiplier"-> ToString[FortranForm[multiplier]]]];
If[offset!= 0, unit=Append[unit,"offset"-> ToString[FortranForm[offset]]]];


If[!checkUnitKind[id, kind],Abort[]]; 
unit=XMLElement["unit",unit,ann]; 
Return[unit];

]; 
getkind[kind_]:=Module[{},
If[!checkUnitKind[id, kind],Abort[]]; 
Return[XMLElement["unit",{"kind"-> stringer[kind]},{}]]
];
getkind[kind___]:=Module[{},
Print["Warning:"//boldOrange,"Invalid unit kind for "//boldBlack,id//boldRed," kind = "//boldBlack, kind//boldRed," assumed dimensionless."//boldBlack];
Return[XMLElement["unit",{"kind"-> "dimensionless"},{}]]
];


opts = Flatten[{opt}];
id = stringer[( Global`id/.opts)/.{ Global`id-> ""}];
If[id == "", id = "unit"<>ToString[MB$unitcounter++]];
If[!SIDQ[id],
Print["Error: "//boldOrange, "unitToSymbolicSBML: unit id "//boldBlack, id//boldRed, " is not a valid SID."//boldBlack];
Abort[];
];
name = stringer[ Global`name/.opts/.{ Global`name-> id}];
unit = Global`unit/.opts/.{Global`unit-> {"dimensionless"-> {}}}; 
ann = {Global`annotation/.opts/.{Global`annotation-> {}}}//Flatten//optionToAnnotation;

If[Length[unit]<1, 
Print["Warning: "//boldOrange, "No <unit kind=.../> specified for "//boldBlack,id//boldRed, ". At least one unit must be specified."//boldBlack];
]; 

If[dbg, Print["unitToSymbolicSBML: unit(1):"//boldRed,unit//boldBlue]]; 

unit = Map[getkind, unit];
If[dbg, Print["unitToSymbolicSBML: unit(2):"//boldRed,unit//boldBlue]]; 

SBML = Join[ann,{XMLElement["listOfUnits",{},unit]}]; 

s={"id"->stringer[ id],"name"-> stringer[name]};

metaid = Global`metaid/.opts/.{Global`metaid-> ""}; 
metaid=stringer[metaid]; 
If[metaid!= "", s = Append[s,"metaid"-> metaid]]; 


SBML=XMLElement["unitDefinition",s ,SBML];
Return[SBML];
];


compartmentToSymbolicSBML[opt___?OptionQ]:= Module[{opts, id, name, spatialDimensions, size, units, outside, constant, SBML,ann,notes, metaid, arrayDimensions,allowedOpts,ctype},

allowedOpts={Global`id,Global`name,Global`spatialDimensions, Global`size,Global`units,Global`outside,Global`constant,Global`notes,Global`annotation,Global`metaid};
If[ToExpression[MB$LevelVersion]>2.1, allowedOpts=Append[allowedOpts,Global`compartmentType];
]; 

opts=Flatten[{opt}]; 

checkOptions[compartmentToSymbolicSBML, opts, allowedOpts];

id = stringer[( Global`id/.opts)/.{ Global`id-> ""}];
If[id == "", id = "compartment"<>ToString[MB$compartmentcounter++]];

If[!SIDQ[id],
Print["Error: "//boldRed, "compartmentToSymbolicSBML: compartment id "//boldBlack, id//boldBlue, " is not a valid SID."//boldBlack];
Abort[];
];

name = stringer[ Global`name/.opts/.{ Global`name-> id}];
SBML = {"id"-> id, "name"-> name};
metaid =( Global`metaid/.opts/.{Global`metaid-> ""})//stringer;
metaid=stringer[metaid];
If[metaid!= "", SBML = Append[SBML,"metaid"-> metaid]]; 

ann = {Global`annotation/.opts/.{Global`annotation-> {}}}//Flatten//optionToAnnotation;
notes = {Global`notes/.opts/.{Global`notes-> {}}}//Flatten//stringToNotes; 


spatialDimensions=stringer[Global`spatialDimensions/.opts/.{Global`spatialDimensions-> 3}];
If[spatialDimensions!= "3",
If[MemberQ[{"0","1","2"}, spatialDimensions],
SBML=Append[SBML,"spatialDimensions"-> spatialDimensions]
, 
Print["Error:"//boldRed," compartmentToSymbolicSBML: Invalid "//boldBlack, " spatialDimensions \[Rule] "//boldBlue, spatialDimensions//boldBlue, " for compartment "//boldBlack,id//boldBlue," Allowed values of spatialDimensions are: 0, 1, 2, or 3."//boldBlack];
];
,
SBML=Append[SBML,"spatialDimensions"-> spatialDimensions];
];
units = stringer[Global`units/.opts/.{Global`units-> ""}]; 

If[units=="",
Switch[spatialDimensions,
"3",units="volume",
"2",units="area",
"1",units="length",
"0",units="dimensionless"
];
];
If[units!= "", SBML=Append[SBML,"units"-> units],
Print["Error:"//boldRed," compartmentToSymbolicSBML: Unable to determine units for compartment "//boldBlack, name//boldBlue]]; 

size = deFortranize[Global`size/.opts/.{Global`size-> "Indeterminate"}];
If[NumberQ[size],SBML = Append[SBML,"size"-> stringer[FortranForm[size]]]];

constant =stringer[ Global`constant/.opts/.{Global`constant-> "true"}]//ToUpperCase;
If[constant=="FALSE",
SBML = Append[SBML, "constant"-> "false"];,
If[constant!= "TRUE",
Print["Error: "//boldRed, "allowed values for constant are true and false, not "//boldBlack, constant//boldBlue];
SBML = Append[SBML, "constant"-> "true"];
]];


outside = stringer[Global`outside/.opts/.{Global`outside-> ""}];
If[outside!= "",SBML = Append[SBML,"outside"-> outside]];

If[ToExpression[MB$LevelVersion]>2.1, 
ctype=stringer[Global`compartmentType/.opts/.{Global`compartmentType-> ""}];
If[ctype!= "", SBML=Append[SBML,"compartmentType"-> ctype]]; 
]; 



(* If Arrays are allowed, check for dimensions: note that getArrayDimensions always returns a list: with an XMLElment if arrays are allowed, and an empty list if not! *) 

arrayDimensions = getArrayDimensions[id,opts]; 

SBML = XMLElement["compartment",SBML,Join[notes,ann,arrayDimensions]//Flatten];
Return[SBML];
];


initialAssignmentToSymbolicSBML[opt___?OptionQ]:= Module[{allowedOptions={Global`symbol, Global`math, Global`sboTerm, Global`notes, Global`annotation, Global`metaid}, opts,meta, sbo, s, expr, ann, notes},
s= Global`symbol/.{opt}/.{Global`symbol-> ""};
expr=Global`math/.{opt}/.{Global`math-> "?"};
sbo=stringer[Global`sboTerm/.{opt}/.{Global`sboTerm-> ""}];
meta=stringer[Global`metaid/.{opt}/.{Global`metaid-> ""}];

If[stringer[s]=="", 
Print["Error: "//boldRed, "initialAssignmentToSymbolicSBML: no symbol."//boldBlack];
];
If[stringer[expr]=="?", 
Print["Error: "//boldRed, "initialAssignmentToSymbolicSBML: no math."//boldBlack];
expr=1;
];

ann =Flatten[{Global`annotation/.{opt}/.{Global`annotation-> {}}}]; 
If[Length[ann]>0, ann={annotationToSymbolicSBML@@ann}]; 
notes = {Global`notes/.{opt}/.{Global`notes-> {}}}//Flatten//stringToNotes;



checkOptions[initialAssignmentToSymbolicSBML, Flatten[{opt}], {"symbol","math", "sboTerm", "metaid", "annotation", "notes"}];

(* opts =First/@{opt};
opts=Complement[opts, allowedOptions];
Print["Error: "//boldRed, "initialAssignmentToSymbolicSBML: invalid Option: "//boldBlack, quote[#]//boldBlue, " valid options are: "//boldBlack, allowedOptions//boldBlack]&/@opts;
*)

Return[initialAssignmentToSymbolicSBML[s, expr,ann, notes, meta,sbo]];

];
initialAssignmentToSymbolicSBML[symbol_, math_,ann_, notes_,metaid_,  SBOTerm_:""]:= Module[{mathml, opts,sub, sbo,ia, meta},

If[!MemberQ[First/@$SBML$IDTable,stringer[symbol]], Print["Error: "//boldRed, "initialAssignmentToSymbolicSBML: "//boldBlack, 
" Unknown symbol\[Rule]"//boldBlack, symbol//boldBlue, " not previously defined specified in initialAssignment."//boldBlack
]];

mathml ={ expression2SymbolicSBML[math]};
opts={"symbol"-> stringer[symbol]};
sbo = stringer[SBOTerm];
If[StringLength[sbo]>0,
opts= Append[opts, "SBOTerm"-> sbo];
];
meta=stringer[metaid];
If[StringLength[meta]>0, 
opts=Append[opts, "metaid"-> meta];
];

sub=mathml;

If[Length[notes]>0, 
sub=Flatten[Append[{sub},notes]]
];
If[Length[ann]>0, 
sub=Flatten[Append[{sub},ann]]
];
ia = XMLElement["initialAssignment", opts, sub];
Return[ia]
];


ruleToSymbolicSBML[opt___?OptionQ]:= Module[{SBML,type, TYPE,opts,math,variable,varname,data,subdata, id,  metaid, ann, notes, arrayDimensions,variableLink,setAnnotation,matrixresult,fromindices, toindices, sboTerm,fromcompartment, tocompartment, debug=False, connection, indices,mathinput, inputType},




varname[]:= Module[{v},
v = stringer[Global`variable/.opts/.{Global`variable-> ""}];
(* If[v=="",v="variable"<>ToString[MB$variablecounter++]; ];*) 
If[v=="",
Print["Error:"//boldRed,"ruleToSymbolicSBML: "//boldBlack,
"A variable is required for an "//boldBlack,type//boldBlue,
" --- No variable was specified for the rule (type="//boldBlack,inputType//boldBlue,") with math "//boldBlack,mathinput//boldRed
];
Abort[];
];

If[!MemberQ[First/@$SBML$IDTable,v], Print["Error: "//boldRed, "ruleToSymbolicSBML: "//boldBlack, 
" Unknown "//boldBlack, " variable\[Rule]"//boldBlue, v//boldBlue, " not previously defined in model specified in rule  ("//boldBlack,"type\[Rule]"//boldBlue, inputType//boldBlue,")."//boldBlack
]];

Return[v];  
]; 

opts=Flatten[{opt}];
If[ToExpression[MB$LevelVersion]>2.15, 

(* "id" is translated to "metaid" later in the program *)

checkOptions[ruleToSymbolicSBML, opts, 
{ "metaid", "annotation", "notes","math","variable","id","type","sboTerm"}],
checkOptions[ruleToSymbolicSBML, opts, 
{ "metaid", "annotation", "notes","math","variable","id", "type"}]
];

type = stringer[Global`type/.opts/.{Global`type-> ""}];
inputType=type;

TYPE = ToUpperCase[type];
math = Global`math/.opts/.{Global`math-> Indeterminate}; 

If[SameQ[math,Indeterminate] \[And] TYPE != "INITIALASSIGNMENTRULE",
Print["Error:"//boldRed,
"The "//boldBlack,"math "//boldBlue," option is required for any rule. Options found: "//boldBlack,({opt})//boldBlue
];
Abort[];
];

If[debug,
Print["ruleToSymbolicSBML: math:"//boldRed,math//boldBlue];
Print["ruleToSymbolicSBML: StringQ[math]:"//boldRed,StringQ[math]//boldBlue];
];

If[StringQ[math], math=ToExpression[math]];
If[debug,Print["ruleToSymbolicSBML: math:"//boldRed,math//boldBlue];];

mathinput=math;
math ={ expression2SymbolicSBML[math]};

ann = {Global`annotation/.opts/.{Global`annotation-> {}}}//Flatten//optionToAnnotation;

notes = {Global`notes/.opts/.{Global`notes-> {}}}//Flatten//stringToNotes; 

arrayDimensions = getArrayDimensions[id,opts]; 
variableLink=getObjectLink[Global`variableLink,opt]; 

matrixresult=ifArrays[]\[And]Global`matrixResult/.opts/.{Global`matrixrResult-> False};

If[ifArrays[],connection=(Global`connection/.opts/.{Global`connection-> ""})//stringer;
indices = {Global`indices/.opts/.{Global`indices-> {}}}//Flatten;
,
connection="";
indices={};
];

(* If id is given, add metaid since there is no id field in SBML for rules*)

metaid = stringer[Global`metaid/.opts/.{Global`metaid-> ""}];id = stringer[Global`id/.opts/.{Global`id-> ""}];
If[metaid=="" \[And] id!= "", metaid=id];

If[metaid!= "",If[!SIDQ[metaid],
Print["Error: "//boldRed, "ruleToSymbolicSBML: rule metaid "//boldBlack, metaid//boldBlue, " is not a valid SID."//boldBlack];
];
]; 

sboTerm = stringer[Global`sboTerm/.opts/.{Global`sboTerm-> ""}];

data = {};
setAnnotation=False; 


Switch[TYPE,

"ALGEBRAICRULE",
type = "algebraicRule";
data = {};
subdata = Join[notes, ann,arrayDimensions, math]//Flatten;
,


"ASSIGNMENTRULE",
type = "assignmentRule";
variable=varname[]; 
If[Length[variableLink]<1,data = {"variable"-> variable}];
subdata = Join[notes, ann,arrayDimensions,variableLink, math]//Flatten;

,

"CONSTRAINTRULE",
Print["Error:"//boldRed,"constraintRules were proposed in an eralier draft of the SBML Level 2 Version 2 specification but were not adopted, in lieu of the constraint object. Please revise your model accordingly"//boldBlack]; 
type = "constraintRule";
subdata = Join[notes, ann,arrayDimensions,variableLink, math]//Flatten;
,

"RATERULE",
type="rateRule";
variable=varname[]; 
If[Length[variableLink]<1,data = {"variable"-> variable}];
subdata = Join[notes, ann,arrayDimensions,variableLink, math]//Flatten;
,
"CONNECTIONRULE",
If[debug,Print["ruleToSymbolicSBML: connectionRule:"//boldRed]];
If[!ifArrays[],
Return[stringToNotes["Connection Rule inhibited because Arrays->False."]];
]; 
type="connectionRule";
fromcompartment=stringer[ Global`from/.opts/.{Global`from-> ""}]; 
tocompartment=stringer[ Global`to/.opts/.{Global`to-> ""}]; 
If[fromcompartment=="" \[Or] tocompartment=="", 
Print["Error:"//boldOrange," connectionRule: both from and to fields must be specified."//boldBlack];
Return[stringToNotes["Connection Rule inhibited because either from or to field is missing"]];
];

(* from/to indices added in 2.5.5 11/9/05 *)

fromindices=Global`listOfIndicesFrom/.opts/.{Global`listOfIndicesFrom-> {}};
toindices=Global`listOfIndicesTo/.opts/.{Global`listOfIndicesTo-> {}};

fromindices=XMLElement["ci",{},{stringer[#]}]&/@Flatten[{fromindices}];
toindices =XMLElement["ci",{},{stringer[#]}]&/@ Flatten[{toindices}]; 

fromindices={XMLElement["listOfIndicesFrom",{},fromindices]};
toindices={XMLElement["listOfIndicesTo",{},toindices]}; 


subdata = Join[notes, ann,arrayDimensions, fromindices, toindices, math]//Flatten;
data = {"from"-> fromcompartment, "to"-> tocompartment};
,
"INITIALASSIGNMENTRULE",
If[debug,Print["ruleToSymbolicSBML: InitialAssignmentRule:"//boldRed]]; 

If[!ifArrays[],Return[stringToNotes["Initial Assignment Rule inhibited because Arrays->False."]]]; 

variable=varname[]; 
type="initialAssignmentRule";
data = (Global`data/.opts/.Global`data-> Indeterminate);
If[VectorQ[data],
data={vectorToSymbolicSBML[data]},
If[MatrixQ[data],
data={matrixToSymbolicSBML[data]},
If[stringer[data]!= "Indeterminate", 
data= {expression2SymbolicSBML[data]},
data = math;
];
];
];

arrayDimensions = Cases[arrayDimensions,XMLElement["listOfDimensions",___],Infinity]; 

subdata = Join[notes,ann,arrayDimensions,variableLink,data];
If[Length[variableLink]<1,data = {"variable"-> variable}, data={}];
If[ifArraysAreAnnotations[], setAnnotation=True];


,

(* MISSING TYPE *) 
"",
Print["Error: "//boldRed,"No type specified for rule "//boldBlack,metaid//boldBlue," Valid types are "//boldBlack, "algebraicRule, assignmentRule, rateRule"//boldBlue ];
type = "algebraicRule"; data={}; 
math ={ expression2SymbolicSBML[0]};
subdata = Join[notes, ann,arrayDimensions,variableLink, math]//Flatten;
,
(* UNKNOWN TYPE *) 

_,Print["Warning: "//boldRed,"Unknown type\[Rule]"//boldBlack,type//boldBlue," for rule "//boldBlack,metaid//boldBlue," Valid types are algebraicRule, assignmentRule, or rateRule."//boldBlack ];
Abort[];
math ={ expression2SymbolicSBML[0]}; type = "algebraicRule"; data={}; 
subdata = Join[notes, ann,arrayDimensions,variableLink, math]//Flatten;
];

If[metaid!= "", data = Append[data,"metaid"-> metaid]]; 

If[sboTerm!= "",
If[ToExpression[MB$LevelVersion]>2.15, 
AppendTo[data, "sboTerm"-> sboTerm],
Print["Error: "//boldRed, "ruleToSymbolicSBML: "//boldBlack, "sboTerm"//boldBlue, " is not permitted in "//boldBlack, "SBML Level "//boldBlue, MB$Level//boldBlue, " Version "//boldBlue, MB$Version//boldBlue];
];
];



If[matrixresult, data = Append[data, "matrixResult"-> "true"]];

If[ifArrays[]\[And] connection!= "", 
data = Append[data, "connection"-> connection];
];
If[ifArrays[] \[And] Length[indices]>0, 
indices=indicesToSymbolicSBML[indices];
subdata = Append[subdata, indices];
];

SBML=XMLElement[type,data,subdata];


If[setAnnotation,SBML=annotationToSymbolicSBML[SBML ]];
If[debug,Print["ruleToSymbolicSBML: InitialAssignmentRule:"//boldRed, SBML//boldBlue]]; 

Return[SBML];
];


constraintToSymbolicSBML[opt___?OptionQ]:= Module[{ msg, opts,meta, sbo, s, expr, ann, notes, dbg=False},

checkOptions[constraintToSymbolicSBML, Flatten[{opt}], 
{ "metaid", "annotation", "notes","math","message","sboTerm"}];
If[dbg, Print["constraintToSymbolicSBML: options:ok"]];

msg=stringer[Global`message/.{opt}/.{Global`message-> ""}];
expr=Global`math/.{opt}/.{Global`math-> "?"};
sbo=stringer[Global`sboTerm/.{opt}/.{Global`sboTerm-> ""}];
meta=stringer[Global`metaid/.{opt}/.{Global`metaid-> ""}];

If[stringer[expr]=="?", 
Print["Error: "//boldRed, "constraintToSymbolicSBML: no math."//boldBlack];
expr=True;
];

ann =Flatten[{Global`annotation/.{opt}/.{Global`annotation-> {}}}]; 
If[Length[ann]>0, ann={annotationToSymbolicSBML@@ann}]; 
notes = {Global`notes/.{opt}/.{Global`notes-> {}}}//Flatten//stringToNotes;


opts =First/@{opt};
If[dbg, Print["constraintToSymbolicSBML: opts:",opts]];

Return[constraintToSymbolicSBML[expr,msg, ann, notes, meta,sbo]];

];
constraintToSymbolicSBML[math_,message_, ann_, notes_,metaid_,  SBOTerm_:""]:= Module[{mathml, opts,sub, sbo,ia, meta,m,newmath,  dbg=False,MYANGLE},

MYANGLE[x_, "time"]:= x;
MYANGLE[x_, "delay"]:= x; 


If[dbg, Print["constraintToSymbolicSBML:",{math,message, ann,notes, metaid, SBOTerm}]];

mathml ={ expression2SymbolicSBML[math]};

If[dbg, Print["constraintToSymbolicSBML: mathml: ",mathml]];

opts={};
sbo = stringer[SBOTerm];
If[StringLength[sbo]>0,
opts= Append[opts, "sboTerm"-> sbo];
];
meta=stringer[metaid];
If[StringLength[meta]>0, 
opts=Append[opts, "metaid"-> meta];
];
If[dbg, Print["constraintToSymbolicSBML: opts: ",opts]];

sub=mathml;
If[dbg, Print["constraintToSymbolicSBML: sub(1): ",sub]];
If[dbg, Print["constraintToSymbolicSBML: message: ", message]]; 

If[StringLength[message]>0,
m= stringToNotes[message];
If[dbg, Print["constraintToSymbolicSBML: m(1): ",m]];
,
newmath=math//.{MyAngleBracket-> MYANGLE};
If[dbg, Print["constraintToSymbolicSBML: newmath: ", newmath]]; 

newmath=StringReplace[stringer[newmath], {">"-> ".gt.","<"-> ".lt." }];
newmath="constraint violation: "<>newmath;
If[dbg, Print["constraintToSymbolicSBML: newmath: ", newmath]]; 
m=stringToNotes[newmath];
If[dbg, Print["constraintToSymbolicSBML: m(2): ",m]];

];
m = (m/.{"notes"-> "message"});
If[dbg, Print["constraintToSymbolicSBML: m(3): ",m]];

sub=Flatten[Append[{sub}, m]];


If[Length[notes]>0, 
sub=Flatten[Append[{sub},notes]]
];
If[Length[ann]>0, 
sub=Flatten[Append[{sub},ann]]
];

If[dbg, Print["constraintToSymbolicSBML: sub(2): ",sub]];

ia = XMLElement["constraint", opts, sub];

If[dbg, Print["constraintToSymbolicSBML: ia: ",ia]];

Return[ia]
];


eventToSymbolicSBML[opt___?OptionQ]:= Module[{SBML,opts,id, name, trigger, delay, timeUnits, eventAssignment, data, eventVariables,okevent,metaid, ann, notes,eventAssignmentNotes,eventAssignmentMetaids,nasg,eventAssignmentSBOTerms,eventAssignmentAnnotations,eventAssignmentStuff, easbos, dbg=False},

opts=Flatten[{opt}];

If[ToExpression[MB$LevelVersion]<2.3, 
checkOptions[eventToSymbolicSBML, opts, 
{"annotation","delay","eventAssignment","eventAssignmentAnnotations","eventAssignmentMetaids","eventAssignmentNotes","eventAssignmentSBOTerms","id","metaid","name", "notes","sboTerm","timeUnits","trigger"}],
checkOptions[eventToSymbolicSBML, opts, 
{"annotation","delay","eventAssignment","eventAssignmentAnnotations","eventAssignmentMetaids","eventAssignmentNotes","eventAssignmentSBOTerms","id","metaid","name", "notes","sboTerm","trigger"}]
]; 


If[dbg, Print["eventToSymbolicSBML: options checked."]]; 

id = stringer[( Global`id/.opts)/.{ Global`id-> ""}];
If[id == "", id = "event"<>ToString[MB$eventcounter++]];


If[!SIDQ[id],
Print["Error: "//boldOrange, "eventToSymbolicSBML: event id "//boldBlack, id//boldRed, " is not a valid SID."//boldBlack];
Abort[];
];

If[dbg, Print["eventToSymbolicSBML: id=",id]]; 

name = stringer[ Global`name/.opts/.{ Global`name-> id}];
SBML = {"id"-> id, "name"-> name}; 
metaid =( Global`metaid/.opts/.{Global`metaid-> ""});
metaid=stringer[metaid];
If[StringLength[metaid]>0, SBML = Append[SBML,"metaid"-> metaid]]; 

If[dbg, Print["eventToSymbolicSBML: metaid=",metaid, " name=", name, " SBML=", SBML]]; 

(* Print["metaid=",metaid];
Print["SBML=",SBML]; *)
If[ToExpression[MB$LevelVersion]<2.3, 
timeUnits = stringer[Global`timeUnits/.opts/.{Global`timeUnits-> ""}]; 
If[timeUnits!= "", SBML = Append[SBML,"timeUnits"-> timeUnits]]; 
If[dbg, Print["eventToSymbolicSBML: timeUnits=",timeUnits,  " SBML=", SBML]]; 
]; 

trigger = Global`trigger/.opts/.{Global`trigger-> ""}; 
If[dbg, Print["eventToSymbolicSBML: trigger(1)=",trigger]]; 

If[stringer[trigger]=="",
trigger=False;
Print["Warning: "//boldRed,"The event "//boldBlack, id//boldBlue, " does not have a trigger."//boldBlack]
];
If[dbg, Print["eventToSymbolicSBML: trigger(2)=",trigger]]; 
If[ListQ[trigger], 
Print["Error:"//boldRed, "The event "//boldBlack, id//boldBlue, " has an invalid trigger: trigger must be a boolean expression and not a list: "//boldBlack, 
trigger//boldBlue];
];
If[dbg, Print["eventToSymbolicSBML: trigger(3)=",trigger]]; 


trigger = XMLElement["trigger",{},{ expression2SymbolicSBML[trigger]}];
If[dbg, Print["eventToSymbolicSBML: trigger(4)=",trigger]]; 

data = {trigger}; 

delay = Global`delay/.opts/.{Global`delay-> 0}; 
If[stringer[delay]!= "0", 
delay = XMLElement["delay", {}, {expression2SymbolicSBML[delay]}]; 
data = Append[data, delay]; 
];

eventAssignment=Global`eventAssignment/.opts/.{Global`eventAssignment-> {}};
If[dbg, Print["eventToSymbolicSBML: eventAssignment(1)=",eventAssignment]]; 


eventAssignment = Flatten[{eventAssignment}]; 
If[Length[eventAssignment]>0, 
okevent =Apply[And, Map[ToString[Head[#]]=="Rule"&, eventAssignment]];
If[!okevent, 
Print["Warning: "//boldOrange, "eventAssignment for event "//boldBlack,
id//boldRed," is not a list of rules. Requested eventAssignment -> "//boldBlack,eventAssignment//boldRed," eventAssignment must have the form {variable->expression, variable->expression,...}"//boldBlack];
];
If[dbg, Print["eventToSymbolicSBML: eventAssignment(2)=",eventAssignment]]; 

eventAssignment = Flatten[{eventAssignment}];
eventVariables=stringer/@( First/@eventAssignment);
If[dbg, Print["eventToSymbolicSBML: eventAssignment(3)=",eventAssignment]]; 

eventAssignment=Last/@eventAssignment; 
eventAssignment = expression2SymbolicSBML/@eventAssignment;
If[dbg, Print["eventToSymbolicSBML: eventAssignment(4)=",eventAssignment]]; 

nasg = Length[eventVariables]; 

eventAssignmentNotes=Global`eventAssignmentNotes/.opts/.{Global`eventAssignmentNotes->{} };
eventAssignmentNotes=stringer/@eventAssignmentNotes;
While[Length[eventAssignmentNotes]<nasg, eventAssignmentNotes=Append[eventAssignmentNotes,{}]];
eventAssignmentNotes=Take[eventAssignmentNotes,nasg]; 

If[dbg, Print["eventToSymbolicSBML: eventAssignmentNotes(1)=",eventAssignmentNotes]]; 


eventAssignmentMetaids=
Global`eventAssignmentMetaids/.opts/.{Global`eventAssignmentMetaids->{} };
eventAssignmentMetaids=stringer/@eventAssignmentMetaids;
While[Length[eventAssignmentMetaids]<nasg,eventAssignmentMetaids=Append[eventAssignmentMetaids,""]];
eventAssignmentMetaids= Take[eventAssignmentMetaids,nasg]; 
If[dbg, Print["eventToSymbolicSBML: eventAssignmentMetaids(1)=",eventAssignmentMetaids]]; 


eventAssignmentSBOTerms=
Global`eventAssignmentSBOTerms/.opts/.{Global`eventAssignmentSBOTerms->{} };
eventAssignmentSBOTerms=stringer/@eventAssignmentSBOTerms;
While[Length[eventAssignmentSBOTerms]<nasg,eventAssignmentSBOTerms=Append[eventAssignmentSBOTerms,""]];
eventAssignmentSBOTerms= Take[eventAssignmentSBOTerms,nasg]; 
If[dbg, Print["eventToSymbolicSBML: eventAssignmentSBOTerms(1)=",eventAssignmentSBOTerms]]; 

eventAssignmentAnnotations=Global`eventAssignmentAnnotations/.opts/.{Global`eventAssignmentAnnotations->{} };
If[dbg, Print["eventToSymbolicSBML: eventAssignmentAnnotations(1)=",eventAssignmentAnnotations, " nasg: ", nasg]]; 

While[Length[eventAssignmentAnnotations]<nasg, eventAssignmentAnnotations=Append[eventAssignmentAnnotations,{}]];
eventAssignmentAnnotations=Take[eventAssignmentAnnotations,nasg]; 
If[dbg, Print["eventToSymbolicSBML: eventAssignmentAnnotations(2)=",eventAssignmentAnnotations]]; 

eventVariables=Map[Rule["variable",#]&,eventVariables];
eventAssignmentMetaids=Map[If[StringLength[#]>0,Rule["metaid",#],{}]&,eventAssignmentMetaids]; 
eventVariables = Flatten/@({eventVariables,eventAssignmentMetaids}//Transpose);
If[dbg, Print["eventToSymbolicSBML: eventVariables(1)=",eventVariables]]; 


eventAssignment = MapThread[XMLElement["eventAssignment", #1, {#2,#3,#4}//Flatten]&, {eventVariables, eventAssignment,eventAssignmentNotes,eventAssignmentAnnotations}];
If[dbg, Print["eventToSymbolicSBML: eventAssignment=",eventAssignment]]; 

eventAssignment = XMLElement["listOfEventAssignments",{}, eventAssignment];
If[dbg, Print["eventToSymbolicSBML: eventAssignment=",eventAssignment]]; 
data = Append[data, eventAssignment];
If[dbg, Print["eventToSymbolicSBML: data=",data]]; 

,
Print["Warning: "//boldRed,"The event "//boldBlack,id//boldBlue," does not contain an eventAssignment."//boldBlack];
]; 

notes = {Global`notes/.opts/.{Global`notes-> {}}}//Flatten//stringToNotes; 
ann = {Global`annotation/.opts/.{Global`annotation-> {}}}//Flatten//optionToAnnotation;
If[dbg, Print["eventToSymbolicSBML: notes=",notes]]; 
If[dbg, Print["eventToSymbolicSBML: ann=",ann]]; 

data = Join[notes, ann, data]//Flatten; 
If[dbg, Print["eventToSymbolicSBML: data=",data]]; 

SBML = XMLElement["event",SBML,data]; 
If[dbg, Print["eventToSymbolicSBML: SBML=",SBML]]; 

Return[SBML];
];

eventToSymbolicSBML[id_, opt___?OptionQ]:= eventToSymbolicSBML[Global`id-> id, opt];



getSBMLid[XMLElement[tag_, {opt___?OptionQ}, stuff_]]:= Module[{id},
id = "id"/.{opt}/.{"id"-> "*NONE*"};
id = stringer[id];
If[id=="*NONE*",
Print["Warning: "//boldOrange,"There is no "//boldBlack,"id"//boldRed," field in the following symbolic SBML: "//boldBlack, XMLElement[tag,{opt},stuff]//boldRed];
];
Return[id];
];

getSBMLfield[field_,XMLElement["annotation",{z___},{XMLElement[u___]}]]:= getSBMLfield[field,XMLElement[u]];

getSBMLfield[field_, XMLElement[tag_, {opt___?OptionQ}, stuff_]]:= Module[{value, r,identityRule, dbg=False},

If[dbg, Print["getSBMLfield: field: ", field]]; 

Off[Rule::rhs];
identityRule[Rule[b_, b_]]:= True;
identityRule[b___]:= False;

(* Print["getSBMLfield: {opt}:",{opt}];
Print["getSBMLfield: field:",field];  *) 

value = stringer[field]/.{opt}/.{stringer[field]-> ""};
(* Print["getSBMLfield: value:", value]; *)
value = stringer[value];
If[value=="",

(* check for field -> field *) 

r = Select[Flatten[{opt}], (First[#]==stringer[field])&];
If[Length[r]>0,
r=First[r];
If[identityRule[r], value=stringer[field]];
];
];

If[dbg, Print["getSBMLfield: value: ", value]]; 

Return[value];
];

getSBMLfield[field_, XMLElement[x___],opt__?OptionQ]:=Module[{defaultValue,value},
defaultValue=default/.{opt}/.{default-> ""};
value=getSBMLfield[field,XMLElement[x]];
If[value=="", value=defaultValue];
Return[value];
]


Default$Units={"ampere","becquerel","candela","Celsius","coulomb","dimensionless","farad","gram","gray","henry","hertz","item","joule","katal","kelvin","kilogram","litre","lumen","lux","metre","mole","newton","ohm","pascal","radian","second","siemens","sievert","steradian","tesla","volt","watt","weber", "substance","volume","time","area", "length"};
Built$In$Units={"substance","volume","time","area", "length"};
resetDefaultUnits[]:= (default$Units = Default$Units);
resetDefaultUnits[];

defaultUnit[unit_]:= MemberQ[default$Units,stringer[unit]];
builtInUnit[unit_]:=MemberQ[Built$In$Units, stringer[unit]];
removeDefaultUnit[unit_]:= Module[{},
If[defaultUnit[unit],
default$Units = Complement[default$Units,{stringer[unit]}];
If[builtInUnit[unit],
(* Print["Built-in unit: "//boldGreen,unit//boldBlue," redefined. "//boldGreen]; *)
Return[True];
,
Print["Error: "//boldRed,"Illegal redefinition of default unit "//boldBlack,unit//boldBlue];
Return[True]; 
]
];
Return[False];
];

definedUnits[]:=Union[Flatten[{First/@ MB$Units, 
default$Units}
]];
unitExists[unit_]:= MemberQ[definedUnits[],unit];


expression2SymbolicSBML[Function[x___]]:= Module[{id},
id = "function"<>ToString[MB$functioncounter++];
Return[expression2SymbolicSBML[Function[x], id]];
]; 

expression2SymbolicSBML[Function[x__], id_]:= expression2SymbolicSBML[Function[x], id, id];

expression2SymbolicSBML[Function[x__], id_, name_,metaid_,  annotation_, notes_, sboTerm_:""]:= Module[{s,args, sid, sname},


If[StringQ[id], sid = id, sid=ToString[id]]; 
If[StringQ[name], sname=name, sname=ToString[name]]; 

s = Xpression2SymbolicMathML[Function[x]/.{System`Part-> Global`selector,System`Dot-> Global`scalarproduct
(**),System`If-> piecewiseIf(**)}];
s = Join[{s}, annotation, notes]//Flatten; 
args = {"id"-> sid}; 
If[StringLength[sname]>0, args = Append[args, "name"-> sname]]; 
If[StringLength[metaid]>0, args = Append[args, "metaid"-> metaid]]; 

If[ToExpression[MB$LevelVersion]>2.15,
If[StringLength[sboTerm]>0, args = Append[args, "sboTerm"-> sboTerm]]
];

s = XMLElement["functionDefinition",args,s];

s=encodePiecewise[s];
s=encodeCsymbols[s];


(* s = (s/.XMLElement-> myx); *)

Return[s];
];


expression2SymbolicSBML[infix_]:= Module[{s,myx},

s = Xpression2SymbolicMathML[infix/.{System`Part-> Global`selector, System`Dot-> Global`scalarproduct ,System`If-> piecewiseIf  }]; 


s=encodePiecewise[s];
s=encodeCsymbols[s];

Return[s];
];


encodePiecewise[xml_]:= Module[{s,myx},

myx["apply",{},{XMLElement["ci",{},{"XML`MathML`Symbols`Piece"}],a_,b_}]:=
XMLElement["piece",{},{b,a}];
myx["apply",{},{XMLElement["ci",{},{"XML`MathML`Symbols`Otherwise"}],a___}]:=
XMLElement["otherwise",{},{a}];
myx["apply",{},{XMLElement["ci",{},{"XML`MathML`Symbols`Piecewise"}],a___}]:=
XMLElement["piecewise",{},{a}];

myx[x___]:= XMLElement[x];

s = (xml/.XMLElement-> myx);

Return[s];
];


encodeCsymbols[xml_]:= Module[{s,myx},

(* csymbol time *)
(* if it is enclosed in quotes, it will be encoded as an "ms" element, otherwise, as a "ci" element *)

(*
myx["apply",{},{XMLElement["ci",{},{"AngleBracket"}],XMLElement["ci",{},{x_}],XMLElement["ci",{},{"time"}]}]:= XMLElement["csymbol",{"encoding"->"text","definitionURL"->csymbolTimeURL},{XMLElement["ci",{},{stringer[x]}]}];
myx["apply",{},{XMLElement["ci",{},{"AngleBracket"}],XMLElement["ci",{},{x_}],XMLElement["ms",{},{"time"}]}]:= 
XMLElement["csymbol",{"encoding"->"text","definitionURL"->csymbolTimeURL},{XMLElement["ci",{},{stringer[x]}]}];
*)

myx["apply",{},{XMLElement["ci",{},{"AngleBracket"}],XMLElement["ci",{},{x_}],XMLElement["ci",{},{"time"}]}]:= XMLElement["csymbol",{"encoding"->"text","definitionURL"->csymbolTimeURL},{stringer[x]}];
myx["apply",{},{XMLElement["ci",{},{"AngleBracket"}],XMLElement["ci",{},{x_}],XMLElement["ms",{},{"time"}]}]:= 
XMLElement["csymbol",{"encoding"->"text","definitionURL"->csymbolTimeURL},{stringer[x]}];


(* csymbol delay *)
(* if it is enclosed in quotes, it will be encoded as an "ms" element, otherwise, as a "ci" element *)
(*

myx["apply",{},{XMLElement["ci",{},{"AngleBracket"}],XMLElement["ci",{},{x_}],XMLElement["ci",{},{"delay"}]}]:= XMLElement["csymbol",{"encoding"->"text","definitionURL"->csymbolDelayURL},{XMLElement["ci",{},{stringer[x]}]}];
myx["apply",{},{XMLElement["ci",{},{"AngleBracket"}],XMLElement["ci",{},{x_}],XMLElement["ms",{},{"delay"}]}]:= 
XMLElement["csymbol",{"encoding"->"text","definitionURL"->csymbolDelayURL},{XMLElement["ci",{},{stringer[x]}]}];
*)

myx["apply",{},{XMLElement["ci",{},{"AngleBracket"}],XMLElement["ci",{},{x_}],XMLElement["ci",{},{"delay"}]}]:= XMLElement["csymbol",{"encoding"->"text","definitionURL"->csymbolDelayURL},{stringer[x]}];
myx["apply",{},{XMLElement["ci",{},{"AngleBracket"}],XMLElement["ci",{},{x_}],XMLElement["ms",{},{"delay"}]}]:= 
XMLElement["csymbol",{"encoding"->"text","definitionURL"->csymbolDelayURL},{stringer[x]}];

(* unknown csymbol *)
(* if it is enclosed in quotes, it will be encoded as an "ms" element, otherwise, as a "ci" element *)

myx["apply",{},{XMLElement["ci",{},{"AngleBracket"}],XMLElement["ci",{},{x_}],XMLElement["ci",{},{someURL_}]}]:= XMLElement["csymbol",{"encoding"->"text","definitionURL"->stringer[someURL]},{stringer[x]}];
myx["apply",{},{XMLElement["ci",{},{"AngleBracket"}],XMLElement["ci",{},{x_}],XMLElement["ms",{},{someURL_}]}]:= 
XMLElement["csymbol",{"encoding"->"text","definitionURL"->stringer[someURL]},{stringer[x]}];


(* unspecified URL *)

myx["apply",{},{XMLElement["ci",{},{"AngleBracket"}],XMLElement["ci",{},{x_}]}]:= Block[{r}, 
r=XMLElement["csymbol",{"encoding"->"text","definitionURL"->"the-definition-URL-was-not-specified"},{stringer[x]}];
Print["Error: "//boldRed, "expression2SymbolicSBML: no definitionURL supplied for csymbol "//boldBlack, "\[LeftAngleBracket]"<>x<>"\[RightAngleBracket]"//boldBlue," in the expression "//boldBlack , infix//boldBlue, " The expected syntax for a csymbol is \[LeftAngleBracket]variable, definitionURL\[RightAngleBracket],\[LeftAngleBracket]variable, \"time\"\[RightAngleBracket], or \[LeftAngleBracket]variable, \"delay\"\[RightAngleBracket].\nIt has been encoded as:\n"//boldBlack,
XMLPrintForm[r,Purple]
];
Return[r];
];



myx[x___]:= XMLElement[x];

s = (xml/.XMLElement-> myx);
Return[s];
];


simpleSymbolicXML[tag_, value_]:= Module[{string},
string[x_?StringQ]:= x;
string[x_]:= ToString[x];
Return[XMLElement[string[tag],{}, {string[value]}]]
];
simpleXML[tag_,value_]:= XMLOut[simpleSymbolicXML[tag,value]]


optionToAnnotation[{XMLElement[x___]}]:= {XMLElement[x]};
optionToAnnotation[x___]:= Module[{input,outpt,dbg=False},

debugPrint[dbg,"optionToAnnotation: input:",x];

input={x}//Flatten;
If[Length[input]<1, Return[{}]]; 
If[OptionQ[x], 
outpt={Apply[annotationToSymbolicSBML, x]};
debugPrint[dbg,"optionToAnnotation: return value:",outpt];

Return[outpt];
];
Print["Error: "//boldRed,
"optionToAnnotation: invalid argument: "//boldBlack,x//boldBlue," An annotation should have the form string\[Rule]string or string\[Rule]list."//boldBlack
];

Return[annotationToSymbolicSBML[input]];
];


getAnnotations[XMLElement[x_,y_,z_]]:=Cases[z,XMLElement["annotation",___]];
getAnnotations[id_->XMLElement[x___]]:=getAnnotations[XMLElement[x]];
getAnnotations[x_?ListQ]:=getAnnotations/@x;

getAnnotations[tag_,xx_]:=Module[{m},m=Cases[xx,XMLElement[tag,___],Infinity];
Return[getAnnotations[m]];];


isAnnotated[x_]:=Length[getAnnotations[x]]>0;


getNotes[XMLElement[x_, y_, z_]]:=Cases[z, XMLElement["notes",___]];
getNotes[id_-> XMLElement[x___]]:= getNotes[XMLElement[x]];
getNotes[x_?ListQ]:= getNotes/@x;

getNotes[tag_,xx_]:= Module[{m},
m=Cases[xx, XMLElement[tag,___], Infinity];
Return[getNotes[m]];
];


isNoted[x_]:= Length[getNotes[x]]>0;


stringToNotes[XMLElement["notes", x_,y_]]:= XMLElement["notes",x,y];

(* rev 5-31-04 to force XHTML format on notes *) 
(* rev 2.3.24 7-5-04 to not force <body..> on null notes: this should encourage the postprocessor to remove all notes statements that are empty *) 
stringToNotes[""]:= XMLElement["notes",{},{}];
stringToNotes[x_?StringQ]:=XMLElement["notes",{},Cases[ImportString[
"<body xmlns=\"http://www.w3.org/1999/xhtml\">"<>x<>"</body>", "XML"],
XMLElement[___]]
];

 (* XMLElement["notes",{},{x}]; *)

stringToNotes[x_?ListQ]:= stringToNotes/@x;
stringToNotes[x___]:= Print["Error: "//boldRed,"stringToNotes: "//boldBlue," argument must be a string, XMLElement, or list of XMLElements of notes. Input given: "//boldBlack, x];

updateNotes[XMLElement[z___],opt___?OptionQ]:=Module[{oldnotes,newnotes,x,formatNotes},

formatNotes[w_?StringQ]:={w};formatNotes[XMLElement[w1_,w2_,w3_]]:=w3;
formatNotes[w_?ListQ]:=formatNotes/@w;formatNotes[w___]:=Print[boldOrange["Error: "],boldRed["updateNotes: "],boldBlank["invalid call to "],boldRed["formatNotes"],boldBlack[" arguments: "],x];

x=XMLElement[z];
oldnotes=formatNotes[getNotes[x]];

newnotes=Global`notes/.{opt}/.{Global`notes->{}};
newnotes=formatNotes[newnotes];newnotes=Flatten[{oldnotes,newnotes}];
newnotes=StringJoin@@newnotes;
If[newnotes!= "", 
newnotes={XMLElement["notes",{},{newnotes}]},
newnotes={}
]; 
Return[newnotes];
];

updateNotes[{},opt___?OptionQ]:= {};

updateNotes[x___]:=Print[boldOrange["Error: "],boldRed["updateNotes "],boldBlack["called with invalid argment: "],boldRed[ToString[x]]];



updateAnnotations[XMLElement[z__], opt___?OptionQ]:= Module[{x, old, new, ann, checkAnn},

checkAnn[XMLElement["annotation",u___]]:= True;
checkAnn[u_?ListQ]:= And@@(checkAnn/@u);
checkAnn[u___]:= False;

x = XMLElement[z];
old =  getAnnotations[x]//Flatten;
new =Flatten[{ (Global`annotation)/.{opt}/.{Global`annotation-> {}}}];
If[checkAnn[new],
ann = Join[new, old]//Flatten,
ann = old;
Print["Error:"//boldOrange,"updateAnnotations: checkAnn:"//boldRed," annotations must be Symbolic XML or a list of Symbolic XML: input ignored: "//boldBlack,new];
];
Return[ann]; 
];
updateAnnotations[{},opt___?OptionQ]:= {};
updateAnnotations[x___]:= Print["Error: "//boldRed," udpateAnnotations: invalid argument list: "//boldBlack,
boldBlue/@{x}
];


createSymbolicAnnotation[package_, ns_,tag_, {data___?OptionQ}, sub_]:= Module[{string },
string[x_?StringQ]:= x; 
string[x_-> y_]:= string[x]-> string[y]; 
string[x_?ListQ]:= string/@x; 
string[x_]:= ToString[x]; 


 XMLElement["annotation",{"xmlns:"<>string[package]-> string[ns]},{
XMLElement[string[tag],string[{data}],{sub}//Flatten
]

}]
];




If[$$LoadBug, Print["Loading: Model Builder: annotations"]];


setAnnotationNamespace[arg_]:= Module[{},
MB$CurrentAnnotationNamespace = stringer[arg];
]; 
setAnnotationURI[arg_]:= setAnnotationNamespace[arg];
setAnnotationURL[arg_]:= Block[{},
Print["Warning:"//boldRed," setAnnotationURL has been disparaged in favor of setAnnotationURI and will be discontinued in a future version of MathSBML."//boldBlack];
setAnnotationURI[arg];
]; 

setAnnotationPackage[arg_]:= Module[{},
MB$CurrentAnnotationPackage=stringer[arg];
]; 

If[$$LoadBug, Print["Loading: Model Builder: annotationToSymbolicSBML "]];

annotationToSymbolicSBML[a_?StringQ-> ann_]:= annotationToSymbolicSBML[a-> ann, MB$CurrentAnnotationPackage, MB$CurrentAnnotationNamespace]; 

annotationToSymbolicSBML[topLevel_?StringQ->ann_,pkg_:StringQ,URI_?StringQ]:= Module[{a,inline={},tree={},inlineElements,package, URL,treeElements,dbg=False},

package=pkg;
If[package=="",Print["Error: "//boldRed,"annotationToSymbolicSBML: annotation package has not been defined. Use setAnnotationPackage[package-name] to define the name of the package. "//boldBlack];
package="Indeterminate-resource";
];

URL=URI;
If[URL=="http://",Print["Error: "//boldRed,"annotationToSymbolicSBML: annotation URI has not been defined. Use setAnnotationURI[URI] to define the annotation namespace URI. "//boldBlack];
URL="http://sbml.org/Indeterminate-resource-URI/";
];

inlineElements[tool_,data_]:= Module[{r={},in},
in = Select[data,( Head[#]===Rule)\[And]StringQ[Last[#]]&];
r=Rule[tool<>":"<>First[#],Last[#]]&/@in;
Return[r]
];

(* end of inlineElements *)

treeElements[tool_,data_]:= Module[{r={},out,in,ok,notok, nextlevel},
in = Select[data,( Head[#]===Rule)\[And]StringQ[Last[#]]&];
out=Complement[data,in];

If[dbg,Print["treeElements: tree:",out]];

(* first check to make sure only rules are found *)
ok = Select[out,( Head[#]===Rule)&];
notok=Complement[out,ok];
Print["Error: "//MathSBML`Private`boldRed,"annotationToSymbolicSBML: invalid format for annotation data: "//MathSBML`Private`boldBlack,MathSBML`Private`boldBlue[#]," is not a rule."//MathSBML`Private`boldBlack]&/@notok;

(* reject any rules that are not heirarchies of lists  *)

out=ok;
ok = Select[out, ListQ[Last[#]]&]; 
notok=Complement[out,ok];
If[dbg,
Print["treeElements: really ok:",ok];
Print["treeElements: notok:",notok];
]; 

Print["Error: annotationToSymbolicSBML: "//MathSBML`Private`boldRed,
MathSBML`Private`boldBlue[#], " does not have the form string\[Rule]string or string\[Rule]list and will be ignored."//MathSBML`Private`boldBlack
]&/@notok;

nextlevel[u_?StringQ-> {v_?StringQ}]:= XMLElement[tool<>":"<>u,{},{v}];
nextlevel[u_?StringQ-> v_?ListQ]:= Module[{in,out},
in=inlineElements[tool,v];
out=treeElements[tool,v];
XMLElement[tool<>":"<>u,in,out]
];
nextlevel[u___]:= {};
ok=nextlevel/@ok;

Return[ok]
];
(* end of treeElements *)

(* "a"-> "b" *)
(* normally this would be inline but not at the top level *)
If[StringQ[ann],
 tree={ann},
 
(* "a"-> { ... } *)
If[ListQ[ann], 

(* "a"-> {"b",..} *) 
If[StringQ[First[ann]],
If[Length[ann]==1, 

(* "a"->{"b"} *) 
tree=ann, 

(* "a"-> {"b", other stuff} *) 
Print["Error: "//MathSBML`Private`boldRed," annotationToSymbolicSBML: invalid format for annotation: If the first element in a list is a string, there should not be any additional elements in the list: "//MathSBML`Private`boldBlack,MathSBML`Private`boldBlue[ann], " will be interpreted as "//MathSBML`Private`boldBlack,{First[ann]}//MathSBML`Private`boldBlue];
tree={First[ann]};
];
,
(* First[ann] is not a string *)
inline=inlineElements[package,ann];
 tree=treeElements[package,ann]; 

]; (* end If StringQ[First[ann]] *)


(* end TRUE part of If ListQ[ann]*)
,
(* ann is not a list and not a string *)
tree={}; 
Print["Error: annotationToSymbolicSBML: annotation must be of the form string-> string or string -> List"];

(* "a"-> {stuff } *) 

]; (* end if ListQ[ann]*)
]; (* end if StringQ[ann] *)

a=XMLElement[
"annotation",
{},
{XMLElement[package<>
":"<>topLevel, Join[{"xmlns:"<>package-> URL},inline], tree]}
];

Return[a];
];


annotationToSymbolicSBML[XMLElement["annotation",x___]]:= XMLElement["annotation",x];

annotationToSymbolicSBML[XMLElement[x___]]:= XMLElement["annotation",{},{XMLElement[x]}];

annotationToSymbolicSBML[x___]:= Block[{},
If[Length[{x}]>0, Print["Error: "//boldRed," annotationToSymbolicSBML: incorrect format for argument: "//boldBlack,x//boldBlue," argument should be string\[Rule]string or string\[Rule]list."//boldBlack]; 
]; 
Return[{}]];


If[$$LoadBug, Print["Loading: Model Builder: annotationToSBML "]];

(* annotationToSBML[opt___?OptionQ]:= XMLOut[annotationToSymbolicSBML[opt]];*)

annotationToSBML[x___]:= XMLOut[annotationToSymbolicSBML[x]];


If[$$LoadBug, Print["Loading: Model Builder: setModelAnnotation "]];

setModelAnnotation[x___]:= Module[{ann},
ann = annotationToSymbolicSBML[x];
(* If[!ListQ[ann], ann={ann}]; *) 
MB$ModelAnnotation=Append[MB$ModelAnnotation, ann];
Return[ann];
]; 
 setSBMLAnnotation[x___]:= Module[{ann,debug=False},
 ann =annotationToSymbolicSBML[x];
(* If[!ListQ[ann], ann={ann}]; *)
MB$SBMLAnnotation=Append[MB$SBMLAnnotation,ann];
If[debug,Print["setSBMLAnnotation: ann:",ann]];
If[debug,Print["setSBMLAnnotation: MB$SBMLAnnotation:",MB$SBMLAnnotation]];

Return[ann];
]; 




If[$$LoadBug, Print["Loading: Model Builder: symbolicXMLForm "]]
(* 
symbolicXMLForm[attribute_-> value_?StringQ]:= If[StringLength[MB$CurrentAnnotationPackage]>0,XMLElement[MB$CurrentAnnotationPackage<>":"<>stringer[attribute],{},{value}],
XMLElement[stringer[attribute],{},{value}]
];
symbolicXMLForm[attribute_-> value_?ListQ]:=Module[{element,SXML, attributeValuePairs, data, ruleQ,listRuleQ, listRules, simpleRules,values, nonRules,srule,bo,br,bb,dbg=False},

srule[x_-> y_]:=
If[StringLength[MB$CurrentAnnotationPackage]>0,Rule[MB$CurrentAnnotationPackage<>":"<>stringer[x],stringer[y]],
Rule[stringer[x],stringer[y]]
];
listRuleQ[x_-> y_?ListQ]:= True;
listRuleQ[x___]:= False;

ruleQ[x_-> y_]:=True;
ruleQ[x___]:=False;

element =stringer[attribute];

values = Select[value, ruleQ];
nonRules=Complement[value,values];
listRules= Select[values, listRuleQ];
simpleRules = Complement[values, listRules];
simpleRules=srule/@simpleRules;

If[dbg, Print["symbolicXMLForm: listRules:",listRules,"\nsimpleRules:",simpleRules,"\nbadRules:",nonRules]; ];

Map[Print["Error: symbolicXMLForm: "//boldOrange,"The following input was ignored because it is not a rule: "//boldBlack,#//boldRed]&,nonRules];
attributeValuePairs=simpleRules;
data={}; 
data = symbolicXMLForm/@listRules;

SXML=XMLElement[element,attributeValuePairs,data];
Return[SXML];
];


symbolicXMLForm[attribute_-> value_]:= symbolicXMLForm[attribute-> stringer[value]];
symbolicXMLForm[x_?ListQ]:= symbolicXMLForm/@x;
symbolicXMLForm[x__?RuleQ]:= symbolicXMLForm[{x}];
symbolicXMLForm[x___]:= Module[{},Print["Error: symbolicXMLForm: "//boldOrange,"input is not a rule, a sequence of rules, or a list of rules: "//boldBlack, {x}//boldRed];Return[{}]];

*)


annotate[XMLElement[x_, y_, z_], XMLElement["annotation",u_, v_]]:= XMLElement[x, y, Join[z, {XMLElement["annotation",u,v]}]];

annotate[XMLElement[x_, y_, z_], u_?ListQ]:= Fold[annotate, XMLElement[x,y,z], u];


If[$$LoadBug, Print["Loading:arrays"]];


dimensionIsDefined[variable_, index_]:= Module[{x,i,p},
x=stringer[variable];
i=stringer[index];
p = Position[MB$Dimensions,x];
If[Length[p]<1, Return[False]];
p=First[Flatten[p]];
Return[MemberQ[MB$Dimensions[[p,2]],i]];
];



SymbolQ[x_]:= ToString[Head[x]]=="Symbol";
idQ[x_]:= SymbolQ[x]\[Or]StringQ[x];
dimensionToSymbolicSBML[id_?idQ,min_, max_,opt___?OptionQ]:= Module[{name,lower,upper,dim,tags,metaid,ann,notes,data},
tags={"id"-> stringer[id]};

(* If[Length[Names["MathSBML`Private`MB$CurrentDimension"]]<1, MB$CurrentDimension={}]; *) 
MB$CurrentDimension=Append[MB$CurrentDimension,stringer[id]]; 

name = Global`name/.{opt}/.{Global`name-> ""}//stringer; 
If[name!= "", tags = Append[tags,"name"-> name]]; 

metaid=Global`metaid/.{opt}/.{Global`metaid-> ""}//stringer; 
If[metaid!= "", tags = Append[tags,"metaid"-> metaid]]; 

If[NumberQ[min],
lower = {};
tags = Append[tags, "lowerLimit"-> ToString[min]];
,
lower = expression2SymbolicSBML[min];
lower=XMLElement["lowerLimit",{},{lower}];
];

If[NumberQ[max],
upper={};
tags = Append[tags, "upperLimit"-> ToString[max]];
,
upper = expression2SymbolicSBML[max];
upper = XMLElement["upperLimit",{},{upper}]; 
];

ann = {Global`annotation/.{opt}/.{Global`annotation-> {}}}//Flatten; 
notes = {Global`notes/.{opt}/.{Global`notes-> {}}}//Flatten//stringToNotes; 

data =Join[ann,notes,{upper,lower}]//Flatten; 
dim = XMLElement["dimension",tags,data];
Return[dim];
];
dimensionToSymbolicSBML[id_-> {min_,max_, opt___?OptionQ},opts___?OptionQ]:= dimensionToSymbolicSBML[id,min,max,opt];
dimensionToSymbolicSBML[u_?ListQ,opt___?OptionQ]:= Module[{dims, tags={}, metaid, ann, notes},
dims = dimensionToSymbolicSBML/@u;
metaid=Global`metaid/.{opt}/.{Global`metaid-> ""}//stringer; 
If[metaid!= "", tags = Append[tags,"metaid"-> metaid]]; 
ann = {Global`annotation/.{opt}/.{Global`annotation-> {}}}//Flatten; 
notes = {Global`notes/.{opt}/.{Global`notes-> {}}}//Flatten//stringToNotes; 
Return[XMLElement["listOfDimensions",tags,Join[ann,notes,dims]]];
]; 
dimensionToSymbolicSBML[u___]:= {}; 
dimensionToSBML[u___]:= XMLOut[dimensionToSymbolicSBML[u]];


listOfIndicesToSymbolicSBML[x___,opt___?OptionQ]:= Module[{indices,metaid, tags={}, ann, note},
indices = expression2SymbolicSBML/@Flatten[{x}];


metaid=Global`metaid/.{opt}/.{Global`metaid-> ""}//stringer;
If[metaid!= "", tags = Append[tags,"metaid"-> metaid]];  


ann = {Global`annotation/.{opt}/.{Global`annotation-> {}}}//Flatten; 
notes = {Global`notes/.{opt}/.{Global`notes-> {}}}//Flatten//stringToNotes; 

indices = XMLElement["listOfIndices",tags, Join[ann,notes,indices]];

Return[indices];
]


indexToSymbolicSBML[id_]:=Module[{type},
If[NumberQ[id], type="cn", type="ci"];
Return[XMLElement["index", {"id"-> stringer[id], "type"-> type},{}]];
];
indicesToSymbolicSBML[{i__}]:= Module[{ii,listOfIndices},
ii=Flatten[{i}];
listOfIndices = indexToSymbolicSBML/@ii;
listOfIndices = XMLElement["listOfIndices", {}, listOfIndices];
Return[listOfIndices];
];
indicesToSymbolicSBML[i__]:= indicesToSymbolicSBML[{i}];
indexToSBML[x___]:= XMLOut[indexToSymbolicSBML[x]];
indicesToSBML[x___]:= XMLOut[indicesToSymbolicSBML[x]];


objectLinkToSymbolicSBML[link_, object_, {indices___},opt___?OptionQ]:= Module[{listOfIndices,linkXML={},slink,metaid,tags,data,ann,notes,knownLinks={"compartmentLink","foreachLink","outsideLink","speciesLink","variableLink"}},

If[ifArrays[],
slink = stringer[link];
If[!MemberQ[knownLinks,slink],
Print["Error: "//boldOrange, "objectLinkToSymbolicSBML: unknown link "//boldBlack,slink//boldRed,"; allowed types are: "//boldBlack,knownLinks//boldBlack];
Return[{}]; 
]; 
tags = {"object"-> stringer[object]}; 

metaid=Global`metaid/.{opt}/.{Global`metaid-> ""}//stringer;
If[metaid!= "", tags = Append[tags,"metaid"-> metaid]];  


listOfIndices = {listOfIndicesToSymbolicSBML[indices]};
 
ann = {Global`annotation/.{opt}/.{Global`annotation-> {}}}//Flatten; 
notes = {Global`notes/.{opt}/.{Global`notes-> {}}}//Flatten//stringToNotes; 
data = Join[listOfIndices,ann, notes];


linkXML=XMLElement[slink, tags, data];

]; 

Return[linkXML];
];


getObjectLink[tag_, opt___?OptionQ]:= Module[{v,l,ruleQ,variables, indices,tagstring,opts},
opts=Flatten[{opt}]; 
ruleQ[x_]:= ToString[Head[x]]=="Rule";
l={}; 
If[ifArrays[],
v=tag/.opts/.{tag-> {}}; 
v=Flatten[{v}]; 
If[And@@ruleQ/@v,
variables = First/@v;
indices = Flatten/@List/@Last/@v;
tagstring=decontextify[tag]//stringer;
l=MapThread[objectLinkToSymbolicSBML[tagstring,#1,#2]&,{variables,indices}];

;,
Print["Error: "//boldOrange, tag//boldRed,"\[Rule]"//boldRed,v//boldRed," incorrectly formatted, should be "//boldBlack,tag//boldBlack," \[Rule]{var\[Rule]{i,j,k,...},var\[Rule]{i,j,k},...}"//boldBlack];
]; 
]; 
Return[l];
];  


getArrayDimensions[var_, opt___?OptionQ]:= Module[{dim},

dim={};
If[ifArrays[], 
dim = Global`ArrayDimensions/.opt/.{Global`ArrayDimensions-> {}};
If[Length[dim]>0, 
MB$CurrentDimension={}; 
dim = dimensionToSymbolicSBML[dim]; 
MB$Dimensions = Prepend[MB$Dimensions,{var,MB$CurrentDimension}]; 

If[ifArraysAreAnnotations[],
dim={annotationToSymbolicSBML[dim ]};
,
dim={dim};
];
];
]; 
Return[dim];
];



symbolicMathML[m_]:= Module[{p},
p=Flatten[{m}];
p=XMLElement["math",{"xmlns"-> "http://www.w3.org/1998/Math/MathML"},p];
Return[p];
]; 



matrixToSymbolicSBML[mat_?MatrixQ,opt___?OptionQ]:= Module[{mrows,m, matrixrow},
matrixrow[x_]:= XMLElement["matrixrow",{},Map[XMLElement["cn",{},{ToString[FortranForm[#]]}]&, x]];
mrows = matrixrow/@mat;
m=symbolicMathML[XMLElement["matrix",{},mrows]];
Return[m];
] ;
matrixToSymbolicSBML[mat_]:= Module[{},
Print["Error:"//boldOrange," matrixToSymbolicSBML:"//boldBlack,mat//boldRed," is not a matrix."//boldBlack];
Return[stringToNotes["\nMathSBML: matrixToSymbolicSBML: InvalidInput:\n"<>ToString[InputForm[mat]]<>"\n"]];
]

matrixToSBML[x___]:= XMLOut[matrixToSymbolicSBML[x]];


vectorToSymbolicSBML[vec_?VectorQ,opt___?OptionQ]:= Module[{v},
v = Map[XMLElement["cn",{},{ToString[FortranForm[#]]}]&, vec];
v=symbolicMathML[XMLElement["vector",{},v]];
Return[v];
] ;
vectorToSymbolicSBML[mat_]:= Module[{},Print["Error:"//boldOrange," vectorToSymbolicSBML: "//boldBlack,mat//boldRed," is not a vector."//boldBlack];
Return[stringToNotes["\nMathSBML: vectorToSymbolicSBML: Invalid Input:\n"<>ToString[InputForm[mat]]<>"\n"]];
];
vectorToSBML[x___]:= XMLOut[vectorToSymbolicSBML[x]];



MIRIAMcreatorToSymbolicXML[]:= MIRIAMcreatorToSymbolicXML[MIRIAMcreatorFamily,MIRIAMcreatorGiven,MIRIAMcreatorEMAIL,MIRIAMcreatorOrgname];

MIRIAMcreatorToSymbolicXML[family_?StringQ, given_?StringQ, email_?StringQ, org_?StringQ]:=Module[
{v,b,t,d,warn, dbg=False},

If[dbg, Print["dbg: MIRIAMcreatorToSymbolicXML: setMIRIAMCreator"]]; 
setMIRIAMcreator[family,given,email,org];

If[dbg, Print["dbg: MIRIAMcreatorToSymbolicXML: vCardToSymbolicXML"]]; 

v=vCardToSymbolicXML[MIRIAMcreatorFamily,MIRIAMcreatorGiven,MIRIAMcreatorEMAIL,MIRIAMcreatorOrgname];

If[dbg, Print["dbg: MIRIAMcreatorToSymbolicXML: warnings"]]; 

warn[test_, descr_]:= If[test,Print["Warning:"//boldRed,"MIRIAM creator "//boldBlack, descr//boldBlue," is not specified."//boldBlack]];

warn[family=="Indeterminate","Family"];
warn[given=="Indeterminate","Given"];
warn[org=="Indeterminate","Orgname"];
warn[StringMatchQ[org,RegularExpression[".*Indeterminate.*"]],"EMAIL"];

If[dbg, Print["dbg: MIRIAMcreatorToSymbolicXML: createBag"]]; 

b=createBag[];
b=appendToBag[b,v];
b=XMLElement["dc:creator",{"rdf:ParseType"->"Resource"},{b}]; 

If[dbg, Print["dbg: MIRIAMcreatorToSymbolicXML: setMIRIAMcreatedTime"]]; 
setMIRIAMcreatedTime[];
t=MIRIAMCreateTimeToSymbolicXML[];
If[MB$MetaID=="",Print["Warning:"//boldRed,"MIRIAMcreatorToSymbolicXML: Model MetaID has not been defined."//boldBlack]];

d=XMLElement["rdf:Description",{"rdf:about"-> stringer[MB$MetaID]},{b, t}];
d=XMLElement["rdf:RDF",{
"xmlns:rdf"-> "http://www.w3.org/1999/02/22-rdf-syntax-ns#","xmlns:dc"-> "http://purl.org/dc/elements/1.1/",
"xmlns:dcterms"-> "http://purl.org/dc/terms/",
"xmlns:vCard"-> "http://www.w3.org/2001/vcard-rdf/3.0#"
},{d}];
If[dbg, Print["dbg: MIRIAMcreatorToSymbolicXML: annotationToSymbolicSBML"]]; 
d=annotationToSymbolicSBML[d];
Return[d];
];
MIRIAMcreatorToSymbolicXML[x___]:=Print["Error: "//boldRed,"MIRIAMcreatorToSymbolicXML: correct format is \n\tMIRIAMcreatorToSymbolicXML[family,given,email,org]\nwhere all arguments are strings."//boldBlack];


setMIRIAMcreator[family_, given_, email_, org_]:= Module[{a,b,c,d},
a=setMIRIAMcreatorFamily[family];
b=setMIRIAMcreatorGiven[given];
c=setMIRIAMcreatorEMAIL[email];
d=setMIRIAMcreatorOrgname[org];
{a,b,c,d}//Return
]; 

resetMIRIAMcreator[]:=setMIRIAMcreator["Indeterminate", "Indeterminate", "Indeterminate@Indeterminate.Indeterminate", "Indeterminate"]

MIRIAMcreatorFamily="Indeterminate";
setMIRIAMcreatorFamily[x_?StringQ]:= (MIRIAMcreatorFamily=x);
setMIRIAMcreatorFamily[x___]:= Print["Error: "//boldRed,"setMIRIAMcreatorFamily: argument must be a string."//boldBlack];

MIRIAMcreatorGiven="Indeterminate";
setMIRIAMcreatorGiven[x_?StringQ]:=(MIRIAMcreatorGiven=x);
setMIRIAMcreatorGiven[x___]:= Print["Error: "//boldRed,"setMIRIAMcreatorGiven: argument must be a string."//boldBlack];

(* 
eMailAddressQ[x_?StringQ]:= StringMatchQ[x,RegularExpression["([a-zA-Z1-9_]+)((\\.[a-zA-Z1-9_]*[^.])*"<>")@([a-zA-Z1-9_]+)((\\.[a-zA-Z1-9_]*[^.])*"<>")"]]; 
*)


eMailAddressQ[x_?StringQ, echo_:False]:= Module[{ok, chars,badchars, emailAsciiStartCharacter, emailAsciiEndCharacter, invalidAsciiEmailCharacters,emailWord , emailsword,emailListOfWords,okemail, Eprint },

Eprint[xx___]:= If[echo, Print[xx]]; 

emailAsciiStartCharacter=FromCharacterCode[33];
emailAsciiEndCharacter=FromCharacterCode[126];
invalidAsciiEmailCharacters=Characters["()[]<>,;:'\\\""];
emailWord="["<>emailAsciiStartCharacter<>"-"<>emailAsciiEndCharacter<>"]+";
emailListOfWords=emailWord<>"((."<>emailWord<>")*)";
okemail= emailListOfWords<>"@"<>emailListOfWords;

(* basic address *)
(* ascii(.ascii)* @ ascii(.ascii)* *)

ok=StringMatchQ[x, RegularExpression[okemail]];
If[ok==False,
EPrint["Warning: ", "The email address ", "\""<> x<>"\"", " is invalid because it does not specify the pattern specified in RFC 2822, stuff[(.stuff)+]@stuff[(.stuff)+]"];
]; 

(* check for special cases *)

chars=Characters[x];
badchars = Intersection[chars, invalidAsciiEmailCharacters]; 

If[Length[badchars]>0, 
badchars=Union[badchars];
EPrint["Warning: ", "The character: \""<>#<>"\" in the email address ","\""<> x<>"\"", " is not allowed by RFC 2822"]&/@badchars;
ok=False;]; 

If[Length[StringCases[x, "@"]]>1, 
EPrint["Warning: ", "The email address ", "\""<> x<>"\"", " is invalid because only one \"@\" is permitted in an email address."];
ok=False;
]; 

If[StringTake[x, -1]==".", 
EPrint["Warning: ", "The email address ", "\""<> x<>"\"", " is invalid because an email address may not terminate with a period."];
ok=False;]; 

If[StringTake[x, -1]=="@", 
EPrint["Warning: ", "The email address ", "\""<> x<>"\"", " is invalid because an email address may not terminate with an @."];
ok=False;]; 

If[Length[StringCases[x, ".@"]]>0, 
EPrint["Warning: ", "The email address ", "\""<> x<>"\"", " is invalid because a period may not immediately precede the \"@\" in an email address."];
ok=False;
]; 
If[Length[StringCases[x, "@."]]>0, 
EPrint["Warning: ", "The email address ", "\""<> x<>"\"", " is invalid because a period may not immediately follow the \"@\" in an email address."];
ok=False;
]; 
If[Length[StringCases[x, ".."]]>0,
EPrint["Warning: ", "The email address ", "\""<> x<>"\"", " is invalid because two periods may not be adjacent to one another in an email address."];
ok=False;]; 

Return[ok]
];
eMailAddressQ[x___]:= False;

MIRIAMcreatorEMAIL="Indeterminate@Indeterminate.Indeterminate";
setMIRIAMcreatorEMAIL[x_?StringQ]:=Module[{ok},
If[eMailAddressQ[x],
(MIRIAMcreatorEMAIL=x),
Print["Error:"//boldRed,"The string: "//boldBlack,x//boldBlue," does not appear to be a valid email address."//boldBlack]
];
Return[MIRIAMcreatorEMAIL];
];
setMIRIAMcreatorEMAIL[x___]:= Print["Error: "//boldRed,"setMIRIAMcreatorEMAIL: argument must be a string."//boldBlack];

MIRIAMcreatorOrgname="Indeterminate";
setMIRIAMcreatorOrgname[x_?StringQ]:=(MIRIAMcreatorOrgname=x);
setMIRIAMcreatorOrgname[x___]:= Print["Error: "//boldRed,"setMIRIAMcreatorOrgname: argument must be a string."//boldBlack];




checkW3CDTF[s_?StringQ]:= Module[{monthDay,time,year},

monthDay="(((0[13578]|1[02])-(0[1-9]|[12][0-9]|3[0-1]))"<>"|"<>"((0[469]|11)-(0[1-9]|[12][0-9]|30))"<>"|"<>"(02-(0[1-9]|[12][0-9])))";
time="(T([0-1][0-9]|2[0-4]):([0-5][0-9]):([0-5][0-9]))";
year="(2[0-9][0-9][0-9]-)";
Return[StringMatchQ[s,RegularExpression[year<>monthDay<>time]]];
];

MIRIAMcreatedTime="Indeterminate";
setMIRIAMcreatedTime[]:=(MIRIAMcreatedTime=W3CDTF[]);
setMIRIAMcreatedTime[s_?StringQ]:= Module[{},
If[checkW3CDTF[s],
(MIRIAMcreatedTime=W3CDTF[]);
Return[s];
,
Print["Error: "//boldRed,"setMIRIAMcreatedTime: the input string "//boldBlack,
s//boldBlue," does not appear to be in W3CDTF yyyy-mm-ddThh:mm:ss"//boldBlack];
Return[setMIRIAMcreatedTime[]];
];
]; 

MIRIAMmodifiedTime="Indeterminate";
setMIRIAMmodifiedTime[]:=(MIRIAMmodifiedTime=W3CDTF[]);
setMIRIAMmodifiedTime[s_?StringQ]:= Module[{},
If[checkW3CDTF[s],
(MIRIAMmodifiedTime=W3CDTF[]);
Return[s];
,
Print["Error: "//boldRed,"setMIRIAMmodifiedTime: the input string "//boldBlack,
s//boldBlue," does not appear to be in W3CDTF yyyy-mm-ddThh:mm:ss"//boldBlack];
Return[setMIRIAMmodifiedTime[]];
];
]


MIRIAMCreateTimeToSymbolicXML[]:= 
XMLElement["dcterms:created",{"rdf:parseType"->"Resource"},{XMLElement["dcterms:W3CDTF",{},{MIRIAMcreatedTime}]}];

MIRIAMmodifiedTimeToSymbolicXML[]:= 
XMLElement["dcterms:created",{"rdf:parseType"->"Resource"},{XMLElement["dcterms:W3CDTF",{},{MIRIAMmodifiedTime}]}]



createBag[]:= XMLElement["rdf:Bag",{},{}];
getBagSize[XMLElement["rdf:Bag",l1_?ListQ,l2_?ListQ]]:=Length[l2];
getBagSize[z___]:=Print["Error: "//boldRed: " getBagSize: "//boldBlack,z//boldBlue," does not appear to be an rdf:Bag."//boldBlack];
appendToBag[
XMLElement["rdf:Bag",l1_?ListQ,l2_?ListQ], 
XMLElement["rdf:li",l3_?ListQ,l4_?ListQ]]:= 
XMLElement["rdf:Bag",l1,
Append[l2,XMLElement["rdf:li",l3,l4]]];
appendToBag[z_]:=Print["Error: "//boldRed: " appendToBag: "//boldBlack,z//boldBlue," Invalid syntax."//boldBlack]



vCardToSymbolicXML[family_?StringQ, given_?StringQ, email_?eMailAddressQ, org_?StringQ]:= 
XMLElement["rdf:li",{"rdf:parseType"-> "Resource"},
{XMLElement["vCard:N" ,{"rdf:parseType"-> "Resource"},
{XMLElement["vCard:Family",{},{family}],
XMLElement["vCard:Given",{},{given}]}
],
XMLElement["vCard:EMAIL",{},{email}],
XMLElement["vCard:ORG",{},{XMLElement["vCard:Orgname",{},{org}]}]
}];
vCardToSymbolicXML[x___]:= Module[{nargs,family, given, email, org},
nargs=Length[{x}]; 
If[nargs!=4,
Print["Error: "//boldRed,"vCardToSymbolicSBML: invalid argument syntax "//boldBlack,boldBlue/@{x},"; expected 4 arguments."//boldBlack]];
If[nargs>= 1, 
family={x}[[1]];
If[!StringQ[family],
Print["Error:"//boldRed," vCardToSymbolicXML The expression: "//boldBlack,family//boldBlue," does not appear to be a valid \"family\" String. Attempting Recovery"//boldBlack];
family=ToString[family];
],
family="Unspecified";
];
If[nargs>=2, 
given={x}[[2]];
If[!StringQ[given],
Print["Error:"//boldRed," vCardToSymbolicXML The expression: "//boldBlack,given//boldBlue," does not appear to be a valid \"given\" String. Attempting Recovery. "//boldBlack];
given=ToString[given];
],
given="Unspecified";
];
If[nargs>=3, 
email={x}[[3]];
If[!eMailAddressQ[email],
Print["Error:"//boldRed,"The expression: "//boldBlack,email//boldBlue," does not appear to be a valid email address string."//boldBlack];
email="Indeterminate@Email.Address";
],
email="Unspecified@Email.Address";
];
If[nargs>=4, 
org={x}[[4]];
If[!StringQ[org],
Print["Error:"//boldRed," vCardToSymbolicXML The expression: "//boldBlack,org//boldBlue," does not appear to be a valid \"Orgname\" String. Attempting Recovery."//boldBlack];
org=ToString[org];
],
org="Unspecified";
];
vCardToSymbolicXML[family,given,email, org]//Return
];





Help[u___]:= help[u]; 

help[]:= Module[{packages}, 
If[ListQ [$HelpContexts] \[And] Length[$HelpContexts]>0, 
packages = $HelpContexts,

Print["Warning: Help[] has been reinitialized incorrectly. Attempting recovery."];
$HelpContexts={"MathSBML`"};
packages=$HelpContexts; 
]; 
Print["To get help on a specific package type one of the following: "]; 
packages = StringReplace[#, "`"-> ""]&/@packages; 
Print["help[\""<>#<>"\"]"]&/@packages; 
]; 

help[pkg_?StringQ]:= Module[{packages, package, helpfunction}, 
If[ListQ[$HelpContexts] \[And] Length[$HelpContexts]>0, 
packages = $HelpContexts,

packages={}; 
]; 
package=pkg; 
If [StringTake[package, -1]!=   "`", package = package<>"`"]; 

If[!MemberQ[packages, package], 
Print["No help is available on ", pkg]; 
Return[help[]]; 
];

(* execute the requested help function *)

helpfunction=package<>"Private`"<>StringReplace[package, "`"-> ""]<>"help[]"; 
Return[ToExpression[helpfunction]];
 
]; 
help[pkg_]:= help[ToString[pkg]]; 
help[x___]:= (Print["Expecting Help[\"Context\"]"]; Return[$Failed]); 

(* define the local help function in the form contexthhelp[] *)

MathSBMLhelp[]:= Module[{names, usagestrings, print}, 
names=decontextify/@Names["MathSBML`*"];
usagestrings = ToExpression/@((ToString[#]<>"::usage")&/@names); 
print[a_, b_]:= Module[{}, 
StylePrint[a, "Subsection"]; 
Print[b]; 
]; 
StylePrint["MathSBML Help", "Section"]; 
Print["This is the MathSBML Help file. Please note that MathSBML is experimental software and as such many of the functions may only contain partial implementations. And like a lot of software documentation in the cybersphere it does not always keep up with the latest implementation. Please check with the developer if you have any questions."];
Print["This file was generated by MathSBML version "<>$MathSBML$Version<>" on "<>DateString[{"Day", " ", "MonthNameShort", " ", "Year", " at ", "Hour", ":", "Minute", ":", "Second", " (", "TimeZone",")"}]<>" using Mathematica "<>$Version<>" (Version "<>ToString[ $VersionNumber]<>", Release "<>ToString[ $ReleaseNumber]<> ")"];  
MapThread[print, {names, usagestrings}]; 
];



AddHelp[context_?StringQ]:= Module[{ctx, c},
ctx = context;
If[StringTake[ctx, -1]!= "`", ctx = ctx <> "`"]; 
If[MemberQ[$HelpContexts, ctx], Return[True]]; 
c=Append[$HelpContexts, ctx]; 
$HelpContexts=c; 
Return[True]; 
];
AddHelp[context_]:=AddHelp[ToString[context]]; 

ResetHelp[]:= Module[{contexts, me}, 
contexts=$HelpContexts ;
If[ToString[contexts]=="$HelpContexts", 
$HelpContexts={}, 
$HelpContexts=Flatten[{contexts}];
];
AddHelp["MathSBML`"]; 
]; 

ResetHelp[]; 



If[Length[Names["FLAGS`ECHOLOAD"]]>0,
MathSBML`Private`msgflag=ToExpression["FLAGS`ECHOLOAD"],
MathSBML`Private`msgflag=True;
];

VR=" (Version "<>ToString[$VersionNumber]<>", Release "<>ToString[$ReleaseNumber]<>")";
rightnow=DateString[{"Day"," ","MonthName", " ", "Year", " at ", "Hour24",":", "Minute", " ", "TimeZone"}];

If[MathSBML`Private`msgflag,
If[TEMP$FIRST \[Or] (!TEMP$FIRST \[And] !Equal[ToString[$MathSBML$Version], TEMP$OLDVERSION]),
Print[MyStyleForm["MathSBML Version "<>ToString[$MathSBML$Version]<>" using Mathematica Version "<>$Version<>VR<>" loaded "<>rightnow<>"\nGNU Lesser General Public License (LGPL) Terms Apply. ", FontWeight-> Bold, FontColor-> Black]];,

Print[MyStyleForm["MathSBML Version "<>ToString[$MathSBML$Version]<>" using Mathematica Version "<>$Version<>VR<>" reloaded "<>rightnow<>"\nGNU Lesser General Public License (LGPL) Terms Apply. ", FontWeight-> Bold, FontColor-> Black]];

];

];
If[!TEMP$FIRST \[And] !Equal[ToString[$MathSBML$Version], TEMP$OLDVERSION],Print[
MyStyleForm["MathSBML: warning: loading a different version of MathSBML may cause unexpected results.\ncurrent version of MathSBML: "<>ToString[$MathSBML$Version]<>"\nprevious version of MathSBML:"<>TEMP$OLDVERSION,FontWeight-> Bold, FontColor-> Red]
]]; 

If[MathSBML`Private`msgflag,
Print["Please report MathSBML issues to the MathSBML Tracker at "//boldBlack, Hyperlink["http://sourceforge.net/tracker/?atid=984327&group_id=71971&func=browse"]//boldBlue]
]; 
FLAGS`ECHOLOAD=MathSBML`Private`msgflag;
Remove[MathSBML`Private`msgflag];

End[];

Remove[TEMP$OLDVERSION];
Remove[TEMP$FIRST];
Remove[rightnow]; 
 
EndPackage[];
