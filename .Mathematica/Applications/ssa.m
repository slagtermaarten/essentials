(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



BeginPackage["SSA`"];


$SSA$Version = "0.11 (17-Mar-2009)";


Needs["DifferentialEquations`InterpolatingFunctionAnatomy`"]


SSA::usage="SSA[reactions, tmax, initialConditiosn]\nSSA[reactions, tmax, initialConditions, rates]\nSSA[reactions, tmax, initialConditions, rates, MaxSteps:10^6]\nSSA[reactions, {tmin,tmax}, initialConditions, rates, MaxSteps:10^6]\nSSA[reactions, tmax]\nSSA[reactions]\n\nreactions is {\!\(\*SubscriptBox[\"r\", \"1\"]\),\!\(\*SubscriptBox[\"r\", \"2\"]\),...,\!\(\*SubscriptBox[\"r\", \"n\"]\)} where (in BNF) each \n\!\(\*SubscriptBox[\"r\", 
RowBox[{\"i\", \" \"}]]\)::={\!\(\*SubscriptBox[\"R\", \"1\"]\)[+\!\(\*SubscriptBox[\"R\", \"2\"]\)]\[Rule]\!\(\*SubscriptBox[\"R\", \"3\"]\)[+\!\(\*SubscriptBox[\"R\", \"4\"]\)] [,k]}\nIf omitted, k defaults to 1.\nReactions {0\[Rule]A, k} or {A\[Rule]0, k} [or {\[EmptySet]\[Rule]A,k}, {A\[Rule]\[EmptySet],k}] designate creation and annihilation.\nHigher order reactions (e.g., trimolecular) are not supported. ";

SSAPlot::usage="SSAPlot[solution, variable, options]\nSSAPlot[solution, {variables}, options]\n\nOptions: SSAPlotType, SSAPlotStyles, any option for ListPlot";
SSALinePlot::usage="SSALinePlot[solution, variable, options]\nSSALinePlot[solution, {variables}, options]";
SSADotPlot::usage="SSADotPlot[solution, variable, options]\nSSADotPlot[solution, {variables}, options]";
SSAPhasePlot::usage="SSAPhasePlot[solution, {X,Y}, OptionalGraphicsDirectives] \nSSAPhasePlot[solution, {X,Y}, Options]\nSSAPhasePlot[solution, {X,Y}, \"Directives\"\[Rule]{dir,...}] is equivalent to SSAPhasePlot[solution, {X,Y}, dir], where dir is a list of Graphics Directives. Any valid option for Graphics may be used."; 
SSAPhaseCurve::usage="SSAPhaseCurve[solution, {X,Y}, OptionalGraphicsDirectives] is equivalent to SSAPhasePlot[solution, {X,Y}, Axes\[Rule]False, \"Directives\"\[Rule]OptionalGraphicsDirectives]"; 
SSAPlotStyles::usage="An option for SSAPlot. A list of values for PlotStyle, when multiple variables are being plotted on the same figure. If omitted, random hues are used to color the curves.";
(* SSAPhaseCurveData::usage=""; *)
(* SSAPhaseArrayPlot::usage=""; *)

SSAMean::usage=""; 
SSAFit::usage=""; 

SSAPlotType::usage="An option for SSAPlot, values are \"Line\", \"Dot\". ";
Options[SSAPlot]={SSAPlotStyles-> Automatic, SSAPlotType-> "Line"};


HillFunction::usage="HillFunction[x,n,K,v] =  \!\(\*FractionBox[
RowBox[{\"v\", \"*\", SuperscriptBox[\"x\", \"n\"]}], 
RowBox[{SuperscriptBox[\"K\", \"n\"], \"+\", SuperscriptBox[\"x\", \"n\"]}]]\)";
UmbralHillFunction::usage="UmbralHillFunction[X, n, K, v] =\!\(\*FractionBox[
RowBox[{\"v\", SubscriptBox[
RowBox[{\"(\", \"x\", \")\"}], \"n\"], \" \"}], 
RowBox[{SuperscriptBox[\"K\", \"n\"], \"+\", SubscriptBox[
RowBox[{\"(\", \"X\", \")\"}], \"n\"]}]]\), for integer n >0.\n"<>"UmbralHillFunction[X, -m, K, v] = \!\(\*FractionBox[
RowBox[{\"v\", SubscriptBox[
RowBox[{\"(\", \"X\", \")\"}], \"m\"]}], 
RowBox[{SuperscriptBox[\"K\", \"m\"], \"+\", SubscriptBox[
RowBox[{\"(\", \"X\", \")\"}], \"m\"]}]]\), for integer m>0.\n"<>"where (X\!\(\*SubscriptBox[\")\", \"n\"]\)= X(X-1)(X-2)\[Ellipsis] (X-n+1) = \!\(\*FractionBox[
RowBox[{\"X\", \"!\"}], 
RowBox[{
RowBox[{\"(\", 
RowBox[{\"X\", \"-\", \"2\"}], \")\"}], \"!\"}]]\)"; 

LogisticFunction::usage="LogisticFunction[x]:= \!\(\*FractionBox[\"1\", 
RowBox[{\"1\", \"+\", SuperscriptBox[\"e\", \"x\"]}]]\)\nLogisticFunction[x,v:1, \[Beta]:1,n:1, h:0]:= \!\(\*FractionBox[\"v\", 
RowBox[{\"1\", \"+\", SuperscriptBox[\"e\", 
RowBox[{
RowBox[{\"-\", \"h\"}], \"-\", SuperscriptBox[\"\[Beta]x\", \"n\"]}]]}]]\)"; 

UmbralLogisticFunction::usage="UmbralLogisticFunction[x, v:1, \[Beta]:1, n:1, h:0]:= \!\(\*FractionBox[\"v\", 
RowBox[{\"1\", \"+\", SuperscriptBox[\"e\", 
RowBox[{
RowBox[{\"-\", \"h\"}], \"-\", 
RowBox[{\"\[Beta]\", SubscriptBox[
RowBox[{\"(\", \"x\", \")\"}], \"n\"]}]}]]}]]\) where (x\!\(\*SubscriptBox[\")\", \"n\"]\)=(x)(x-1)(x-2)...(x-n+1)"; 


ExpandReactions::usage="ExpandReactions[{r1,r2, ...}] returns the list of base reactions that the list of input reactions is reduced to by ExpandReaction. "; 

ExpandReaction::usage="ExpandReaction[reaction] returns  the list of base reactions that the high level reaction represets, for example, ExpandReaction[{A\[RightArrowLeftArrow]B, kf, kr}] returns {{A\[Rule]B,kf},{B\[Rule]A,kr}}."; 

sHill::usage="sHill is an uninstantiated function used to reprsent a reaction law with a Hill Function with an Umbral Substitution of \!\(\*SuperscriptBox[\"X\", \"n\"]\)\[Rule]X(X-1)(X-2)...(X-n+1).";

sMMH::usage="sMMH is an uninstantiated function used to represent Michaelis-Menten-Henri kinetics.";
sGRN::usage="sGRN is an uninstantiated function used to represent Logistic function rate laws (aka GRN functions)." 
sSSystem::usage="sSSystem is an uninstantiated function used to represent S-Systems"; 
sMWC::usage="sMWC is an uninstantiated function used to represent MWC rate laws";

MWCFunction::usage="MWCFunction[X, Enz, k, n, c, L, K] returns "<>"\!\(\*FractionBox[
RowBox[{\"Enz\", \" \", \"k\", \" \", 
RowBox[{\"(\", 
RowBox[{FractionBox[
RowBox[{\"X\", \" \", SuperscriptBox[
RowBox[{\"(\", 
RowBox[{\"1\", \"+\", FractionBox[\"X\", \"K\"]}], \")\"}], 
RowBox[{
RowBox[{\"-\", \"1\"}], \"+\", \"n\"}]]}], \"K\"], \"+\", FractionBox[
RowBox[{\"c\", \" \", \"L\", \" \", \"X\", \" \", SuperscriptBox[
RowBox[{\"(\", 
RowBox[{\"1\", \"+\", FractionBox[
RowBox[{\"c\", \" \", \"X\"}], \"K\"]}], \")\"}], 
RowBox[{
RowBox[{\"-\", \"1\"}], \"+\", \"n\"}]]}], \"K\"]}], \")\"}]}], 
RowBox[{SuperscriptBox[
RowBox[{\"(\", 
RowBox[{\"1\", \"+\", FractionBox[\"X\", \"K\"]}], \")\"}], \"n\"], \"+\", 
RowBox[{\"L\", \" \", SuperscriptBox[
RowBox[{\"(\", 
RowBox[{\"1\", \"+\", FractionBox[
RowBox[{\"c\", \" \", \"X\"}], \"K\"]}], \")\"}], \"n\"]}]}]]\)"; 
UmbralMWCFunction::usage="MWCFunction[S, Enz, k, n, c, L, K] represents the MWC rate function under the umbral transformation \!\(\*SuperscriptBox[\"x\", 
RowBox[{\"k\", \" \"}]]\)\[Rule](x\!\(\*SubscriptBox[\")\", \"k\"]\), which is given by "<>"\!\(\*FractionBox[
RowBox[{\"k\", \" \", \"Enz\", \" \", 
RowBox[{\"(\", 
RowBox[{FractionBox[
RowBox[{\"S\", \" \", 
RowBox[{\"UmbralBinomial\", \"[\", 
RowBox[{\"1\", \",\", \" \", 
RowBox[{\"1\", \"/\", \"K\"}], \",\", \" \", \"S\", \",\", \" \", 
RowBox[{
RowBox[{\"-\", \"1\"}], \"+\", \"n\"}]}], \"]\"}]}], \"K\"], \"+\", FractionBox[
RowBox[{\"c\", \" \", \"L\", \" \", \"S\", \" \", 
RowBox[{\"UmbralBinomial\", \"[\", 
RowBox[{\"1\", \",\", \" \", 
RowBox[{\"c\", \"/\", \"K\"}], \",\", \" \", \"S\", \",\", \" \", 
RowBox[{
RowBox[{\"-\", \"1\"}], \"+\", \"n\"}]}], \"]\"}]}], \"K\"]}], \")\"}]}], 
RowBox[{
RowBox[{\"UmbralBinomial\", \"[\", 
RowBox[{\"1\", \",\", \" \", 
RowBox[{\"1\", \"/\", \"K\"}], \",\", \" \", \"S\", \",\", \" \", \"n\"}], \"]\"}], \"+\", 
RowBox[{\"L\", \" \", 
RowBox[{\"UmbralBinomial\", \"[\", 
RowBox[{\"1\", \",\", \" \", 
RowBox[{\"c\", \"/\", \"K\"}], \",\", \" \", \"S\", \",\", \" \", \"n\"}], \"]\"}]}]}]]\)"; 

UmbralPower::usage="";
UmbralBinomial::usage="UmbralBinomial[a, b, x, n] represents the result of  transforming (a+bx\!\(\*SuperscriptBox[\")\", \"n\"]\) under the unbral substition \!\(\*SuperscriptBox[\"x\", 
RowBox[{\"k\", \" \"}]]\)\[Rule](x\!\(\*SubscriptBox[\")\", \"k\"]\), which is given by   \!\(\*UnderoverscriptBox[\"\[Sum]\", 
RowBox[{\"k\", \"=\", \"0\"}], \"n\"]\)(\[NoBreak]\*GridBox[{
{n},
{k}
}]\[NoBreak])\!\(\*SuperscriptBox[\"a\", 
RowBox[{\"n\", \"-\", \"k\"}]]\)\!\(\*SuperscriptBox[\"b\", \"k\"]\)(x\!\(\*SubscriptBox[\")\", \"k\"]\) where (x\!\(\*SubscriptBox[\")\", \"k\"]\)=\!\(\*FractionBox[
RowBox[{\" \", 
RowBox[{\"x\", \"!\"}]}], 
RowBox[{
RowBox[{\"(\", 
RowBox[{\"x\", \"-\", \"k\"}], \")\"}], \"!\"}]]\)"<>
"\nUmbralBinomial[a, b, x, y, n] represents the result of  transforming (a x+b y\!\(\*SuperscriptBox[\")\", \"n\"]\) under the unbral substition \!\(\*SuperscriptBox[\"x\", 
RowBox[{\"k\", \" \"}]]\)\[Rule](x\!\(\*SubscriptBox[\")\", \"k\"]\)   and \!\(\*SuperscriptBox[\"y\", \"k\"]\)\[Rule](y\!\(\*SubscriptBox[\")\", \"k\"]\) which is given by   \!\(\*UnderoverscriptBox[\"\[Sum]\", 
RowBox[{\"k\", \"=\", \"0\"}], \"n\"]\)(\[NoBreak]\*GridBox[{
{n},
{k}
}]\[NoBreak])\!\(\*SuperscriptBox[\"a\", 
RowBox[{\"n\", \"-\", \"k\"}]]\)\!\(\*SuperscriptBox[\"b\", \"k\"]\)(x\!\(\*SubscriptBox[\")\", 
RowBox[{\"n\", \"-\", \"k\"}]]\)(y\!\(\*SubscriptBox[\")\", \"k\"]\) where (x\!\(\*SubscriptBox[\")\", \"k\"]\)=\!\(\*FractionBox[
RowBox[{\" \", 
RowBox[{\"x\", \"!\"}]}], 
RowBox[{
RowBox[{\"(\", 
RowBox[{\"x\", \"-\", \"k\"}], \")\"}], \"!\"}]]\)"; 
UmbralMultinomial::usage="UmbralMultinomial[{\!\(\*SubscriptBox[\"x\", \"1\"]\),\!\(\*SubscriptBox[\"x\", \"2\"]\), ..., \!\(\*SubscriptBox[\"x\", \"p\"]\)}, n] returns the umbral transform \n\tL[(\!\(\*SubscriptBox[\"x\", \"1\"]\)+\!\(\*SubscriptBox[\"x\", \"2\"]\)+...+ \!\(\*SubscriptBox[\"x\", \"p\"]\)\!\(\*SuperscriptBox[\")\", \"n\"]\)]= \!\(\*UnderoverscriptBox[\"\[Sum]\", 
RowBox[{\"k\", \"=\", \"0\"}], \"n\"]\)(\[NoBreak]\*GridBox[{
{n},
{k}
}]\[NoBreak])(\!\(\*SubscriptBox[\"x\", \"i\"]\)\!\(\*SubscriptBox[\")\", \"k\"]\)L[(\!\(\*SubscriptBox[\"x\", \"2\"]\)+\!\(\*SubscriptBox[\"x\", \"3\"]\)+...+ \!\(\*SubscriptBox[\"x\", \"p\"]\)\!\(\*SuperscriptBox[\")\", \"k\"]\)],\n where each L[(\!\(\*SubscriptBox[\"x\", \"i\"]\)\!\(\*SuperscriptBox[\")\", 
RowBox[{\"k\", \" \"}]]\)]\[Rule] (\!\(\*SubscriptBox[\"x\", \"i\"]\)\!\(\*SubscriptBox[\")\", \"k\"]\), for each variable \!\(\*SubscriptBox[\"x\", \"i\"]\).\nUmbralMultinomial[{\!\(\*SubscriptBox[\"a\", \"1\"]\),\!\(\*SubscriptBox[\"a\", \"2\"]\),...,\!\(\*SubscriptBox[\"a\", \"p\"]\)}, {\!\(\*SubscriptBox[\"x\", \"1\"]\),\!\(\*SubscriptBox[\"x\", \"2\"]\),..., \!\(\*SubscriptBox[\"x\", \"p\"]\)}, n] returns the transform\n\t L[(\!\(\*SubscriptBox[\"a\", \"1\"]\)\!\(\*SubscriptBox[\"x\", \"1\"]\)+\!\(\*SubscriptBox[\"a\", \"2\"]\)\!\(\*SubscriptBox[\"x\", \"2\"]\)+...+\!\(\*SubscriptBox[\"a\", \"p\"]\) \!\(\*SubscriptBox[\"x\", \"p\"]\)\!\(\*SuperscriptBox[\")\", 
RowBox[{\"n\", \" \"}]]\)] = \!\(\*UnderoverscriptBox[\"\[Sum]\", 
RowBox[{\"k\", \"=\", \"0\"}], \"n\"]\)(\[NoBreak]\*GridBox[{
{n},
{k}
}]\[NoBreak])\!\(\*SubsuperscriptBox[\"a\", \"1\", \"k\"]\)(\!\(\*SubscriptBox[\"x\", \"1\"]\)\!\(\*SubscriptBox[\")\", \"k\"]\)L[(\!\(\*SubscriptBox[\"a\", \"2\"]\)\!\(\*SubscriptBox[\"x\", \"2\"]\)+\!\(\*SubscriptBox[\"a\", \"3\"]\)\!\(\*SubscriptBox[\"x\", \"3\"]\)+...+\!\(\*SubscriptBox[\"a\", \"p\"]\) \!\(\*SubscriptBox[\"x\", \"p\"]\)\!\(\*SuperscriptBox[\")\", \"k\"]\)],\n  where the \!\(\*SubscriptBox[\"a\", \"i\"]\) are constants."; 

UmbralProduct::usage=""


XLR8RtoSSA::usage="XLR8RtoSSA[{r1,r2,...}] where r1, r2, ... are each cellerator reactions returns a list of SSA-compatible reactions.\nXLR8RtoSSA[{reaction, rates}] converts a single reaction from xlr8r format to SSA format, e.g., XLR8RtoSSA[{A+B\[Rule]C, k}]\nAny unidentifable (or unimplemented) reactions are returned as Indeterminate[reaction]."; 
SSAtoXLR8R::usage="SSAtoXLR8R[{r1,r2, ..}] returns a list of reactions  in Cellerator format.\nSSAtoXLR8R[{reaction, rates} converts a single reaction from SSA format to xlr8r format, e.g., SSAtoXLR8R[{A+B\[Rule]C, k}]"; 


SSASave::usage="SSASave[model, options] converts the model to xlr8r form and saves it as CelleratorML. An interactive file name dialog will be opened to determine the output file name. The file can be read back in and automatically converted to SSA form using SSAGet.\n"<>"\nSSASave[filename, model, options] will open the specified file"<>"\nOptions:"<>
"\n\"File\"\[Rule]filename (screen if not specified)"<>
"\n\"InitialConditions\"\[Rule] list of initial conditions as rules"<>
"\n\"Parameters\"\[Rule] list of parameter rules"<>
"\n\"Description\"\[Rule] any text string describing the model"<>
"\n\"Name\"\[Rule] any indentifier to use as the model name"<>
"\n\nNote: If CelleratorML.m,xlr8r.m,MathSBML.m,Cellzilla.m,mPower.m cannot be found this will generate an error message.";

SSAGet::usage="SSAGet[filename] reads the specified CelleratorML file\nSSAGet[] first opens an interactive file name dialog to determine the file, and then reads the file.\n\nThe file is read, converted from XLR8R form to SSA form, and returned as the following list: \n"<>"{\"Name\"\[Rule]modelname\n \"Model\"\[Rule]list of reactions\n \"Parameters\"\[Rule] list of parameter assignments as a rule list\n \"InitialConditions\"\[Rule]Initial conditions as a rule list}\n\nOptions:\n\"Quiet\"\[Rule]False, if True, suppresse printing a statistical summary."; 


Begin["`Private`"];


MyFilterOptions[f_, opt___?OptionQ]:= 
If[$VersionNumber<6,
Utilities`FilterOptions`FilterOptions[f, opt]
,
Sequence@@FilterRules[Flatten[{opt}],Options[f]]
];



now::usage="now[] returns the date and time as a string";

now[]:= StringReplace[DateString[], " "-> "-"]


NewFileName[opt___?OptionQ]:= Module[{f,file, prefix, type, n},
prefix = "FilePrefix"/.{opt}/.{"FilePrefix"-> "SSA-"}; 
type = "FileType"/.{opt}/.{"FileType"-> "dat"}; 
If[StringLength[type]<1, type="."]; 
If[StringTake[type, {1,1}]!= ".", type = "."<>type];  
file=DateString[{"YearShort", "Month", "Day","T","Hour","Minute", "Second"}];
n=1; 
f= prefix<>file<>type;
While[Length[FileNames[f]]>0 \[And] n< 1000,
f=prefix<>file<>"-"<>ToString[n]<>type;
n=n+1;
];
If[Length[FileNames[f]]>0, Print["Warning: file ", f, " will be overwritten."]]; 

Return[f]; 
]


PositiveInteger[x_]:= And[IntegerQ[x], Positive[x]];
NegativeInteger[x_]:= And[IntegerQ[x], Negative[x]]; 


UmbralPower[x_, 0]:= 1; 
UmbralPower[x_, 1]:= x;
UmbralPower[x_, n_?PositiveInteger]:=x* UmbralPower[x-1, n-1];
UmbralPower[x_?ListQ, {n__?PositiveInteger}]:= Module[{powers},
powers = PadRight[{n}, Length[x]]; 
Return[MapThread[UmbralPower, {x, powers}]];
];
UmbralPower[x_, n_?Positive]:= Gamma[x+1]/Gamma[x+1-n]; 

UmbralPower[x_, n_]:= (Print["Error: UmbralPower undefined for power ", n, " (must be a positive integer)."]; $Failed); 


UmbralProduct[{}]:= 1; 
UmbralProduct[x_?ListQ]:= UmbralProduct@@x; 
UmbralProduct[x__]:= Module[{p},
p=(Times@@Sort[{x}])/.{Power-> UmbralPower}; 
Return[p]; 
];


UmbralBinomial[0_, b_, x_, n_]:= b^n UmbralPower[x, n]; 
UmbralBinomial[a_, 0_, x_, n_]:= a^n; 
UmbralBinomial[a_, b_, 0, n_]:= a^n; 
UmbralBinomial[a_, b_, x_, n_?PositiveInteger]:=Module[{k},  \!\(
\*UnderoverscriptBox[\(\[Sum]\), \(k = 0\), \(n\)]\(Binomial[n, \ k] Power[a, \ n - k] Power[b, \ k]\ UmbralPower[x, \ k]\)\) ];
UmbralBinomial[a_, b_, x_, y_, n_?PositiveInteger]:=Module[{k},  \!\(
\*UnderoverscriptBox[\(\[Sum]\), \(k = 0\), \(n\)]\(Binomial[n, \ k] Power[a, \ n - k] Power[b, \ k]\ UmbralPower[x, \ n - k]\ UmbralPower[y, \ k]\)\) ];
UmbralBinomial[x___]:= (Print["Error: Expecting UmbralBinomial[a, b, x, n:PositiveInteger] or UmbralBinomial[a, b, x, y, n:PositiveInteger], not ","UmbralBinomial"@@{x}]; $Failed);  


UmbralMultinomial[a_List, B_List, 0]:= 1; 
UmbralMultinomial[{}, {}, n_]:= $Failed; 
UmbralMultinomial[{a_}, {x_}, n_?PositiveInteger]:= a^n UmbralPower[x, n]; 
UmbralMultinomial[{a_, b_}, {x_, y_}, n_?PositiveInteger]:= UmbralBinomial[a,b, x, y, n]; 
UmbralMultinomial[vars_List, n_?PositiveInteger]:= UmbralMultinomial[Table[1, {Length[vars]}], vars, n]; 
UmbralMultinomial[a_List, vars_List, n_?PositiveInteger]:= Module[{coefficients, variables, ncoef, nvars, X, A, value, k, nonzero, dbg=False, dpr},
 dpr[x___]:= If[dbg, Print["UmbralMultinomial:", x]]; 
nonzero=!SameQ[#*1.0, 0.]&/@a;
coefficients = Pick[a, nonzero];
variables = Pick[vars, nonzero]; 
ncoef =  Length[coefficients]; 
nvars = Length[variables]; 
dpr[{nonzero, coefficients, variables, ncoef, nvars}]; 

If[nvars != ncoef, Print["Error: UmbralMultinomial: ", ncoef," coefficients for ", nvars," expecting same number of coefficients and variables."]; Return[$Failed]; 
]; 

X = First[variables]; 
variables = Rest[variables]; 
A = First[coefficients];
coefficients = Rest[coefficients]; 

value = \!\(
\*UnderoverscriptBox[\(\[Sum]\), \(k = 0\), \(n\)]\(Binomial[n, \ k] UmbralPower[X, k] UmbralMultinomial[coefficients, \ variables, \ n - k]\)\);
Return[value]; 
];
UmbralMultinomial[x___]:= (Print["Error: expecting UmbralMultinomal[{\!\(\*SubscriptBox[\"a\", \"1\"]\), \!\(\*SubscriptBox[\"a\", \"2\"]\), ...}, {\!\(\*SubscriptBox[\"x\", \"1\"]\),\!\(\*SubscriptBox[\"x\", \"2\"]\), ...}, n:PostiveInteger], not ", "UmbralMultinomial"@@{x}]; $Failed); 


HillFunction[x_, n_, K_, v_]:= (v*x^n)/(K^n+x^n);

UmbralHillFunction[{x__}, n_?PositiveInteger, K_, v_]:= (v*UmbralMultinomial[{x}, n ])/(K^n+ UmbralMultinomial[{x}, n]);
UmbralHillFunction[ {x__}, {T__},n_?PositiveInteger, K_, v_]:=Module[{Tout}, 
Tout = PadRight[{T}, Length[{x}], 1]; 

If[Length[Tout]>Length[{T}], Print["Error: UmbralHillFunction: ", Length[{T}], " coeffficients found; ", Length[{x}], " variables in ","UmbralHillFunction"@@{{x}, {T}, n, K, v}, " There should be the same number of input variables as there are coefficients. I assume you meant the following: ", "UmbralHillFunction"@@{{x}, {Tout}, n, K, v}]; 
]; 
Return[ (v*UmbralMultinomial[Tout, {x}, n ])/(K^n+ UmbralMultinomial[Tout, {x}, n])]];
UmbralHillFunction[{x__}, m_?NegativeInteger, K_, v_]:=Module[{n}, n=-m;Return[  (v*K^n)/(K^n+ UmbralMultinomial[{x}, n])]];
UmbralHillFunction[{x__},{T__},  m_?NegativeInteger, K_, v_]:=Module[{n}, n=-m;Return[  (v*K^n)/(K^n+ UmbralMultinomial[{T}, {x}, n])]];
UmbralHillFunction[x_, n_?Positive, K_, v_]:= (v*UmbralPower[x,n])/(K^n+UmbralPower[x,n]);
UmbralHillFunction[x_, n_?NegativeInteger, K_, v_]:= Module[{m}, m=-n;Return[(v*K^m)/(K^m+UmbralPower[x,m])]];
UmbralHillFunction[x_, n_, K_, v_]:= (Print["Error: UmbralHillFunction undefined for power ", n, " (must be a non-zero integer)."]; $Failed); 


LogisticFunction[x_]:= 1/(1+E^-x);
LogisticFunction[x_, v_:1, \[Beta]_:1, n_:1,  h_:0]:=v* LogisticFunction[\[Beta]*x^n+h];
LogisticFunction[x___]:= $Failed; 
UmbralLogisticFunction[x_List, v_:1, \[Beta]_:1, n_:1,  h_:0]:= Module[{beta, nx, enn, error},

error[varz_]:= Module[{f, errs, vars},
(* add a unique dummy variable, otherwise the Times->List will have no effect if there is only a single repeated variable in the list*) 
vars = Append[varz, Unique[]];   
errs=Select[((Times@@vars/.{Power-> f})/.Times-> List)/.{f-> List}, ListQ];
Print["Error: UmbralLogisticFunction: the variable ",#[[1]], " is not allowed to be repeated in the left hand side of ", 
"UmbralLogisticFunction"@@{x,v,\[Beta], n, h}
]&/@errs;
Return[Length[errs]>0]
];

If[error[x], Return[$Failed]]; 

nx=Length[x];  
beta = PadRight[Flatten[{\[Beta]}], nx, 1]; 
enn = PadRight[Flatten[{n}], nx, 1]; 

v* LogisticFunction[beta.UmbralPower[x,enn]+h]
];

UmbralLogisticFunction[x_, v_:1, \[Beta]_:1, n_:1,  h_:0]:= v* LogisticFunction[\[Beta]*UmbralPower[x,n]+h];
UmbralLogisticFunction[x___]:= $Failed; 


MWCFunction[S_, Enz_?(!ListQ[#]&), k_, n_, c_, L_, K_?(!ListQ[#]&)]:= (k Enz ((S (1+S/K)^(-1+n))/K+(c L S (1+(c S)/K)^(-1+n))/K))/((1+S/K)^n+L (1+(c S)/K)^n);  
MWCFunction[S_, enz_?ListQ, k_, n_, c_, L_, K_?ListQ]:=Module[{nEnz, nK,Klist, enzymes, Enzyme, Act, Inh, KS, KA, KI, function},

enzymes=PadRight[enz, 3, 0];
Klist = PadRight[K, 3, Infinity]; 

{Enzyme, Act, Inh} = enzymes; 
{KS, KA, KI} = Klist; 
function = (Enzyme k (((1+Act/KA)^n S (1+S/KS)^(-1+n))/KS+(c (1+Inh/KI)^n L S (1+(c S)/KS)^(-1+n))/KS))/((1+Act/KA)^n (1+S/KS)^n+(1+Inh/KI)^n L (1+(c S)/KS)^n)
]; 



UmbralMWCFunction[S_, enz_?ListQ, k_, n_?PositiveInteger, c_, L_, K_?ListQ]:=Module[{nEnz, nK,Klist, enzymes, Enzyme, Act, Inh, KS, KA, KI, function, UB, UBS},

UB[ X_, \[Alpha]_, p_]:=Module[{j}, \!\(
\*UnderoverscriptBox[\(\[Sum]\), \(j = 0\), \(p\)]\(Binomial[p, \ j] Power[\[Alpha], \ j]\ UmbralPower[X, \ j]\)\) ]; 
UBS[X_, \[Alpha]_, p_]:= Module[{j},  \!\(
\*UnderoverscriptBox[\(\[Sum]\), \(j = 0\), \(p\)]\(Binomial[p, \ j] Power[\[Alpha], \ j]\ UmbralPower[X, \ j + 1]\)\) ];

enzymes=PadRight[enz, 3, 0];
Klist = PadRight[K, 3, Infinity]; 

{Enzyme, Act, Inh} = enzymes; 
{KS, KA, KI} = Klist; 
function =Enzyme k* ((UB[Act, 1/KA, n]  UBS[S, 1/KS, n-1] )/KS+(c *L*UB[Inh ,1/KI, n] UBS[S, c/KS, n-1] )/KS)/(UB[Act, 1/KA, n] UB[S, 1/KS, n]+L UB[Inh, 1/KI, n] UB[S, c/KS, n]) ;
Return[function];
]; 

UmbralMWCFunction[S_, Enz_, k_, n_?PositiveInteger, c_, L_, K_]:=Module[{UB, UBS},

UB[ X_, \[Alpha]_, p_]:=Module[{j}, \!\(
\*UnderoverscriptBox[\(\[Sum]\), \(j = 0\), \(p\)]\(Binomial[p, \ j] Power[\[Alpha], \ j]\ UmbralPower[X, \ j]\)\) ]; 
UBS[X_, \[Alpha]_, p_]:= Module[{j},  \!\(
\*UnderoverscriptBox[\(\[Sum]\), \(j = 0\), \(p\)]\(Binomial[p, \ j] Power[\[Alpha], \ j]\ UmbralPower[X, \ j + 1]\)\) ]; 
 
Return[ (k Enz (UBS[S, 1/K, n-1]/K+(c L   UBS[S, c/K, n-1])/K))/(UB[S, 1/K,  n]+L UB[S, c/K, n])]];



UmbralMWCFunction[x___]:= (Print["Error: Expecting UmbralMWCFunction[s, Enz, k, n:Positive Integer, c, L, K], not ", "UmbralMWCFunction"@@{x}]; Return[$Failed]);


ListToSum[Rule[a_, b_]]:= Rule[ListToSum[a], ListToSum[b]]; 
ListToSum[x_]:= Plus@@Flatten[{x/.{Plus->List}}];


ReactantQ[A_?AtomQ]:=True;
ReactantQ[HoldPattern[Plus[Q___]]]:=False;
ReactantQ[A_?AtomQ[B__]]:=True;
ReactantQ[A___]:=False;


ReactionQ[{A_->B_, k_}]:=True;
ReactionQ[{A_->B_}]:=True;
ReactionQ[A___]:=False;


SSACheck[r_]:=Module[{ok, notok, listifyReaction, dbg=False, dPrint},

dPrint[x___]:= If[dbg, Print["SSACheck: ", x]]; 

listifyReaction[{A_-> B_,k_}]:=Module[{rs,p, myTimes, c, k2c, ok},
myTimes[n_?IntegerQ,x_?ReactantQ]:=Table[x,{n}];
myTimes[x_?ReactantQ,n_?IntegerQ]:=Table[x,{n}];
myTimes[x_,y_]:={x,y};


rs=(A/.{Plus-> List,Times-> myTimes})//List//Flatten//Sort;

dPrint["rs=", rs]; 

p=(B/.{Plus-> List,Times-> myTimes})//List//Flatten//Sort;

dPrint["p=", p]; 

ok=True;

(*  Note: there is no factorial here because the factorials in equations (6b) and (15) cancel out in reference (1).  This is because k in the input reactions is the usual rate constant expressed in units of amount (not concentration) and is not the stochastic rate constant.*)


k2c[{0}]:=k;
k2c[s_?ListQ]:=k*( (Times@@Sort[s/.{Global`\[EmptySet]-> 1}])/.{Power-> UmbralPower}) ; 

c=k2c[rs];

dPrint["c=", c]; 

Return[{rs,p ,c,ok}]

];

listifyReaction[{A_-> B_}]:=Module[{},
Print["Warning: The reaction ", {A-> B}, " does not have a rate constant specified, and was interpreted as ",{A-> B, 1}];
Return[listifyReaction[{A-> B,1}]];
];

ok=Select[r,ReactionQ];
notok=Complement[r,ok];
Map[Print["The reaction ",#," is incorrectly formatted and will be ignored."]&,notok];

ok=listifyReaction/@ok;
notok=Select[ok,!Last[#]&];

Map[Print["The following reaction is neither unimolecular nor bimolecular and will be ignored: ", Rule[Plus@@#[[1]],Plus@@#[[2]]]]&,notok];
ok=Complement[ok,notok];

If[Length[ok]>0, 
ok =Most/@ok;
Return[Transpose[ok]];
];
Return[Null];
];


ExpandReactions[r_]:= Module[{rexp},
rexp = ExpandReaction/@r;
rexp = Join@@rexp;
(* Print[rexp]; *)
Return[rexp]; 
];


ExpandReaction[{A_-> B_, x___}]:={{A-> B , x}};


ExpandReaction[{A_\[RightArrowLeftArrow]B_,x___}]:= Module[{r,k, kin},
kin=Flatten[{x}]; 
k=PadRight[kin, 2]; 
If[Length[k]> Length[kin], 
Print["Warning: Missing rate constants in the reaction ",{A\[RightArrowLeftArrow]B,x}, " are assumed to be zero: ", {A\[RightArrowLeftArrow]B,Sequence@@k}];
]; 
If[Length[k]< Length[kin], 
Print["Warning: Extra rate constants in the reaction ",{A\[RightArrowLeftArrow]B,x}, " were ignored: ", {A\[RightArrowLeftArrow]B,Sequence@@k}];
]; 

r={{A-> B, k[[1]]}, {B-> A, k[[2]]}}; 
Return[r]; 
];



ExpandReaction[{
\!\(\*OverscriptBox[
RowBox[{"A_", "\[Rule]", " ", "B_"}], "e_"]\), x___}]:= Module[
{r, kin}, 
kin={x}//Flatten; 
k=PadRight[kin, 1]; 
If[Length[k]> Length[kin], 
Print["Warning: Missing rate constants in the reaction ",{
\!\(\*OverscriptBox[
RowBox[{"A", "\[Rule]", " ", "B"}], "e"]\),x}, " are assumed to be zero: ", {
\!\(\*OverscriptBox[
RowBox[{"A", "\[Rule]", " ", "B"}], "e"]\), Sequence@@k}];
]; 
If[Length[k]< Length[kin], 
Print["Warning: Extra rate constants in the reaction ",{
\!\(\*OverscriptBox[
RowBox[{"A", "\[Rule]", " ", "B"}], "e"]\),x}, " were ignored: ", {
\!\(\*OverscriptBox[
RowBox[{"A", "\[Rule]", " ", "B"}], "e"]\), Sequence@@k}];
]; 
r={{A+e-> B+e, k[[1]]}}; 
Return[r]]; 



ExpandReaction[{
\!\(\*OverscriptBox[
RowBox[{"A_", "\[RightArrowLeftArrow]", " ", "B_"}], "e_"]\), x___}]:= Module[
{r, kin}, 
kin={x}//Flatten; 
k=PadRight[kin, 4]; 
If[Length[k]> Length[kin], 
Print["Warning: Missing rate constants in the reaction ",{
\!\(\*OverscriptBox[
RowBox[{"A", "\[RightArrowLeftArrow]", " ", "B"}], "e"]\),x}, " are assumed to be zero: ", {
\!\(\*OverscriptBox[
RowBox[{"A", "\[RightArrowLeftArrow]", " ", "B"}], "e"]\), Sequence@@k}];
]; 
If[Length[k]< Length[kin], 
Print["Warning: Extra rate constants in the reaction ",{
\!\(\*OverscriptBox[
RowBox[{"A", "\[RightArrowLeftArrow]", " ", "B"}], "e"]\),x}, " were ignored: ", {A-> B, Sequence@@k}];
]; 
r={
{A+e-> Diamond[A,e], k[[1]]}, 
{Diamond[A,e]-> e+A, k[[2]]}, 
{Diamond[A, e]-> B, k[[3]]}, 
{B-> Diamond[A, e], k[[4]]}
}; 
Return[r]]; 


ExpandReaction[{Underoverscript[RightArrowLeftArrow[A_,B_],rev_,fwd_], x___}]:= Module[
{r, kin, rf, rr, kf, kr}, 
kin={x}//Flatten; 
k=PadRight[kin, 8]; 
If[Length[k]> Length[kin], 
Print["Warning: Missing rate constants in the reaction ", {Underoverscript[RightArrowLeftArrow[A,B],rev,fwd],x}, " are assumed to be zero: ", {Underoverscript[RightArrowLeftArrow[A,B],rev,fwd], Sequence@@k}];
]; 
If[Length[k]< Length[kin], 
Print["Warning: Extra rate constants in the reaction ",{Underoverscript[RightArrowLeftArrow[A,B],rev,fwd],x}, " were ignored: ", {Underoverscript[RightArrowLeftArrow[A,B],rev,fwd], Sequence@@k}];
]; 
kf= Sequence@@Take[k, 4]; 
kr = Sequence@@Take[k, -4]; 

rf={Overscript[RightArrowLeftArrow[A,B],fwd], kf}; 
rr={Overscript[RightArrowLeftArrow[B,A],rev] ,kr}; 

rf=ExpandReaction[rf]; 
rr=ExpandReaction[rr]; 

r=Join[rf, rr]; 
Return[r]]; 


ExpandReaction[{
\!\(\*OverscriptBox[
RowBox[{"A_", "\[Equilibrium]", "B_"}], "e_"]\), x___}]:= Module[
{r, kin}, 
kin={x}//Flatten; 
k=PadRight[kin, 6]; 
If[Length[k]> Length[kin], 
Print["Warning: Missing rate constants in the reaction ",{
\!\(\*OverscriptBox[
RowBox[{"A", "\[Equilibrium]", " ", "B"}], "e"]\),x}, " are assumed to be zero: ", {
\!\(\*OverscriptBox[
RowBox[{"A", "\[Equilibrium]", " ", "B"}], "e"]\), Sequence@@k}];
]; 
If[Length[k]< Length[kin], 
Print["Warning: Extra rate constants in the reaction ",{
\!\(\*OverscriptBox[
RowBox[{"A", "\[Equilibrium]", " ", "B"}], "e"]\),x}, " were ignored: ", {
\!\(\*OverscriptBox[
RowBox[{"A", "\[Equilibrium]", " ", "B"}], "e"]\) ,Sequence@@k}];
]; 
r={
{A+e-> Diamond[A,e], k[[1]]}, 
{Diamond[A,e]-> e+A, k[[2]]}, 
{Diamond[A, e]-> Diamond[B, e], k[[3]]}, 
{Diamond[B,e]-> Diamond[A, e], k[[4]]}, 
{Diamond[B,e]-> e+B, k[[5]]}, 
{e+B-> Diamond[B, e], k[[6]]}
}; 
Return[r]]; 


ExpandReaction[{
\!\(\*OverscriptBox[
RowBox[{"A_List", "\[RightTeeArrow]", "B_"}], "via_"]\),sHill[T_, n_,K_,v_]}]:= Module[
{r, k, nA, nT, TT, nTT}, 
nA = Length[A];
TT={T}//Flatten;  
nT = Length[TT]; 
TT=PadRight[TT, nA, 1]; 
nTT=Length[TT]; 
If[nTT!=  nT, Print["Error: ExpandReaction: expecting ", nA, " coefficients; found ", nT," in reaction ", {
\!\(\*OverscriptBox[
RowBox[{"A", "\[RightTeeArrow]", "B"}], "via"]\),sHill[T, n,K,v]}, " using ", {
\!\(\*OverscriptBox[
RowBox[{"A", "\[RightTeeArrow]", "B"}], "via"]\), sHill[TT, n, K, v]}] 
]; 
k = ( via*UmbralHillFunction[A, TT,  n, K, v])/(via*UmbralProduct[A]); 
r={{Plus@@A+via-> B+via+Plus@@A, k}}; 
Return[r]];
ExpandReaction[{
\!\(\*OverscriptBox[
RowBox[{"A_", "\[RightTeeArrow]", "B_"}], "e_"]\),sHill[n_,K_,v_]}]:= Module[
{r, k}, 

k = (e*UmbralHillFunction[A, n, K, v])/(e*UmbralProduct[A]); 
r={{Plus@@A+e-> B+e, k}}; 
Return[r]]; 
ExpandReaction[{
\!\(\*OverscriptBox[
RowBox[{"A_", "\[RightTeeArrow]", "B_"}], "e_"]\),sHill[k___]}]:= Module[
{}, 
Print["Error: ExpandReaction: Expecing sHill[n, K, v]] in reaction ",{
\!\(\*OverscriptBox[
RowBox[{"A", "\[RightTeeArrow]", "B"}], "e"]\),sHill[k]} ]; 
Return[$Failed]]; 


ExpandReaction[{A_List\[RightTeeArrow]B_,sHill[T_, n_,K_,v_]}]:= Module[
{r, k, nA, nT, TT, nTT}, 
nA = Length[A]; 
TT=Flatten[{T}]; 
nT = Length[TT]; 
TT=PadRight[TT, nA, 1]; 
nTT=Length[TT]; 
If[nTT!=  nT, Print["Error: ExpandReaction: expecting ", nA, " coefficients; found ", nT," in reaction ", {A\[RightTeeArrow]B,sHill[T, n,K,v]}, " using ", {A\[RightTeeArrow]B, sHill[TT, n, K, v]}] 
]; 
k =  UmbralHillFunction[A, TT,  n, K, v]/UmbralProduct[A]; 
r={{Plus@@A-> B+Plus@@A, k}}; 
Return[r]]; 
ExpandReaction[{A_\[RightTeeArrow]B_,sHill[n_,K_,v_]}]:= Module[
{r, k}, 

k =  UmbralHillFunction[A, n, K, v]/Times@@A; 
r={{Plus@@A-> B+Plus@@A, k}}; 
Return[r]]; 
ExpandReaction[{A_List\[RightTeeArrow]B_, sHill[k___]}]:= Module[
{}, 
Print["Error: ExpandReaction: Expecting sHill[T, n, K, v]] in reaction ",{A\[RightTeeArrow]B,sHill[ k]} ]; 
Return[$Failed]]; 
ExpandReaction[{A_\[RightTeeArrow]B_, sHill[k___]}]:= Module[
{}, 
Print["Error: ExpandReaction: Expecing sHill[n, K, v]] in reaction ",{A\[RightTeeArrow]B,sHill[k]} ]; 
Return[$Failed]]; 


ExpandReaction[{\!\(\*
TagBox[
RowBox[{
TagBox["S_",
DisplayForm], "\[DoubleLongRightArrow]", "P_", " "}],
DisplayForm]\),sMMH[K_, v_]}]:= Module[
{r}, 

r={{S->P, v /(K+S)}}; 
Return[r]]; 
ExpandReaction[{\!\(\*
TagBox["S_",
DisplayForm]\)\[DoubleLongRightArrow]\!\(\*
TagBox["P_",
DisplayForm]\), sMMH[k1_, k2_, k3_]}]:= Module[
{K,r}, 
K=(k2+k3) /k1;
r={{S->P, k3 /(K+S)}}; 
Return[r]]; 
ExpandReaction[{\!\(\*
TagBox["S_",
DisplayForm]\)\[DoubleLongRightArrow]P_,sMMH[x___]}]:= Module[{}, 
Print["Error: ExpandReaction: Expecing sMMH[K,V] or sMMH[\!\(\*SubscriptBox[\"k\", \"1\"]\),\!\(\*SubscriptBox[\"k\", \"2\"]\),\!\(\*SubscriptBox[\"k\", \"3\"]\)] in reaction ",{\!\(\*
TagBox["S",
DisplayForm]\)\[DoubleLongRightArrow]\!\(\*
TagBox["P",
DisplayForm]\),sMMH[x]} ]; 
Return[$Failed]]; 

ExpandReaction[{\!\(\*
TagBox[
RowBox[{
RowBox[{"Overscript", "[", 
RowBox[{
RowBox[{
TagBox["S_",
DisplayForm], "\[DoubleLongRightArrow]", "P_"}], ",", "  ", "e_"}], "]"}], " "}],
DisplayForm]\),sMMH[K_, v_]}]:= Module[
{r}, 
r={{S+e->P+e, v /(K+S)}}; 
Return[r]]; 
ExpandReaction[{Overscript[\!\(\*
TagBox["S_",
DisplayForm]\)\[DoubleLongRightArrow]\!\(\*
TagBox["P_",
DisplayForm]\),e_], sMMH[k1_, k2_, k3_]}]:= Module[
{K,r}, 
K=(k2+k3) /k1;
r={{S+e->P+e, k3 /(K+S)}}; 
Return[r]]; 
ExpandReaction[{Overscript[\!\(\*
TagBox["S_",
DisplayForm]\)\[DoubleLongRightArrow]P_,  e_],sMMH[x___]}]:= Module[{}, 
Print["Error: ExpandReaction: Expecing sMMH[K,V] or sMMH[\!\(\*SubscriptBox[\"k\", \"1\"]\),\!\(\*SubscriptBox[\"k\", \"2\"]\),\!\(\*SubscriptBox[\"k\", \"3\"]\)] in reaction ",{
\!\(\*OverscriptBox[
RowBox[{
TagBox["S",
DisplayForm], "\[DoubleLongRightArrow]", 
TagBox["P",
DisplayForm]}], "e"]\),sMMH[x]} ]; 
Return[$Failed]]; 


ExpandReaction[{RightTeeArrow[{LHS__}, RHS_],sGRN[rates___]}]:= Module[
{r,k, ASum, ATimes, v, \[Beta], n, h, A, B},
A=LHS; 
B=RHS; 
k=PadRight[{rates}, 4, $Failed]; 
v=k[[1]]/.{$Failed-> 1}; 
\[Beta]=k[[2]]/.{$Failed-> Table[1, {Length[{A}]}]}; 
n=k[[3]]/.{$Failed-> 1}; 
h=k[[4]]/.{$Failed-> 0}; 

ATimes = UmbralProduct[A]; 

k =UmbralLogisticFunction[{A}, v, \[Beta], n, h]/ATimes; 

If[k*ATimes==$Failed, 
Print["Error: ExpandReaction: unable to process the reaction: ", {{LHS}\[RightTeeArrow]RHS, sGRN[rates]}];
Return[$Failed]; 
];

ASum = Plus[A]; 
r={{ASum-> B+ASum, k}}; 
Return[r]]; 
ExpandReaction[{A_\[RightTeeArrow]B_,sGRN[rates___]}]:= Module[
{r,k, v, \[Beta], n, h, flatone}, 
flatone[x_]:= Module[{y}, 
y=Flatten[{x}][[1]];
If[ListQ[x], Print["Error: not expecting a list for ", x, " in the reaction ", {A\[RightTeeArrow]B, sGRN[rates]}, " using ", y, " instead."]];
Return[y]; 
]; 

k=PadRight[{rates}, 4, $Failed]; 
v=flatone[k[[1]]/.{$Failed-> 1}]; 
\[Beta]=flatone[k[[2]]/.{$Failed-> 1}]; 
n=flatone[k[[3]]/.{$Failed-> 1}]; 
h=flatone[k[[4]]/.{$Failed-> 0}]; 


k =UmbralLogisticFunction[A, v, \[Beta], n, h]/A; 
If[k*A==$Failed, 
Print["Error: expecting sGRN[\!\(\*SubscriptBox[\"v\", \"max\"]\), \[Beta], n, h]; unexpected input ", sGRN[rates], " ignored."];
Return[$Failed]; 
];

r={{A-> B+A, k}}; 
Return[r]]; 



ExpandReaction[{
\!\(\*OverscriptBox[
RowBox[{"S_", "\[DoubleLongRightArrow]", "P_"}], "Enz_"]\),sMWC[rates___]}]:= Module[
{r,k}, 

k =UmbralMWCFunction[S, Enz, rates]; 
If[k==$Failed, 
Print["Error: expecting sMWC[k, n:PostitiveInteger, c, L, K]; unexpected input ", sMWC[rates], " ignored."];
Return[$Failed]; 
];

r={{S+Enz-> P+Enz, k/(S*Enz)}}; 
Return[r]]; 
ExpandReaction[{Underoverscript[S_\[DoubleLongRightArrow]P_, {Act_, Inh_}, Enz_],sMWC[rates___]}]:= Module[
{r,k}, 

k =UmbralMWCFunction[S, {Enz, Act, Inh}, rates]; 
If[k==$Failed, 
Print["Error: expecting sMWC[k, n:PostitiveInteger, c, L, K]; unexpected input ", sMWC[rates], " ignored."];
Return[$Failed]; 
];

r={{S+Enz+Act+Inh-> P+Enz+Act+Inh, k/(S*Enz*Act*Inh)}}; 
Return[r]]; 


ExpandReaction[x___]:= (Print["Error: ExpandReaction: Unknown reaction: ", x]; Return[$Failed]);


SSA[r_?ListQ]:=SSA[r, 100,{},{}];
SSA[r_?ListQ, tmax_?AtomQ]:=SSA[r, tmax, {},{}];
SSA[r_?ListQ, tmax_?AtomQ, ic_?ListQ]:= SSA[r, tmax, ic, {}]; 
SSA[r_?ListQ, tmax_?AtomQ, ic_, rates_, opt___?OptionQ]:=SSA[r, {0,tmax},ic,rates, opt];
SSA[rin_?ListQ,{tmin_,tmax_}, icInput_, ratesInput_,opt___?OptionQ]:=Module[{ok, reac, prods, X,a, anow, Xnow, xrules,defineX, t, nmax, ran, r1, r2, tau,sums,flags,mu,k,i, reactants, products, results,dbg= False, icVar,missingIC,ic,acheck,rates, nvars, r, mode, s, f, xbefore, changed, newvalues, newnames, indices, ymin, ymax, gfile},

nmax = "MaxSteps"/.{opt}/.{"MaxSteps"-> 10^6}; 
mode = "Mode"/.{opt}/.{"Mode"-> "List"}; 
dbg = "Debug"/.{opt}/.{"Debug"-> False}; 


ran:=RandomReal[{0,1}];

(* X is the vector of species, and 
 a the vector or propensities as defined by Gillespie's SSA 
*)

r=rin/.{ShortRightArrow-> Rule}/.ratesInput; 

r=ExpandReactions[r]; 
ok=SSACheck[r];
If[Length[ok]==0,
Print["Error: SSA: No valid reactions in model."];
Return[];
];
If[dbg, Print["ok=",ok]];

{reac, prods, a}=ok;

X=Join[reac,prods]//Flatten;
X=Sort[Complement[X,{0,Global`\[EmptySet]}]];



If[dbg, Print["X=",X]];

(*  check for missing initial conditions *)
ic=icInput;
icVar=First/@ic;
missingIC=Complement[X,icVar];
If[Length[missingIC]>0, Print["Warning: the following variables are missing initial condtions, which are all assumed to be zero: ",missingIC];
missingIC=Map[#-> 0&,missingIC];
ic=Join[ic,missingIC];

];

rates=ratesInput;
a=a/.rates;
If[dbg, Print["a=",a]];

(* check for missing rate constants *)
acheck =Select[Flatten[ (a/.ic)/.{Times-> List}], !NumericQ[#]&] ;
If[Length[acheck]>0,
Print["Warning: the following rates are undefined and are assumed to be one: ",acheck];
acheck =Map[#-> 1&, acheck];
rates=Join[ acheck,rates];
a=a/.rates;
If[dbg, Print["a(corrected)=",a]];
];

(* XIndex[variable] gives the position in the list X of the variable's value. It is done through a function for faster referencing *)

defineX[x_,y_]:= (XIndex[x]=y);
Clear[XIndex];
nvars=Length[X];
MapThread[defineX,{X,Range[nvars]}];
(*add dummy counters for creation/annihilation *)
defineX[0,nvars+1];
defineX[Global`EmptySet, nvars+2];

(* Here is where the Gillespie algorithm begins *)
(* Xnow contains the vector of molecule numbers at any given time *)
(* anow contains the vector of propensity values at any given time *)

Xnow=X/.ic;
t=tmin;
xrules=MapThread[Rule,{X,Xnow}];
If[dbg, Print["xrules=",xrules]];

indices = Range[Length[X]]; 
ymin = Min[Xnow]; 
ymax = Max[Xnow]; 

(* initialize data collection data structure or file *)

Switch[mode,

"List", results={{t,Xnow}},

"SparseList",xbefore=Xnow;  
results={{t, #}}&/@Xnow;
, 

"Table", results={{"time",X}, {t, Xnow}}, 

"TableFile",
f=NewFileName["FileType"-> "dat"]; s=OpenWrite[f]; 
gfile=StringReplace[f, ".dat"-> ".p"]; 
SetOptions[s, FormatType-> StandardForm]; 
results=f; (* results are not recorded internally so return file name *)
Write[s, ExportString[{Flatten[{"# time", X}]}, "tsv"]];
,

_, Print["Error: SSA: Unknown mode: ", mode, " valid modes are : List, SparseList, Table, TableFile"]; Return[$Failed];
]; 

i=0;a0=1;
While[i++<nmax&&t<tmax  && a0>0,

(* Step 1 of figure 2, page 2341 *)

xrules=MapThread[Rule,{X,Xnow}];
anow=a/.xrules;
a0=Plus@@anow;

If[dbg, Print["t,a=",t,",",anow]];
If[dbg, Print["xrules=",xrules]];


If[a0>0,
(* Step 2: generate random numbers r1 and r2 to calculate mu (here called k) and tau *)

r1=ran;
tau=(1/a0)Log[1/r1];
t=t+tau;

sums=Rest[FoldList[Plus,0,anow]];

r2=ran;
For[k=1, sums[[k]]<a0*r2, k++];


(* step 3 - increment appropriate molecule numbers *)
(* reac[[k]] and prods[[k]] gives the LHS & RHS species in reaction k *)
(* but don't bother counting the empty sets and zeroes *)

reactants=Select[XIndex/@reac[[k]], #<=nvars&];
products=Select[XIndex/@prods[[k]], #<=nvars&];

(* Increment all the products and decrement all reactants*)

Map[Xnow[[#]]--&,reactants];
Map[Xnow[[#]]++&,products];

(* save the data vales *)

Switch[mode,

(* save values internally *)
"List",
AppendTo[results,{t,Xnow}],

(* save only changed values internally *)
"SparseList", 
changed = Not/@MapThread[Equal, {xbefore, Xnow}]; 
newvalues = Pick[Xnow, changed]; 
newnames=Pick[indices, changed]; 
For[j=1, j<= Length[newnames], j++, AppendTo[results[[newnames[[j]]]], {t, newvalues[[j]]}]]; 

If[dbg, Print["changed: ", changed]; Print["newvalues: ", newvalues]; Print["newnames: ", newnames]]; 
 xbefore=Xnow;
,

(* save table of values internally *)
"Table", 
AppendTo[results, {t, Xnow}], 


(* write line of data to file *)
(* Table File, determine y-ranges for gnuplot *) 
"TableFile", 
Write[s, ExportString[{Flatten[{t, Xnow}]}, "tsv"]];
ymin  = Min [Flatten[{ymin, Xnow}]]; 
ymax  = Max [Flatten[{ymax, Xnow}]]; 
,

_, Print["Error: SSA: Unimplemented mode (normal step): ", mode ]; Abort[];
]; 


];
];

(* handle max reaction count *)
If[t<tmax, 
If[dbg,
If[a0>0,Print[nmax," reactions at t=", t],
Print["a0 = 0 at t=",t]]
];
(* Switch [mode, 
"List",AppendTo[results, {tmax, Xnow}], 
"SparseList", AppendTo[results, {tmax, Xnow}], 
"Table", AppendTo[results, {tmax, Xnow}], 
"TableFile", Write[s, ExportString[{Flatten[{tmax, Xnow}]}, "tsv"]],
_, Print["Error: Unimplemented mode (maxsteps) ", mode]; Return[$Failed]; 
]; *) 
];


If[dbg, Print["results: ", results]];

(* finish up data or data file*)
Switch[mode,
"List", 
t=First/@results;
results=Last/@results;
results=Transpose[results];
results=MapThread[Rule[#1, Transpose[{t,#2}]]&,{X,results}];
, 
"SparseList",
results = MapThread[Rule, {X, results}]; 

,
"Table",
results = Flatten/@results;
,
(* Write out the TSV file and a GNUPLOT file *)
"TableFile", 
Close[s]; 
results=ToFileName[Directory[], f]; 
Export[gfile, gnuplotheader[tmin,tmax, ymin, ymax, X, f], "text"]; 
,

_,
Print["Error: SSA: unimplemented mode (file termination): ", mode]
]; 

Return[results];
];
SSA[r___]:=Print["Incorrect format for SSA. Correct Format is SSA[reactions, tmax, ic, rates, options]"];


gnuplotheader[xmin_,xmax_, ymin_, ymax_, variables_, title_]:= Module[{gnuplot, gp}, gnuplot = "# gnuplot script generated "<>DateString[]<>"\n#\nset xlabel 'time'\n"<>"set ylabel 'number of molecules'\n"<>"set title '"<>title<>"'\n"<>
"set xrange ["<>ToString[xmin]<>":"<>ToString[xmax]<>"]\n"<>"set yrange ["<>ToString[ymin]<>":"<>ToString[ymax]<>"]\nplot";
gp=
StringDrop[StringJoin@@MapThread[" '"<>title<>"' using 1:"<>ToString[1+#1]<>" title '"<>ToString[#2]<>"' with lines ,\\\n"&, {Range[Length[variables]], variables}], -4];
gnuplot = gnuplot<>gp;
Return[gnuplot];
]


XLR8RtoSSA[{A_-> B_, k___}]:= {{A-> B, k}}; 
XLR8RtoSSA[{A_\[ShortRightArrow]B_, k___}]:= {{A-> B, k}}; 


XLR8RtoSSA[{A_\[DoubleLongRightArrow]B_,xlr8r`MM[k___]}]:= {{\!\(\*
TagBox["A",
DisplayForm]\)\[DoubleLongRightArrow]\!\(\*
TagBox["B",
DisplayForm]\),sMMH[k]}};
XLR8RtoSSA[{
\!\(\*OverscriptBox[
RowBox[{"A_", "\[DoubleLongRightArrow]", "B_"}], "via_"]\),xlr8r`MM[k___]}]:={{
\!\(\*OverscriptBox[
RowBox[{
TagBox["A",
DisplayForm], "\[DoubleLongRightArrow]", 
TagBox["B",
DisplayForm]}], "via"]\),sMMH[\!\(\*
TagBox["k",
DisplayForm]\)]}};
XLR8RtoSSA[{A_\[DoubleLongLeftRightArrow]B_,xlr8r`MM[k_]}]:= Module[{kf, kr, r,  kall},
kall = PadRight[{k, 4, 1}] ;
kf = Take[kall, 2]; 
kr = Drop[kall, 2]; 
r = {{\!\(\*
TagBox["A",
DisplayForm]\)\[DoubleLongRightArrow]\!\(\*
TagBox["B",
DisplayForm]\),sMMH@kf}, {B\[DoubleLongRightArrow]A,sMMH@kr}};
Return[r];
];
XLR8RtoSSA[{Underoverscript[DoubleLongLeftRightArrow[A_, B_], rev_, for_],xlr8r`MM[k___]}]:= Module[{kf, kr, r,  kall},
kall = {k}; 
If[Length[kall]<= 4, 
kall = PadRight[kall, 4, 1];
kf = Take[kall, 2]; 
kr = Drop[kall, 2]; 
,

kall = PadRight[kall, 6,1];
kf = Take[kall, 3]; 
kr = Drop[kall, 3]; 
];

r = {{
\!\(\*OverscriptBox[
RowBox[{"A", "\[DoubleLongRightArrow]", "B"}], "for"]\),sMMH@kf}, {
\!\(\*OverscriptBox[
RowBox[{"B", "\[DoubleLongRightArrow]", "A"}], "rev"]\),sMMH@kr}};
Return[r];
];


XLR8RtoSSA[{A_List\[RightTeeArrow]B_,xlr8r`hill[k___]}]:=  Module[{T, K, n, b, v, kin, r, nA},
nA = Length[A];  
kin=PadRight[{k},5,  $Failed]; 
T= kin[[1]]/.{$Failed-> 1}; 
T = PadRight[T, nA, 1]; 
K= kin[[2]]/.{$Failed-> 1}; 
n=kin[[3]]/.{$Failed-> 1}; 
b=kin[[4]]/.{$Failed-> 0}; 
v=kin[[5]]/.{$Failed-> 1}; 
If[b!= 0  \[Or] Not[NumericQ[b]],
Print["XLR8RtoSSA: Warning: the Cellerator parameter b in the reaction",  {A\[RightTeeArrow]B, xlr8r`hill[T,K,n,b, v]," is not currently implemented in this verison of SSA and will be set to zero."}];
];
b=0; 
r={{A\[RightTeeArrow]B, sHill[T, n, K, v]}}; 
Return[r]; 
];
XLR8RtoSSA[{A_\[RightTeeArrow]B_,xlr8r`hill[k___]}]:=  Module[{T, K, n, b, v, kin, r}, 
kin=PadRight[{k},5,  $Failed]; 
T= kin[[1]]/.{$Failed-> 1}; 
K= kin[[2]]/.{$Failed-> 1}; 
n=kin[[3]]/.{$Failed-> 1}; 
b=kin[[4]]/.{$Failed-> 0}; 
v=kin[[5]]/.{$Failed-> 1}; 
If[b!= 0  \[Or] Not[NumericQ[b]],
Print["XLR8RtoSSA: Warning: the Cellerator parameter b in the reaction",  {A\[RightTeeArrow]B, xlr8r`hill[T,K,n,b, v]," is not currently implemented in this verison of SSA and will be set to zero."}];
];
b=0; 
r={{\!\(\*
TagBox["A",
DisplayForm]\)\[RightTeeArrow]\!\(\*
TagBox["B",
DisplayForm]\),sHill[\!\(\*
TagBox["n",
DisplayForm]\),\!\(\*
TagBox["K",
DisplayForm]\),\!\(\*
TagBox[
RowBox[{"v", "*", 
RowBox[{"(", 
SuperscriptBox["T", "n"], ")"}]}],
DisplayForm]\)]}};
Return[r]; 
];
XLR8RtoSSA[{Overscript[A_\[RightTeeArrow]B_, via_],xlr8r`hill[k___]}]:=  Module[{T, K, n, b, v, kin, r}, 
kin=PadRight[{k},5,  $Failed]; 
T= kin[[1]]/.{$Failed-> 1}; 
K= kin[[2]]/.{$Failed-> 1}; 
n=kin[[3]]/.{$Failed-> 1}; 
b=kin[[4]]/.{$Failed-> 0}; 
v=kin[[5]]/.{$Failed-> 1}; 
If[b!= 0  \[Or] Not[NumericQ[b]],
Print["XLR8RtoSSA: Warning: the Cellerator parameter b in the reaction",  {A\[RightTeeArrow]B, xlr8r`hill[T,K,n,b, v]," is not currently implemented in this verison of SSA and will be set to zero."}];
];
b=0; 
r={{Overscript[A\[RightTeeArrow]B, via],sHill[\!\(\*
TagBox["n",
DisplayForm]\),\!\(\*
TagBox["K",
DisplayForm]\),\!\(\*
TagBox[
RowBox[{"v", "*", "T"}],
DisplayForm]\)]}};
Return[r]; 
]; 


XLR8RtoSSA[{\!\(\*
TagBox["A_",
DisplayForm]\)\[RightTeeArrow]\!\(\*
TagBox["B_",
DisplayForm]\),xlr8r`GRN[k___]}]:= {{A\[RightTeeArrow]B,sGRN[k ]}};


XLR8RtoSSA[{r_, xlr8r`MWC[k___]}]:= {{r, sMWC[k]}}; 


XLR8RtoSSA[{reaction___List}]:=Join@@(XLR8RtoSSA/@{reaction});
XLR8RtoSSA[unknownReaction_]:= (Print["Error: XLR8RtoSSA: unknown reaction: ", unknownReaction]; {{Indeterminate[unknownReaction]}});


SSAtoXLR8R[{A_-> B_, k___}]:= {A-> B, k};


SSAtoXLR8R[{\!\(\*
TagBox["A_",
DisplayForm]\)\[DoubleLongRightArrow]\!\(\*
TagBox["B_",
DisplayForm]\),sMMH[\!\(\*
TagBox["k___",
DisplayForm]\)]}]:= {A\[DoubleLongRightArrow]B,xlr8r`MM[k]};
SSAtoXLR8R[{
\!\(\*OverscriptBox[
RowBox[{
TagBox["A_",
DisplayForm], "\[DoubleLongRightArrow]", 
TagBox["B_",
DisplayForm]}], "via_"]\),sMMH[\!\(\*
TagBox["k___",
DisplayForm]\)]}]:= {
\!\(\*OverscriptBox[
RowBox[{"A", "\[DoubleLongRightArrow]", "B"}], "via"]\),xlr8r`MM[k]}


SSAtoXLR8R[{RightTeeArrow[{A_}, B_],sHill[k___]}]:= Module[{kin,T,  n, K, v, r},
kin = PadRight[{k}, 4, 1]; 
{T, n, K, v} = kin;

r= {A\[RightTeeArrow]B,xlr8r`hill[T,K,n,0,v]};
Return[r]; 
];
SSAtoXLR8R[{\!\(\*
TagBox["A_",
DisplayForm]\)\[RightTeeArrow]\!\(\*
TagBox["B_",
DisplayForm]\),sHill[k___]}]:= Module[{kin, n, K, v, r},
If[Length[{k}]>3, Print["Error: Reaction: ", {\!\(\*
TagBox["A",
DisplayForm]\)\[RightTeeArrow]\!\(\*
TagBox["B",
DisplayForm]\),sHill[k]}, " is ambiguous and may be translated incorrectly. There should only be 3 coefficents in ", {k}, " Did you mean: ", {\!\(\*
TagBox[
RowBox[{"Flatten", "[", 
RowBox[{"{", "A", "}"}], "]"}],
DisplayForm]\)\[RightTeeArrow]\!\(\*
TagBox["B",
DisplayForm]\),sHill[Flatten[{{k}[[1]]}], Sequence@@Rest[{k}]]}];
]; 
kin = PadRight[{k}, 3, 1]; 
{n, K, v} = kin;

r= {A\[RightTeeArrow]B,xlr8r`hill[1,K,n,0,v]};
Return[r]; 
];
SSAtoXLR8R[{Overscript[RightTeeArrow[{A_}, B_], via_],sHill[\!\(\*
TagBox["k___",
DisplayForm]\)]}]:= Module[{kin,T,  n, K, v, r},
kin = PadRight[{k},4, 1]; 
{T, n, K, v} = kin;

r= {
\!\(\*OverscriptBox[
RowBox[{"A", "\[RightTeeArrow]", "B"}], "via"]\),xlr8r`hill[T,K,n,0,v]};
Return[r]; 
];
SSAtoXLR8R[{
\!\(\*OverscriptBox[
RowBox[{"A_", "\[RightTeeArrow]", "B_"}], "via_"]\),sHill[\!\(\*
TagBox["k___",
DisplayForm]\)]}]:= Module[{kin, n, K, v, r},
If[Length[{k}]>3, Print["Error: Reaction: ", {\!\(\*
TagBox["A",
DisplayForm]\)\[RightTeeArrow]\!\(\*
TagBox["B",
DisplayForm]\),sHill[k]}, " is ambiguous and may be translated incorrectly. There should only be 3 coefficents in ", {k}, " Did you mean: ", {\!\(\*
TagBox[
RowBox[{"Flatten", "[", 
RowBox[{"{", "A", "}"}], "]"}],
DisplayForm]\)\[RightTeeArrow]\!\(\*
TagBox["B",
DisplayForm]\),sHill[Flatten[{{k}[[1]]}], Sequence@@Rest[{k}]]}];
]; 

kin = PadRight[{k}, 3, 1]; 
{n, K, v} = kin;

r= {
\!\(\*OverscriptBox[
RowBox[{"A", "\[RightTeeArrow]", "B"}], "via"]\),xlr8r`hill[1,K,n,0,v]};
Return[r]; 
];



SSAtoXLR8R[{\!\(\*
TagBox["A_",
DisplayForm]\)\[RightTeeArrow]\!\(\*
TagBox["B_",
DisplayForm]\),sGRN[k___]}]:= {A\[RightTeeArrow]B,xlr8r`GRN[k ]};


SSAtoXLR8R[{r_, sMWC[k___]}]:= {r, xlr8r`MWC[k]}; 


SSAtoXLR8R[{reaction___List}]:=SSAtoXLR8R/@{reaction};
SSAtoXLR8R[unknownReaction_]:= (Print["Error: SSAtoXLR8R: unknown reaction: ", unknownReaction]; Indeterminate[unknownReaction]);


SSAPlot[solution_, opt___?OptionQ]:=Module[{variables},
variables=First/@solution;
Return[SSAPlot[solution,variables,opt]];
];
SSAPlot[solution_, variables_, opt___?OptionQ]:= Module[{type},
type=SSAPlotType/.{opt}/.Options[SSAPlot];
Switch[type,
"Line",
 Return[SSALinePlot[solution,variables,opt]],

"Dot", 
Return[SSADotPlot[solution,variables,opt]],

_, 
Print["Error: SSAPlot: Unknown format: ",type, "\nvalid formats are \"Line\", \"Dot\""];
Abort[];
]
];


SSADotPlot[solution_,variables_?ListQ,opt___?OptionQ]:=Module[{styles,plots, plt,nvars},
nvars=Length[variables];

styles=SSAPlotStyles/.{opt}/.Options[SSAPlot];
If[styles==Automatic,
styles=Table[Hue[RandomReal[{0,1}]], {nvars}];
];

If[ListQ[styles],
styles=PadRight[styles,nvars,Automatic];,
styles=Table[styles,{nvars}];
];
plots = MapThread[SSADotPlot[solution, #1, DisplayFunction-> Identity, PlotStyle-> #2, opt]&, {variables, styles}];

plt=Show[plots, DisplayFunction-> (DisplayFunction/.{opt}/.{DisplayFunction-> $DisplayFunction})];
Return[plt];
];


SSADotPlot[solution_,variable_,opt___?OptionQ]:=Module[{plt,popt},

With[
{popt=MyFilterOptions[ListPlot,opt]},
pplt=ListPlot[variable/.solution, popt];
];

Return[pplt];
];


SSALinePlot[solution_,variables_?ListQ,opt___?OptionQ]:=Module[{styles,plots, plt,nvars},
nvars=Length[variables];

styles=SSAPlotStyles/.{opt}/.Options[SSAPlot];
If[styles==Automatic,
styles=Table[Hue[RandomReal[{0,1}]], {nvars}];
];

If[ListQ[styles],
styles=PadRight[styles,nvars,Automatic];,
styles=Table[styles,{nvars}];
];
plots = MapThread[SSALinePlot[solution, #1, DisplayFunction-> Identity, PlotStyle-> #2, opt]&, {variables, styles}];

plt=Show[plots, DisplayFunction-> (DisplayFunction/.{opt}/.{DisplayFunction-> $DisplayFunction})];
Return[plt];
];


SSALinePlot[solution_,variable_,opt___?OptionQ]:=Module[{plt,popt, data, xvals, yvals,moredata},
If[!MemberQ[First/@solution,variable], Print["Error:SSALinePlot:variable not found: ",variable];Abort[]];
data =variable/.solution;
{xvals,yvals}=Transpose[data];
xvals=Rest[xvals];
yvals=Most[yvals];
moredata=Transpose[{xvals,yvals}];
data=Append[Transpose[{Most[data], moredata}], Last[data]];
data=Partition[Flatten[data],2];
With[
{popt=MyFilterOptions[ListPlot,opt]},
pplt=ListPlot[data,PlotJoined-> True, popt];
];

Return[pplt];
];


SSAPhasePlot[solution_, {X_, Y_}, opt___?OptionQ]:= Module[{vars,x, y, xy, g, directives},
x=X/.solution/.{X-> $Failed}; 
y=Y/.solution/.{Y-> $Failed}; 
vars=First/@solution; 

If[SameQ[#, $Failed], Print["Error: SSAPhasePlot: Variable ", X, " not Found. Variables are: ", vars]]&/@{x, y}; 

x=Last/@x; 
y=Last/@y; 

xy=Transpose[{x,y}]; 
With[{gopt=MyFilterOptions[Graphics, opt]}, 
directives="Directives"/.{opt}/.{"Directives"-> {}};
directives=Directive@@directives;   
g=Graphics[{directives,Line[xy]}, gopt, Axes-> True, AxesLabel-> {ToString[X], ToString[Y]}]
];
Return[g]; 
];
SSAPhasePlot[s_, {X_, Y_}, directives_]:= SSAPhasePlot[s, {X,Y}, "Directives"-> {directives}]; 
SSAPhasePlot[x___]:= (Print["Error: expecting SSAPhasePlot[solution, {X, Y}, GraphicsDirectives] or SSAPhasePlot[solution, {X,Y}, Options]"]; $Failed);
SSAPhaseCurve[solution_, {X_, Y_}, directives___]:= SSAPhasePlot[solution, {X,Y}, "Directives"-> {directives}, Axes-> False]; 


SSAPhaseCurveData[solution_, {X_, Y_}]:= Module[{x, y, vars, xy},
x=X/.solution/.{X-> $Failed}; 
y=Y/.solution/.{Y-> $Failed}; 
vars=First/@solution; 

If[SameQ[#, $Failed], Print["Error: SSAPhasePlot: Variable ", X, " not Found. Variables are: ", vars]]&/@{x, y}; 

x=Last/@x; 
y=Last/@y; 

xy=Transpose[{x,y}]; 
xy
]; 


SSAPhaseArrayPlot[solutions_, {X_, Y_}, {{xmin_, xmax_}, {ymin_ , ymax_}}]:= Module[{pcdata, ixmax, iymax, i, x, y, map},
ixmax = xmax-xmin + 1; 
iymax = ymax - ymin + 1; 
map = ConstantArray[0, {ixmax, iymax}]; 

pcdata = SSAPhaseCurveData[#, {X,Y}]&/@solutions;
pcdata = Join@@pcdata; 
For[i=1, i<= Length[pcdata], i++, 
{x, y} = pcdata[[i]]+{1-xmin, 1-ymin}; 
map[[x, y]] = map[[x, y]] + 1
]; 
Return[map]; 
 ]


SSAFit[sim_]:= Module[{vars, funcs, fit},
vars = First/@sim;
funcs = Interpolation[#/.sim, InterpolationOrder-> 1]&/@vars;
fit = MapThread[Rule, {vars, funcs}]
]


SSAMean[sims_, opt___?OptionQ]:= Module[{vars, fits, domains, tstart, tend, dt, tvals, i,timespan, npoints, values, sums, t, vals, functionate, ffits, nvars, valsums, valsumsq, \[Mu], means, \[Sigma], sigmas, nsims, times, plus1sigma, plus2sigma, plus3sigma, minus1sigma, minus2sigma, minus3sigma, \[Sigma]p1, \[Sigma]p2, \[Sigma]p3, \[Sigma]m1, \[Sigma]m2, \[Sigma]m3, Interp},
functionate[f_, val_]:=f[val]; 
 
npoints = "Points"/.{opt}/.{"Points"-> 100}; 
timespan = "TimeSpan"/.{opt}/.{"TimeSpan"-> Automatic}; 

nsims = Length[sims]; 

 If[npoints<2, Print["Error: SSAMean requires n of at least 2"]; Return[$Failed]]; 

vars = Union[Flatten[Map[First, #]&/@sims]];
nvars=Length[vars]; 
fits = SSAFit/@sims;
fits = (vars/.#)&/@fits;
ffits = Flatten[fits]; 
domains=Map[InterpolatingFunctionDomain, #]&/@fits;
domains = Partition[Flatten[domains], 2]//Transpose;
{tstart, tend} = {Max[domains[[1]]], Min[domains[[2]]]};
If[Not[SameQ[timespan, Automatic]], 
timespan=PadRight[Flatten[{timespan}], 2, tend]; 
tstart = Max[tstart, timespan[[1]]]; 
tend = Min[tend, timespan[[2]]]; 
If[tend < tstart, Print["Error: SSAMean tend < tstart."]; Return[$Failed]]; 
];

dt = (tend-tstart)/(npoints-1.); 
tvals = times= Table[tstart + i*dt, {i, 0, npoints-1}];

means=sigmas=plus1sigma=plus2sigma=plus3sigma=minus1sigma=minus2sigma=minus3sigma={}; 
While[Length[tvals]>0,
t= First[tvals];
tvals=Rest[tvals]; 
vals=Partition[functionate[#, t]&/@ffits, nvars];

valsums = Plus@@vals; 
\[Mu] = valsums/nsims; 

valsumsq=Plus@@(#*#&/@vals);
\[Sigma] =Sqrt[valsumsq/nsims - \[Mu]^2]; 


\[Sigma]p1={t, #}&/@(\[Mu]+\[Sigma]); 
\[Sigma]p2={t, #}&/@(\[Mu]+2\[Sigma]); 
\[Sigma]p3={t, #}&/@(\[Mu]+3\[Sigma]); 

\[Sigma]m1={t, #}&/@(Max[0,#]&/@(\[Mu]-\[Sigma])); 
\[Sigma]m2={t, #}&/@(Max[0,#]&/@ (\[Mu]-2\[Sigma])); 
\[Sigma]m3={t, #}&/@(Max[0, #]&/@(\[Mu]-3\[Sigma])); 

\[Mu] = {t, #}&/@\[Mu]; 
\[Sigma]={t, #}&/@\[Sigma]; 



 (*Print["t=", t];  
Print["Mu=", \[Mu], " sigma=",  \[Sigma]]; 
 Print[vals]; 
Print[valsums, valsumsq]; *)


AppendTo[means, \[Mu]]; 
AppendTo[sigmas, \[Sigma]]; 
AppendTo[plus1sigma,\[Sigma]p1];
AppendTo[plus2sigma,\[Sigma]p2];
AppendTo[plus3sigma,\[Sigma]p3];
AppendTo[minus1sigma,\[Sigma]m1];
AppendTo[minus2sigma,\[Sigma]m2];
AppendTo[minus3sigma,\[Sigma]m3];


];

Interp[list_]:= Module[{ilist},
ilist=Transpose[list]; 
ilist = Interpolation[#, InterpolationOrder-> 1]&/@ilist; 
ilist = MapThread[Rule, {vars, ilist}]; 
Return[ilist]; 
 ];

means = Interp[means]; 
sigmas=Interp[sigmas]; 

plus1sigma=Interp[plus1sigma]; 
plus2sigma=Interp[plus2sigma]; 
plus3sigma=Interp[plus3sigma]; 

minus1sigma=Interp[minus1sigma]; 
minus2sigma=Interp[minus2sigma]; 
minus3sigma=Interp[minus3sigma]; 


(*
means=Transpose[means]; 
means = Interpolation[#, InterpolationOrder-> 1]&/@means; 
means = MapThread[Rule, {vars, means}]; 

sigmas = Transpose[sigmas]; 
sigmas = Interpolation[#, InterpolationOrder-> 1]&/@sigmas; 
sigmas=MapThread[Rule, {vars, sigmas}]; 
*) 


Return[{"Means"-> means, "StandardDeviations"-> sigmas, 
"MeanPlusSigma"-> plus1sigma,
"MeanPlus2Sigma"-> plus2sigma,
"MeanPlus3Sigma"-> plus3sigma,
"MeanMinusSigma"-> minus1sigma,
"MeanMinus2Sigma"-> minus2sigma,
"MeanMinus3Sigma"-> minus3sigma
}]; 

]


CelleratorMLLoaded=False; 
SSASave[x___]:= SSASaveXML[x]; 

SSASaveXML[file_?StringQ, model_, opt___?OptionQ]:= SSASaveXML[model, "File"-> file, opt]; 
SSASaveXML[model_, opt___?OptionQ]:= Module[{x, p, ic,saved, name, opts, filename, descr, save},
If[!CelleratorMLLoaded,
save=FLAGS`ECHOLOAD;
FLAGS`ECHOLOAD=False; 
load = Get["CelleratorML.m"]; 
FLAGS`ECHOLOAD=save;

If[SameQ[load, $Failed], Return[$Failed]]; 
CelleratorMLLoaded=True; 
]; 

p="Parameters"/.{opt}/.{"Parameters"-> {}}; 
ic = "InitialConditions"/.{opt}/.{"InitialConditions"-> {}}; 
name = "Name"/.{opt}/.{"Name"-> "SSA-Model"}; 
descr="Description"/.{opt}/.{"Description"-> "Model converted from SSA"}; 
filename="File"/.{opt}/.{"File"-> Automatic}; 

If[SameQ[filename, Automatic],
filename=SystemDialogInput["FileSave", "SSA-Model.xml"]; 
If[SameQ[filename, $Canceled], Return[$Canceled]]; 
];

x=SSAtoXLR8R[model];

opts={"Parameters"-> p, "InitialConditions"-> ic, "SoftwareTool"-> "SSA", "Name"-> name , "Description"-> descr}; 

(*
If[SameQ[filename,""], 
saved=CelleratorML`SaveModel[x, Sequence@@opts],

If[SameQ[filename, Automatic], filename="SSA-Model.xml"]; 
saved=CelleratorML`SaveModel[filename, x, Sequence@@opts]
]; 
*)

saved=CelleratorML`SaveModel[filename, x, Sequence@@opts];
Return[saved];
]


SSAGet[x___]:= SSAReadXML[x]; 
SSAReadXML[file_?StringQ, opt___?OptionQ]:= Module[{load, m, r, ic, opts, name, save},
If[Not["Quiet"/.{opt}/.{"Quiet"-> False}], Print["Reading: "<>file<>" ..."]
];
If[!CelleratorMLLoaded,
save=FLAGS`ECHOLOAD;
FLAGS`ECHOLOAD=False; 
load = Get["CelleratorML.m"]; 
FLAGS`ECHOLOAD=save;
If[SameQ[load, $Failed], Return[$Failed]]; 
CelleratorMLLoaded=True; 
]; 

m=CelleratorML`GetModel[file, opt];

If[SameQ[m, $Failed], Return[$Failed]]; 
{m, r, ic, opts}=m;
m=XLR8RtoSSA[m];
name="Name"/.opts/.{"Name"-> ToString[Unique["Model"]]};

Return[{"Name"-> name, "Model"-> m, "Parameters"-> r,"InitialConditions"-> ic}];
];
SSAReadXML[]:=Module[{f}, f=SystemDialogInput["FileOpen", "*.xml"]; 
Return[SSAReadXML[f]]];
SSAReadXML[x___]:= (Print["Error: SSAReadXML: Expecting SSAReadXML[filename]"]; $Failed); 


vrel=StringTake[ToString[$VersionNumber]<>"00",3]<>"."<>ToString[$ReleaseNumber];
Print["SSA "<>$SSA$Version<>" loaded "<>now[]<>" using Mathematica "<>$Version<>"("<>vrel<>")"];
End[];
EndPackage[];
