(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



BeginPackage["xSSA`"];


$xSSA$Version = "12.01.1";


Needs["DifferentialEquations`InterpolatingFunctionAnatomy`"]


If[Length[Names["FLAGS`ECHOLOAD"]]>0,
xSSA`Private`msgflag=ToExpression["FLAGS`ECHOLOAD"],
xSSA`Private`msgflag=True;];
FLAGS`ECHOLOAD=False;
(* insert any loads that you want to keep quiet here *)
FLAGS`ECHOLOAD=xSSA`Private`msgflag;


SSA::usage="SSA[reactions, tmax, initialConditiosn]\nSSA[reactions, tmax, initialConditions, rates]\nSSA[reactions, tmax, initialConditions, rates, MaxSteps:10^6]\nSSA[reactions, {tmin,tmax}, initialConditions, rates, MaxSteps:10^6]\nSSA[reactions, tmax]\nSSA[reactions]\n\nreactions is {\!\(\*SubscriptBox[\(r\), \(1\)]\),\!\(\*SubscriptBox[\(r\), \(2\)]\),...,\!\(\*SubscriptBox[\(r\), \(n\)]\)} where (in BNF) each \n\!\(\*SubscriptBox[\(r\), \(\(i\)\(\\\ \)\)]\)::={\!\(\*SubscriptBox[\(R\), \(1\)]\)[+\!\(\*SubscriptBox[\(R\), \(2\)]\)]\[Rule]\!\(\*SubscriptBox[\(R\), \(3\)]\)[+\!\(\*SubscriptBox[\(R\), \(4\)]\)] [,k]}\nIf omitted, k defaults to 1.\nReactions {0\[Rule]A, k} or {A\[Rule]0, k} [or {\[EmptySet]\[Rule]A,k}, {A\[Rule]\[EmptySet],k}] designate creation and annihilation.\nHigher order reactions (e.g., trimolecular) are not supported.\n\nOptions:\n\"MaxSteps\"->10^6\n\"Mode\"\[Rule]\"List\" (list of every calculation),\n\"Mode\"\[Rule]\"SparseList\" (list only when there are changes),\n\"Mode\"\[Rule]\"Interpolation\" (fit interpolation function to results),\n\"Mode\"\[Rule]\"Table\" (return a rectangular table of values as a list),\n\"Mode\"\[Rule]\"TableFile\" (Save a table of values to a file), \n\"Mode\"\[Rule]\"Variable\" (return a list of {t,X} values), \n\"Mode\"\[Rule]\"Variables\" (return a list of {t,X1,X2,...} values) \n\"OutputVariable\"\[Rule]variablename (for \"Mode\"\[Rule]\"Variable\")\n\"Variables\"\[Rule]{var1,var2,...} (for \"Mode\"\[Rule]\"Variables\".\n\"Sample\"\[Rule]1 (only output if this many calculations have occurred since the last output). \n\"Summary\"\[Rule]True (Print a summary message when done)."<>"\n\"Summarize\"\[Rule]False, Print a more detailed summary (final time, values, transitions)\n\"Rates\"\[Rule]{}, List of numbers between zero and 1, will calculate least squares fit of (dv/dt) in  V = V0 + (dV/dt) * t for each variable using the last fraction of data specified; .5 = use last 50%; 1 = use all data; only valid if the production rate is in the steady state (linear) range. Requires \"Summarize\" and \"Mode\"\[Rule]\"Variables\". Value of Rates will be ignored if a value is used for SteadyStateStart."<>"\n\"SteadyStateStart\"\[Rule]\[Infinity], time value when to start estimating steady state and rates in \"variables\" mode"<>"\n\"TimeCourse\"\[Rule]True, when False, suppresses return of timecourse data (typically used when only the summary is wanted).";

SSAPlot::usage="SSAPlot[solution, variable, options]\nSSAPlot[solution, {variables}, options]\n\nOptions: SSAPlotType, SSAPlotStyles, any option for ListPlot";
SSALinePlot::usage="SSALinePlot[solution, variable, options]\nSSALinePlot[solution, {variables}, options]";
SSADotPlot::usage="SSADotPlot[solution, variable, options]\nSSADotPlot[solution, {variables}, options]";
SSAPhasePlot::usage="SSAPhasePlot[solution, {X,Y}, OptionalGraphicsDirectives] \nSSAPhasePlot[solution, {X,Y}, Options]\nSSAPhasePlot[solution, {X,Y}, \"Directives\"\[Rule]{dir,...}] is equivalent to SSAPhasePlot[solution, {X,Y}, dir], where dir is a list of Graphics Directives. Any valid option for Graphics may be used."; 
SSAPhaseCurve::usage="SSAPhaseCurve[solution, {X,Y}, OptionalGraphicsDirectives] is equivalent to SSAPhasePlot[solution, {X,Y}, Axes\[Rule]False, \"Directives\"\[Rule]OptionalGraphicsDirectives]"; 
SSAPlotStyles::usage="An option for SSAPlot. A list of values for PlotStyle, when multiple variables are being plotted on the same figure. If omitted, random hues are used to color the curves.";
(* SSAPhaseCurveData::usage=""; *)
(* SSAPhaseArrayPlot::usage=""; *)

SSAMean::usage="SSAMean[simulation,options]\n\nReturns a list of interpolations of the mean and standard deviation of the data. The simulation \"Mode\" should  either be not specified in SSA, or selected as \"Interpolation\". The output is returned in the form \n\n{\"Means\"{variable\[Rule]InterpolatingFunction[...], variable\[Rule]...}, \n\"StandardDeviations\"\[Rule]{ ... }\n\"MeanPlusSigma\"\[Rule]{ ... }\n\"MeanMinusSigma\[Rule]{ ... }, ...}\n\nOptions:\n\n\"Rates\"\[Rule]False, If True, includes \"MeanRates\" as variables \[Delta]var\[Delta]t for each variable var.\n\"Points\"\[Rule]100, number of points to calculate the statistics at. The statistics are interpolated at n equally spaced intervals. ";
SSAFit::usage="";
PlotStats::usage="PlotStats[var, stats, options]\n\nPlots the mean and +/- one-sigma shaded envelope.\n\nstats is the output of SSAMean\nvar is any variable in the simulation\noptions are any options for Plot\n\nExample:\nsimlations=Table[SSA[... simulation parameters ...],{1000}];\nmystats=SSAMean[simulations];\nPlotStats[X, mystats, PlotStyle -> {{ Red}, { Red}, {Thick, Red}}, FillingStyle -> Lighter[Pink]]";

SSAPlotType::usage="An option for SSAPlot, values are \"Line\", \"Dot\". ";
Options[SSAPlot]={SSAPlotStyles-> Automatic, SSAPlotType-> "Line"};

ExpandReactions::usage="ExpandReactions[{r1,r2, ...}] returns the list of base reactions that the list of input reactions is reduced to by ExpandReaction. "; 

ExpandReaction::usage="ExpandReaction[reaction] returns  the list of base reactions that the high level reaction represets, for example, ExpandReaction[{A\[RightArrowLeftArrow]B, kf, kr}] returns {{A\[Rule]B,kf},{B\[Rule]A,kr}}."; 
UmbralPower::usage="";


XLR8RtoSSA::usage="XLR8RtoSSA[{r1,r2,...}] where r1, r2, ... are each cellerator reactions returns a list of SSA-compatible reactions.\nXLR8RtoSSA[{reaction, rates}] converts a single reaction from xlr8r format to SSA format, e.g., XLR8RtoSSA[{A+B\[Rule]C, k}]\nAny unidentifable (or unimplemented) reactions are returned as Indeterminate[reaction]."; 
SSAtoXLR8R::usage="SSAtoXLR8R[{r1,r2, ..}] returns a list of reactions  in Cellerator format.\nSSAtoXLR8R[{reaction, rates} converts a single reaction from SSA format to xlr8r format, e.g., SSAtoXLR8R[{A+B\[Rule]C, k}]"; 


SSASave::usage="SSASave[model, options] converts the model to xlr8r form and saves it as CelleratorML. An interactive file name dialog will be opened to determine the output file name. The file can be read back in and automatically converted to SSA form using SSAGet.\n"<>"\nSSASave[filename, model, options] will open the specified file"<>"\nOptions:"<>
"\n\"File\"\[Rule]filename (screen if not specified)"<>
"\n\"InitialConditions\"\[Rule] list of initial conditions as rules"<>
"\n\"Parameters\"\[Rule] list of parameter rules"<>
"\n\"Description\"\[Rule] any text string describing the model"<>
"\n\"Name\"\[Rule] any indentifier to use as the model name"<>
"\n\nNote: If CelleratorML.m,xlr8r.m,MathSBML.m,Cellzilla.m,mPower.m cannot be found this will generate an error message.";

SSAGet::usage="SSAGet[filename] reads the specified CelleratorML file\nSSAGet[] first opens an interactive file name dialog to determine the file, and then reads the file.\n\nThe file is read, converted from XLR8R form to SSA form, and returned as the following list: \n"<>"{\"Name\"\[Rule]modelname\n \"Model\"\[Rule]list of reactions\n \"Parameters\"\[Rule] list of parameter assignments as a rule list\n \"InitialConditions\"\[Rule]Initial conditions as a rule list}\n\nOptions:\n\"Quiet\"\[Rule]False, if True, suppresse printing a statistical summary."; 

ResetNaive::usage=""; 
NewFileName::usage="NewFileName[options]\nGenerates a unique file name based on the current system time. Options are\n\"FilePrefix\"\[Rule]\"SSA-\"\n\"FileType\"\[Rule]\"dat\"\nThe file name is SSA-yymmddThhmmss.dat with the defaults."; 
OpenSSAFile::usage="OpenSSAFile[options]\nOpens a unique file for writing with a name based on the current system time. Prints the file name and returns the stream name. Options for NewFileName or OpenWrite can be used"; 
WriteTSV::usage="WriteTSV[stream, data, ... ] writes a line of data in TSV form to the specified stream. Multiple items may be listed. They are combinded in a single list to put them on the line. "; 
WriteCSV::usage="WriteCSV[stream, data, ...] writes a line of data in CSV form to the specified stream.";


Begin["`Private`"];


MyFilterOptions[f_, opt___?OptionQ]:= 
If[$VersionNumber<6,
Utilities`FilterOptions`FilterOptions[f, opt]
,
Sequence@@FilterRules[Flatten[{opt}],Options[f]]
];



now::usage="now[] returns the date and time as a string";

now[]:= StringReplace[DateString[], " "-> "-"]


OpenSSAFile[opt___?OptionQ]:= Module[{fname, stream},
fname=NewFileName[opt]; 
With[{fopt=MyFilterOptions[OpenWrite,opt]}, 
stream=OpenWrite[fname, fopt, FormatType-> StandardForm, PageWidth-> Infinity];
];
Print[fname," opened."]; 
Return[stream];
];
WriteCSV[stream_, data__]:= Write[stream, ExportString[{data}, "csv"]];
WriteTSV[stream_, data__]:= Write[stream, ExportString[{data}, "tsv"]];




NewFileName[opt___?OptionQ]:= Module[{f,file, prefix, type, n},
prefix = "FilePrefix"/.{opt}/.{"FilePrefix"-> "SSA-"}; 
type = "FileType"/.{opt}/.{"FileType"-> "dat"}; 
If[StringLength[type]<1, type="."]; 
If[StringTake[type, {1,1}]!= ".", type = "."<>type];  
file=DateString[{"YearShort", "Month", "Day","T","Hour","Minute", "Second"}];
n=1; 
f= prefix<>file<>type;
While[Length[FileNames[f]]>0 \[And] n< 1000,
f=prefix<>file<>"-"<>ToString[n]<>type;
n=n+1;
];
If[Length[FileNames[f]]>0, Print["Warning: file ", f, " will be overwritten."]]; 

Return[f]; 
]


PositiveInteger[x_]:=And[IntegerQ[x],Positive[x]];
NegativeInteger[x_]:=And[IntegerQ[x],Negative[x]];


UmbralPower[x_,0]:=1;
UmbralPower[x_,1]:=x;
UmbralPower[x_,n_?PositiveInteger]:=x*UmbralPower[x-1,n-1];
UmbralPower[x_?ListQ,{n__?PositiveInteger}]:=Module[{powers},powers=PadRight[{n},Length[x]];
Return[MapThread[UmbralPower,{x,powers}]];];
UmbralPower[x_,n_?Positive]:=Gamma[x+1]/Gamma[x+1-n];

UmbralPower[x_,n_]:=(Print["Error: UmbralPower undefined for power ",n," (must be a positive integer)."];$Failed);


ListToSum[Rule[a_, b_]]:= Rule[ListToSum[a], ListToSum[b]]; 
ListToSum[x_]:= Plus@@Flatten[{x/.{Plus->List}}];


ReactantQ[A_?AtomQ]:=True;
ReactantQ[HoldPattern[Plus[Q___]]]:=False;
ReactantQ[A_?AtomQ[B__]]:=True;
ReactantQ[A___]:=False;


ReactionQ[{A_->B_, k_}]:=True;
ReactionQ[{A_->B_}]:=True;
ReactionQ[A___]:=False;


SSACheck[r_, dbg_:False]:=Module[{ok, notok, listifyReaction, dPrint},

dPrint[x___]:= If[dbg, Print["SSACheck: ", x]]; 

listifyReaction[{A_-> B_,k_}]:=Module[{rs,p, myTimes, c, k2c, ok},
myTimes[n_?IntegerQ,x_?ReactantQ]:=Table[x,{n}];
myTimes[x_?ReactantQ,n_?IntegerQ]:=Table[x,{n}];
myTimes[x_,y_]:={x,y};


rs=(A/.{Plus-> List,Times-> myTimes})//List//Flatten//Sort;

dPrint["rs=", rs]; 

p=(B/.{Plus-> List,Times-> myTimes})//List//Flatten//Sort;

dPrint["p=", p]; 

ok=True;

(* Note: there is no factorial here because the factorials in equations (6b) and (15) cancel out in reference (1).  This is because k in the input reactions is the usual rate constant expressed in units of amount (not concentration) and is not the stochastic rate constant.*)


k2c[{0}]:=k;
k2c[s_?ListQ]:=k*( (Times@@Sort[s/.{Global`\[EmptySet]-> 1}])/.{Power-> UmbralPower}) ; 

c=k2c[rs];
c=removeExplicitTimeDependence[c, Global`t]; 

dPrint["c=", c]; 

Return[{rs,p ,c,ok}]

];

listifyReaction[{A_-> B_}]:=Module[{},
Print["Warning: The reaction ", {A-> B}, " does not have a rate constant specified, and was interpreted as ",{A-> B, 1}];
Return[listifyReaction[{A-> B,1}]];
];

ok=Select[r,ReactionQ];
notok=Complement[r,ok];
Map[Print["The reaction ",#," is incorrectly formatted and will be ignored."]&,notok];

ok=listifyReaction/@ok;
notok=Select[ok,!Last[#]&];

Map[Print["The following reaction is neither unimolecular nor bimolecular and will be ignored: ", Rule[Plus@@#[[1]],Plus@@#[[2]]]]&,notok];
ok=Complement[ok,notok];

If[Length[ok]>0, 
ok =Most/@ok;
Return[Transpose[ok]];
];
Return[Null];
];


removeExplicitTimeDependence[a_, t_:Global`t]:= Module[{dbg=False, dPrint, fixrate, tstring, fixed},
dPrint[x___]:= If[dbg, Print["removeExplicitTimeDependence:", x]];
tstring="["<>ToString[t]<>"]";  
fixrate[x_]:=ToExpression[StringReplace[ ToString[InputForm[x]], tstring-> ""]]; 

dPrint["a:", a];
fixed = fixrate/@a;
dPrint["fixed: ", fixed];
Return[fixed]; 
];


ResetNaive:= Module[{}, NaiveWarnings=0];  
NaiveWarnings=0;
NaiveMax=5; 


ExpandReactions[r_]:= Module[{rexp},
rexp = ExpandReaction/@r;
rexp = Join@@rexp;
(* Print[rexp]; *)
Return[rexp]; 
];


ExpandReaction[{A_-> B_, x___}]:={{A-> B , x}};


ExpandReaction[{A_\[RightArrowLeftArrow]B_,x___}]:= Module[{r,k, kin},
kin=Flatten[{x}]; 
k=PadRight[kin, 2]; 
If[Length[k]> Length[kin], 
Print["Warning: Missing rate constants in the reaction ",{A\[RightArrowLeftArrow]B,x}, " are assumed to be zero: ", {A\[RightArrowLeftArrow]B,Sequence@@k}];
]; 
If[Length[k]< Length[kin], 
Print["Warning: Extra rate constants in the reaction ",{A\[RightArrowLeftArrow]B,x}, " were ignored: ", {A\[RightArrowLeftArrow]B,Sequence@@k}];
]; 

r={{A-> B, k[[1]]}, {B-> A, k[[2]]}}; 
Return[r]; 
];



ExpandReaction[{
\!\(\*OverscriptBox[\(A_ \[Rule] \ B_\), \(e_\)]\), x___}]:= Module[
{r, kin}, 
kin={x}//Flatten; 
k=PadRight[kin, 1]; 
If[Length[k]> Length[kin], 
Print["Warning: Missing rate constants in the reaction ",{
\!\(\*OverscriptBox[\(A \[Rule] \ B\), \(e\)]\),x}, " are assumed to be zero: ", {
\!\(\*OverscriptBox[\(A \[Rule] \ B\), \(e\)]\), Sequence@@k}];
]; 
If[Length[k]< Length[kin], 
Print["Warning: Extra rate constants in the reaction ",{
\!\(\*OverscriptBox[\(A \[Rule] \ B\), \(e\)]\),x}, " were ignored: ", {
\!\(\*OverscriptBox[\(A \[Rule] \ B\), \(e\)]\), Sequence@@k}];
]; 
r={{A+e-> B+e, k[[1]]}}; 
Return[r]]; 



ExpandReaction[{
\!\(\*OverscriptBox[\(A_ \[RightArrowLeftArrow] \ B_\), \(e_\)]\), x___}]:= Module[
{r, kin}, 
kin={x}//Flatten; 

k=PadRight[kin, 4]; 
If[Length[k]> Length[kin], 
(* Let it be OK to drop the 4th rate constant and default to zero *)
If[Length[kin]<3,
Print["Warning: Missing rate constants in the reaction ",{
\!\(\*OverscriptBox[\(A \[RightArrowLeftArrow] \ B\), \(e\)]\),x}, " are assumed to be zero: ", {
\!\(\*OverscriptBox[\(A \[RightArrowLeftArrow] \ B\), \(e\)]\), Sequence@@k}]];
]; 
If[Length[k]< Length[kin], 
Print["Warning: Extra rate constants in the reaction ",{
\!\(\*OverscriptBox[\(A \[RightArrowLeftArrow] \ B\), \(e\)]\),x}, " were ignored: ", {A-> B, Sequence@@k}];
]; 
r={
{A+e-> Diamond[A,e], k[[1]]}, 
{Diamond[A,e]-> e+A, k[[2]]}, 
{Diamond[A,e]-> B+e, k[[3]]}, 
{B-> Diamond[A, e] + e, k[[4]]}
}; 
Return[r]]; 


ExpandReaction[{Underoverscript[RightArrowLeftArrow[A_,B_],rev_,fwd_], x___}]:= Module[
{r, kin, rf, rr, kf, kr}, 
kin={x}//Flatten; 
k=PadRight[kin, 8]; 
If[Length[k]> Length[kin], 
Print["Warning: Missing rate constants in the reaction ", {Underoverscript[RightArrowLeftArrow[A,B],rev,fwd],x}, " are assumed to be zero: ", {Underoverscript[RightArrowLeftArrow[A,B],rev,fwd], Sequence@@k}];
]; 
If[Length[k]< Length[kin], 
Print["Warning: Extra rate constants in the reaction ",{Underoverscript[RightArrowLeftArrow[A,B],rev,fwd],x}, " were ignored: ", {Underoverscript[RightArrowLeftArrow[A,B],rev,fwd], Sequence@@k}];
]; 
kf= Sequence@@Take[k, 4]; 
kr = Sequence@@Take[k, -4]; 

rf={Overscript[RightArrowLeftArrow[A,B],fwd], kf}; 
rr={Overscript[RightArrowLeftArrow[B,A],rev] ,kr}; 

rf=ExpandReaction[rf]; 
rr=ExpandReaction[rr]; 

r=Join[rf, rr]; 
Return[r]]; 


ExpandReaction[{
\!\(\*OverscriptBox[\(A_ \[Equilibrium] B_\), \(e_\)]\), x___}]:= Module[
{r, kin}, 
kin={x}//Flatten; 
k=PadRight[kin, 6]; 
If[Length[k]> Length[kin], 
Print["Warning: Missing rate constants in the reaction ",{
\!\(\*OverscriptBox[\(A \[Equilibrium] \ B\), \(e\)]\),x}, " are assumed to be zero: ", {
\!\(\*OverscriptBox[\(A \[Equilibrium] \ B\), \(e\)]\), Sequence@@k}];
]; 
If[Length[k]< Length[kin], 
Print["Warning: Extra rate constants in the reaction ",{
\!\(\*OverscriptBox[\(A \[Equilibrium] \ B\), \(e\)]\),x}, " were ignored: ", {
\!\(\*OverscriptBox[\(A \[Equilibrium] \ B\), \(e\)]\) ,Sequence@@k}];
]; 
r={
{A+e-> Diamond[A,e], k[[1]]}, 
{Diamond[A,e]-> e+A, k[[2]]}, 
{Diamond[A, e]-> Diamond[B, e], k[[3]]}, 
{Diamond[B,e]-> Diamond[A, e], k[[4]]}, 
{Diamond[B,e]-> e+B, k[[5]]}, 
{e+B-> Diamond[B, e], k[[6]]}
}; 
Return[r]]; 


ExpandReaction[x___]:= (Print["Error: ExpandReaction: Unknown reaction: ", x]; Return[$Failed]);


SSA[r_?ListQ]:=SSA[r, 100,{},{}];
SSA[r_?ListQ, tmax_?AtomQ]:=SSA[r, tmax, {},{}];
SSA[r_?ListQ, tmax_?AtomQ, ic_?ListQ]:= SSA[r, tmax, ic, {}]; 
SSA[r_?ListQ, tmax_?AtomQ, ic_, rates_, opt___?OptionQ]:=SSA[r, {0,tmax},ic,rates, opt];
SSA[rin_?ListQ,{tmin_,tmax_}, icInput_, ratesInput_,opt___?OptionQ]:=Module[{ok, reac, prods, X,a, anow, Xnow, xrules,defineX, t, nmax, ran, r1, r2, tau,sums,flags,mu,k,i, reactants, products, results,dbg= True,dPrint, icVar,missingIC,ic,acheck,rates, nvars, r, mode, s, f, xbefore, changed, newvalues, newnames, indices, ymin, ymax, gfile, sample, tused, iused, OutputVariable, iv, summary,   summarize, itransitions, findrates, TimeCourse, Quiet, averages,SSstart, ss0, SSMODE, qPrint, nss},

qPrint[x___]:= If[False, Print["SSA:",x]; ]; 

tused=SessionTime[]; 

nmax = "MaxSteps"/.{opt}/.{"MaxSteps"-> 10^6}; 
mode = "Mode"/.{opt}/.{"Mode"-> "List"}; 
dbg = "Debug"/.{opt}/.{"Debug"-> False};
sample = Max["Sample"/.{opt}/.{"Sample"-> 1}, 1]; 
summary = "Summary"/.{opt}/.{"Summary"-> True}; 
summarize="Summarize"/.{opt}/.{"Summarize"-> False}; 
summarize=oksummarize[summarize,mode]; 

SSstart = "SteadyStateStart"/.{opt}/.{"SteadyStateStart"-> \[Infinity]}; 
findrates="Rates"/.{opt}/.{"Rates"-> {}};
If[SSstart<Infinity,
findrates = {SSstart/tmax};
]; 
rates = okfindrates[findrates, mode];
TimeCourse = "TimeCourse"/.{opt}/.{"TimeCourse"-> True}; 
Quiet = "Quiet"/.{opt}/.{"Quiet"-> False}; 
SSMODE=False; 
nss=0;

dPrint[x___]:= If[dbg, Print["SSA: ", x]]; 

ran:=RandomReal[{0,1}];

(* X is the vector of species, and 
 a the vector or propensities as defined by Gillespie's SSA 
*)

r=rin/.{ShortRightArrow-> Rule}/.ratesInput; 

r=ExpandReactions[r]; 
ok=SSACheck[r];
If[Length[ok]==0,
Print["Error: SSA: No valid reactions in model."];
Return[];
];
dPrint["ok: ", ok]; 

{reac, prods, a}=ok;

X=Join[reac,prods]//Flatten;
X=Sort[Complement[X,{0,Global`\[EmptySet]}]];

dPrint["X:",X]; 

(*  check for missing initial conditions *)
ic=icInput;
icVar=First/@ic;
dPrint["icVar:", icVar]; 
missingIC=Complement[X,icVar];
If[Length[missingIC]>0, Print[Style["Warning: ", Red], Style[" the following variables are missing initial condtions, which are all assumed to be zero: ",Blue], Style[missingIC, Black]];
missingIC=Map[#-> 0&,missingIC];
ic=Join[ic,missingIC];
];
dPrint["ic:", ic]; 

rates=ratesInput;
a=a/.rates;
dPrint["a:", a]; 
dPrint["a/.ic:", a/.ic]; 

(* check for missing rate constants *)
acheck =Select[Flatten[ (a/.ic)/.{Times-> List}], !NumericQ[#]&] ;
If[Length[acheck]>0,
Print["Warning: the following rates are undefined and are assumed to be one: ",acheck];
acheck =Map[#-> 1&, acheck];
rates=Join[ acheck,rates];
a=a/.rates;
dPrint["a(corrected):", a];
];

(* XIndex[variable] gives the position in the list X of the variable's value. It is done through a function for faster referencing *)

defineX[x_,y_]:= (XIndex[x]=y);
Clear[XIndex];
nvars=Length[X];
MapThread[defineX,{X,Range[nvars]}];
(*add dummy counters for creation/annihilation *)
defineX[0,nvars+1];
defineX[Global`EmptySet, nvars+2];

(* Here is where the Gillespie algorithm begins *)
(* Xnow contains the vector of molecule numbers at any given time *)
(* anow contains the vector of propensity values at any given time *)

Xnow=X/.ic;
t=tmin;
xrules=MapThread[Rule,{X,Xnow}];
dPrint["xrules: ", xrules];

indices = Range[Length[X]]; 
ymin = Min[Xnow]; 
ymax = Max[Xnow]; 

itransitions=Table[0, {Length[X]}]; 
averages = Table[0, {Length[X]}]; 
qPrint["averages: ", averages]; 

(* initialize data collection data structure or file *)
iused=0; 
Switch[mode,

"List", results={{t,Xnow}},

"SparseList",xbefore=Xnow;  
results={{t, #}}&/@Xnow;
, 

"Interpolation",xbefore=Xnow;  
results={{t, #}}&/@Xnow;
, 


"Table", results={{"time",X}, {t, Xnow}}, 

"TableFile",
f=NewFileName["FileType"-> "dat"]; s=OpenWrite[f]; 
gfile=StringReplace[f, ".dat"-> ".p"]; 
SetOptions[s, FormatType-> StandardForm]; 
results=f; (* results are not recorded internally so return file name *)
Write[s, ExportString[{Flatten[{"# time", X}]}, "tsv"]];
,

"Variable",
xbefore=Xnow;
OutputVariable="OutputVariable"/.{opt}/.{"OutputVariable"-> "Unknown"}; 
If[!MemberQ[X,OutputVariable], Print[Style["Error: SSA: ", Red], "In \"Variable\" mode, selected \"OutputVariable\"\[Rule]\""<>ToString[OutputVariable]<>"\" unspecified or not found"]; Abort[]];
iv=Position[X, OutputVariable]; 
While[ListQ[iv], iv=First[iv]]; 
results={{t,Xnow[[iv]]}};
 ,

"Variables",
xbefore=Xnow;
OutputVariable=Flatten[{"Variables"/.{opt}/.{"Variables"-> {}}}]; 
If[Length[OutputVariable]<1, Print[Style["Error: SSA: ", Red], Style["\"Variables\"", Blue], " not specified in \"Mode\"\[Rule]\"Variables\""]; Abort[]]; 

(If[!MemberQ[X,#], Print[Style["Error: SSA:",Red],   " In \"Variables\" mode, selected \"OutputVariable\"\[Rule]"<>ToString[#]<> " does not exist in model."]; Abort[]])&/@OutputVariable; 

iv=Position[X, #]&/@OutputVariable;
iv=Flatten[iv]; 
results={Flatten[{"t", ToString/@X[[iv]]}], Flatten[{t,Xnow[[iv]]}]};
,

_, Print["Error: SSA: Unknown mode: ", mode, " valid modes are : List, SparseList, Interpolation, Table, TableFile"]; Return[$Failed];
]; 

i=0;a0=1;
While[i++<nmax&&t<tmax  && a0>0,

(* Step 1 of figure 2, page 2341 *)

xrules=MapThread[Rule,{X,Xnow}];
anow=a/.xrules;
a0=Plus@@anow;

If[dbg, Print["t,a=",t,",",anow]];
If[dbg, Print["xrules=",xrules]];


If[a0>0,
(* Step 2: generate random numbers r1 and r2 to calculate mu (here called k) and tau *)
r1=ran;
tau=(1/a0)Log[1/r1];
t=t+tau;

sums=Rest[FoldList[Plus,0,anow]];

(* update running averages (numerater) if needed, or *)
(* set start time of steady state average calculation if required and turn on SSMODE *)
If[SSMODE, 
(* Print["averages:", averages]; 
Print["Xnow:", Xnow]; 
Print["tau: ", tau]; 
Abort[]; *)
nss++; 
averages = averages + Xnow*tau; 
qPrint["tau=", tau," averages: ",MapThread[Rule, {X, averages}]]; 

 (* use old Xvalues *),

(* when first past SSstart, set start time to next time point *) 
 If[t-tau>= SSstart, SSstart = t; SSMODE=True; qPrint["SSstart=",SSstart]];
];

(* continue with Gillespie Algorithm *)
 
r2=ran;
For[k=1, sums[[k]]<a0*r2, k++];


(* step 3 - increment appropriate molecule numbers *)
(* reac[[k]] and prods[[k]] gives the LHS & RHS species in reaction k *)
(* but don't bother counting the empty sets and zeroes *)

reactants=Select[XIndex/@reac[[k]], #<=nvars&];
products=Select[XIndex/@prods[[k]], #<=nvars&];

(* Increment all the products and decrement all reactants*)

dPrint["reactants: ", reactants];
dPrint["products:  ",products]; 
dPrint["Xnow: ", Xnow]; 
Map[Xnow[[#]]--&,reactants];
Map[Xnow[[#]]++&,products];
dPrint["Xnow: ", Xnow]; 

(* save the data vales *)


If[Mod[i, sample]==0, 
iused++; 
Which[

(* save values internally *)
mode == "List",
AppendTo[results,{t,Xnow}],

(* save only changed values internally *)
(mode== "SparseList" \[Or] mode=="Interpolation"), 
changed = Not/@MapThread[Equal, {xbefore, Xnow}]; 
newvalues = Pick[Xnow, changed]; 
newnames=Pick[indices, changed]; 
For[j=1, j<= Length[newnames], j++, AppendTo[results[[newnames[[j]]]], {t, newvalues[[j]]}]]; 
 dPrint["changed: ", changed, " newvalues: ", newvalues, " newnames: ", newnames]; 
 xbefore=Xnow;
,

(* save table of values internally *)
(mode== "Table"), 
AppendTo[results, {t, Xnow}], 


(* write line of data to file *)
(* Table File, determine y-ranges for gnuplot *) 
(mode=="TableFile"), 
Write[s, ExportString[{Flatten[{t, Xnow}]}, "tsv"]];
ymin  = Min [Flatten[{ymin, Xnow}]]; 
ymax  = Max [Flatten[{ymax, Xnow}]]; 
,

(mode=="Variable"),
itransitions += Abs/@(Xnow-xbefore); 
changed=Xnow[[iv]]!= xbefore[[iv]];
If[changed,
AppendTo[results,{t,Xnow[[iv]]}],
iused=iused-1
]; 
xbefore=Xnow;
,

(mode=="Variables"),
itransitions += Abs/@(Xnow-xbefore); 
changed=Xnow[[iv]]!= xbefore[[iv]];
If[changed,
AppendTo[results,Flatten[{t,Xnow[[iv]]}]],
iused=iused-1
]; 
xbefore=Xnow;
,

True, Print["Error: SSA: Unimplemented mode (normal step): ", mode ]; Abort[];
] (* end Which *)
]   (* End if Mod [i, sample] .. *)
]    (* End For *) 
]; (* End If a0 .. *) 

(* handle max reaction count *)
If[t<tmax, 
If[True (* dbg *),
If[a0>0,Print[nmax," reactions at t=", t],
Print["a0 = 0 at t=",t]]
];
];

If[SSMODE, 
averages = averages/(t-SSstart);
qPrint["averages: ", MapThread[Rule, {X, averages}]]; 
]; 

dPrint["results: ", results];

(* finish up data or data file*)
Switch[mode,
"List", 
t=First/@results;
results=Last/@results;
results=Transpose[results];
results=MapThread[Rule[#1, Transpose[{t,#2}]]&,{X,results}];
, 
"SparseList",
results = MapThread[Rule, {X, results}]; 
,
"Interpolation",
results = MapThread[Rule, {X, results}]; 
results=SSAFit[results]; 

,
"Table",
results = Flatten/@results;
,
(* Write out the TSV file and a GNUPLOT file *)
"TableFile", 
Close[s]; 
results=ToFileName[Directory[], f]; 
Export[gfile, gnuplotheader[tmin,tmax, ymin, ymax, X, f], "text"]; 
,

"Variable",
AppendTo[results,{t,Xnow[[iv]]}]; 
,

"Variables",
AppendTo[results,Flatten[{t,Xnow[[iv]]}]]; 
,

_,
Print["Error: SSA: unimplemented mode (file termination): ", mode]
]; 

If[summarize,
Block[{info, sim}, 
sim = results; 
info={};
AppendTo[info, "Steps"-> i]; 
AppendTo[info, "FinalValues"-> MapThread[Rule, {X, Xnow}]]; 
AppendTo[info,"FinalTime"-> t]; 
AppendTo[info, "Transitions"-> MapThread[Rule, {X, itransitions}]]; 
If[SSMODE, 
AppendTo[info, "SteadyStates"-> MapThread[Rule,{X, averages}]];
AppendTo[info, "SteadyStateStart"-> SSstart]; 
AppendTo[info, "SteadyStatePoints"-> nss]; 
];
If[Length[findrates]>0, 
dPrint["finding rates: ", findrates];
Block[{amount2Take, rateresults, variable, header, data, variables , times, n, TakeAmounts, TheRates,TheIntcpts,Sigmas,  m, b, ratesigs},
rateresults={}; 
ratesigs={}; 

header = sim[[1]]; 
variables = Rest[header]; 
variables = "d"<>#<>"/dt"&/@variables; 

dPrint[variables]; 

(* Convert data to sets of {{t,x}, {t,x}, ...} for each variable *) 
data = Most[Rest[sim]]; 
n=Length[data]; 
dPrint["n=", n]; 
TakeAmounts = Floor[#*n]&/@findrates;
dPrint["TakeAmounts:", TakeAmounts]; 
data = Transpose[data]; 

times = First[data]; 
data = Rest[data]; 
data = {times, #}&/@data; 
data = Transpose/@data; 
dPrint["Data:\n", data]; 

While[Length[TakeAmounts]>0,
amount2Take=First[TakeAmounts];
TakeAmounts=Rest[TakeAmounts];
dPrint["amount2Take=",amount2Take]; 

TheRates=Map[m/.FindFit[Take[#,-amount2Take],m*x+b, {m,b}, x]&, data];

TheIntcpts=Map[b/.FindFit[Take[#,-amount2Take],m*x+b, {m,b}, x]&, data];

Sigmas=MapThread[RSSError[Take[#1,-amount2Take],#2,#3]&, {data,TheRates,TheIntcpts}]; 

(* TheRates=MapThread[Rule, {Prepend[variables,"n"], Prepend[TheRates,amount2Take]}];*)

TheRates=MapThread[Rule, {variables, TheRates}];
Sigmas=MapThread[Rule, {variables, Sigmas}]; 

dPrint["TheRates=", TheRates]; 
AppendTo[rateresults, TheRates];
AppendTo[ratesigs,Sigmas]; 
];
rateresults=Flatten[rateresults]; 
ratesigs = Flatten[ratesigs]; 

AppendTo[info, "MeanProductionRates"-> rateresults];
AppendTo[info, "RatePoints"-> n];
AppendTo[info, "RateRSSError"-> ratesigs]; 
] (* end findrates Block *)

]; (* end if length findrates *)

results = {"Summary"-> info}; 
If[TimeCourse, AppendTo[results, "Simulation"-> sim]]; 

If[summary \[And] Not[Quiet], Print[info//TableForm]]; 

]; (* end summarize block *)

]; 

If[summary \[And] Not[Quiet],
Print["xSSA Exit. ", i, " steps.  ",iused, " points sampled.  ", SessionTime[]-tused, " seconds."];
]; 


Return[results];
];
SSA[r___]:=Print["Incorrect format for SSA. Correct Format is SSA[reactions, tmax, ic, rates, options]"];


RSSError[xydata_, m_,b_]:=Module[{npts, xpts, ypts, xmean, ymean, ssxx,ssyy,ssxy,s, SEm,seslope},
npts = Length[xydata]; 
{xpts, ypts} =Transpose[xydata]; 

xmean = Mean[xpts];
ymean = Mean[ypts]; 

xpts = (#-xmean)&/@xpts;
ypts = (#-ymean)&/@ypts; 

ssyy = ypts.ypts; 
ssxx = xpts.xpts;
ssxy = xpts.ypts; 
s=Sqrt[(ssxx*ssyy-ssxy^2)/(ssxx(npts-2))];

seslope = s/Sqrt[ssxx];

Return[seslope];
];


oksummarize[summarize_, mode_]:= Module[{sum}, 
sum = summarize;
If[sum,
If[Not[MemberQ[{"Variable", "Variables"},mode]],
Print[Style["Warning: ", Red, Bold], "SSA: \"Summarize\" option requires \"Mode\"=\"Variable\" or \"Variables\", and will be ignored."]; 
sum=False;
];
];
Return[sum]; 
];


okfindrates[findrates_, mode_]:= Module[{rates}, 
rates = findrates; 
rates = Flatten[{rates}];  
If[Length[rates]>0,
If[Not[MemberQ[{"Variable", "Variables"},mode]],
Print[Style["Warning: ", Red, Bold], "SSA: \"Rates\" option requires \"Mode\"=\"Variable\" or \"Variables\", and will be ignored."]; 
rates={};
];
If[!NumberQ[#],
Print[Style["Error: ",Red, Bold], " SSA: \"Rates\" value = ", #, " is not a number. \"Rates\" must be a list of numbers."]; 
Abort[];]&/@rates;

If[(#>1)\[Or] (#<0), Print[Style["Error: ",Red, Bold], "SSA: \"Rates\" value = ",#, " is not in the range [0,1] and will be truncated."]]&/@rates; 

rates = Max[Min[#, 1],0]&/@rates
];
Return[rates]; 
]; 


gnuplotheader[xmin_,xmax_, ymin_, ymax_, variables_, title_]:= Module[{gnuplot, gp}, gnuplot = "# gnuplot script generated "<>DateString[]<>"\n#\nset xlabel 'time'\n"<>"set ylabel 'number of molecules'\n"<>"set title '"<>title<>"'\n"<>
"set xrange ["<>ToString[xmin]<>":"<>ToString[xmax]<>"]\n"<>"set yrange ["<>ToString[ymin]<>":"<>ToString[ymax]<>"]\nplot";
gp=
StringDrop[StringJoin@@MapThread[" '"<>title<>"' using 1:"<>ToString[1+#1]<>" title '"<>ToString[#2]<>"' with lines ,\\\n"&, {Range[Length[variables]], variables}], -4];
gnuplot = gnuplot<>gp;
Return[gnuplot];
]


XLR8RtoSSA[{A_-> B_, k___}]:= {{A-> B, k}}; 
XLR8RtoSSA[{A_\[ShortRightArrow]B_, k___}]:= {{A-> B, k}}; 

XLR8RtoSSA[{A_\[RightArrowLeftArrow]B_}]:= {{A-> B}, {B-> A}};
XLR8RtoSSA[{A_\[RightArrowLeftArrow]B_ , k1_, k2___}]:= {{A->B, k1}, {B-> A, k2}};


XLR8RtoSSA[{
\!\(\*OverscriptBox[\(A_ \[ShortRightArrow] B_\), \(via_\)]\), k___}]:= {{A+via -> B+via, k}}; 


XLR8RtoSSA[{
\!\(\*OverscriptBox[\(A_ \[RightArrowLeftArrow] B_\), \(enzyme_\)]\)}]:= 
{{A+enzyme\[ShortRightArrow]Diamond[A,enzyme]},
{Diamond[A,enzyme]\[ShortRightArrow]A+enzyme},
{Diamond[A,enzyme]\[ShortRightArrow]B+enzyme}}
XLR8RtoSSA[{
\!\(\*OverscriptBox[\(A_ \[RightArrowLeftArrow] B_\), \(enzyme_\)]\), k1_}]:= 
{{A+enzyme\[ShortRightArrow]Diamond[A,enzyme],k1},
{Diamond[A,enzyme]\[ShortRightArrow]A+enzyme},
{Diamond[A,enzyme]\[ShortRightArrow]B+enzyme}}
XLR8RtoSSA[{
\!\(\*OverscriptBox[\(A_ \[RightArrowLeftArrow] B_\), \(enzyme_\)]\), k1_, k2_}]:= 
{{A+enzyme\[ShortRightArrow]Diamond[A,enzyme],k1},
{Diamond[A,enzyme]\[ShortRightArrow]A+enzyme,k2},{Diamond[A,enzyme]\[ShortRightArrow]B+enzyme}};
XLR8RtoSSA[{
\!\(\*OverscriptBox[\(A_ \[RightArrowLeftArrow] B_\), \(enzyme_\)]\), k1_, k2_, k3_}]:= {{A+enzyme\[ShortRightArrow]Diamond[A,enzyme],k1},
{Diamond[A,enzyme]\[ShortRightArrow]A+enzyme,k2},{Diamond[A,enzyme]\[ShortRightArrow]B+enzyme,k3}};
XLR8RtoSSA[{
\!\(\*OverscriptBox[\(A_ \[RightArrowLeftArrow] B_\), \(enzyme_\)]\), k1_, k2_, k3_, k4___}]:= {{A+enzyme\[ShortRightArrow]Diamond[A,enzyme],k1},{Diamond[A,enzyme]\[ShortRightArrow]A+enzyme,k2},{Diamond[A,enzyme]\[ShortRightArrow]B+enzyme,k3},{B+enzyme\[ShortRightArrow]Diamond[A,enzyme],k4}};


XLR8RtoSSA[{Underoverscript[RightArrowLeftArrow[A_,B_],Reverse_,Forward_], rates___}]:= 
Module[{k, result},
k={rates}; 
Switch[
Length[k],
 6,
result=Join[XLR8RtoSSA[{
\!\(\*OverscriptBox[\(A \[RightArrowLeftArrow] B\), \(Forward\)]\), Sequence@@Take[k,3]}], XLR8RtoSSA[{ 
\!\(\*OverscriptBox[\(B \[RightArrowLeftArrow] A\), \(Reverse\)]\), Sequence@@Drop[k,3]}]];
,
 8,result=Join[XLR8RtoSSA[{
\!\(\*OverscriptBox[\(A \[RightArrowLeftArrow] B\), \(Forward\)]\), Sequence@@Take[k,4]}], XLR8RtoSSA[{
\!\(\*OverscriptBox[\(B \[RightArrowLeftArrow] A\), \(Reverse\)]\), Sequence@@Drop[k,4]}]];
, 
_,

Print["Error: XLR8RtoSSA: unable to parse rate constants; there must be either six or eight for the reaction ",{Underoverscript[RightArrowLeftArrow[A,B],Reverse, Forward] , rates}];
result={{Indeterminate[{ Underoverscript[RightArrowLeftArrow[A,B],Reverse, Forward] , rates}]}}; 

];
Return[result]
];


XLR8RtoSSA[{
\!\(\*OverscriptBox[\(A_ \[Equilibrium] B_\), \(enzyme_\)]\), k1_, k2_, k3_,k4_,k5_,k6_}]:= {{A+enzyme\[ShortRightArrow]Diamond[A,enzyme],k1},{Diamond[A,enzyme]\[ShortRightArrow]A+enzyme,k2},{Diamond[A,enzyme]\[ShortRightArrow]Diamond[B,enzyme],k3},{Diamond[B,enzyme]\[ShortRightArrow]Diamond[A,enzyme],k4},{Diamond[B,enzyme]\[ShortRightArrow]B+enzyme,k5},{B+enzyme\[ShortRightArrow]Diamond[B,enzyme],k6}};
XLR8RtoSSA[{
\!\(\*OverscriptBox[\(A_ \[Equilibrium] B_\), \(enzyme_\)]\), k1___}]:= (Print["Error: XLR8RtoSSA: unable to parse rate constants; there must be precisely six rates for the reaction ",{(
\!\(\*OverscriptBox[\(A \[Equilibrium] B\), \(enzyme\)]\)), k1}] ;{{Indeterminate[{(
\!\(\*OverscriptBox[\(A \[Equilibrium] B\), \(enzyme\)]\))  , k1}]}} );


XLR8RtoSSA[{reaction___List}]:=Join@@(XLR8RtoSSA/@{reaction});
XLR8RtoSSA[unknownReaction_]:= (Print["Error: XLR8RtoSSA: unable to convert the reaction: ", unknownReaction 
]; {{Indeterminate[unknownReaction]}});


SSAtoXLR8R[{A_-> B_, k___}]:= {A-> B, k};


SSAtoXLR8R[{reaction___List}]:=SSAtoXLR8R/@ExpandReactions[{reaction}];
SSAtoXLR8R[unknownReaction_]:= (Print["Error: SSAtoXLR8R: unknown reaction: ", unknownReaction]; Indeterminate[unknownReaction]);


SSAPlot[solution_, opt___?OptionQ]:=Module[{variables},
variables=First/@solution;
Return[SSAPlot[solution,variables,opt]];
];
SSAPlot[solution_, variables_, opt___?OptionQ]:= Module[{type},
type=SSAPlotType/.{opt}/.Options[SSAPlot];
Switch[type,
"Line",
 Return[SSALinePlot[solution,variables,opt]],

"Dot", 
Return[SSADotPlot[solution,variables,opt]],

_, 
Print["Error: SSAPlot: Unknown format: ",type, "\nvalid formats are \"Line\", \"Dot\""];
Abort[];
]
];


SSADotPlot[solution_,variables_?ListQ,opt___?OptionQ]:=Module[{styles,plots, plt,nvars},
nvars=Length[variables];

styles=SSAPlotStyles/.{opt}/.Options[SSAPlot];
If[styles==Automatic,
styles=Table[Hue[RandomReal[{0,1}]], {nvars}];
];

If[ListQ[styles],
styles=PadRight[styles,nvars,Automatic];,
styles=Table[styles,{nvars}];
];
plots = MapThread[SSADotPlot[solution, #1, DisplayFunction-> Identity, PlotStyle-> #2, opt]&, {variables, styles}];

plt=Show[plots, DisplayFunction-> (DisplayFunction/.{opt}/.{DisplayFunction-> $DisplayFunction})];
Return[plt];
];


SSADotPlot[solution_,variable_,opt___?OptionQ]:=Module[{plt,popt},

With[
{popt=MyFilterOptions[ListPlot,opt]},
pplt=ListPlot[variable/.solution, popt];
];

Return[pplt];
];


SSALinePlot[solution_,variables_?ListQ,opt___?OptionQ]:=Module[{styles,plots, plt,nvars},
nvars=Length[variables];

styles=SSAPlotStyles/.{opt}/.Options[SSAPlot];
If[styles==Automatic,
styles=Table[Hue[RandomReal[{0,1}]], {nvars}];
];

If[ListQ[styles],
styles=PadRight[styles,nvars,Automatic];,
styles=Table[styles,{nvars}];
];
plots = MapThread[SSALinePlot[solution, #1, DisplayFunction-> Identity, PlotStyle-> #2, opt]&, {variables, styles}];

plt=Show[plots, DisplayFunction-> (DisplayFunction/.{opt}/.{DisplayFunction-> $DisplayFunction})];
Return[plt];
];


SSALinePlot[solution_,variable_,opt___?OptionQ]:=Module[{plt,popt, data, xvals, yvals,moredata, dbg, dPrint, variables},
dbg = "Debug"/.{opt}/.{"Debug"-> False};
dPrint[x___]:= If[dbg, Print["SSALinePlot: ", x]]; 
variables = First/@solution; 
dPrint["variables: ", variables]; 
If[!MemberQ[First/@solution,variable], Print["Error:SSALinePlot:variable not found: ",variable];Abort[]];
data =variable/.solution;
{xvals,yvals}=Transpose[data];
xvals=Rest[xvals];
yvals=Most[yvals];
moredata=Transpose[{xvals,yvals}];
data=Append[Transpose[{Most[data], moredata}], Last[data]];
data=Partition[Flatten[data],2];
With[
{popt=MyFilterOptions[ListPlot,opt]},
pplt=ListPlot[data,PlotJoined-> True, popt];
];

Return[pplt];
];


SSAPhasePlot[solution_, {X_, Y_}, opt___?OptionQ]:= Module[{vars,x, y, xy, g, directives},
x=X/.solution/.{X-> $Failed}; 
y=Y/.solution/.{Y-> $Failed}; 
vars=First/@solution; 

If[SameQ[#, $Failed], Print["Error: SSAPhasePlot: Variable ", X, " not Found. Variables are: ", vars]]&/@{x, y}; 

x=Last/@x; 
y=Last/@y; 

xy=Transpose[{x,y}]; 
With[{gopt=MyFilterOptions[Graphics, opt]}, 
directives="Directives"/.{opt}/.{"Directives"-> {}};
directives=Directive@@directives;   
g=Graphics[{directives,Line[xy]}, gopt, Axes-> True, AxesLabel-> {ToString[X], ToString[Y]}]
];
Return[g]; 
];
SSAPhasePlot[s_, {X_, Y_}, directives_]:= SSAPhasePlot[s, {X,Y}, "Directives"-> {directives}]; 
SSAPhasePlot[x___]:= (Print["Error: expecting SSAPhasePlot[solution, {X, Y}, GraphicsDirectives] or SSAPhasePlot[solution, {X,Y}, Options]"]; $Failed);
SSAPhaseCurve[solution_, {X_, Y_}, directives___]:= SSAPhasePlot[solution, {X,Y}, "Directives"-> {directives}, Axes-> False]; 


SSAPhaseCurveData[solution_, {X_, Y_}]:= Module[{x, y, vars, xy},
x=X/.solution/.{X-> $Failed}; 
y=Y/.solution/.{Y-> $Failed}; 
vars=First/@solution; 

If[SameQ[#, $Failed], Print["Error: SSAPhasePlot: Variable ", X, " not Found. Variables are: ", vars]]&/@{x, y}; 

x=Last/@x; 
y=Last/@y; 

xy=Transpose[{x,y}]; 
xy
]; 


SSAPhaseArrayPlot[solutions_, {X_, Y_}, {{xmin_, xmax_}, {ymin_ , ymax_}}]:= Module[{pcdata, ixmax, iymax, i, x, y, map},
ixmax = xmax-xmin + 1; 
iymax = ymax - ymin + 1; 
map = ConstantArray[0, {ixmax, iymax}]; 

pcdata = SSAPhaseCurveData[#, {X,Y}]&/@solutions;
pcdata = Join@@pcdata; 
For[i=1, i<= Length[pcdata], i++, 
{x, y} = pcdata[[i]]+{1-xmin, 1-ymin}; 
map[[x, y]] = map[[x, y]] + 1
]; 
Return[map]; 
 ]


SSAFit[sim_]:= Module[{vars, funcs, fit},
vars = First/@sim;
funcs = Interpolation[#/.sim, InterpolationOrder-> 1]&/@vars;
fit = MapThread[Rule, {vars, funcs}]
]


SSAMean[sims_,opt___?OptionQ]:=Module[{vars,fits,domains,tstart,tend,dt,tvals,i,timespan,npoints,values,sums,t,vals,functionate,ffits,nvars,valsums,valsumsq,\[Mu],means,\[Sigma],sigmas,nsims,times,plus1sigma,plus2sigma,plus3sigma,minus1sigma,minus2sigma,minus3sigma,\[Sigma]p1,\[Sigma]p2,\[Sigma]p3,\[Sigma]m1,\[Sigma]m2,\[Sigma]m3,Interp,dPrint,dbg,Rates,rates,results},dbg="Debug"/.{opt}/.{"Debug"->False};
Rates="Rates"/.{opt}/.{"Rates"->False};
dPrint[x___]:=If[dbg,Print["SSAMean: ",x]];
functionate[f_,val_]:=f[val];
npoints="Points"/.{opt}/.{"Points"->100};
timespan="TimeSpan"/.{opt}/.{"TimeSpan"->Automatic};
nsims=Length[sims];
If[npoints<2,Print["Error: SSAMean requires n of at least 2"];
Return[$Failed]];
vars=Union[Flatten[Map[First,#]&/@sims]];
dPrint["vars: ",vars];
nvars=Length[vars];
dPrint["nvars: ",nvars];
If[(Length[Cases[sims,InterpolatingFunction[___],3]]>0),dPrint["Mode is Interpolation, no fitting done."];
fits=sims;,dPrint["Fitting data."];
fits=SSAFit/@sims];
fits=(vars/.#)&/@fits;
(*dPrint["fits: ",fits];*)ffits=Flatten[fits];
domains=Map[InterpolatingFunctionDomain,#]&/@fits;
domains=Partition[Flatten[domains],2]//Transpose;
{tstart,tend}={Max[domains[[1]]],Min[domains[[2]]]};
If[Not[SameQ[timespan,Automatic]],timespan=PadRight[Flatten[{timespan}],2,tend];
tstart=Max[tstart,timespan[[1]]];
tend=Min[tend,timespan[[2]]];
If[tend<tstart,Print["Error: SSAMean tend < tstart."];
Return[$Failed]];];
dt=(tend-tstart)/(npoints-1.);
tvals=times=Table[tstart+i*dt,{i,0,npoints-1}];
means=sigmas=plus1sigma=plus2sigma=plus3sigma=minus1sigma=minus2sigma=minus3sigma={};
While[Length[tvals]>0,t=First[tvals];
tvals=Rest[tvals];
vals=Partition[functionate[#,t]&/@ffits,nvars];
valsums=Plus@@vals;
\[Mu]=valsums/nsims;
valsumsq=Plus@@(#*#&/@vals);
\[Sigma]=Sqrt[valsumsq/nsims-\[Mu]^2];
\[Sigma]p1={t,#}&/@(\[Mu]+\[Sigma]);
\[Sigma]p2={t,#}&/@(\[Mu]+2 \[Sigma]);
\[Sigma]p3={t,#}&/@(\[Mu]+3 \[Sigma]);
\[Sigma]m1={t,#}&/@(Max[0,#]&/@(\[Mu]-\[Sigma]));
\[Sigma]m2={t,#}&/@(Max[0,#]&/@(\[Mu]-2 \[Sigma]));
\[Sigma]m3={t,#}&/@(Max[0,#]&/@(\[Mu]-3 \[Sigma]));
\[Mu]={t,#}&/@\[Mu];\[Sigma]={t,#}&/@\[Sigma];
AppendTo[means,\[Mu]];
AppendTo[sigmas,\[Sigma]];
AppendTo[plus1sigma,\[Sigma]p1];
AppendTo[plus2sigma,\[Sigma]p2];
AppendTo[plus3sigma,\[Sigma]p3];
AppendTo[minus1sigma,\[Sigma]m1];
AppendTo[minus2sigma,\[Sigma]m2];
AppendTo[minus3sigma,\[Sigma]m3];];
Interp[list_]:=Module[{ilist},ilist=Transpose[list];
ilist=Interpolation[#,InterpolationOrder->1]&/@ilist;
ilist=MapThread[Rule,{vars,ilist}];
Return[ilist];];
means=Interp[means];
sigmas=Interp[sigmas];
plus1sigma=Interp[plus1sigma];
plus2sigma=Interp[plus2sigma];
plus3sigma=Interp[plus3sigma];
minus1sigma=Interp[minus1sigma];
minus2sigma=Interp[minus2sigma];
minus3sigma=Interp[minus3sigma];
results={"Means"->means,"StandardDeviations"->sigmas,"MeanPlusSigma"->plus1sigma,"MeanPlus2Sigma"->plus2sigma,"MeanPlus3Sigma"->plus3sigma,"MeanMinusSigma"->minus1sigma,"MeanMinus2Sigma"->minus2sigma,"MeanMinus3Sigma"->minus3sigma};
tvals=Table[tstart+i*dt,{i,0,npoints-1}];
If[Rates,(*MMA will convert linear to step function interpolation*)Block[{meanrates,ifs,n,if,variable,name,data,fit},meanrates={};
vars=First/@means;
dPrint["mean rates to be computed: ",vars];
ifs=(Last/@means);
dPrint["ifs: ",ifs];
n=Length[vars];
For[i=1,i<=n,i++,if=ifs[[i]];
variable=vars[[i]];
name=Symbol["\[Delta]"<>ToString[variable]<>"\[Delta]t"];
dPrint["name: ",name];
data={#,if'[#]}&/@tvals;
fit=Interpolation[data,InterpolationOrder->2];
dPrint[{name->fit}];
AppendTo[meanrates,name->fit];];
AppendTo[results,"MeanRates"->meanrates];]];
Return[results];]


PlotStats[var_,stats_,opt___?OptionQ]:=Module[{start,stop,top,bot,mean,t},top=var/.("MeanPlusSigma"/.stats);
bot=var/.("MeanMinusSigma"/.stats);
mean=var/.("Means"/.stats);
{start,stop}=Flatten[InterpolatingFunctionDomain[var/.("Means"/.stats)]];
Plot[{top[t],bot[t],mean[t]},{t,start,stop},Exclusions->None,Filling->{1->{2}},opt]]


CelleratorMLLoaded=False; 
SSASave[x___]:= SSASaveXML[x]; 

SSASaveXML[file_?StringQ, model_, opt___?OptionQ]:= SSASaveXML[model, "File"-> file, opt]; 
SSASaveXML[model_, opt___?OptionQ]:= Module[{x, p, ic,saved, name, opts, filename, descr, save},
If[!CelleratorMLLoaded,
save=FLAGS`ECHOLOAD;
FLAGS`ECHOLOAD=False; 
load = Get["CelleratorML.m"]; 
FLAGS`ECHOLOAD=save;

If[SameQ[load, $Failed], Return[$Failed]]; 
CelleratorMLLoaded=True; 
]; 

p="Parameters"/.{opt}/.{"Parameters"-> {}}; 
ic = "InitialConditions"/.{opt}/.{"InitialConditions"-> {}}; 
name = "Name"/.{opt}/.{"Name"-> "SSA-Model"}; 
descr="Description"/.{opt}/.{"Description"-> "Model converted from SSA"}; 
filename="File"/.{opt}/.{"File"-> Automatic}; 

If[SameQ[filename, Automatic],
filename=SystemDialogInput["FileSave", "SSA-Model.xml"]; 
If[SameQ[filename, $Canceled], Return[$Canceled]]; 
];

x=SSAtoXLR8R[model];

opts={"Parameters"-> p, "InitialConditions"-> ic, "SoftwareTool"-> "SSA", "Name"-> name , "Description"-> descr}; 

(*
If[SameQ[filename,""], 
saved=CelleratorML`SaveModel[x, Sequence@@opts],

If[SameQ[filename, Automatic], filename="SSA-Model.xml"]; 
saved=CelleratorML`SaveModel[filename, x, Sequence@@opts]
]; 
*)

saved=CelleratorML`SaveModel[filename, x, Sequence@@opts];
Return[saved];
];
SSASaveXML[x___]:= (Print["Expecting SSASave[model]"]; $Failed);


SSAGet[x___]:= SSAReadXML[x]; 
SSAReadXML[file_?StringQ, opt___?OptionQ]:= Module[{load, m, r, ic, opts, name, save},
If[Not["Quiet"/.{opt}/.{"Quiet"-> False}], Print["Reading: "<>file<>" ..."]
];
If[!CelleratorMLLoaded,
save=FLAGS`ECHOLOAD;
FLAGS`ECHOLOAD=False; 
load = Get["CelleratorML.m"]; 
FLAGS`ECHOLOAD=save;
If[SameQ[load, $Failed], Return[$Failed]]; 
CelleratorMLLoaded=True; 
]; 

m=CelleratorML`GetModel[file, opt];

If[SameQ[m, $Failed], Return[$Failed]]; 
{m, r, ic, opts}=m;
m=XLR8RtoSSA[m];
name="Name"/.opts/.{"Name"-> ToString[Unique["Model"]]};

Return[{"Name"-> name, "Model"-> m, "Parameters"-> r,"InitialConditions"-> ic}];
];
SSAReadXML[]:=Module[{f}, f=SystemDialogInput["FileOpen", "*.xml"]; 
Return[SSAReadXML[f]]];
SSAReadXML[x___]:= (Print["Error: SSAReadXML: Expecting SSAReadXML[filename]"]; $Failed); 


vrel=StringTake[ToString[$VersionNumber]<>"00",3]<>"."<>ToString[$ReleaseNumber];
If[xSSA`Private`msgflag, Print["xSSAlite "<>$xSSA$Version<>" loaded "<>now[]<>" using Mathematica "<>$Version<>"("<>vrel<>")"]];
End[];
EndPackage[];
