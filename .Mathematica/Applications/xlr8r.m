(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input:: *)
BeginPackage["xlr8r`"];


If[Length[Names["FLAGS`ECHOLOAD"]]>0,
xlr8r`Private`msgflag=ToExpression["FLAGS`ECHOLOAD"],
xlr8r`Private`msgflag=True;
];
FLAGS`ECHOLOAD=False; 
Needs["MathSBML`"];
Needs["XML`"]; 
FLAGS`ECHOLOAD=xlr8r`Private`msgflag;
If[$VersionNumber<6, 
Needs["Utilities`FilterOptions`"];
]; 


$xlr8r$Version = "0.78 (20 Sept 2010)";


Bind::usage="Bind is an uninstantiated function that is used to indicate intermediate complexes formed during a reaction, e.g., A+E\[RightArrowLeftArrow]Bind[A,E]\[RightArrowLeftArrow]B+E, for an enzymatic reaction. When Bind[A,B] is gnerated by interpret, the arguments will be alphabetized, i.e., Bind[B,A] will be converted to Bind[A,B]. If Bind[B,A] is sent to interpret, the order of the arguments will not be changed. The user should ensure that Bind[A,B] and Bind[B,A] are treated equivalently.";
dbgArrows=False;


interpret::usage="interpret[] converts a list of reactions into differential equations of the form {{ode for variable 1, ode for variable 2, ...}, {variable 1, variable 2, ...}}.\nThe variable Global`t is used for the time argument.\nA reaction has the format {arrow-form, rateConstants}.\nSupported arrow-forms are\n"<>"Mass Action: A\[ShortRightArrow]B, \!\(\*OverscriptBox[
RowBox[{\"A\", \"\[ShortRightArrow]\", \"B\"}], \"C\"]\), A\[RightArrowLeftArrow]B, \!\(\*OverscriptBox[
RowBox[{\"A\", \"\[RightArrowLeftArrow]\", \"B\"}], \"En\"]\), \!\(\*OverscriptBox[
RowBox[{\"A\", \"\[Equilibrium]\", \"B\"}], \"En\"]\), \!\(\*UnderoverscriptBox[
RowBox[{\"A\", \"\[RightArrowLeftArrow]\", \"B\"}], \"REn\", \"FEn\"]\)"<>"\nMichaelis Menten: A\[DoubleLongRightArrow]B, \!\(\*OverscriptBox[
RowBox[{\"A\", \"\[DoubleLongRightArrow]\", \"B\"}], \"En\"]\), A\[DoubleLongLeftRightArrow]B, \!\(\*UnderoverscriptBox[
RowBox[{\"A\", \"\[DoubleLongLeftRightArrow]\", \"B\"}], \"REn\", \"FEn\"]\)"<>" \nHill (catalytic): \!\(\*OverscriptBox[
RowBox[{\" \", 
RowBox[{\"A\", \"\[RightTeeArrow]\", \"B\"}]}], \"En\"]\)\nRegulatory: A\[RightTeeArrow]B, (Hill[..], GRN[..\!\(\*SuperscriptBox[\"]\", \"*\"]\), NHCA[..\!\(\*SuperscriptBox[\"]\", \"*\"]\),S-System[..\!\(\*SuperscriptBox[\"]\", \"*\"]\))"<>" \n\!\(\*SuperscriptBox[\"MWC\", \"*\"]\):\!\(\*UnderoverscriptBox[
RowBox[{\"S\", \"\[DoubleLongRightArrow]\", \"P\"}], \"A\", \"En\"]\)  \n\!\(\*SuperscriptBox[\"GMWC\", \"*\"]\):\!\(\*UnderoverscriptBox[
RowBox[{
RowBox[{\"{\", 
RowBox[{SubscriptBox[\"S\", \"1\"], \",\", SubscriptBox[\"S\", \"2\"], \",\", \"\[Ellipsis]\"}], \"}\"}], \"\[DoubleLongRightArrow]\", 
RowBox[{\"{\", 
RowBox[{SubscriptBox[\"P\", \"1\"], \",\", SubscriptBox[\"P\", \"2\"], \",\", \"\[Ellipsis]\"}], \"}\"}]}], 
RowBox[{\"{\", 
RowBox[{
RowBox[{\"{\", 
RowBox[{SubscriptBox[\"A\", \"1\"], \",\", \"\[Ellipsis]\"}], \"}\"}], \",\", 
RowBox[{\"{\", 
RowBox[{SubscriptBox[\"In\", \"1\"], \",\", \"\[Ellipsis]\"}], \"}\"}], \",\", \" \", 
RowBox[{\"{\", 
RowBox[{SubscriptBox[\"CI\", \"1\"], \",\", \"\[Ellipsis]\"}], \"}\"}]}], \"}\"}], \"En\"]\) "<>"\n\n\!\(\*SuperscriptBox[\"\\\"\<<>\>\\\"\", \"*\"]\)in development.";
debugflag::usage="debug is a flag used for debugging";
frozen::usage="frozen is an option for interpret that gives a list of variables to hold constant, default is frozen->{}";
rates::usage="rates is an option for interpret that gives a list of rate constant replacement rules. Default is rates-> {}"; 
Options[interpret]={frozen-> {}, rates-> {}};


Comp::usage="Comp[] is an uninstantiated function to indicate the Complement of a variable with respect to 1, Comp[x][t]=1-x[t]";


lowLevelReactions::usage="lowLevelReactions[reactions, options] returns a list of basic reactions in a reaction list, by breaking down complex mass-action reations into their simplest forms.\nThe format for reactions is the same as the input to interpret.\n\nOptions:\nrates->False - If True, return rate constants.";
Options[lowLevelReactions]={rates-> False};


jacobianMatrix::usage="jacobianMatrix will calculate the jacobian of either the input to or the output from interpret";
Options[jacobianMatrix]={};


steadyState::usage="steadyState[r, t] returns a list of rule lists giving the steady state of the system, if possible.\nr may be either a list of reactions, or have the same format as the output of interpret, {{eq1,eq2,...}, {var1, var2,...}}.Each eqi is an expression involving vari'[t]. \nEach rule list returned represents a different steady state.\nExample:\nsteadyState[{{x'[t]\[Equal]x[t]^2-y[t], y'[t]\[Equal]y[t]+3x[t]}, {x[t],y[t]}},t]\nreturns:\n{{y[t]\[Rule]0,x[t]\[Rule]0},{y[t]\[Rule]9,x[t]\[Rule]-3}}";


eq1="  \!\(\*SuperscriptBox[\"B\", \"\[Prime]\",\nMultilineFunction->None]\)[t]\[Equal]\!\(\*FractionBox[
RowBox[{\"v\", 
RowBox[{\"(\", 
RowBox[{\"b\", \"+\", 
RowBox[{\"T\", \" \", SuperscriptBox[
RowBox[{\"A\", \"[\", \"t\", \"]\"}], \"n\"], \" \", 
RowBox[{\"\[ScriptCapitalE]\", \"[\", \"t\", \"]\"}]}]}], \")\"}]}], 
RowBox[{SuperscriptBox[\"K\", \"n\"], \"+\", SuperscriptBox[
RowBox[{\"A\", \"[\", \"t\", \"]\"}], \"n\"]}]]\)==-A'[t]";
eq2=" \!\(\*SuperscriptBox[\"B\", \"\[Prime]\",\nMultilineFunction->None]\)[t]\[Equal]\!\(\*FractionBox[
RowBox[{\"v\", 
RowBox[{\"(\", 
RowBox[{\"b\", \"+\", 
RowBox[{\"T\", SuperscriptBox[
RowBox[{\"(\", 
RowBox[{UnderscriptBox[\"\[Sum]\", \"i\"], 
RowBox[{\"A\", \"[\", \"t\", \"]\"}]}], \")\"}], \"n\"], \" \", 
RowBox[{\"\[ScriptCapitalE]\", \"[\", \"t\", \"]\"}]}]}], \")\"}]}], 
RowBox[{SuperscriptBox[\"K\", \"n\"], \"+\", SuperscriptBox[
RowBox[{\"(\", 
RowBox[{UnderscriptBox[\"\[Sum]\", \"i\"], 
RowBox[{\"A\", \"[\", \"t\", \"]\"}]}], \")\"}], \"n\"]}]]\)==-\!\(\*SubscriptBox[\"A\", \"i\"]\)'[t] ";
eq3="  \!\(\*SuperscriptBox[\"B\", \"\[Prime]\",\nMultilineFunction->None]\)[t]\[Equal]\!\(\*FractionBox[
RowBox[{\"v\", 
RowBox[{\"(\", 
RowBox[{\"b\", \"+\", 
RowBox[{\"T\", 
RowBox[{UnderscriptBox[\"\[Product]\", \"i\"], 
RowBox[{SuperscriptBox[
RowBox[{SubscriptBox[\"A\", \"i\"], \"[\", \"t\", \"]\"}], \"n\"], \" \", 
RowBox[{\"\[ScriptCapitalE]\", \"[\", \"t\", \"]\"}]}]}]}]}], \")\"}]}], 
RowBox[{SuperscriptBox[\"K\", \"n\"], \"+\", 
RowBox[{UnderscriptBox[\"\[Product]\", \"i\"], SuperscriptBox[
RowBox[{SubscriptBox[\"A\", \"i\"], \"[\", \"t\", \"]\"}], \"n\"]}]}]]\)==-\!\(\*SubscriptBox[\"A\", \"i\"]\)'[t]";
eq4=" \!\(\*SuperscriptBox[\"X\", \"\[Prime]\",\nMultilineFunction->None]\)[t]\[Equal]\!\(\*FractionBox[
RowBox[{\"v\", SuperscriptBox[
RowBox[{\"(\", 
RowBox[{\"b\", \"+\", 
RowBox[{\"TA\", \"[\", \"t\", \"]\"}]}], \")\"}], \"n\"]}], 
RowBox[{SuperscriptBox[\"K\", \"n\"], \"+\", SuperscriptBox[
RowBox[{\"(\", 
RowBox[{\"b\", \"+\", 
RowBox[{\"T\", \" \", 
RowBox[{\"A\", \"[\", \"t\", \"]\"}]}]}], \")\"}], \"n\"]}]]\)";
eq5=" \!\(\*SuperscriptBox[\"X\", \"\[Prime]\",\nMultilineFunction->None]\)[t]\[Equal]\!\(\*FractionBox[
RowBox[{\"v\", SuperscriptBox[
RowBox[{\"(\", 
RowBox[{\"b\", \"+\", 
RowBox[{\"T1\", \" \", 
RowBox[{\"A\", \"[\", \"t\", \"]\"}]}], \"+\", 
RowBox[{\"T2\", \" \", 
RowBox[{\"B\", \"[\", \"t\", \"]\"}]}], \"+\", \"\[CenterEllipsis]\"}], \")\"}], \"n\"]}], 
RowBox[{SuperscriptBox[\"K\", \"n\"], \"+\", SuperscriptBox[
RowBox[{\"(\", 
RowBox[{\"b\", \"+\", 
RowBox[{\"T1\", \" \", 
RowBox[{\"A\", \"[\", \"t\", \"]\"}]}], \"+\", 
RowBox[{\"T2\", \" \", 
RowBox[{\"B\", \"[\", \"t\", \"]\"}]}], \"+\", \"\[CenterEllipsis]\"}], \")\"}], \"n\"]}]]\)";
hill::usage="hill is an uninstantiated function used to indicate parameter values for a hill-function based reaction.\n\nThe typical format for a Catalytic Hill Function is:"<>"\n{\!\(\*OverscriptBox[
RowBox[{\"A\", \"\[RightTeeArrow]\", \"B\"}], \"\[ScriptCapitalE]\"]\), hill[T,K,n,b,v]} gives"<>eq1<>"\n{\!\(\*OverscriptBox[
RowBox[{
RowBox[{\"{\", 
RowBox[{SubscriptBox[\"A\", \"1\"], \",\", SubscriptBox[\"A\", \"2\"], \",\", \"\[Ellipsis]\"}], \"}\"}], \"\[RightTeeArrow]\", \"B\"}], \"\[ScriptCapitalE]\"]\), hill[\[Ellipsis]]} and {\!\(\*OverscriptBox[
RowBox[{
RowBox[{SubscriptBox[\"A\", \"1\"], \"+\", SubscriptBox[\"A\", \"2\"], \"+\", \"\[CenterEllipsis]\"}], \"\[RightTeeArrow]\", \"B\"}], \"\[ScriptCapitalE]\"]\), hill[\[Ellipsis]]} give "<>eq2<>"\n{\!\(\*OverscriptBox[
RowBox[{
RowBox[{\"{\", 
RowBox[{
RowBox[{\"SubscriptBox\", \"[\", 
RowBox[{\"A\", \",\", \"1\"}], \"]\"}], 
RowBox[{\"SubscriptBox\", \"[\", 
RowBox[{\"A\", \",\", \"2\"}], \"]\"}], 
RowBox[{\"SubscriptBox\", \"[\", 
RowBox[{\"A\", \",\", \"3\"}], \"]\"}], \"\[CenterEllipsis]\"}], \"}\"}], \"\[RightTeeArrow]\", \"B\"}], \"\[ScriptCapitalE]\"]\), hill[\[Ellipsis]]} gives"<>eq3<>"\n\nIn regulatory hill reactions, the concentrations of the reactants do not change. Typical Formats for Regulatory Hill Functions are:\n"<>"\n{A\[RightTeeArrow]X,hill[T,K,n,b,v]} gives "<>eq4<>"\n{{A,B,\[Ellipsis]}\[RightTeeArrow]X,hill[{T1,T2}, K,n,b,v]} or {A\[RightTeeArrow]X,hill[T1,K,n,b,b]},{B\[RightTeeArrow]X,hill[T2,\[Ellipsis]]},\[Ellipsis]} give "<>eq5<>"\nNotes:\nDefault values are T:1, K:1, n:1, b:0 (basal production), v:1 (rate)\nIf multiple regulatory hill reactions have the same product, the values of K, n, b, and v are ignored after the first reaction.\nDifferent types of regulatory reactions (e.g., hill, GRN, S-System,\[Ellipsis]) with the same product cannot not be combined.";
Hill::usage="Hill[] is an alternative form for hill[].";

Remove[eq1,eq2,eq3,eq4];


eq1="\!\(\*FractionBox[\"1\", \"2\"]\) (1+\!\(\*FractionBox[\"x\", SqrtBox[
RowBox[{\"1\", \"+\", SuperscriptBox[\"x\", \"2\"]}]]]\))";
sigma::usage="sigma[x] returns the value"<>eq1;
eq2="\!\(\*FractionBox[\"1\", 
RowBox[{\"1\", \"+\", SuperscriptBox[\"\[ExponentialE]\", 
RowBox[{\"-\", \"x\"}]]}]]\)";
sigmoid::usage="sigmoid [x] returns the value "<>eq2;
eq3="\!\(\*FractionBox[\"r\", 
RowBox[{\"1\", \"+\", SuperscriptBox[\"\[ExponentialE]\", 
RowBox[{
RowBox[{\"-\", \"h\"}], \"-\", 
RowBox[{\"T\", \" \", SuperscriptBox[\"x\", \"n\"]}]}]]}]]\)";
grnsigmoid::usage="grnsigmoid[x, r:1, T:1, n:1, h:0] returns the value "<>eq3;
eq4="\!\(\*FractionBox[\"r\", 
RowBox[{\"1\", \"+\", SuperscriptBox[\"\[ExponentialE]\", 
RowBox[{
RowBox[{\"-\", \"h\"}], \"-\", 
RowBox[{\"T\", \" \", SuperscriptBox[
RowBox[{\"A\", \"[\", \"t\", \"]\"}], \"n\"]}]}]]}]]\)";
eq5="\!\(\*FractionBox[\"r\", 
RowBox[{\"1\", \"+\", SuperscriptBox[\"\[ExponentialE]\", 
RowBox[{
RowBox[{\"-\", \"h\"}], \"-\", 
RowBox[{\"T1\", \" \", SuperscriptBox[
RowBox[{\"A1\", \"[\", \"t\", \"]\"}], \"n1\"]}], \"-\", 
RowBox[{\"T2\", \" \", SuperscriptBox[
RowBox[{\"A2\", \"[\", \"t\", \"]\"}], \"n2\"]}], \"-\", \"\[CenterEllipsis]\"}]]}]]\)";
GRN::usage="GRN[r, T, n, h] is an uninstantiated function used to represent neural network based Genetic Regulatory Networks. The canonical forms are\n"<>"{A\[RightTeeArrow]B, GRN[r, T, n, h]} "<>" which means B'[t]=="<>eq4<>"\n{{A1,A2,...}\[RightTeeArrow]B, GRN[r, {T1,T2,...}, {n1,n2,...}, h]} which means B'[t]="<>eq5<>"= r * sigma[h*T.(x^n)], where T={T1,T2,...}, x={A1,A2,...}, n={n1,n2,...}"<>"\nGRN[r,T,n,h,f] is a user-defined GRN reaction, with "<>"canonical form  {A\[RightTeeArrow]B, mygrn[r, T, n, h, f]}, where mygrn is any uninstantiated function that the user chooses, and f is any function of a single argument"<>"\nGRN[r,T,n,h], GRN[r,T,n,h,sigma], and mygrn[r,T,n,h,sigma] will produce the same results. However, GRN and mygrn reactions can not be combined with the same product, even if the same function is used.";
Remove[eq1,eq2,eq3,eq4,eq5];


eq1="\!\(\*SuperscriptBox[\"B\", \"\[Prime]\",\nMultilineFunction->None]\)[t]\[Equal]\!\(\*FractionBox[
RowBox[{\"v\", \" \", 
RowBox[{\"A\", \"[\", \"t\", \"]\"}]}], 
RowBox[{
RowBox[{\"A\", \"[\", \"t\", \"]\"}], \"+\", SubscriptBox[\"K\", \"M\"]}]]\)==-\!\(\*SuperscriptBox[\"A\", \"\[Prime]\",\nMultilineFunction->None]\)[t]";
eq2="\!\(\*SuperscriptBox[\"B\", \"\[Prime]\",\nMultilineFunction->None]\)[t]\[Equal]\!\(\*FractionBox[
RowBox[{
RowBox[{\"A\", \"[\", \"t\", \"]\"}], \" \", SubscriptBox[\"v\", \"1\"]}], 
RowBox[{
RowBox[{\"A\", \"[\", \"t\", \"]\"}], \"+\", SubscriptBox[\"K\", 
RowBox[{\"M\", \",\", \"1\"}]]}]]\)-\!\(\*FractionBox[
RowBox[{
RowBox[{\"B\", \"[\", \"t\", \"]\"}], \" \", SubscriptBox[\"v\", \"2\"]}], 
RowBox[{
RowBox[{\"B\", \"[\", \"t\", \"]\"}], \"+\", SubscriptBox[\"K\", 
RowBox[{\"M\", \",\", \"2\"}]]}]]\)==-\!\(\*SuperscriptBox[\"A\", \"\[Prime]\",\nMultilineFunction->None]\)[t]";
eq3="\!\(\*SuperscriptBox[\"B\", \"\[Prime]\",\nMultilineFunction->None]\)[t]\[Equal]\!\(\*FractionBox[
RowBox[{\"v\", \" \", 
RowBox[{\"A\", \"[\", \"t\", \"]\"}], \" \", 
RowBox[{\"En\", \"[\", \"t\", \"]\"}]}], 
RowBox[{
RowBox[{\"A\", \"[\", \"t\", \"]\"}], \"+\", SubscriptBox[\"K\", \"M\"]}]]\)==-\!\(\*SuperscriptBox[\"A\", \"\[Prime]\",\nMultilineFunction->None]\)[t]";
eq4="\!\(\*SuperscriptBox[\"B\", \"\[Prime]\",\nMultilineFunction->None]\)[t]\[Equal]\!\(\*FractionBox[
RowBox[{
RowBox[{\"A\", \"[\", \"t\", \"]\"}], \" \", 
RowBox[{\"En\", \"[\", \"t\", \"]\"}], \" \", SubscriptBox[\"k\", \"3\"]}], 
RowBox[{
RowBox[{\"A\", \"[\", \"t\", \"]\"}], \"+\", FractionBox[
RowBox[{SubscriptBox[\"k\", \"2\"], \"+\", SubscriptBox[\"k\", \"3\"]}], SubscriptBox[\"k\", \"1\"]]}]]\)==-\!\(\*SuperscriptBox[\"A\", \"\[Prime]\",\nMultilineFunction->None]\)[t]";
eq5="\!\(\*SuperscriptBox[\"B\", \"\[Prime]\",\nMultilineFunction->None]\)[t]\[Equal]\!\(\*FractionBox[
RowBox[{
RowBox[{\"A\", \"[\", \"t\", \"]\"}], \" \", 
RowBox[{\"EF\", \"[\", \"t\", \"]\"}], \" \", SubscriptBox[\"v\", \"F\"]}], 
RowBox[{
RowBox[{\"A\", \"[\", \"t\", \"]\"}], \"+\", SubscriptBox[\"K\", 
RowBox[{\"D\", \",\", \"F\"}]]}]]\)-\!\(\*FractionBox[
RowBox[{
RowBox[{\"B\", \"[\", \"t\", \"]\"}], \" \", 
RowBox[{\"ER\", \"[\", \"t\", \"]\"}], \" \", SubscriptBox[\"v\", \"R\"]}], 
RowBox[{
RowBox[{\"B\", \"[\", \"t\", \"]\"}], \"+\", SubscriptBox[\"K\", 
RowBox[{\"D\", \",\", \"R\"}]]}]]\)==-A'[t]";
eq6="\!\(\*SuperscriptBox[\"B\", \"\[Prime]\",\nMultilineFunction->None]\)[t]\[Equal]\!\(\*FractionBox[
RowBox[{
RowBox[{\"A\", \"[\", \"t\", \"]\"}], \" \", 
RowBox[{\"EF\", \"[\", \"t\", \"]\"}], \" \", SubscriptBox[\"k\", 
RowBox[{\"3\", \",\", \"f\"}]]}], 
RowBox[{
RowBox[{\"A\", \"[\", \"t\", \"]\"}], \"+\", FractionBox[
RowBox[{SubscriptBox[\"k\", 
RowBox[{\"2\", \",\", \"f\"}]], \"+\", SubscriptBox[\"k\", 
RowBox[{\"3\", \",\", \"f\"}]]}], SubscriptBox[\"k\", 
RowBox[{\"1\", \",\", \"f\"}]]]}]]\)-\!\(\*FractionBox[
RowBox[{
RowBox[{\"B\", \"[\", \"t\", \"]\"}], \" \", 
RowBox[{\"ER\", \"[\", \"t\", \"]\"}], \" \", SubscriptBox[\"k\", 
RowBox[{\"6\", \",\", \"f\"}]]}], 
RowBox[{
RowBox[{\"B\", \"[\", \"t\", \"]\"}], \"+\", FractionBox[
RowBox[{SubscriptBox[\"k\", 
RowBox[{\"5\", \",\", \"f\"}]], \"+\", SubscriptBox[\"k\", 
RowBox[{\"6\", \",\", \"f\"}]]}], SubscriptBox[\"k\", 
RowBox[{\"4\", \",\", \"5\"}]]]}]]\)==-A'[t]";
MM::usage="MM is an uninstantiated function used to define parameters for a Michaelis-Menten type of reaction."<>"\n{A\[DoubleLongRightArrow]B,MM[\!\(\*SubscriptBox[\"K\", \"M\"]\),v]} means" <>eq1<>"\n{A\[DoubleLongLeftRightArrow]B,MM[\!\(\*SubscriptBox[\"K\", 
RowBox[{\"M\", \",\", \"1\"}]]\),\!\(\*SubscriptBox[\"v\", \"1\"]\), \!\(\*SubscriptBox[\"K\", 
RowBox[{\"M\", \",\", \"2\"}]]\),\!\(\*SubscriptBox[\"v\", \"2\"]\)]} means "<>eq2<>"\n{\!\(\*OverscriptBox[
RowBox[{\"A\", \"\[DoubleLongRightArrow]\", \"B\"}], \"En\"]\),MM[\!\(\*SubscriptBox[\"K\", \"M\"]\),v]} means "<>eq3<>"\n{\!\(\*OverscriptBox[
RowBox[{\"A\", \"\[DoubleLongRightArrow]\", \"B\"}], \"En\"]\),MM[\!\(\*SubscriptBox[\"k\", \"1\"]\),\!\(\*SubscriptBox[\"k\", \"2\"]\),\!\(\*SubscriptBox[\"k\", \"3\"]\)]} means "<>eq4<>"\n{\!\(\*UnderoverscriptBox[
RowBox[{\"A\", \"\[DoubleLongLeftRightArrow]\", \"B\"}], \"ER\", \"EF\"]\),MM[\!\(\*SubscriptBox[\"K\", 
RowBox[{\"D\", \",\", \"F\"}]]\),\!\(\*SubscriptBox[\"v\", \"F\"]\),\!\(\*SubscriptBox[\"K\", 
RowBox[{\"D\", \",\", \"R\"}]]\),\!\(\*SubscriptBox[\"v\", \"R\"]\)]} means "<>eq5<>"\n{\!\(\*UnderoverscriptBox[
RowBox[{\"A\", \"\[DoubleLongLeftRightArrow]\", \"B\"}], \"ER\", \"EF\"]\),MM[\!\(\*SubscriptBox[\"k\", 
RowBox[{\"1\", \",\", \"f\"}]]\),\!\(\*SubscriptBox[\"k\", 
RowBox[{\"2\", \",\", \"f\"}]]\),\!\(\*SubscriptBox[\"k\", 
RowBox[{\"3\", \",\", \"f\"}]]\),\!\(\*SubscriptBox[\"k\", 
RowBox[{\"4\", \",\", \"5\"}]]\),\!\(\*SubscriptBox[\"k\", 
RowBox[{\"5\", \",\", \"f\"}]]\),\!\(\*SubscriptBox[\"k\", 
RowBox[{\"6\", \",\", \"f\"}]]\)]} means "<>eq6;
Remove[eq1, eq2,eq3,eq4,eq5];



eq1="\[Tau]B'[t]=\!\(\*SuperscriptBox[\"k\", \"+\"]\)A[t\!\(\*SuperscriptBox[\"]\", SuperscriptBox[\"c\", \"+\"]]\)-\!\(\*SuperscriptBox[\"k\", \"-\"]\)A[t\!\(\*SuperscriptBox[\"]\", SuperscriptBox[\"c\", \"-\"]]\)";
eq2="\[Tau]B'[t]=\[Tau]B'[t]=\!\(\*SuperscriptBox[\"k\", \"+\"]\)\!\(\*UnderscriptBox[\"\[Product]\", \"i\"]\)\!\(\*SubscriptBox[\"A\", \"i\"]\)[t\!\(\*SuperscriptBox[\"]\", SuperscriptBox[SubscriptBox[\"c\", \"i\"], \"+\"]]\)-\!\(\*SuperscriptBox[\"k\", \"-\"]\)\!\(\*UnderscriptBox[\"\[Product]\", \"i\"]\)\!\(\*SubscriptBox[\"A\", \"i\"]\)[t\!\(\*SuperscriptBox[\"]\", SuperscriptBox[SubscriptBox[\"c\", \"i\"], \"-\"]]\)";
eq3="\n{{A1,A2,\[Ellipsis]}\[RightTeeArrow]B,SSystem[\[Tau],\!\(\*SuperscriptBox[\"k\", \"+\"]\), \!\(\*SuperscriptBox[\"k\", \"-\"]\),{\!\(\*SuperscriptBox[\"c\", \"+\"]\),\[Ellipsis]},{\!\(\*SuperscriptBox[\"c\", \"-\"]\),\[Ellipsis]}]}";
eq4="SSystem[\[Tau], \!\(\*SuperscriptBox[\"k\", \"+\"]\), \!\(\*SuperscriptBox[\"k\", \"-\"]\), \!\(\*SuperscriptBox[\"c\", \"+\"]\),\!\(\*SuperscriptBox[\"c\", \"-\"]\)]";
SSystem::usage=eq4<>" is an uninstantiated function used to specify parameters for Synergestic System (S-System) interactions. The canonical form is"<>"\n{A\[RightTeeArrow]B, SSystem[\[Tau], \!\(\*SuperscriptBox[\"k\", \"+\"]\), \!\(\*SuperscriptBox[\"k\", \"-\"]\), \!\(\*SuperscriptBox[\"c\", \"+\"]\),\!\(\*SuperscriptBox[\"c\", \"-\"]\)]}"<>
"\n which means "<>eq1<>eq3<>
"\n which means"<>eq2<>"\n{A1,A2,\[Ellipsis]}\[RightTeeArrow]B is the same as A1+A2+\[Ellipsis]\[RightTeeArrow]B. S-Systems are a special case of Generalized Mass Action interactions.";
Remove[eq1,eq2, eq3, eq4]



eq1="\[Tau]B'[t]=\!\(\*SuperscriptBox[\"k\", \"+\"]\)A[t\!\(\*SuperscriptBox[\"]\", SuperscriptBox[\"c\", \"+\"]]\)-\!\(\*SuperscriptBox[\"k\", \"-\"]\)A[t\!\(\*SuperscriptBox[\"]\", SuperscriptBox[\"c\", \"-\"]]\)";
eq2="\[Tau]B'[t]=\!\(\*UnderscriptBox[\"\[Sum]\", \"j\"]\)\!\(\*SubsuperscriptBox[\"k\", \"j\", \"+\"]\)\!\(\*UnderscriptBox[\"\[Product]\", \"i\"]\)\!\(\*SubscriptBox[\"A\", \"i\"]\)[t\!\(\*SuperscriptBox[\"]\", SuperscriptBox[SubscriptBox[\"c\", \"ij\"], \"+\"]]\)-\!\(\*UnderscriptBox[\"\[Sum]\", \"j\"]\)\!\(\*SuperscriptBox[\"k\", \"-\"]\)\!\(\*UnderscriptBox[\"\[Product]\", \"i\"]\)\!\(\*SubscriptBox[\"A\", \"i\"]\)[t\!\(\*SuperscriptBox[\"]\", SuperscriptBox[SubscriptBox[\"c\", \"ij\"], \"-\"]]\)";
eq3="\n{{A1,A2,\[Ellipsis]}\[RightTeeArrow]B,GMA[\[Tau],(\!\(\*SuperscriptBox[\"k\", \"+\"]\),\[Ellipsis]}, {\!\(\*SuperscriptBox[\"k\", \"-\"]\),\[Ellipsis]},{\!\(\*SuperscriptBox[\"c\", \"+\"]\),\[Ellipsis]},{\!\(\*SuperscriptBox[\"c\", \"-\"]\),\[Ellipsis]}]}";
eq4="GMA[\[Tau], \!\(\*SuperscriptBox[\"k\", \"+\"]\), \!\(\*SuperscriptBox[\"k\", \"-\"]\), \!\(\*SuperscriptBox[\"c\", \"+\"]\),\!\(\*SuperscriptBox[\"c\", \"-\"]\)]";
GMA::usage=eq4<>" is an uninstantiated function used to specify parameters for Generalized Mass Action (GMA) interactions. The canonical form is"<>"\n{A\[RightTeeArrow]B, GMA[\[Tau], \!\(\*SuperscriptBox[\"k\", \"+\"]\), \!\(\*SuperscriptBox[\"k\", \"-\"]\), \!\(\*SuperscriptBox[\"c\", \"+\"]\),\!\(\*SuperscriptBox[\"c\", \"-\"]\)]}"<>
"\n which means "<>eq1<>eq3<>
"\n which means"<>eq2<>"\n{A1,A2,\[Ellipsis]}\[RightTeeArrow]B is the same as A1+A2+\[Ellipsis]\[RightTeeArrow]B. When the k's are scalars then GMA interactions reduce to Synergistic System (S-System) interactions.";
Remove[eq1,eq2, eq3, eq4]



GMWC::usage="";
MWC::usage="";



eq1="\!\(\*SuperscriptBox[\"B\", \"\[Prime]\",\nMultilineFunction->None]\)[t]\[Equal]\!\(\*FractionBox[
RowBox[{\"v\", \" \", SuperscriptBox[
RowBox[{\"(\", 
RowBox[{\"1\", \"+\", 
RowBox[{\"T\", \" \", SuperscriptBox[
RowBox[{\"A\", \"[\", \"t\", \"]\"}], \"n\"], \" \", 
RowBox[{\"\[CapitalTheta]\", \"[\", \"T\", \"]\"}]}]}], \")\"}], \"m\"]}], 
RowBox[{
RowBox[{\"k\", \" \", SuperscriptBox[
RowBox[{\"(\", 
RowBox[{\"1\", \"+\", 
RowBox[{\"T\", \" \", SuperscriptBox[
RowBox[{\"A\", \"[\", \"t\", \"]\"}], \"n\"], \" \", 
RowBox[{\"\[CapitalTheta]\", \"[\", 
RowBox[{\"-\", \"T\"}], \"]\"}]}]}], \")\"}], \"m\"]}], \"+\", SuperscriptBox[
RowBox[{\"(\", 
RowBox[{\"1\", \"+\", 
RowBox[{\"T\", \" \", SuperscriptBox[
RowBox[{\"A\", \"[\", \"t\", \"]\"}], \"n\"], \" \", 
RowBox[{\"\[CapitalTheta]\", \"[\", \"T\", \"]\"}]}]}], \")\"}], \"m\"]}]]\)";
eq2="\!\(\*SuperscriptBox[\"B\", \"\[Prime]\",\nMultilineFunction->None]\)[t]\[Equal]\!\(\*FractionBox[
RowBox[{\"v\", \" \", SuperscriptBox[
RowBox[{\"(\", 
RowBox[{\"1\", \"+\", 
RowBox[{\"TP\", \" \", SuperscriptBox[
RowBox[{\"A\", \"[\", \"t\", \"]\"}], \"n\"]}]}], \")\"}], \"m\"]}], 
RowBox[{
RowBox[{\"k\", \" \", SuperscriptBox[
RowBox[{\"(\", 
RowBox[{\"1\", \"+\", 
RowBox[{\"TM\", \" \", SuperscriptBox[
RowBox[{\"A\", \"[\", \"t\", \"]\"}], \"n\"]}]}], \")\"}], \"m\"]}], \"+\", SuperscriptBox[
RowBox[{\"(\", 
RowBox[{\"1\", \"+\", 
RowBox[{\"TP\", \" \", SuperscriptBox[
RowBox[{\"A\", \"[\", \"t\", \"]\"}], \"n\"]}]}], \")\"}], \"m\"]}]]\)";
eq3="\!\(\*SuperscriptBox[\"B\", \"\[Prime]\",\nMultilineFunction->None]\)[t]\[Equal]\!\(\*FractionBox[
RowBox[{\"v\", 
RowBox[{UnderscriptBox[\"\[Product]\", \"i\"], SuperscriptBox[
RowBox[{\"(\", 
RowBox[{\"1\", \"+\", 
RowBox[{
RowBox[{\"SubscriptBox\", \"[\", 
RowBox[{\"TP\", \",\", \"i\"}], \"]\"}], SuperscriptBox[
RowBox[{SubscriptBox[\"A\", \"i\"], \"[\", \"t\", \"]\"}], SubscriptBox[\"n\", \"i\"]]}]}], \")\"}], \"m\"]}]}], 
RowBox[{
RowBox[{\"k\", \" \", 
RowBox[{UnderscriptBox[\"\[Product]\", \"i\"], SuperscriptBox[
RowBox[{\"(\", 
RowBox[{\"1\", \"+\", 
RowBox[{
RowBox[{\"SubscriptBox\", \"[\", 
RowBox[{\"TM\", \",\", \"i\"}], \"]\"}], SuperscriptBox[
RowBox[{SubscriptBox[\"A\", \"i\"], \"[\", \"t\", \"]\"}], SubscriptBox[\"n\", \"i\"]]}]}], \")\"}], \"m\"]}]}], \"+\", 
RowBox[{UnderscriptBox[\"\[Product]\", \"i\"], SuperscriptBox[
RowBox[{\"(\", 
RowBox[{\"1\", \"+\", 
RowBox[{
RowBox[{\"SubscriptBox\", \"[\", 
RowBox[{\"TP\", \",\", \"i\"}], \"]\"}], SuperscriptBox[
RowBox[{SubscriptBox[\"A\", \"i\"], \"[\", \"t\", \"]\"}], SubscriptBox[\"n\", \"i\"]]}]}], \")\"}], \"m\"]}]}]]\)";
eq4="\!\(\*SuperscriptBox[\"B\", \"\[Prime]\",\nMultilineFunction->None]\)[t]\[Equal]\!\(\*FractionBox[
RowBox[{\"v\", 
RowBox[{UnderscriptBox[\"\[Product]\", \"i\"], SuperscriptBox[
RowBox[{\"(\", 
RowBox[{\"1\", \"+\", 
RowBox[{
RowBox[{\"SubscriptBox\", \"[\", 
RowBox[{\"T\", \",\", \"i\"}], \"]\"}], 
RowBox[{\"\[CapitalTheta]\", \"[\", SubscriptBox[\"T\", \"i\"], \"]\"}], SuperscriptBox[
RowBox[{SubscriptBox[\"A\", \"i\"], \"[\", \"t\", \"]\"}], SubscriptBox[\"n\", \"i\"]]}]}], \")\"}], \"m\"]}]}], 
RowBox[{
RowBox[{\"k\", \" \", 
RowBox[{UnderscriptBox[\"\[Product]\", \"i\"], SuperscriptBox[
RowBox[{\"(\", 
RowBox[{\"1\", \"+\", 
RowBox[{
RowBox[{\"SubscriptBox\", \"[\", 
RowBox[{\"T\", \",\", \"i\"}], \"]\"}], 
RowBox[{\"\[CapitalTheta]\", \"[\", 
RowBox[{\"-\", SubscriptBox[\"T\", \"i\"]}], \"]\"}], SuperscriptBox[
RowBox[{SubscriptBox[\"A\", \"i\"], \"[\", \"t\", \"]\"}], SubscriptBox[\"n\", \"i\"]]}]}], \")\"}], \"m\"]}]}], \"+\", 
RowBox[{UnderscriptBox[\"\[Product]\", \"i\"], SuperscriptBox[
RowBox[{\"(\", 
RowBox[{\"1\", \"+\", 
RowBox[{
RowBox[{\"SubscriptBox\", \"[\", 
RowBox[{\"T\", \",\", \"i\"}], \"]\"}], 
RowBox[{\"\[CapitalTheta]\", \"[\", SubscriptBox[\"T\", \"i\"], \"]\"}], SuperscriptBox[
RowBox[{SubscriptBox[\"A\", \"i\"], \"[\", \"t\", \"]\"}], SubscriptBox[\"n\", \"i\"]]}]}], \")\"}], \"m\"]}]}]]\)";
NHCA::usage="NHCA is an uninstantiated function used to specify parameters for SSystem reactions. The canonical forms are\n{A\[RightTeeArrow]B,NHCA[v,T,n,m,k] which means "<>eq1<>" where \[CapitalTheta][u] is UnitStep[u]"<>"\n{A\[RightTeeArrow]B, NHCA[v,{TP,TM},n,m,k] which means "<>eq2<>"\nMultiple Reactions with the same product combine vectorally and are equivalent to "<>"{A1,A2,\[Ellipsis]}\[RightTeeArrow]B and A1+A2+\[Ellipsis]\[RightTeeArrow]B, as "<>eq3<>" or "<>eq4;
Remove[eq1,eq2,eq3,eq4];
Null


run::usage="run[sys, {t, tstart, tend}, options]"<>"\nrun[sys, {tstart, tend}, options]: gets t from timeVariable"<>"\nrun[sys,options]: gest times from timeSpan"<>"\n\nOptions:\ninitialConditions->{}.  Missing initial conditions are set to zero. Unassigned parameters are set to 1. \nplot->False\ngridPlotVariables-> {}\nplotVariables->{}\nrates->{}\ntimeSpan->100 (run duration)\ntimeVariable->Global`t\n\"BoundaryConditions\"\[Rule]{\!\(\*SubscriptBox[\"X\", \"1\"]\)[t]\[Rule]\!\(\*SubscriptBox[\"f\", \"1\"]\)[t],\!\(\*SubscriptBox[\"X\", \"2\"]\)[t]\[Rule]\!\(\*SubscriptBox[\"f\", \"2\"]\)[t], \[Ellipsis]}] - replace each of the variables \!\(\*SubscriptBox[\"X\", \"i\"]\) with the explicity function \!\(\*SubscriptBox[\"f\", \"i\"]\)\n\"Quiet\"\[Rule]True\n\"Debug\"\[Rule]False\n\nTo plot (gridplot) plot must be set to True and plotVariables (gridPlotVariables)->All or a list of variables. If both plotVariables and gridPlotVariables are assigned, then both sets of plots will be produced. Options can not be sent to the plots; more precise plotting control can be obtained using runPlot and gridPlot.";

simulate::usage="same as run but used SBMLNDSolve and returns result in SBMLNDSolve format.";
rates::usage="rates->{} is an option for run. A list of replacement rules, typically giving the values used for parameters such as rate constants.\n\n"<>"rates->False is an option for lowLevelReactions. If True, the rates will also be returend.";
initialConditions::usage="initialConditions->{} is an option for run. It gives the initial conditions used in the integration. \nFormat 1: {a[0]==a0, ...}\nFormat 2: {a->a0, ...}";
plot::usage="";
plotVariables::usage="";
timeSpan::usage="timeSpan->{0,100} is an option for run.\nIt is ignored unless run is invoked by run[sys, options]. \ntimeSpan->{} or not specified means {timeVariable, tstart, tend} = {Global`t, 0, 100}\ntimeSpan->x or {x} means {timeVariable, tstart, tend}={Global`t, 0, x}"<>"\ntimeSpan->{x,y} means {timeVariable, tstart, tend}={Global`t, x, y}"<>"\ntimeSpan->{z, x, y} means {timeVariable, tstart, tend} = {z, x, y}"; 
timeVariable::usage="timeVariable->Global`t is an option for run. It is the name of the time variable in the equations solved by run. ";
gridPlotVariables::usage="";
Options[run]={rates->{}, initialConditions->{}, plot-> False, plotVariables-> {}, timeSpan->{0,100}, timeVariable-> Global`t, gridPlotVariables-> None, "Quiet"-> True, "Debug"-> False};

runPlot::usage="runPlot[sys,options] plots all variables in sys (output of interpret) for the entire solution time span.
\nrunPlot[sys,{var1,var2,...},options] plots the requested variables for the entire solution time span\nrunPlot[sys, {var1,var2,...}, {tstart, tend},options] plots the requested variables for the specified time span\n\nOptions:\nAny option for Plot or Graphics may be used.";
gridPlot::usage="gridPlot[sys, vars,{tstart, tend}, options]\nvars is either a list of variables or the symbol All.\nsys is the output of run.\n\nOptions:\nplotColumns->3";
plotColumns::usage="";
Options[gridPlot]={plotColumns-> 3};

arrayGridPlot::usage="arrayGridPlot[system,n, tmax, {\!\(\*SubscriptBox[\"var\", \"1\"]\),\!\(\*SubscriptBox[\"var\", \"2\"]\),...}, options]\ngenerates a grid of plots of each array on a separate plot. Then \!\(\*SubscriptBox[\"var\", \"1\"]\)[1],...,\!\(\*SubscriptBox[\"var\", \"1\"]\)[n] are plotted on the first plot, \!\(\*SubscriptBox[\"var\", \"2\"]\)[1],..,\!\(\*SubscriptBox[\"var\", \"2\"]\)[n] are plotted on the second plot, and so forth. \n\nOptions:\nplotColumns\[Rule]3.";

PhasePlot::usage="PhasePlot[solution, {v1, v2}, {tbegin, tend}, options] is a wrapper for ParametricPlot. Here solution is the output of run."; 

PredictTransferFunction::usage="PredictTransferFunction[system, {time, tbegin, tend}, {input, min, max, delta}, output, options]\nrepeatedly executes run, varying the value of input=min, min+delta, min+2delta, ..., max. \nThe symbol input may refer to either a chemical species in a reaction or a rate constant. \nThe symbol output is either the name of a single variable, or a list of variables. Returns a table in the form of a list of values of all the variables in output for each value of input.\n\nOptions:\n\"Integrate\"\[Rule]False, if True, integrates the output variables from tbegin to tend; otherwise, just returns the value of the variable.\n\"Function\"\[Rule]optional function to be applied to either the values of variable (if \"Integrate\"\[Rule]False) or the variable before integration (if \"Integrate\"\[Rule]True).\n\nPredictionTransferFunction[net, {t,0,100}, {A, 1,10, .5}, {P, Q, R}]\nreturns\n{{list-of-column-headers}\n{1, P[100], Q[100], R[100]}, \n{1.5, P[100], Q[100], R[100]},\n ...\n{10, P[100], Q[100], R[100]} "; 
ParametricVariation::usage=""; 

snapshot::usage="";

Options[BifurcationPlot]={PlotPoints->2000,PlotStyle->{Black,PointSize[0.001]}};
BifurcationPlot::usage="BifurcationPlot[f, {r, rmin, rmax}, {x, x0}, {i, ishow}, options], where f[x,r] is a function of x that depends on a parameter r, which undergoes a period doubling bifurcation between rmin and rmax; i is the total number of iterations; ishow is the number to actually show. "



vmax::usage="vmax is a Cellerator option for hill[] or NHCA[]. Cellerator options may not be combined with positional parameters and are discouraged becuase they can significantly degrade performance.";
nhill::usage="nhill is a Cellerator option for hill[]. Cellerator options may not be combined with positional parameters and are discouraged becuase they can significantly degrade performance.";
khalf::usage="khalf is a Cellerator option for hill[]. Cellerator options may not be combined with positional parameters and are discouraged becuase they can significantly degrade performance.";
basalRate::usage="basalRate is a Cellerator option for hill[]. Cellerator options may not be combined with positional parameters and are discouraged becuase they can significantly degrade performance.";
Thill::usage="Thill is a Cellerator option for hill[].Cellerator options may not be combined with positional parameters and are discouraged becuase they can significantly degrade performance.";
Options[hill]= {vmax-> 1, nhill-> 1, khalf-> 1, basalRate-> 0, Thill-> 1};
RGRN::usage="RGRN is a Cellerator option for GRN[]. It corresponds to the GRN positional parameter r (see GRN). Cellerator options may not be combined with positional parameters and are discouraged becuase they can significantly degrade performance.";
TGRN::usage="TGRN is a Cellerator option for GRN[]. It corresponds to the GRN positional parameter T (see GRN). Cellerator options may not be combined with positional parameters and are discouraged becuase they can significantly degrade performance.";
nGRN::usage="nGRN is a Cellerator option for GRN[]. It corresponds to the GRN positional parameter n (see GRN). Cellerator options may not be combined with positional parameters and are discouraged becuase they can significantly degrade performance.";
hGRN::usage="hGRN is a Cellerator option for GRN[]. It corresponds to the GRN positional parameter h (see GRN). Cellerator options may not be combined with positional parameters and are discouraged becuase they can significantly degrade performance.";
Sigmoid::usage="Sigmoid is a Cellerator option for GRN[]. It represents a user-defined function, corresponding to the optional positional parameter f in GRN (see GRN). Cellerator options may not be combined with positional parameters and are discouraged becuase they can significantly degrade performance. In particular, user-defined sigmoids should be defined with user-defined arrows rather than the Sigmoid option. Not to be confused with the functions sigmoid, grnsigmoid, and sigma. ";
Options[GRN]={TGRN-> 1, RGRN-> 1, nGRN-> 1, hGRN-> 0, Sigmoid-> sigmoid};
grn::usage="grn is an alternate spelling for GRN[]."
TNHCA::usage="TNHCA is a Cellerator option for NHCA. Cellerator options may not be combined with positional parameters and are discouraged becuase they can significantly degrade performance. ";
TPLUS::usage="TPLUS  is a Cellerator option for NHCA. Cellerator options may not be combined with positional parameters and are discouraged becuase they can significantly degrade performance. ";
TMINUS::usage="TMINUS  is a Cellerator option for NHCA. Cellerator options may not be combined with positional parameters and are discouraged becuase they can significantly degrade performance. ";
nNHCA::usage="nNHCA  is a Cellerator option for NHCA. Cellerator options may not be combined with positional parameters and are discouraged becuase they can significantly degrade performance. ";
kNHCA::usage="kNHCA is a Cellerator option for NHCA. Cellerator options may not be combined with positional parameters and are discouraged becuase they can significantly degrade performance. ";
mNHCA::usage="mNHCA is a Cellerator option for  NHCA. Cellerator options may not be combined with positional parameters and are discouraged becuase they can significantly degrade performance. ";
Options[NHCA]={TNHCA-> 1, TPLUS-> {}, TMINUS-> {}, nNHCA-> 1, kNHCA-> 1, mNHCA-> 1, vmax-> 1};
KGMWC::usage="KGMWC is a Cellerator option for GMWC. Cellerator options may not be combined with positional parameters and are discouraged becuase they can significantly degrade performance. ";
cGMWC::usage="cGMWC is a Cellerator option for GMWC. Cellerator options may not be combined with positional parameters and are discouraged becuase they can significantly degrade performance. ";
LGMWC::usage="LGMWC is a Cellerator option for GMWC. Cellerator options may not be combined with positional parameters and are discouraged becuase they can significantly degrade performance. ";
kcatGMWC::usage="kcatGMWC is a Cellerator option for GMWC. ";
Options[GMWC]:= {KGMWC-> 1, cGMWC-> 1, LGMWC-> 1, nGMWC-> 1, kcatGMWC-> 1};


Begin["`Private`"];


tovernum[u_?StringQ]:=  Module[{vs, num}, 
vs=u;
While[StringLength[vs]>0,
num=StringMatchQ[vs, RegularExpression["\\d+\\.?\\d*"]];
If[num, Return[ToExpression[vs]]]; 
vs=StringDrop[vs, -1];
];
Return[0];
];
tovernum[x___]:= Return[0]; 

mver[]:= Module[{vs}, 
vs=tovernum[MathSBML`$MathSBML$Version]; 
Return[vs];
];


If[$VersionNumber>5.999, 
If[tovernum[$xlr8r$Version]>0.59, 
If[tovernum[MathSBML`$MathSBML$Version]<2.8, 
Print["Warning: this version of xlr8r requies MathSBMl version 2.8 or higher. Version loaded: ", MathSBML`$MathSBML$Version];
];
]; 
]; 




MyTextStyle[x___]:= If[$VersionNumber<6, TextStyle[x], Style[x]]; 
MyStyle[x___]:= If[$VersionNumber<6, StyleForm[x], Style[x]]; 
MyDate[x___]:= If[$VersionNumber<6, Date[], DateList[]];
MyStylePrint[x___]:= If[$VersionNumber<6, StylePrint[x], Print[Style[x]]]; 
MyStyleForm[x___]:= If[$VersionNumber<6, StyleForm[x], Style[x]]; 



MyFilterOptions[f_, opt___?OptionQ]:= 
If[$VersionNumber<6,
Utilities`FilterOptions`FilterOptions[f, opt]
,
Sequence@@FilterRules[Flatten[{opt}],Options[f]]
];

(* 
The following nonsense is required to suppress printing of a Global`AngleBracket::shdw error message, because Off[..] does not work propertly in version 6
*)

If[$VersionNumber<6,
 MyAngleBracket[x___]:=ToExpression["Global`AngleBracket"]@@{x};
MyRightArrowLeftArrow[x___]:=ToExpression["Global`RightArrowLeftArrow"]@@{x};
ExportXMLString[x_]:= ExportString[x, "XML", ConversionOptions-> {"AttributeQuoting"-> "\""}]
,
MyAngleBracket[x___]:=ToExpression["System`AngleBracket"]@@{x};
MyRightArrowLeftArrow[x___]:=ToExpression["System`RightArrowLeftArrow"]@@{x}; 
ExportXMLString[x_]:= ExportString[x,"XML", "AttributeQuoting"-> "\""]
]; 


(* syntax change in version 6.0.1, reverted back to old version in 6.0.2/3!!! *)
(* 
If[$VersionNumber<6 , 
Xpression2SymbolicMathML[x_]:= XML`MathML`ExpressionToSymbolicMathML[x,"Formats"-> {"ContentMathML"}],
If[$ReleaseNumber <1.5, 
Xpression2SymbolicMathML[x_]:= XML`MathML`ExpressionToSymbolicMathML[x, "Semantics"-> True, "Presentation"-> False], 
Xpression2SymbolicMathML[x_]:= XML`MathML`ExpressionToSymbolicMathML[x,"Formats"-> {"ContentMathML"}]
];
]; 
*)

Which[
$VersionNumber<6, 
Xpression2SymbolicMathML[x_]:= XML`MathML`ExpressionToSymbolicMathML[x,"Formats"-> {"ContentMathML"}],

$VersionNumber ==6 \[And] $ReleaseNumber<2,
Xpression2SymbolicMathML[x_]:= XML`MathML`ExpressionToSymbolicMathML[x, "Semantics"-> True, "Presentation"-> False], 

$VersionNumber ==6 \[And] $ReleaseNumber>1, 
Xpression2SymbolicMathML[x_]:= XML`MathML`ExpressionToSymbolicMathML[x,"Formats"-> {"ContentMathML"}],

$VersionNumber==7, 
Xpression2SymbolicMathML[x_]:= XML`MathML`ExpressionToSymbolicMathML[x,"Formats"-> {"ContentMathML"}],

$VersionNumber>7,
Xpression2SymbolicMathML[x_]:= XML`MathML`ExpressionToSymbolicMathML[x,"Formats"-> {"ContentMathML"}]


];




now::usage="now[] returns the date and time as a string";

now[]:=DateString[{"Day","-","MonthName", "-", "Year", " ", "Hour24",":", "Minute", ":","Second", ".", "Millisecond"}];
nower[]:=DateString[{"Day"," ","MonthName", " ", "Year", " at ", "Hour24",":", "Minute", " ", "TimeZone"}];


symbolQ[x_]:=SameQ[Head[x],Symbol];


getSingleValue[k_,kdefault_,  message_,reaction_]:= Module[{K},
K=Flatten[{k}];
Switch[Length[K],
0, K=kdefault;, 
1, K=First[K];,
_,  
Print["Error: extra ",message," ",Drop[K,1], " in ", reaction," ignored."];
K=First[K];
];

Return[K];
];
getnValues[n_,v_,message_,reaction_]:= Module[{V,lastv},
V=Flatten[{v}];
lastv=Last[V];
While[Length[V]<n, V=Append[V,lastv]];
If[Length[V]>n, Print["Error: extra ",message," ",Drop[V,n]," in reaction ",reaction," ignored."];];
V=Take[V,n];
Return[V];
];
getnListValues[n_,v_,message_,reaction_]:= Module[{V,lastv},
If[ListQ[v], V=v, V={v}]; 
V=Flatten/@List/@V;

lastv=Last[V];
While[Length[V]<n, V=Append[V,lastv]];
If[Length[V]>n, Print["Error: extra ",message," ",Drop[V,n]," in reaction ",reaction," ignored."];];
V=Take[V,n];
Return[V];
];


functionArguments[f_[x___]]:= {x};


sigma[x_]:= 1/2 (1+x/Sqrt[1+x^2]);
sigmoid[x_]:= 1/(1+Exp[-x]);
grnsigmoid[x_,r_:1,T_:1, n_:1,h_:0]:= r*sigmoid[h+T*x^n];

(* The following expansion is done to handle negative exponents on hill functions near x=0. This is because x^-n/(1+x^-n) has a 1/0 form in both the numerator and denominator, whereas the mathematically equivalent form  1/(1+x^n) has neither. The x^-n is actually part of the denominator, i.e., Matheamtica treats it as  1/(x^n (1+x^-n)), which is why this should work. *)

hillFunction[x_,K_,n_,v_, r_]:= Module[{num,den,quotient}, 
quotient=(r+v*x^n)/(K^n+x^n);
num=Expand[Numerator[quotient]]; 
den = Expand[Denominator[quotient]]; 
quotient=num/den;
Return[quotient]
]; 


BifurcationPlot[f_,{r_,a_,b_},{x_,x0_},{iter0_,iterShow_},opts___]:=Module[{sty,n,makePts,cf,rVals,data},{sty,n}={PlotStyle,PlotPoints}/.{opts}/.Options[BifurcationPlot];
makePts[{s_,v_}]:=({s,#}&)/@v;
cf=Compile[{{r,_Real,1},{x,_Real,1}},Evaluate[f]];
rVals=Range[N[a],b,(b-a)/(n-1)];
data=Transpose[{rVals,Transpose[NestList[cf[rVals,#]&,Nest[cf[rVals,#1]&,Array[x0&,n],iter0],iterShow]]}];
Graphics[Append[Flatten[{sty}],Point[Flatten[makePts/@data,1]]],Sequence@@FilterRules[{opts},Options[Graphics]],AspectRatio->1/3,Frame->True,FrameTicks->{Automatic,Range[0,1,.5],None,None},Axes->None]]


ListToSum[x_]:= Plus@@Flatten[{x/.{Plus->List}}];


setBinding[A_, B_]:= Module[{r1,r2},
{r1,r2}=Sort[{A,B}];
Return[Bind[r1,r2]];
]; 


parseReactants[functionForm_,Plus[x___]]:= Module[{r, parseStoichiometry},

If[functionForm,
parseStoichiometry[Times[n?NumberQ,var_]]:= {var[Global`t],n};
parseStoichiometry[Times[var_,n_?NumberQ]]:= {var[Global`t],n};
parseStoichiometry[var_]:= {var[Global`t],1};
,
parseStoichiometry[Times[n?NumberQ,var_]]:= {var,n};
parseStoichiometry[Times[var_,n_?NumberQ]]:= {var,n};
parseStoichiometry[var_]:= {var,1};
];

r=Plus[x]/.{Plus-> List};
If[!ListQ[r], r={r}];
r = parseStoichiometry/@r;
If[functionForm,
r=Complement[r,{{Global`\[EmptySet][Global`t],1}}];,
r=Complement[r,{{Global`\[EmptySet],1}}]; 
];

Return[r];
]; 

parseReactants[x__]:= Module[{},
Print["Unable to parse the expression:", x, " in the reaction ", reaction]; 
Abort[];
]; 


expandArrows[{ShortRightArrow[substrateExpression_,productExpression_] ,rate___:1}]:= Module[{reaction, k},

reaction = substrateExpression\[ShortRightArrow]productExpression;
If[dbgArrows,Print["expandArrows:", reaction]]; 

k={rate}//Flatten;
If[Length[k]<1, 
k=1, 
If[Length[k]>1, Print["Warning: Extra rate constants ", Drop[k,1]," in the reaction ", reaction, " will be ignored."]]; 
k=First[k]
]; 
Return[{{reaction,k}}];
]


expandArrows[{ShortRightArrow[substrateExpression_,productExpression_ ],rate___:1}]:= Module[{reaction, k, lhs, rhs},

lhs = ListToSum[substrateExpression]; 
rhs=ListToSum[productExpression]; 
reaction = ShortRightArrow[lhs,rhs];
If[dbgArrows,Print["expandArrows:", reaction]]; 

k={rate}//Flatten;
If[Length[k]<1, 
k=1, 
If[Length[k]>1, Print["Warning: Extra rate constants ", Drop[k,1]," in the reaction ", reaction, " will be ignored."]]; 
k=First[k]
]; 
Return[{{reaction,k}}];
]


parseArrowForm[{ShortRightArrow[substrateExpression_,productExpression_ ],rate___:1}]:= Module[{parseExpression, reaction, input, output, klaw,species, nspecies, dbg=False, netStoichiometry, rates,odes, k},

reaction = ShortRightArrow[substrateExpression,productExpression];
If[dbgArrows,Print["parseArrowForm:", reaction]]; 

{reaction,k}=expandArrows[{reaction,rate}][[1]];

If[dbg, Print["reaction: " ,reaction, "\nsubstrateExpression: ", substrateExpression, "\nproductExpression: ", productExpression]]; 

input=parseReactants[True,substrateExpression];
output=parseReactants[True, productExpression];
klaw=k*Times@@Map[Power@@#&,input];
klaw = klaw/.{Global`\[EmptySet][Global`t]-> 1};

If[dbg, Print["input: ", input,"\noutput:", output, "\nklaw: ", klaw]]; 

netStoichiometry[x_]:= Module[{in,out},
in = Cases[input,{x,_}];
If[Length[in]<1, 
in = 0, 
in = Transpose[in];
in=Plus@@in[[2]];
];

out=Cases[output,{x,_}];
If[Length[out]<1, 
out = 0, 
out = Transpose[out];
out=Plus@@out[[2]];
];

Return[out-in];

]; (* end netStoichiometry *)

species=Union[First/@input, First/@output]; 
rates=klaw*netStoichiometry/@species;

If[dbg,
Print["input stoichiometry:",input];
Print["klaw=",klaw];
Print["output stoichiometry:",output];
Print["species:", species];
Print["rates:",rates];
];

odes = {species,rates}//Transpose;
Return[odes];
]


expandArrows[{RightArrowLeftArrow[X_,Y_ ],k___}]:= Module[{forward, reverse,kf,kr,rates,reaction},
reaction={RightArrowLeftArrow[X,Y],k};
If[dbgArrows,Print["expandArrows:", reaction]];
rates=Flatten[{k}];
While[Length[rates]<2, rates=Append[rates,1]];
If[Length[rates]>2, Print["Warning: extra rate constants ", Drop[rates,2]," in the reaction ", reaction, " will be ignored."]]; 
rates=Take[rates,2];
{kf,kr}=rates;

forward={ShortRightArrow[X, Y],kf};
reverse={ShortRightArrow[Y,X],kr};
If[dbgArrows,Print["expandArrows:", {forward, reverse}]];

Return[{forward, reverse}];
]


parseArrowForm[{RightArrowLeftArrow[X_,Y_ ],k___}]:= Module[{forward, reverse, odes,reaction},
reaction={RightArrowLeftArrow[X,Y],k};
{forward, reverse}=parseArrowForm/@expandArrows[reaction];
odes = Join[forward, reverse];
Return[odes];
]


expandArrows[{ShortRightArrow[X_,Y_ , Z__],rates___}]:= Module[{ reaction,reactants, k, nreactions,reactions, nrates},

reactants={X,Y,Z};
reaction={ShortRightArrow@@reactants,rates};
If[dbgArrows,Print["parseArrowForm:", reaction]];

reactions=Partition[reactants,2,1];
nreactions=Length[reactions];

k={rates};
If[Length[k]>nreactions,
 Print["Warning: Extra rate constants ", Drop[k,nreactions]," in the reaction ", reaction, " will be ignored."]; 
k=Take[k,nreactions]
];
k=PadRight[k,nreactions,1];
reactions=MapThread[{ShortRightArrow@@#1,#2}&,{reactions,k}];
Return[reactions];
]


parseArrowForm[{ShortRightArrow[X_,Y_ , Z__],rates___}]:= Module[{ odes,reactions},
reactions=expandArrows[{ShortRightArrow[X,Y, Z],rates}];
odes=Join@@(parseArrowForm/@reactions);
Return[odes];
]


expandArrows[{RightArrowLeftArrow[X_,Y_ , Z__],rates___}]:= Module[{ odes,reaction,reactants, k, nreactions,reactions, nrates},

reactants={X,Y,Z};
reaction={RightArrowLeftArrow@@reactants,rates};
If[dbgArrows,Print["expandArrows:", reaction]];

reactions=Partition[reactants,2,1];
nreactions=Length[reactions];

k={rates};
If[Length[k]>2*nreactions,
 Print["Warning: Extra rate constants ", Drop[k,2*nreactions]," in the reaction ", reaction, " will be ignored."]; 
k=Take[k,2*nreactions]
];
k=PadRight[k,2*nreactions,1];
k=Partition[k,2];
reactions=MapThread[{RightArrowLeftArrow@@#1,Sequence@@#2}&,{reactions,k}];
Return[reactions];
]


parseArrowForm[{RightArrowLeftArrow[X_,Y_ , Z__],rates___}]:= Module[{ odes,reaction,reactants, k, nreactions,reactions, nrates},
reactions=expandArrows[{RightArrowLeftArrow[X,Y , Z],rates}];
odes=Join@@(parseArrowForm/@reactions);
Return[odes];
]


expandArrows[{Overscript[ShortRightArrow[X_,Y_ ],Z_],rates___}]:= Module[{reaction,k},
reaction={Overscript[ShortRightArrow[X,Y],Z],rates};
If[dbgArrows,Print["expandArrows:", reaction]];

k={rates}//Flatten;
If[Length[k]<1, 
k=1, 
If[Length[k]>1, Print["Warning: Extra rate constants ", Drop[k,1]," in the reaction ", reaction, " will be ignored."]]; 
k=First[k]
]; 

reaction={ShortRightArrow[X+Z, Y+Z],k};
Return[{reaction}];
]


parseArrowForm[{Overscript[ShortRightArrow[X_,Y_ ],Z_],rates___}]:= Module[{ odes,reaction},
reaction=expandArrows[{Overscript[ShortRightArrow[X,Y],Z],rates}];
odes=parseArrowForm[reaction];
Return[odes];
]


expandArrows[{Overscript[ShortRightArrow[X_,Y_ , Z__],modifiers_],rates___}]:= 
Module[{ reaction,reactants, k, nreactions,reactions, nrates,modifierList,nmods,m1},

reactants={X,Y,Z};
reaction={Overscript[ShortRightArrow@@reactants,modifiers],rates};
If[dbgArrows,Print["expandArrows:", reaction]];
modifierList={modifiers}//Flatten;
If[Length[modifierList]<1, Print["Error: At least one modifier must be specified for:",reaction];
Return[{}]
];
reactions=Partition[reactants,2,1];
nreactions=Length[reactions];
nmod=Length[modifierList];
If[nmod>nreactions, Print["Warning: Extra modifiers ", Drop[modifierList,nreactions]," in the reation ", reaction," will be ignored."];
modifierList=Take[modifierList,nreactions];
];
m1=First[modifierList];
(* modifierList=PadRight[modifierList,nreactions, m1];*)
While[Length[modifierList]<nreactions, AppendTo[modifierList, m1]];

k={rates};
If[Length[k]>nreactions,
 Print["Warning: Extra rate constants ", Drop[k,nreactions]," in the reaction ", reaction, " will be ignored."]; 
k=Take[k,nreactions]
];
k=PadRight[k,nreactions,1];
reactions=MapThread[{Overscript[ShortRightArrow@@#1,#2],#3}&,{reactions,modifierList,k}];
reactions=expandArrows/@reactions;
Return[reactions];
]


parseArrowForm[{Overscript[ShortRightArrow[X_,Y_ , Z__],modifiers_],rates___}]:= 
Module[{ odes,reactions},
reactions=expandArrows[{Overscript[ShortRightArrow[X,Y, Z],modifiers],rates}];
odes=Join@@(parseArrowForm/@reactions);
Return[odes];
]


expandArrows[{Overscript[RightArrowLeftArrow[X_,Y_ ],En_],k___}]:= 
Module[{a,d,kf,kr,r1,r2,r3,r4, reactions, rates},
reaction={Overscript[RightArrowLeftArrow[X,Y],En],k};
If[dbgArrows,Print["expandArrows (single input):", reaction]];

rates={k}//Flatten;
While[Length[rates]<3, rates=Append[rates,1]];
While[Length[rates]<4, rates=Append[rates,0]];
If[Length[rates]>4, Print["Warning: the extra rate constants ",Drop[rates,4]," will be ignored in the reaction ",reaction];
]; 
rates=Take[rates,4];
{a,d,kf,kr}=rates;
If[dbgArrows,Print["expandArrows (single rates):", rates]];
If[dbgArrows,Print["expandArrows single (X, Length[X], Y, Length[Y]):",{X, Length[X], Y, Length[Y]}]];
If[dbgArrows,Print["expandArrows single (X, Length[X/.{Plus\[Rule] List}], Y, Length[Y/.{Plus\[Rule] List}]):",{X, Length[X/.{Plus-> List}], Y, Length[Y/.{Plus-> List}]}]];

If[Length[({X}//Flatten)/.{Plus-> List}]>1 \[Or] Length[({Y}//Flatten)/.{Plus-> List}]>1, 
Print["The reaction ",Overscript[RightArrowLeftArrow[X,Y],En]," is not correctly formatted: too many reactants or products."];
Return[{}];
];
r1={ShortRightArrow[X+En,setBinding[X,En]],a};
r2={ShortRightArrow[setBinding[X,En], X+En],d};
r3={ShortRightArrow[setBinding[X,En], Y+En],kf};
reactions={r1,r2,r3};
If[\[Not](kr===0),
r4={ShortRightArrow[Y+En,setBinding[X,En]],kr};
reactions=Append[reactions,r4];
]; 
If[dbgArrows,Print["expandArrows (single: return reactions):", reactions]];
Return[reactions];
];


parseArrowForm[{Overscript[RightArrowLeftArrow[X_,Y_ ],En_],k___}]:= 
Module[{reaction,reactions,odes},
reaction={Overscript[RightArrowLeftArrow[X,Y],En],k};
reactions = expandArrows[reaction];
odes =Join@@( parseArrowForm/@reactions);
Return[odes];
];


expandArrows[{Overscript[RightArrowLeftArrow[X_,Y_ , Z__],modifiers_],rates___}]:= 
Module[{ odes,reaction,reactants, k, nreactions,reactions, nrates,modifierList,nmods,m1,lastset},

reactants={X,Y,Z};
reaction={Overscript[RightArrowLeftArrow@@reactants,modifiers],rates};
If[dbgArrows,Print["expandArrows (cascade):", reaction]];

modifierList={modifiers}//Flatten;
If[dbgArrows,Print["expandArrows (cascade: modifierList):", modifierList]];
If[Length[modifierList]<1, Print["Error: At least one modifier must be specified for:",reaction];
Return[{}]
];
reactions=Partition[reactants,2,1];
nreactions=Length[reactions];
nmod=Length[modifierList];
If[nmod>nreactions, Print["Warning: Extra modifiers ", Drop[modifierList,nreactions]," in the reation ", reaction," will be ignored."];
modifierList=Take[modifierList,nreactions];
];
m1=Last[modifierList];
(* modifierList=PadRight[modifierList,nreactions, m1]; *)
While[Length[modifierList]<nreactions, AppendTo[modifierList, m1]];


If[dbgArrows,Print["expandArrows (cascade: modifierList):", modifierList]];


k={rates}//Flatten;
If[Length[k]==0, k={1,1,1,0}];
If[Length[k]<3, k=PadRight[k,3,1]];
If[Length[k]<4, k=PadRight[k,4,0]];
If[Length[k]>4*nreactions, k=Take[k,4*nreactions]]; 
If[Mod[Length[k],4]!= 0,
While[Mod[Length[k]+1,4]!= 0, k=Append[k,1]]; 
k=Append[k,0];
];
lastset=Take[k,-4];
While[Length[k]<4*nreactions,k=Join[k,lastset]];  
k=Flatten[k]; 


k = Partition[k,4];
reactions=MapThread[{Overscript[RightArrowLeftArrow@@#1,#2],Sequence@@#3}&,{reactions,modifierList,k}];
reactions=Join@@(expandArrows/@reactions);
Return[reactions];
]


parseArrowForm[{Overscript[RightArrowLeftArrow[X_,Y_ , Z__],modifiers_],rates___}]:= 
Module[{ odes,reaction,reactions},
reactants={X,Y,Z};
If[dbgArrows, Print["*** parseArrowForm (cascade): {reactants}:", {reactants}]];
reaction={Overscript[RightArrowLeftArrow@@reactants,modifiers],rates};
If[dbgArrows, Print["*** parseArrowForm (cascade): {reaction}:", {reaction}]];
reactions=expandArrows[reaction];
If[dbgArrows, Print["*** parseArrowForm (cascade): {reactions}:", {reactions}]];
odes=Join@@(parseArrowForm/@reactions);
Return[odes];
]


expandArrows[{Underoverscript[RightArrowLeftArrow[X_,Y_ ],Rev_,Fwd_],k___}]:= 
Module[{nk,nrk,k1,k2,r1,r2, reactions,rates,reaction,nrates,
defrates={1,1,1,0,1,1,1,0}}, 
reaction={Underoverscript[RightArrowLeftArrow[X,Y],Rev,Fwd],k};
If[dbgArrows,Print["expandArrows:", reaction]];

rates=Flatten[{k}];
nk=Length[Flatten[rates]];

If[!(nk==6 \[Or]nk==8),
nrates=Take[rates,Min[8,nk]];
nrk=Length[nrates];
If[nrk<8, nrates=Join[nrates,Drop[defrates,nrk]]]; 

Print["Unable to unambiguously parse the rate constants in the reaction :",{ Underoverscript[RightArrowLeftArrow[X,Y],Rev,Fwd],Sequence@@rates}," ", nk, " rates were found; the number of rates should be either 6 or 8; the following values were used instead: ",{ Underoverscript[RightArrowLeftArrow[X,Y],Rev,Fwd],Sequence@@nrates}];
rates=nrates;
nk=Length[rates];
];
k1=Take[rates, nk/2];
k2=Drop[rates,nk/2];

r1={Overscript[RightArrowLeftArrow[X,Y],Fwd],Sequence@@k1};
r2={Overscript[RightArrowLeftArrow[Y,X],Rev],Sequence@@k2};

reactions=Join@@expandArrows/@{r1,r2};

Return[reactions];
];


parseArrowForm[{Underoverscript[RightArrowLeftArrow[X_,Y_ ],Rev_,Fwd_],k___}]:= 
Module[{nk,nrk,k1,k2,r1,r2, odes,rates,reaction,nrates,
defrates={1,1,1,0,1,1,1,0}}, 
reaction={Underoverscript[RightArrowLeftArrow[X,Y],Rev,Fwd],k};
reactions=expandArrows[reaction];
odes = Join@@parseArrowForm/@reactions;
Return[odes];
];


expandArrows[{Underoverscript[RightArrowLeftArrow[X_,Y_ , Z__],bottomModifiers_,topModifiers_],rates___}]:= 
Module[{ reaction,reactants, k, nreactions,reactions, nrates,bottommodifierList,topmodifierList,nmod,lastset,m1, dbg=False, dPrint},

dPrint[x___]:= If[dbg, Print["expandArrows: ", x]]; 

reactants={X,Y,Z};
reaction={Underoverscript[RightArrowLeftArrow@@reactants,bottomModifiers,topModifiers],rates};
If[dbgArrows,Print["expandArrows (cascade):", reaction]];
topmodifierList={topModifiers}//Flatten;
bottommodifierList={bottomModifiers}//Flatten;
dPrint["top:", topmodifierList]; 
dPrint["bottom:", bottommodifierList]; 
If[Length[topmodifierList]<1, Print["Error: At least one forward modifier must be specified for:",reaction];
Return[{}]
];
If[Length[bottommodifierList]<1, Print["Error: At least one reverse modifier must be specified for:",reaction];
Return[{}]
];
reactions=Partition[reactants,2,1];
nreactions=Length[reactions];
nmod=Length[topmodifierList];
If[nmod>nreactions, Print["Warning: Extra modifiers ", Drop[topmodifierList,nreactions]," in the reation ", reaction," will be ignored."];
topmodifierList=Take[topmodifierList,nreactions];
];
nmod=Length[bottommodifierList];
If[nmod>nreactions, Print["Warning: Extra modifiers ", Drop[bottommodifierList,nreactions]," in the reation ", reaction," will be ignored."];
bottommodifierList=Take[bottommodifierList,nreactions];
];
dPrint["nmod: ", nmod]; 

m1=Last[bottommodifierList];
dPrint["m1 (bottom):", m1]; 

(* bottommodifierList=PadRight[bottommodifierList,nreactions, m1];*)
While[Length[bottommodifierList]<nreactions, AppendTo[bottommodifierList, m1]];
dPrint["bottom: ", bottommodifierList]; 

m1=Last[topmodifierList];
dPrint["m1 (top):", m1]; 
(* topmodifierList=PadRight[topmodifierList,nreactions, m1]; *)
While[Length[topmodifierList]<nreactions, AppendTo[topmodifierList, m1]];
dPrint["top: ", topmodifierList]; 

k={rates};
If[Length[k]==0, k={1,1,1,0,1,1,1,0}]; 
If[Length[k]==6, k=Join[Take[k,3],{0}, Take[k,-3],{0}]]; 
If[Length[k]<3, k=PadRight[k,3,1]]; 
If[Length[k]<4, k=PadRight[k,4,0]];
If[Length[k]<7, k=PadRight[k,7,1]];
If[Length[k]<8, k=PadRight[k,8,0]];

If[Mod[Length[k],6]==0 \[And] Length[k]!= 8*nreactions, 
If[Mod[Length[k],8]==0,
Print["Warning: unable to unambiguously parse the rates constants for ", reaction];
]; 
If[Length[k]>6*nreactions, k=Take[k, 6*nreactions]]; 

lastset=Take[k,-6];
While[Length[k]<6*nreactions, k=Join[k,lastset]]; 
k=Flatten[k];
k=Partition[k,3];
k=Map[Append[#,0]&,k]//Flatten;
,
If[Mod[Length[k],8]==0, 


If[Length[k]>8*nreactions, k=Take[k,8*nreactions]]; 
lastset=Take[k,-8];
While[Length[k]<8*nreactions,k=Join[k,lastset]]; 
k=Flatten[k];
,
Print["Warning: unable to unambiguously parse the rate constsnt for ", reaction]; 
If[Length[k]>8*nreactions,k=Take[k,8*nreactions]]; 
k=PadRight[k,8*nreactions];
];
]; 



k = Partition[k,8];
dPrint["k=",k ]; 

(* the following line revised 0.74 to remove application of Sequence@@ to #2 and #3 which was a bug*)

reactions=MapThread[{Underoverscript[RightArrowLeftArrow@@#1,#2, #3], Sequence@@#4}&,{reactions,bottommodifierList,topmodifierList,k}];

dPrint["reactions: ", reactions]; 

reactions=Join@@expandArrows/@reactions;
Return[reactions];
]


parseArrowForm[{Underoverscript[RightArrowLeftArrow[X_,Y_ , Z__],bottomModifiers_,topModifiers_],rates___}]:= 
Module[{ odes,reaction,reactants, reactions},

reactants={X,Y,Z};reaction={Underoverscript[RightArrowLeftArrow@@reactants,bottomModifiers,topModifiers],rates};
reactions = expandArrows[reaction];
odes=Join@@(parseArrowForm/@reactions);
Return[odes];
]


expandArrows[{Overscript[Equilibrium[X_,Y_ ],En_],k___}]:= 
Module[{a,d,kf,kr,r1,r2,r3, reactions, rates,nrates, XEN, YEN},
reaction={Overscript[Equilibrium[X,Y],En],k};
If[dbgArrows,Print["expandArrows:", reaction]];

rates={k}//Flatten;
nrates=Length[rates];
If[nrates<6, Print["Missing rate constants in the reaction ", reaction," set to a value of 1"]]; 
If[Length[rates]>6,
Print["The extra rate constants ",Drop[rates,6]," in the reaction ", reaction, " will be ignored."];
];
rates=PadRight[rates,6,1];
rates=Take[rates,6];
{a,d,k1,k2, kf,kr}=rates;

If[Length[X/.{Plus-> List}]>1 \[Or] Length[Y/.{Plus-> List}]>1, 
Print["The reaction ",Overscript[Equilibrium[X,Y],En]," is not correctly formatted: too many reactants or products."];
Return[{}];
];

XEN=setBinding[X, En];
YEN=setBinding[Y,En];

r1={RightArrowLeftArrow[X+En,XEN],a,d};
r2={RightArrowLeftArrow[XEN, YEN],k1,k2};
r3={RightArrowLeftArrow[YEN, Y+En],kf,kr};

reactions=Join@@(expandArrows/@{r1,r2,r3});
Return[reactions];
];


parseArrowForm[{Overscript[Equilibrium[X_,Y_ ],En_],k___}]:= 
Module[{reaction, odes},
reaction={Overscript[Equilibrium[X,Y],En],k};
odes = Join@@(parseArrowForm/@expandArrows[reaction]);
Return[odes];
];


expandArrows[{Overscript[Equilibrium[X_,Y_ , Z__],modifiers_],rates___}]:= 
Module[{ odes,reaction,reactants, k, nreactions,reactions, nrates,modifierList,nmods,m1},

reactants={X,Y,Z};
reaction={Overscript[Equilibrium@@reactants,modifiers],rates};
If[dbgArrows,Print["expandArrows:", reaction]];
modifierList={modifiers}//Flatten;
If[Length[modifierList]<1, Print["Error: At least one modifier must be specified for:",reaction];
Return[{}]
];
reactions=Partition[reactants,2,1];
nreactions=Length[reactions];
nmod=Length[modifierList];
If[nmod>nreactions, Print["Warning: Extra modifiers ", Drop[modifierList,nreactions]," in the reation ", reaction," will be ignored."];
modifierList=Take[modifierList,nreactions];
];
m1=Last[modifierList];
(* modifierList=PadRight[modifierList,nreactions, m1];*)
While[Length[modifierList]<nreactions, AppendTo[modifierList, m1]];


k={rates};

k={rates}//Flatten;

If[Length[k]==0, 
Print["Warning: missing rate constants in the reaction ",reaction, " set to default values."]; 
k={1,1,1,1,1,1}]; 
If[Length[k]>6*nreactions,
Print["Warning: the extra rate constants ",Drop[k,6*nreactions]," in the reaction ",reaction," will be ignored."];
k=Take[k,6*nreactions];
];

If[Mod[Length[k],6]!= 0,
Print["Warning: Only ",Length[k]," or the required ",6*nreactions," rate constants found for the reaction ", reaction, " Default assumptions will be applied to determine the missing rates."];
While[Mod[Length[k],6]!= 0, k=Append[k,1]]; 
];
If[Length[k]<6*nreactions,
last6=Take[k,-6];
While[Length[k]<6*nreactions, k=Join[k,last6]]; 
];
k=Partition[Flatten[k],6];
reactions=MapThread[{Overscript[Equilibrium@@#1,#2],Sequence@@#3}&,{reactions,modifierList,k}];
reactions=Join@@(expandArrows/@reactions);
Return[reactions];
]


parseArrowForm[{Overscript[Equilibrium[X_,Y_ , Z__],modifiers_],rates___}]:= 
Module[{ odes,reaction,reactions},

reactants={X,Y,Z};
reaction={Overscript[Equilibrium@@reactants,modifiers],rates};
reactions = expandArrows[reaction];
odes=Join@@(parseArrowForm/@reactions);
Return[odes];
]


expandArrows[{Rule[x_,y_], rates___}]:= 
Module[{r, reactants, products},

reactants  = ListToSum[x]; 
products  = ListToSum[y]; 

r=Rule[reactants,products];
r=ShortRightArrow@@((r/.{Rule-> List})//Flatten);
r=expandArrows[{r,rates}];
Return[r];
]


parseArrowForm[{Rule[x_,y_],rates___}]:= 
Module[{r, reactants, products},
reactants  = ListToSum[x]; 
products  = ListToSum[y]; 

r=Rule[reactants,products];
r=ShortRightArrow@@((r/.{Rule-> List})//Flatten);
r=parseArrowForm[{r,rates}];
Return[r];
]


expandArrows[{Overscript[Rule[x_,y_], z_], rates___}]:= 
Module[{r, reactants, products},
reactants  = ListToSum[x]; 
products  = ListToSum[y]; 

r=Rule[reactants,products];
r=ShortRightArrow@@((r/.{Rule-> List})//Flatten);
r=expandArrows[{Overscript[r,z],rates}];
Return[r];
]


parseArrowForm[{Overscript[Rule[x_,y_],z_],rates___}]:= 
Module[{r, reactants, products},
reactants  = ListToSum[x]; 
products  = ListToSum[y]; 

r=Rule[reactants,products];
r=ShortRightArrow@@((r/.{Rule-> List})//Flatten);
r=parseArrowForm[{Overscript[r,z],rates}];
Return[r];
]


expandArrows[{DoubleLongRightArrow[X_,Y_ ],MM[KD_:1,v_:1]}]:= 
Module[{odes,rateLaw},
reaction={DoubleLongRightArrow[X,Y],MM[KD,v]};
If[dbgArrows,Print["expandArrows:", reaction]];
Return[{reaction}];
];


parseArrowForm[{DoubleLongRightArrow[X_,Y_ ],MM[KD_:1,v_:1]}]:= 
Module[{odes,rateLaw},
reaction={Overscript[DoubleLongRightArrow[X,Y],En],MM[KD,v]};
If[dbgArrows,Print["parseArrowForm:", reaction]];

rateLaw=v*X[Global`t]/(KD+X[Global`t]);
rateLaw=rateLaw/.{Global`\[EmptySet][Global`t]-> 0};

odes={{X[Global`t],-rateLaw},{Y[Global`t], rateLaw}};
Return[odes];
];


expandArrows[{Overscript[DoubleLongRightArrow[X_,Y_ ],En_],MM[KD_:1,v_:1]}]:= 
Module[{reaction},
reaction={Overscript[DoubleLongRightArrow[X,Y],En],MM[KD,v]};
If[dbgArrows,Print["expandArrows:", reaction]];
Return[{reaction}];
];


parseArrowForm[{Overscript[DoubleLongRightArrow[X_,Y_ ],En_],MM[KD_:1,v_:1]}]:= 
Module[{odes,rateLaw},
reaction={Overscript[DoubleLongRightArrow[X,Y],En],MM[KD,v]};
If[dbgArrows,Print["parseArrowForm:", reaction]];

rateLaw=v*X[Global`t]En[Global`t]/(KD+X[Global`t]);
rateLaw=rateLaw/.{Global`\[EmptySet][Global`t]-> 0};

odes={{X[Global`t],-rateLaw},{Y[Global`t], rateLaw}, {En[Global`t],0}};
Return[odes];
];


expandArrows[{Overscript[DoubleLongRightArrow[X_,Y_ ],En_],MM[k1_,k2_, k3_]}]:= 
Module[{reaction},
reaction=expandArrows[{Overscript[DoubleLongRightArrow[X,Y],En],MM[(k2+k3)/k1, k3]}];
Return[reaction];
];


parseArrowForm[{Overscript[DoubleLongRightArrow[X_,Y_ ],En_],MM[k1_,k2_, k3_]}]:= 
Module[{odes},
odes=parseArrowForm[{Overscript[DoubleLongRightArrow[X,Y],En],MM[(k2+k3)/k1, k3]}];
Return[odes];
];


expandArrows[{DoubleLongLeftRightArrow[X_,Y_ ],MM[k___]}]:= 
Module[{reactions ,r1,r2, rates, reaction,K1,K2,v1,v2},
rates={k}//Flatten;
reaction={DoubleLongLeftRightArrow[X,Y],MM[Sequence@@rates]};
If[Length[rates]>4, Print["The extra rates ",Drop[rates,4]," in the reaction ", reaction, " will be ignored."]];

While[Length[rates]<4, rates=Append[rates,1]];
rates=Take[rates,4];
{K1,v1,K2,v2}=rates;


r1={DoubleLongRightArrow[X,Y],MM[K1,v1]};
r2={DoubleLongRightArrow[Y,X],MM[K2,v2]};

reactions={r1,r2};
Return[reactions];
];


parseArrowForm[{DoubleLongLeftRightArrow[X_,Y_ ],MM[k___]}]:= 
Module[{odes ,rates, reaction,reactions},
rates={k}//Flatten;
reaction={DoubleLongLeftRightArrow[X,Y],MM[Sequence@@rates]};
reactions=expandArrows[reaction];
odes=Join@@(parseArrowForm/@reactions);
Return[odes];
];


expandArrows[{Underoverscript[DoubleLongLeftRightArrow[X_,Y_ ],REn_,FEn_],MM[k___]}]:= 
Module[{ r1,r2,rates, reaction, kf, kr,n, reactions},
rates=Flatten[{k}];
reaction={Underoverscript[DoubleLongLeftRightArrow[X,Y],REn,FEn], MM@@rates};
n=Length[rates];
Switch[n,
4,
kf=Take[rates,2];
kr=Drop[rates,2];
,
6,
kf=Take[rates,3];
kr=Drop[rates,3];
,
_
, 
Print["The reaction ",reaction," should have precisely 4 or 6 rate constants."]; 
Return[{}];
];

r1={Overscript[DoubleLongRightArrow[X,Y],FEn], MM@@kf};
r2={Overscript[DoubleLongRightArrow[Y,X],REn],MM@@kr};
reactions={r1,r2};
Return[reactions];
];


parseArrowForm[{Underoverscript[DoubleLongLeftRightArrow[X_,Y_ ],REn_,FEn_],MM[k___]}]:= 
Module[{odes ,rates, reaction,reactions},
rates=Flatten[{k}];
reaction={Underoverscript[DoubleLongLeftRightArrow[X,Y],REn,FEn], MM@@rates};
reactions = expandArrows[reaction];
odes=Join@@(parseArrowForm/@reactions);
Return[odes];
];


expandArrows[{DoubleLongRightArrow[X_,Y_ ,Z__],MM[rates___]}]:= Module[{reactants, reactions,nreactions,k,reaction,default},
reaction = {DoubleLongRightArrow[X,Y,Z],MM[rates]};
reactants={X,Y,Z};
reactions=Partition[reactants,2,1];
nreactions=Length[reactions];
nreactants=Length[reactants];
reactions=DoubleLongRightArrow@@#&/@reactions;
k={rates}//Flatten;
Switch[Length[k],
0,
k=Table[{},{nreactions}],
2,
default=k;
While[Length[k]<2*nreactions,k=Join[k,default]];
k=Partition[k,2];
,
2*nreactions,k=Partition[k,2],
_,
If[Length[k]<2*nreactions,
Print["Error: Some (possibly incorrect) assumptions were made to determine the missing rate constants in the reaction ", reaction];
If[OddQ[Length[k]],k=Append[k,1]];
default=Take[k,-2];
While[Length[k]<2*nreactions,k=Join[k,default]];
,
Print["Error: extra rate constants ",Drop[k,2*nreactions]," ignored in the reaction ",reaction];
k=Take[k,2*nreactions];
];
k=Partition[k,2];
];
reactions=MapThread[{#1,MM@@#2}&,{reactions,k}];
Return[reactions];
]


parseArrowForm[{DoubleLongRightArrow[X_,Y_ ,Z__],MM[rates___]}]:= Module[{ reactions,reaction,odes},
reaction = {DoubleLongRightArrow[X,Y,Z],MM[rates]};
reactions=expandArrows[reaction];
odes=Join@@(parseArrowForm/@reactions);
Return[odes];
];


expandArrows[{Overscript[DoubleLongRightArrow[X_,Y_ ,Z__],\[ScriptCapitalE]_], MM[rates___]}]:= Module[{reactants, reactions,nreactions,k,reaction,default,modifiers},
reaction = {Overscript[DoubleLongRightArrow[X,Y,Z],\[ScriptCapitalE]],MM[rates]};
reactants={X,Y,Z};
reactions=Partition[reactants,2,1];
nreactions=Length[reactions];
nreactants=Length[reactants];
reactions=DoubleLongRightArrow@@#&/@reactions;
modifiers={\[ScriptCapitalE]}//Flatten;
default=Last[modifiers];
If[Length[modifiers]>nreactions, Print["Warning: excess modifiers ",Drop[modifiers,nreactions]," ignored in the reaction ",reaction]];
modifiers=PadRight[modifiers,nreactions,default];
modifiers=Take[modifiers,nreactions];
reactions = MapThread[Overscript,{reactions,modifiers}];

k={rates}//Flatten;
Switch[Length[k],
0,k=Table[{},{nreactions}],

2,
default=k;
While[Length[k]<2*nreactions,k=Join[k,default]];
k=Partition[k,2];
,

3,
default=k;
While[Length[k]<3*nreactions,k=Join[k,default]];
k=Partition[k,3];
,

2*nreactions,k=Partition[k,2],


3*nreactions,k=Partition[k,3],

_,

Print["Warning: Unable to unambiguously parse the rate constants in the reaction ", reaction];

If[Length[k]<2*nreactions,
If[OddQ[Length[k]],k=Append[k,1]];
default=Take[k,-2];
While[Length[k]<2*nreactions,k=Join[k,default]];
,
k=Take[k,2*nreactions];
];



k=Partition[k,2];
];
reactions=MapThread[{#1,MM@@#2}&,{reactions,k}];
Return[reactions];
]


parseArrowForm[{Overscript[DoubleLongRightArrow[X_,Y_ ,Z__],\[ScriptCapitalE]_], MM[rates___]}]:= Module[{ reactions,reaction,odes},
reaction = {Overscript[DoubleLongRightArrow[X,Y,Z],\[ScriptCapitalE]],MM[rates]};

reactions = expandArrows[reaction];
odes=Join@@( parseArrowForm/@reactions);
Return[odes];

];



expandArrows[{Overscript[RightTeeArrow[X_,Y_ ],En_],hill[v_:1,K_:1,n_:1,r_:0,m_:1]}]:= 
Module[{reaction},
reaction={Overscript[RightTeeArrow[X,Y],En],hill[v,K,n,r,m]};
If[dbgArrows,Print["expandArrows:", reaction]];
Return[{reaction}];
];




parseArrowForm[{Overscript[RightTeeArrow[Times[X_,X1__],Y_ ],En_],hill[v_:1,k_:1,n_:1,r_:0,m_:1]}]:= 
Module[{odes,rateLaw, x, vars},
reaction={Overscript[RightTeeArrow[Times[X],Y],En],hill[v,k,n,r,m]};
If[dbgArrows,Print["parseArrowForm:", reaction]];

vars=Times[X,X1]/.{Times-> List}//Flatten;
vars=(#[Global`t]&)/@vars;
x=Times@@vars;

rateLaw=m* hillFunction[x,k, n,v*En[Global`t],r];

rateLaw=rateLaw/.{Global`\[EmptySet][Global`t]-> 0};

odes = Join[{#,-rateLaw}&/@vars,{{Y[Global`t], rateLaw}, {En[Global`t],0}}];

Return[odes];
];

parseArrowForm[{Overscript[RightTeeArrow[Plus[X_,X1__],Y_ ],En_],hill[v_:1,k_:1,n_:1,r_:0,m_:1]}]:= 
Module[{odes,rateLaw, vars,x},
reaction={Overscript[RightTeeArrow[Plus[X],Y],En],hill[v,k,n,r,m]};
If[dbgArrows,Print["parseArrowForm:", reaction]];
vars={X,X1}//Flatten;
odes = parseArrowForm[{Overscript[RightTeeArrow[vars,Y],En],hill[v,k,n,r,m]}];
Return[odes];
];

parseArrowForm[{Overscript[RightTeeArrow[X_,Y_ ],En_],hill[v_:1,k_:1,n_:1,r_:0,m_:1]}]:= 
Module[{odes,rateLaw, vars,x},
reaction={Overscript[RightTeeArrow[X,Y],En],hill[v,k,n,r,m]};
If[dbgArrows,Print["parseArrowForm:", reaction]];

vars={X}//Flatten;
vars=(#[Global`t]&)/@vars;
x=Plus@@vars;

rateLaw=m*hillFunction[x,k, n,v*En[Global`t],r];
rateLaw=rateLaw/.{Global`\[EmptySet][Global`t]-> 0};

odes = Join[{#,-rateLaw}&/@vars,{{Y[Global`t], rateLaw}, {En[Global`t],0}}];
Return[odes];
];



expandArrows[{RightTeeArrow[X_,Y_ ],hill[v_:1,K_:1,n_:1,r_:0,m_:1]}]:= 
Module[{reaction},
reaction={RightTeeArrow[X,Y],hill[v,K,n,r,m]};
If[dbgArrows,Print["expandArrows:", reaction]];
Return[{reaction}];
];
expandArrows[{RightTeeArrow[Plus[X_,X1__],Y_ ],hill[v_:1,K_:1,n_:1,r_:0,m_:1]}]:= 
Module[{reaction,vars},
vars={X,X1}//Flatten;
reaction={RightTeeArrow[vars,Y],hill[v,K,n,r,m]};
If[dbgArrows,Print["expandArrows:", reaction]];
Return[{reaction}];
];



parseArrowForm[{RightTeeArrow[Plus[X_,X1__],Y_ ],hill[v_:1,k_:1,n_:1,r_:0,m_:1]}]:= 
Module[{odes,rateLaw, vars,x, reaction},

reaction={RightTeeArrow[Plus[X],Y],hill[v,k,n,r,m]};
If[dbgArrows,Print["parseArrowForm:", reaction]];
vars={X,X1}//Flatten;
odes = parseArrowForm[{RightTeeArrow[vars,Y],hill[v,k,n,r,m]}];
Return[odes];
];

parseArrowForm[{RightTeeArrow[X_,Y_ ],hill[v_:1,k_:1,n_:1,r_:0,mult_:1]}]:= 
Module[{odes,rateLaw, vars,x,nvars,V, K,nn,rr,multiplier, reaction},
reaction={RightTeeArrow[X,Y],hill[v,k,n,r]};
If[dbgArrows,Print["parseArrowForm:", reaction]];

vars={X}//Flatten;
vars=(#[Global`t]&)/@vars;
nvars=Length[vars];
V=getnValues[nvars,v,"Hill rates",reaction];
K=getSingleValue[k,1,"Hill constants", reaction];
nn=getSingleValue[n,1,"Hill exponents",reaction];
rr=getSingleValue[r,0,"Basal rate", reaction];
multiplier=getSingleValue[mult,1,"multiplier",reaction];

x=rr+Plus@@(V*vars);

rateLaw=multiplier*hillFunction[x,K, nn,1,0];
rateLaw=rateLaw/.{Global`\[EmptySet][Global`t]-> 0};

If[SameQ[Y,Global`\[EmptySet]], 
odes=Map[{#,-rateLaw}&,vars]; 
,
odes = {{Y[Global`t], rateLaw}};
];
Return[odes];
];
parseArrowForm[{RightTeeArrow[X_,Y_ ],{hill[z___]}}]:= parseArrowForm[{RightTeeArrow[X,Y],hill[z]}];



hill[opt___?OptionQ]:= Module[{v,K,n,r,m,ret, 
incorrect, allow},

v=vmax/.{opt}/.Options[hill];
K=khalf/.{opt}/.Options[hill];
n=nhill/.{opt}/.Options[hill];
r=basalRate/.{opt}/.Options[hill];
m=Thill/.{opt}/.Options[hill];
ret=hill[v,K,n,r,m];

incorrect= Complement[First/@{opt},First/@ Options[hill]];
Print["Warning: hill[...] unknown option ", # -> (#/.{opt}), " ignored."]&/@incorrect; 

Return[ret];
];


Hill[x___]:=hill[x];


hillListQ[{h__}]:=SameQ[Union[Head/@{h}],{hill}];
hillListQ[x___]:= False;

GRNListQ[{h__}]:=SameQ[Union[Head/@{h}],{GRN}];
GRNListQ[x___]:= False;

NHCAListQ[{h__}]:=SameQ[Union[Head/@{h}],{NHCA}];
NHCAListQ[x___]:= False;

SSystemListQ[{h__}]:=SameQ[Union[Head/@{h}],{SSystem}];
SSystemListQ[x___]:= False;

listTypes[{h__}]:= Union[Head/@h];




regulatoryQ[{RightTeeArrow[A_,B_],r___}]:= True;
regulatoryQ[x___]:= False;
massActionQ[ShortRightArrow[A_,B_], r___]:= True;
massActionQ[x___]:= False;
regulatoryProduct[{RightTeeArrow[A_,B_],r___}]:= B;
regulatoryProduct[x___]:= {};
regulatorOf[{RightTeeArrow[A_,B_],r___}]:= A;
regulatorOf[x___]:= {};


combineRegulatoryReactions[r_]:= Module[{reg,deg,nonreg,prods,products,dbg=False, reacts,meths, consolidate, dPrint},

dPrint[x___]:= If[dbg, Print["combineRegulatoryReactions: ", x]]; 

consolidate[{reaction_, controls___}]:= Module[{dbg=False,n,heads,firsthead,unheads,nheads,ok,consolidated,
consolidateHill, consolidateUser, consolidateSSystem,consolidateNHCA},

consolidateNHCA[pars_]:= Module[{args,v,T,n,m,k},

(* NHCA will always have 5 arguments SSystem[v,T,n,m,k], *)
(* as a result of preprocessing. *)

args = functionArguments/@pars;
args = Transpose[args];
{v,T,n,m,k}=args;
If[Length[Union[v]]>1, 
Print["Warning: NHCA reactions with different v: reaction: ",reaction," v:",v]];
If[Length[Union[m]]>1, 
Print["Warning: NHCA reactions with different m: reaction: ", reaction," m:",m]];
If[Length[Union[k]]>1, 
Print["Warning: NHCA reactions with different k: reaction: ",reaction," k:",k]];

v=First[v];
m=First[m];
k=First[k];
args = {v,T,n,m,k};
Return[NHCA@@args];
];(* end consolidateNHCA *) 


consolidateSSystem[pars_]:= Module[{args,theTau, theKp,theKm,theCp,theCm},

(* SSystem will always have four arguments SSystem[tau,kplus,kminus,cplus,cminus], *)
(* as a result of preprocessing. *)

args = functionArguments/@pars;
args = Transpose[args];
{theTau,theKp,theKm, theCp, theCm}=args;
theTau=First[theTau];
theKm=First[theKm];
theKp=First[theKp];
args = {theTau,theKp,theKm, theCp, theCm};
Return[SSystem@@args];
];(* end consolidateSSystem *) 


consolidateHill[pars_]:= Module[{args,v,rest},

(* hill will always have four arguments hill[v,K,n,r], *)
(* as a result of preprocessing. *)
(* except for v, only the first is used *)

args = functionArguments/@pars;
v=First/@args;
rest = Rest[First[args]];
Return[hill[v,Sequence@@rest]];
];(* end consolidateHill *) 

consolidateUser[pars_]:= Module[{args,
nargs,v, T, n,h, f,name,rval, dbg=False},

(* user should  always have five arguments user[r,T,n,h,f], *)
(* This should be handled in the preprocessing *) 
(* r, T, n can vary from one to another *)
(* h and f must be the same *)

If[dbg, Print["consolidateUser: pars=",pars]];
name=((Head/@pars)//Union )//First;
args = functionArguments/@pars;
nargs=Union[Length/@args];
If[Length[nargs]>1 \[Or] (Length[nargs]==1 \[And] nargs[[1]]!= 5),
Print["Error: all user defined regulator rates should have five arguments: user[r,T,n,h,f], not ", Union[pars]];
];

If[dbg,Print["consolidateUser: args=",args]];
{v,T,n,h,f}=Transpose[args];
If[dbg, Print["v=",v,"\nT=",T,"\nn=",n,"\nh=",h,"\nf=",f]];
h=Union[h];

If[Length[h]>1, Print["Error: can not combine user reactions ",name,"  with different thresholds: ", h, " unable to unambiguaously determine which threshold to use. The value ", First[h], " was assumed." ];
];
h=First[h];

f=Union[f];
If[Length[f]>1, Print["Error: can not combine user reactions ",name,"  with different rate functions: ", f, " unable to unambiguaously determine which function to use. The function ",First[f], " was assumed." ];
];
f=First[f];


rval  =name[v, T, n, h, f];
If[dbg, Print["consolidateUser: rval=",rval]];
Return[rval];


];(* end consolidateUser *) 

(* begin main code for consolidate *)
n=Length[controls];
If[dbg, Print[reaction," : ",controls," n=",n]]; 
If[n<= 1, Return[{reaction,controls}]];
heads=Head/@controls;
firsthead=First[heads];
unheads=Union[heads];
nheads=Length[unheads];
If[nheads>1, Print["Error: different regulatory methods cannot be mixed for a single product: Reaction: ",reaction," Regulatory controls: ",controls," assumed: ",firsthead];
ok = Select[controls,SameQ[firsthead,Head[#]]&];,
ok=controls;
];
Switch[firsthead,
hill,
consolidated={reaction,consolidateHill[ok]};
,
SSystem,
consolidated= {reaction, consolidateSSystem[ok]};
,
NHCA,
consolidated= {reaction, consolidateNHCA[ok]};
,
_, 

consolidated={reaction,consolidateUser[ok]};

]; 

If[dbg, Print["consolidated---->",consolidated]];
Return[consolidated];
]; (* end consolidate *) 

consolidate[errorInput_]:= Module[{},
Print["Error: combineRegulators: ",errorInput];
Return[errorInput];
]; (* end errorInput consolidate *)

(* main code combineRegulatorityReactions *)

dPrint["r: ", r]; 

reg=Cases[r,{RightTeeArrow[_,_],_}];
(* allow degradation to be treated separately *) 
deg = Cases[r,{RightTeeArrow[_,Global`\[EmptySet]],_}];
reg=Complement[reg,deg]; 

dPrint["reg reactions:",reg];
dPrint["deg reactions:",deg];

(* Can't use Complement becasue that removes duplicates, which we want to keep! *)
(* nonreg=Complement[r,reg]; *)
(* revised v0 .75 *)
nonreg = Select[r, !MemberQ[reg, #]&]; 
dPrint["nonreg: ", nonreg]; 

prods = regulatoryProduct/@reg;
dPrint["prods:",prods];
products=Union[prods];
dPrint["products:",products];
reacts=Map[Cases[reg,{RightTeeArrow[_,#],_}]&,products];
dPrint["reactions:\n",reacts];
meths=Map[Last,#]&/@reacts;

drint["meths:",meths];
reacts=Map[regulatorOf,#]&/@reacts;
dPrint["regulators:",reacts];

reacts=MapThread[{RightTeeArrow[#1,#2],#3}&,{reacts,products,meths}];
drint["reactions: ",reacts];
reacts=consolidate/@reacts;

reacts=Join[nonreg,reacts]; 
 Return[reacts]; 

];


expandArrows[{RightTeeArrow[X_,Y_ ],GRN[r_:1, T_:1, n_:1, h_:0]}]:= 
Module[{reaction},
reaction={RightTeeArrow[X,Y],GRN[r, T, n, h,sigmoid]};
If[dbgArrows,Print["expandArrows:", reaction]];
Return[{reaction}];
];
expandArrows[{RightTeeArrow[Plus[X_,X1__],Y_ ],GRN[r_:1, T_:1,n_:1, h_:0]}]:= 
Module[{reaction,vars},
vars={X,X1}//Flatten;
reaction={RightTeeArrow[vars,Y],GRN[r,T,n,h]};
If[dbgArrows,Print["expandArrows:", reaction]];
Return[{reaction}];
];



parseArrowForm[{RightTeeArrow[Plus[X_,X1__],Y_ ],GRN[r_:1, T_:1, n_:1, h_:0]}]:= 
Module[{odes, vars, reaction},

reaction={RightTeeArrow[Plus[X],Y],GRN[r,T,n,h]};
If[dbgArrows,Print["parseArrowForm:", reaction]];
vars={X,X1}//Flatten;
odes = parseArrowForm[{RightTeeArrow[vars,Y],GRN[r,T,n,h]}];
Return[odes];
];

parseArrowForm[{RightTeeArrow[X_,Y_ ],GRN[r_:1, T_:1, n_:1, h_:0]}]:= 
Module[{reaction},
reaction={RightTeeArrow[X,Y],GRN[r, T, n, h, sigmoid]};

Return[parseArrowForm[reaction]];
];
parseArrowForm[{RightTeeArrow[X_,Y_ ],{GRN[z___]}}]:= parseArrowForm[{RightTeeArrow[X,Y],GRN[z]}];



GRN[opt___?OptionQ]:= Module[{r, T, n, h,ret, f, incorrect},
r=RGRN/.{opt}/.Options[GRN];
T=TGRN/.{opt}/.Options[GRN];
n=nGRN/.{opt}/.Options[GRN];
h=hGRN/.{opt}/.Options[GRN];
f=Sigmoid/.{opt}/.Options[GRN];
If[SameQ[f,sigmoid], 
ret=GRN[r, T, n, h],
ret=GRN[r, T, n, h, f]
]; 
incorrect= Complement[First/@{opt},First/@ Options[GRN]];
Print["Warning: GRN[...] unknown option ", # -> (#/.{opt}), " ignored."]&/@incorrect;
Return[ret];
];


grn[x___]:=GRN[x];


expandArrows[{RightTeeArrow[X_,Y_ ],SSystem[tau_, kplus_, kminus_, cplus_, cminus_]}]:= 
Module[{reaction},
reaction={RightTeeArrow[X,Y],SSystem[tau, kplus, kminus, cplus, cminus]};
If[dbgArrows,Print["expandArrows:", reaction]];
Return[{reaction}];
];
expandArrows[{RightTeeArrow[Plus[X_,X1__],Y_ ],SSystem[tau_, kplus_, kminus_, cplus_, cminus_]}]:= 
Module[{reaction,vars},
vars={X,X1}//Flatten;
reaction={RightTeeArrow[vars,Y],SSystem[tau, kplus, kminus, cplus, cminus]};
If[dbgArrows,Print["expandArrows:", reaction]];
Return[{reaction}];
];
expandArrows[{RightTeeArrow[X_,Y_ ],SSystem[x___]}]:= 
Module[{reaction},
reaction={RightTeeArrow[X,Y],SSystem[x]};
Print["Error: expandArrows: incorrect arrow format in ",reaction," correct format is SSystem[tau,kplus,kminus,cplus,cminus]"];
Return[{reaction}];
];


parseArrowForm[{RightTeeArrow[Plus[X_,X1__],Y_ ],SSystem[tau_, kplus_, kminus_, cplus_, cminus_]}]:= 
Module[{ vars, reaction, rateLaw},

reaction={RightTeeArrow[Plus[X,X1],Y],SSystem[tau, kplus, kminus, cplus, cminus]};
If[dbgArrows,Print["parseArrowForm:", reaction]];
vars={X,X1}//Flatten;
reaction={RightTeeArrow[vars,Y],SSystem[tau, kplus, kminus, cplus, cminus]};
Return[parseArrowForm[reaction]];
];

parseArrowForm[{RightTeeArrow[X_,Y_ ],SSystem[tau_, kplus_, kminus_, cplus_, cminus_]}]:= 
Module[{reaction,rateLaw, vars, nvars, odes,k\[UnderBracket]p,k\[UnderBracket]m,cplusses,cminuses,\[Tau]},
reaction={RightTeeArrow[X,Y],SSystem[tau, kplus, kminus, cplus, cminus]};

vars={X}//Flatten;
vars=(#[Global`t]&)/@vars;
nvars=Length[vars];

\[Tau]=getSingleValue[tau, 1, "SSystem Time Constant", reaction];
k\[UnderBracket]p=getSingleValue[kplus, 1, "SSystem kplus", reaction];
k\[UnderBracket]m=getSingleValue[kminus, 1, "SSystem kminus", reaction];
cplusses=getnValues[nvars,cplus,"SSystem cplus's",reaction];
cminuses=getnValues[nvars,cminus,"SSystem cminus's",reaction];
rateLaw= (1/\[Tau])(k\[UnderBracket]p*Times@@(vars^cplusses) - k\[UnderBracket]m*Times@@(vars^cminuses));
rateLaw=rateLaw/.{Global`\[EmptySet][Global`t]-> 0};

odes = {{Y[Global`t], rateLaw}};
Return[odes];


];
parseArrowForm[{RightTeeArrow[X_,Y_ ],{SSystem[z___]}}]:= parseArrowForm[{RightTeeArrow[X,Y],SSystem[z]}];



expandArrows[{RightTeeArrow[X_,Y_ ],NHCA[v_:1,T_:1,n_:1,m_:1,k_:1]}]:= 
Module[{reaction},
reaction={RightTeeArrow[X,Y],NHCA[v,T,n,m,k]};
If[dbgArrows,Print["expandArrows:", reaction]];
Return[{reaction}];
];
expandArrows[{RightTeeArrow[Plus[X_,X1__],Y_ ],NHCA[v_:1,T_:1,n_:1,m_:1,k_:1]}]:= 
Module[{reaction, vars},
vars={X,X1}//Flatten;
reaction={RightTeeArrow[vars,Y],NHCA[v,T,n,m,k]};
If[dbgArrows,Print["expandArrows:", reaction]];
Return[{reaction}];
];
expandArrows[{RightTeeArrow[X_,Y_ ],NHCA[x___]}]:= 
Module[{reaction},
reaction={RightTeeArrow[X,Y],NHCA[x]};
Print["Error: expandArrows: incorrect arrow format in ",reaction," correct format is NHCA[v,T,n,m,k] or NHCA[v,{TP,TM},n,m,k]"];
Return[{reaction}];
];


parseArrowForm[{RightTeeArrow[X_,Y_ ],NHCA[v_, T_,n_,m_,k_]}]:= 
Module[{reaction,rateLaw, vars, nvars, odes,
vvalue,Tvalues,nvalues,mvalue,nT, QP, QM},
reaction={RightTeeArrow[X,Y],NHCA[v,T,n,m,k]};

vars={X}//Flatten;
vars=(#[Global`t]&)/@vars;
nvars=Length[vars];

vvalue = getSingleValue[v, 1, "NHCA v", reaction];

Tvalues=T;
If[Length[vars]==1, Tvalues=List[Tvalues]]; 
Tvalues=getnListValues[nvars,Tvalues,"NHCA {TP,TM}",reaction]; 

nT=Union[Length/@Tvalues];
If[Length[nT]>1, Print["Error: invalid NHCA T values can not be combined: ", reaction];
Return[{}];
]; 

nT=First[nT]; 
nvalues=getnValues[nvars,n,"NHCA n",reaction];
mvalue=getSingleValue[m,1,"NHCA m", reaction];
kvalue=getSingleValue[k,1,"NHCA k", reaction];

Switch[nT,
1, 
Tvalues = First/@Tvalues;
QP=Tvalues*UnitStep[Tvalues];
QM=Tvalues*UnitStep[-Tvalues];
,
2,{QP, QM}=Transpose[Tvalues];
,
_, Print["Error: invalid format for NHCA T"]; 
]; 

QP=Times@@((1+#)&/@(QP*(vars^nvalues)));
QM=Times@@((1+#)&/@(QM*(vars^nvalues)));

rateLaw=vvalue*(QP^mvalue)/(kvalue*QM^mvalue+QP^mvalue);
rateLaw=rateLaw/.{Global`\[EmptySet][Global`t]-> 0};

odes = {{Y[Global`t], rateLaw}};
Return[odes];


];
parseArrowForm[{RightTeeArrow[X_,Y_ ],{NHCA[z___]}}]:= parseArrowForm[{RightTeeArrow[X,Y],NHCA[z]}];



NHCA[opt___?OptionQ]:= Module[{v,T,TP,TM,n,m,k, incorrect},
v=vmax/.{opt}/.Options[NHCA];
T=TNHCA/.{opt}/.Options[NHCA];
TM=TMINUS/.{opt}/.Options[NHCA];
TP=TPLUS/.{opt}/.Options[NHCA];
n=nNHCA/.{opt}/.Options[NHCA];
m=mNHCA/.{opt}/.Options[NHCA];
k=kNHCA/.{opt}/.Options[NHCA];


If[((!SameQ[TP,{}]) \[And]  (!SameQ[TM,{}])),
ret=NHCA[v, {TP,TM},n,m,k];,
ret=NHCA[v,T,n,m,k];
]; 

incorrect= Complement[First/@{opt},First/@ Options[NHCA]];
Print["Warning: NHCA[...] unknown option ", # -> (#/.{opt}), " ignored."]&/@incorrect;

Return[ret];
];


expandArrows[{Underoverscript[DoubleLongRightArrow[S_, P_],{activators_, inhibitors_, comptetitiveInhibitors_}, enzyme_],GMWC[kcat_:1, n_:1,c_:1, L_:1, K_:1]}]:= 
Module[{reaction,Slist,Alist, Ilist, Plist,CIlist, Klist, nA, nI, nS,nKneeded,nil},

 reaction={Underoverscript[DoubleLongRightArrow[S, P],{activators, inhibitors, comptetitiveInhibitors}, enzyme],GMWC[kcat, n,c, L, K]};
If[dbgArrows,Print["expandArrows:", reaction]];

Alist={activators}//Flatten;
Ilist={inhibitors}//Flatten;
Slist = {S}//Flatten;
Klist={K}//Flatten;
Plist={P}//Flatten;

CIlist=comptetitiveInhibitors;
If[!ListQ[CIlist], CIlist={CIlist}]; 

nS=Length[Slist]; 
nI=Length[Ilist]; 
nA=Length[Alist]; 
nCI=Length[CIlist//Flatten];
nKneeded=nS+nI+nA+nCI;

If[Length[Klist]>nKneeded,Print["Warning: expandArrows: expecting ",nKneeded," K values; found ", Length[Klist], " K values. Extra values ignored. Reaction: ",reaction];
Klist=Take[Klist,nKneeded];
];

Klist=PadRight[Klist, nKneeded,1];


If[!(And@@(ListQ/@CIlist)),
Print["Error: expandArrows: Competitive Inhibitors must be expressed as a list of lists. Up to ",nS+nA," sublists may be specified in the reaction ",reaction ];
];

CIlist=PadRight[CIlist,nS+nA,nil]/.{nil-> {}};

reaction={Underoverscript[DoubleLongRightArrow[Slist, Plist],{Alist, Ilist, CIlist}, enzyme],GMWC[kcat, n,c, L, Klist]};


Return[{reaction}];
];


expandArrows[{Underoverscript[DoubleLongRightArrow[S_, P_],{activators_, inhibitors_}, enzyme_],GMWC[kcat_:1, n_:1,c_:1, L_:1, K_:1]}]:= 
Module[{reaction},
reaction={Underoverscript[DoubleLongRightArrow[S, P],{activators, inhibitors, {}}, enzyme],GMWC[kcat, n,c, L, K]};
If[dbgArrows,Print["expandArrows:", reaction]];
reaction=expandArrows[reaction]; 
Return[reaction];
];
expandArrows[{Underoverscript[DoubleLongRightArrow[S_, P_],\[Alpha]_, enzyme_],GMWC[kcat_:1, n_:1,c_:1, L_:1, K_:1]}]:= 
Module[{reaction},
reaction=expandArrows[{Underoverscript[DoubleLongRightArrow[S, P],{\[Alpha],{}}, enzyme],GMWC[kcat, n,c, L, K]}];
Return[reaction];
];

expandArrows[{Overscript[DoubleLongRightArrow[S_, P_], enzyme_],GMWC[kcat_:1, n_:1,c_:1, L_:1, K_:1]}]:= 
Module[{reaction},
reaction=expandArrows[{Underoverscript[DoubleLongRightArrow[S, P],{{},{}}, enzyme],GMWC[kcat, n,c, L, K]}];
If[dbgArrows,Print["expandArrows:", reaction]];
Return[reaction];
];

expandArrows[{X___,GMWC[Y___]}]:= 
Module[{reaction},
reaction={X,GMWC[Y]};
If[dbgArrows,Print["expandArrows:", reaction]];
Print["Error: expandArrows: incorrect arrow format in ",reaction," correct format for GMWC reaction is ",{Underoverscript[DoubleLongRightArrow["{S1,S2,\[Ellipsis]}", "{P1,P2,\[Ellipsis]}"],{"{A1,A2,\[Ellipsis]}", "{I1,I2,\[Ellipsis]}", "{CI1,CI2,...}"}, "enzyme"],"GMWC[\!\(\*SubscriptBox[\"k\", \"cat\"]\),n,c,L,K]"}];
Return[{reaction}];
];

expandArrows[{X___,MWC[Y___]}]:= expandArrows[{X,GMWC[Y]}];




parseArrowForm[{Underoverscript[DoubleLongRightArrow[S_, P_],{A_, In_, CI_}, En_],GMWC[kcat_, n_,c_, L_, K_]}]:= 
Module[{reaction,rateLaw, svars, pvars,vars, odes, dvdt,
As,Is,CIs,Ss,Ps, Ks, normalize, nCIs, CIss,m,nS,nA, dbg=False,OnePlusS,OnePluscS,OnePlusA, OnePlusI,Prod1PlusX, modifierVariables, nmodifiers, modifierODES},

normalize[X_, Klist_]:= Module[{XX,KX,KNew,nn},
nn=Length[X];
KX=Take[Klist, nn];
XX=(#[Global`t]&)/@X;
XX=XX/KX;

Knew=Drop[Klist,nn];
Return[{XX,Knew}];
];

Prod1PlusX[X_]:=Times@@((1+Plus@@#)&/@X); 

reaction={Underoverscript[DoubleLongRightArrow[S, P],{A, In, CI}, En],GMWC[kcat, n,c, L, K]};
If[dbgArrows,Print["parseArrowForm:", reaction]];

If[dbg, Print["A=", A, " In=", In, " CI=", CI, " En=", En]]; 
modifierVariables=Join[{A}, {In}, {CI}, {En}]//Flatten;
modifierVariables = (#[Global`t]&)/@modifierVariables; 
nmodifiers = Length[modifierVariables]; 
modifierODES=Table[0, {nmodifiers}]; 

If[dbg, Print["modifierVariables: ", modifierVariables]]; 

svars=(#[Global`t]&)/@S;
pvars=(#[Global`t]&)/@P;


Ks=K;
{Ss, Ks}=normalize[S,Ks];
{As, Ks}=normalize[A,Ks];
{Is, Ks}=normalize[In, Ks];

If [dbg,  Print["S=",Ss,"\nA=",As,"\nI=",Is,"\nK's left:",Ks]; ]; 

nCIs=Length/@CI;
{CIs, Ks}=normalize[Flatten[CI],Ks];

CIss={};
While[Length[nCIs]>0,
m=First[nCIs];
nCIs=Rest[nCIs];
CIss=Append[CIss,Take[CIs,m]];
CIs=Drop[CIs,m];
];
dvdt=En[Global`t]*kcat;

If[ dbg, Print["CI=",CIss, "\nK's left:",Ks, "\nnCI:",nCIs]; ] ;

nS=Length[Ss];
nA=Length[As];

CIs=Take[CIss,nS];
CIss=Drop[CIss,nS];
OnePlusS=MapThread[Join[#1,#2]&,{List/@Ss,CIs}]//Prod1PlusX;
OnePluscS=MapThread[Join[#1,#2]&,{c*List/@Ss,CIs}]//Prod1PlusX;

CIs=Take[CIss,nA];
OnePlusA=MapThread[Join[#1,#2]&,{List/@As,CIs}]//Prod1PlusX;
OnePlusI=Times@@((1+#)&/@Is);
CIs=Times@@(c*Ss);
Ss=Times@@Ss;

If[dbg, Print["1+S+Sbar:",OnePlusS,"\n1+cS+cSbar:",OnePluscS,"\n1+A+Abar:",OnePlusA,"\n1+I:",OnePlusI,"\ncS:",CIs]];

dvdt=dvdt*(OnePlusA^n*Ss*OnePlusS^(n-1)+L*CIs*OnePluscS^(n-1)*OnePlusI^n)/(OnePlusA^n OnePlusS^n+L*OnePluscS^n*OnePlusI^n);
If[dbg, Print["dvdt=",dvdt]];



odes=Join[{#,-dvdt}&/@svars, {#,dvdt}&/@pvars];
If[dbg, Print["odes: ", odes]]; 

modifierODES=Transpose[{modifierVariables, modifierODES}]; 
 If[dbg, Print["modifierODES: ", modifierODES]]; 

odes = Join[odes, modifierODES]; 

Return[odes];


];



GMWC[opt___?OptionQ]:= Module[{r, T, n, h,ret, f, incorrect},

ret=GMWC[
 kcatGMWC/.{opt}/.Options[GMWC], 
nGMWC/.{opt}/.Options[GMWC], 
cGMWC/.{opt}/.Options[GMWC],
LGMWC/.{opt}/.Options[GMWC], 
{KGMWC/.{opt}/.Options[GMWC]}//Flatten
]; 
incorrect= Complement[First/@{opt},First/@ Options[GMWC]];
Print["Warning: GMWC[...] unknown option ", # -> (#/.{opt}), " ignored."]&/@incorrect;
Return[ret];
];


expandArrows[{RightTeeArrow[X_,Y_ ],user_[r_, T_,n_,h_,f_]}]:= 
Module[{reaction},
reaction={RightTeeArrow[X,Y],user[r,T,n,h,f]};
If[dbgArrows,Print["expandArrows:", reaction]];
Return[{reaction}];
];
expandArrows[{RightTeeArrow[Plus[X_,X1__],Y_ ],user_[r_,T_,n_,h_,f_]}]:= 
Module[{reaction,vars},
vars={X,X1}//Flatten;
reaction={RightTeeArrow[vars,Y],user[r,T,n,h,f]};
If[dbgArrows,Print["expandArrows:", reaction]];
Return[{reaction}];
];
expandArrows[{RightTeeArrow[X_,Y_ ],user_[x___]}]:= 
Module[{},
reaction={RightTeeArrow[X,Y],user[x]};
If[SameQ[user,Times],Print["Error: invalid user function name: "<>"\""<>ToString[({x}//Flatten)[[1]]]<>"\". Check for embedded blanks in function name, that are interpreted as \"Times\", "<>ToString[FullForm[user[x]]]
]];
Print["Error: invalid user defined reaction format: ",reaction," Correct format is {"<>ToString[X//InputForm]<>"\[RightTeeArrow]"<>ToString[Y//InputForm]<>","<>ToString[user//InputForm]<>"[r,T,n,h,f]}"];
Return[{}];
];



 parseArrowForm[{RightTeeArrow[Plus[X_,X1__],Y_ ],user_[r_,T_,n_,h_,f_]}]:= 
Module[{odes,rateLaw, vars,x, reaction},

reaction={RightTeeArrow[Plus[X],Y],user[r,T,n,h,f]};
If[dbgArrows,Print["parseArrowForm:", reaction]];
vars={X,X1}//Flatten;
odes = parseArrowForm[{RightTeeArrow[vars,Y],user[r,T,n,h,f]}];
Return[odes];
]; 

parseArrowForm[{RightTeeArrow[X_,Y_ ],user_[r_,T_,n_,h_,f_]}]:= 
Module[{reaction,vars,nvars,Tall,nall,x,Tlast,nLast,hused,rused,

odes,rateLaw, V, K,nn,rr,multiplier},

reaction={RightTeeArrow[X,Y],user[r, T, n, h,f]};
If[dbgArrows,Print["parseArrowForm:", reaction]];

vars={X}//Flatten;
vars=(#[Global`t]&)/@vars;

If[dbgArrows,Print["parseArrowForm: vars: ", vars]];

nvars=Length[vars];
If[dbgArrows,Print["parseArrowForm: nvars: ", nvars]];

Tall={T}//Flatten;
Tlast=Last[Tall];
If[Length[Tall]<nvars, Tall=PadRight[Tall,nvars,Tlast]];
If[Length[Tall]>nvars, Tall=Take[Tall,nvars]];
If[dbgArrows,Print["parseArrowForm: Tall=",Tall]]; 


nall={n}//Flatten;
nLast=Last[nall];
If[Length[nall]<nvars, nall=PadRight[nall,nvars,nLast]];
If[Length[nall]>nvars, nall=Take[nall,nvars]];
If[dbgArrows,Print["parseArrowForm: nall=",nall]]; 


hused={h}//Flatten;
If[Length[hused]>0, hused=First[hused], hused=0];

rused={r}//Flatten;
If[Length[rused]>0, rused=First[rused],rused=1];

x = hused+Tall.(vars^nall);

rateLaw=rused*f[x];
rateLaw=rateLaw/.{Global`\[EmptySet][Global`t]-> 0};

odes = {{Y[Global`t], rateLaw}};
Return[odes];
];
parseArrowForm[{RightTeeArrow[X_,Y_ ],{user_[z___]}}]:= parseArrowForm[{RightTeeArrow[X,Y],user[z]}];



expandArrows[{substrateExpression_\[Implies]productExpression_ ,rate___:1}]:= Module[{reaction, k},

reaction =substrateExpression\[Implies]productExpression;
If[dbgArrows,Print["expandArrows:", reaction]]; 

k={rate}//Flatten;
If[Length[k]<1, 
k=1, 
If[Length[k]>1, Print["Warning: Extra rate constants ", Drop[k,1]," in the reaction ", reaction, " will be ignored."]]; 
k=First[k]
]; 
Return[{{reaction,k}}];
]


parseArrowForm[{substrateExpression_\[Implies]productExpression_ ,rate___:1}]:= 


Module[{parseExpression, reaction, input, output, klaw,species, nspecies, dbg=False, netStoichiometry, rates,odes, k},

reaction = substrateExpression\[Implies]productExpression;
If[dbgArrows,Print["parseArrowForm:", reaction]]; 

{reaction,k}=expandArrows[{reaction,rate}][[1]];

input=parseReactants[True,substrateExpression];
output=parseReactants[True, productExpression];
klaw=k;

netStoichiometry[x_]:= Module[{in,out},
in = Cases[input,{x,_}];
If[Length[in]<1, 
in = 0, 
in = Transpose[in];
in=Plus@@in[[2]];
];

out=Cases[output,{x,_}];
If[Length[out]<1, 
out = 0, 
out = Transpose[out];
out=Plus@@out[[2]];
];

Return[out-in];

]; (* end netStoichiometry *)

species=Union[First/@input, First/@output]; 
rates=klaw*netStoichiometry/@species;

If[dbg,
Print["input stoichiometry:",input];
Print["klaw=",klaw];
Print["output stoichiometry:",output];
Print["species:", species];
Print["rates:",rates];
];

odes = {species,rates}//Transpose;
Return[odes];
]


expandArrows[]:= Module[{},Print["expandArrows: A reaction must be given as an argument. "];Return[{}]];
expandArrows[x___]:= Module[{},Print["expandArrows: Unable to identify the reactions: ",x];Return[x]];


parseArrowForm[x___]:= Module[{},Print["parseArrowForm: Unable to identify the reactions: ",x];Return[{}]];


 rateLaw[reaction_, variable_]:= Module[{odeterms,term},
odeterms=parseArrowForm[reaction];
term=Select[odeterms,SameQ[First[#],variable[Global`t]]&];
If[Length[term]<1, 
Print["Error: rateLaw: unknown reaction or variable not present in reaction: ",reaction," variable: ",variable];
Return[0]];
If[Length[term]>1, Print["Possible program error: multiple rate laws for same variable.", "reaction=",reaction," variable=",variable," odeterms=",odeterms," term=",term];
];
Return[term[[1,2]]];
] 


rateLaw[x___]:=Module[{},Print["rateLaw: invalid arguments: should be rateLaw[reaction,variable]"];Return[0]]



interpret[{reactions__?ListQ}, opt___?OptionQ]:= Module[{dbg,r,odes, species,terms,odeterms,cpu,nextvar,nextterm,var,vardot,vardotarray,term,termarray,timer, n,i,vars, j,varnames,varnamearray,vararray,eqn, frozenvariables,somefrozen,\[EmptySet]s, defunctionate, raterules, complement, liquidvariables, f, v
},

complement[p_][Global`t]:= 1-p[Global`t]; 

defunctionate[p_[Global`t]]:= p;
defunctionate[p_]:= p; 

dbg = debugflag/.{opt};
timer = Global`CPU/.{opt}/.{Global`CPU-> False};

raterules=rates/.{opt}/.Options[interpret];

If[dbg, Print["interpret: raterules=",raterules]]; 
r={reactions}/.raterules;
If[dbg, Print["interpret:input:",r]];

frozenvariables = frozen/.{opt}/.Options[interpret]; 
(* add dummy reaction for all frozen variables to force them to be species (11.26.07, v0 .62) *)
f=frozenvariables;
While[Length[f]>0,
v=First[f]; f= Rest[f]; 
AppendTo[r, {v-> v}];
]; 
If[dbg, Print["interpret:revised input: ", r]]; 

frozenvariables = {frozenvariables,Global`\[EmptySet]}//Flatten;
If[dbg, Print["interpret:frozen:", frozenvariables]]; 




somefrozen=Length[frozenvariables]>0;
If[somefrozen, frozenvariables=#[Global`t]&/@frozenvariables];

(* add in pre-processing here *)

If[timer,cpu=TimeUsed[];];

r=Join@@expandArrows/@r;
If[dbg, Print["interpret:after expandArrows: ", r]]; 
r=combineRegulatoryReactions[r];
If[dbg, Print["interpret: after combineRegulatory: ", r]]; 


odes=parseArrowForm/@r;
If[dbg, Print["interpret: odes after parseArrowForm: ", odes]]; 

odes = Join@@odes;

If[dbg, Print["interpret: odes after parseArrowForm (2): ", odes]]; 


If[odes==={}, Return[{}]];

species =Union[First/@odes];

If[timer,
cpu=TimeUsed[]-cpu;
Print["1:",cpu];
cpu=TimeUsed[];
]; 

odes=Sort[odes];

If[timer,
cpu=TimeUsed[]-cpu;
Print["2:",cpu];
cpu=TimeUsed[];
];

{vars,odes}=Transpose[odes];
n=Length[odes];
termarray=Array[terms,n];
varnamearray=Array[varnames,n];
For[i=1,i<= n,i++,
terms[i]=odes[[i]];
varnames[i]=vars[[i]];
];


vararray=Array[var,n];
vardotarray=Array[vardot,n];

i=1;j=1;
var[j]=varnames[i];
If[MemberQ[frozenvariables,var[j]],
vardot[j]=0,
vardot[j]=terms[i]
];

While[i<n,
i++;
nextvar=varnames[i];
nextterm=terms[i];
If[nextvar===var[j],
If[MemberQ[frozenvariables,var[j]],
vardot[j]=0,
vardot[j]+= nextterm
];
,
j++;
var[j]=nextvar;
If[MemberQ[frozenvariables,var[j]],
vardot[j]=0,
vardot[j]=nextterm
];
(* if the current variable is frozen, "unsave" it *)
];

];
species=Take[vararray,j];
odeterms=Take[vardotarray,j]; 
If[timer,
cpu=TimeUsed[]-cpu;
Print["3:",cpu];
cpu=TimeUsed[];
];

If[dbg, 
Print["interpret:odes:",odes];
Print["interpret:species:",species];
Print["interpret:odeterms:",odeterms];
];

\[EmptySet]s=Position[species,Global`\[EmptySet][Global`t]];
If[Length[\[EmptySet]s]>0,
If[Length[\[EmptySet]s]>1,
Print["Error: Empty Set occurs at positions ",\[EmptySet]s];
,
\[EmptySet]s=\[EmptySet]s[[1]];
species=Drop[species,\[EmptySet]s];
odeterms=Drop[odeterms,\[EmptySet]s];
];
];

odes = MapThread[Equal[D[#1,Global`t], #2]&,{species,odeterms}]; 

odes = odes/.{Comp-> complement};

(* remove the odes for the frozen variables *)
(*  n=Length[odes];
liquidvariables=Position[MemberQ[frozenvariables,var[#]]&/@Range[n] , False]//Flatten;
odes = odes[[liquidvariables]];
species=species[[liquidvariables]];
 *)
If[timer,
cpu=TimeUsed[]-cpu;
Print["4:",cpu];
];
species=defunctionate/@species;
Return[{odes,species}]
];


interpret[x___]:=Module[{}, Print["Not a list of lists."];Return[{}];]


lowLevelReactions[reactions_, opt___?OptionQ]:= Module[{RATES, r},

RATES = rates/.{opt}/.Options[rates];
r=xlr8r`Private`expandArrows/@(reactions); 
r=Join@@r;

If [!RATES,
r=First/@r;
]; 
Return[r];
]


interpreted[list_?ListQ]:= Module[{h},
If[Length[list]!= 2, Return[False]];
If[Length[list[[1]]]!= Lenth[list[[2]]], Return[False]]; 
h=Union[Head/@First[list]];
If[Length[h]!= 1, Return[False]];
h=First[h];
If[!SameQ[h,Equal], Return[False]];
Return[True];
];
interpreted[x_]:= False;


jacobianMatrix[r_,t_:Global`t]:= Module[{eqs,vars, dRow},
If[interpreted[r],
 eqs=r,
eqs=interpret[r]];
{eqs,vars}=eqs;
vars = #[t]&/@vars;
(* in 5.0++, equation will not necessarily be of the form x'=stuff but may be an equation will be an expression involving x': need to solve for x'[t] *)

eqs=Last/@Flatten[MapThread[Solve[#1,D[#2,{t,1}]]&, {eqs,vars}]];

dRow[equation_]:= Map[D[equation,{#,1}]&, vars];
dRow/@eqs
]


debugRun=False; 
run[system_, opt___?OptionQ]:= 
Module[{span,runspan,n, sym},
span=Flatten[List[timeSpan/.{opt}/.Options[run]]];
Switch[Length[span],
0,runspan={0,100}; ,
1, runspan=Prepend[span,0];,
2,runspan=span;,
3, runspan=span;,
_, runspan= Take[span,3];
]; 
If[debugRun, Print["run:system:",system," runspan:", runspan," opt:",{opt}]]; 
n = run[system,runspan, opt]; 
Return[n];
];
run[system_, {t_, tstart_, tend_}, opt___?OptionQ]:= run[system, {tstart, tend}, timeVariable-> t, opt]; 
run[sys_,{tstart_, tend_}, opt___?OptionQ]:= Module[

{ic, r, n, eqs, vars, nopt, pvar, time, icsGiven, icsMissing,ruleToICequation, gpvar, deindex, deindexedvars, plt, bc, bcflag,bcvar, dbcvars, fv, dpr, quiet},

quiet = "Quiet"/.{opt}/.Options[run]; 
If["Debug"/.{opt}/.Options[run], debugRun=True, debugRun=False]; 

dpr[x___]:= If[debugRun, Print["run: ", x]]; 

deindex[a_[b___]]:= deindex[a];
deindex[a_]:= a; 

time = timeVariable/.{opt}/.Options[run]; 

bc = "BoundaryConditions"/.{opt}/.{"BoundaryConditions"-> {}}; 
bcflag = Length[bc]>0;

(* make sure boundary conditions are included in frozen variables *)

fv  = frozen/.{opt}/.{frozen-> {}};
If[bcflag,
bcvar = First/@bc; 
bcvar = deindex/@bcvar; 

dpr["bc: ", bcvar]; 

fv = Union[Join[fv, bcvar]];  
dpr["fv: ", fv]; 

]; 

(* if necessary, convert the reactions to ODES *)

If[interpreted[sys], system=sys, system=interpret[sys, frozen-> fv]];



dpr["interpretd system: ", system]; 


(* make sure to remove any boundary conditions from the solve-for variables *)


If[bcflag,
{eqs, vars} = system;
vars = Complement[vars, bcvar]; 
dbcvars = D[#[time], {time, 1}]&/@bcvar;
eqs = Select[eqs,
!MemberQ[dbcvars,First[#]]&
];
eqs = eqs/.bc;
system = {eqs, vars};
dpr["revised system: ", system];
]; 


ic = initialConditions/.{opt}/.Options[run];
r= rates/.{opt}/.Options[run];
vars = system[[2]]; 

(* convert any ics that are given as rules into NDSolve-compatible form *)

ruleToICequation[Rule[a_,b_]]:= Equal[a[tstart], b];
ruleToICequation[a_]:= a;
ic = ruleToICequation/@ic;

dpr[":ic:",ic,"\nr:", r,"\nvars:",vars];

(* determine missing initial conditions and set them to zero *)

icsGiven=Head/@First/@ic;
dpr["icsGiven: ", icsGiven]; 

icsMissing=Complement[vars, icsGiven];
dpr["icsMissing: ", icsMissing]; 

If[Length[icsMissing]>0,
If[!quiet, 
Print["Warning: "//MathSBML`Private`boldRed,"Initial conditions are missing (and assumed to be zero) for the following variables: "//MathSBML`Private`boldBlack, icsMissing//MathSBML`Private`boldBlue]
];

icsMissing=Equal[#[tstart], 0]&/@icsMissing; 
ic=Join[ic, icsMissing];
];

(* create the NDSolve-compatible system *) 

eqs = Join[system[[1]], ic]/.r;
dpr["eqs: ", eqs]; 

(* check for undefined variables/parameters/constants *) 

sym =MathSBML`Private`getSymbols[eqs];
dpr["sym(1):", sym]; 

deindexedvars=Union[deindex/@vars]; 
sym = Complement[sym, vars, deindexedvars,{time}];
dpr["sym(2):", sym]; 

(* 6.24/08 remove system context variables like If and Which *)

sym = Select[sym, (Context[#]!= "System`")&]; 
 dpr["sym(3): ", sym]; 

If[Length[sym]>0, 
If[!quiet,
Print["Warning: "//MathSBML`Private`boldRed," The following symbols are undefined (and assumed to be equal to one (1)): "//MathSBML`Private`boldBlack, sym//MathSBML`Private`boldBlue]
]; 
sym = Rule[#,1]&/@sym;
eqs = eqs/.sym;

dpr["sym(4):", sym]; 
dpr["eqs(2): ", eqs]; 
];


(* filter NDSolve options and solve the system *) 

With[
{nopt=MyFilterOptions[NDSolve,opt]},
n=NDSolve[eqs, vars, {time, tstart, tend}, nopt]; 
];

If[plot/.{opt}/.Options[run],
(* if a plot is requested *) 

pvar = plotVariables/.{opt}/.Options[run];

If[!SameQ[pvar,None],
If[Length[pvar]>0,
plt= runPlot[n, pvar,opt],
plt=runPlot[n] 
];
If[$VersionNumber>5.5, Print[plt]]; 
 ]; 

(* if a gridPlot is requested *)

gpvar = gridPlotVariables/.{opt}/.Options[run];
If[!SameQ[gpvar,None], 
If[SameQ[gpvar,All],
plt=gridPlot[n,All, {tstart, tend},opt];,
plt=gridPlot[n,Flatten[gpvar],{tstart, tend},opt];
];
If[$VersionNumber>5.5, Print[plt]]; 

]; 

];

(* return a list of interpolating functions *)

Return[n];
];



debugRunPlot=False;
runPlot[sys_, opt___?OptionQ]:= Module[{vars},
vars=First/@Flatten[sys]; 
If[debugRunPlot, Print["runPlot(1): vars: ", vars, " {opt}:", {opt}]]; 
Return[runPlot[sys,vars,opt]];
];
runPlot[sys_, {vars___}, opt___?OptionQ]:= Module[{n,arg, tstart, tend,p},

(* determine time span: plot everything *) 
If[debugRunPlot, Print["runPlot(2): {vars}: ", {vars}, " {opt}: ", {opt}]]; 

args[a_[b___]]:= {b}//Flatten; 
args[a___]:= {a}//Flatten;
n=Last/@Flatten[sys];
n=args/@n;
n=(Take[#,2]&/@n)//Union;
tstart=Max[First/@n];
tend=Min[Last/@n];
If[tstart>= tend, Print["Warning: runPlot: unable to plot results. Incompatible time domains."];
Return[];
]; 

p=runPlot[sys, {vars}, {tstart,tend},opt];
Return[p];
];

runPlot[sys_, var_,opt___?OptionQ]:=Module[{}, 
If[debugRunPlot, Print["runPlot(3): {vars}: ", {vars}, " {opt}: ", {opt}]]; 
 runPlot[sys,{var},opt]]; 

runPlot[sys_, {varseq___}, { tstart_, tend_}, opt___?OptionQ]:= Module[{plot, varsRequested, saveContext, n,nd, varsAvailable, missingVars, g, v},
If[debugRunPlot, Print["runPlot(4): {varseq}: ", {varseq}, " {tstart, tend}=",{tstart, tend}, " {opt}: ", {opt}]]; 

plot[x___]:= MathSBML`Private`SBMLPlot;

(* check for missing variables *)

varsRequested = {varseq}; 
n=Flatten[sys];
varsAvailable = First/@n;
missingVars = Complement[varsRequested, varsAvailable]; 
If[Length[missingVars]>0,
Print["Warning: "//MathSBML`Private`boldRed, "The requested plot variables: "//MathSBML`Private`boldBlack, missingVars//MathSBML`Private`boldBlue," can not be found to be plotted."//MathSBML`Private`boldBlack]; 
varsRequested=Complement[varsRequested, missingVars];
]; 


If[Length[varsRequested]>0,
saveContext=MathSBML`Private`$SBML$Context; 
MathSBML`Private`$SBML$Context="None`";

(* 
nd = Flatten[n];
nd = MapThread[Rule[MathSBML`Private`decontextify[#1], #2]&,
{First/@nd,Last/@nd}
];
*)

nd = Flatten[n];
{v,nd}=(nd/.{Rule-> List})//Transpose;

(* The "Hold" is so that things like A\[Diamond]B become (A\[Diamond]B)[t] instead of A\[Diamond](B[t])*)

v=MathSBML`Private`functionate[Hold/@v]/.{Hold-> Identity}; 
If[debugRunPlot, Print["runPlot: v: ", v]]; 
nd=Rule@@#&/@Transpose[{v, #[Global`t]&/@nd}];


If[debugRunPlot, Print["runPlot: calling SBMLPlot: varsRequested: ", varsRequested, " nd=", nd]];

g=MathSBML`SBMLPlot[{nd}, varsRequested, {tstart, tend}, opt];

MathSBML`Private`$SBML$Context=saveContext;
,
Print["Error: runPlot: "//MathSBML`Private`boldRed," at least one valid variable must be specified to generate a plot."//MathSBML`Private`boldBlack]; 
g={};
]; 
Return[g];
];

runPlot[sys_,var_,{tstart_, tend_}, opt___?OptionQ]:= runPlot[sys, {var},{tstart, tend}, opt];


gridPlot[sys_, opt___?OptionQ]:= Module[{vars},
vars=First/@Flatten[sys]; 
Return[gridPlot[sys,vars,opt]];
];
gridPlot[sys_, {vars___}, opt___?OptionQ]:= Module[{n,arg, tstart, tend,p},

(* determine time span: plot everything *) 

args[a_[b___]]:= {b}//Flatten; 
args[a___]:= {a}//Flatten;
n=Last/@Flatten[sys];
n=args/@n;
n=(Take[#,2]&/@n)//Union;
tstart=Max[First/@n];
tend=Min[Last/@n];
If[tstart>= tend, Print["Warning: gridPlot: unable to plot results. Incompatible time domains."];
Return[];
]; 
p=gridPlot[sys, {vars}, {tstart,tend},opt];
Return[p];
];


gridPlot[sys_, var_,opt___?OptionQ]:= gridPlot[sys,{var},opt]; 


gridPlot[sys_, vars_,{tstart_, tend_}, opt___?OptionQ] := Module[{p,v, colors, nv,ga,nc, rem},
If[vars===All,
v=First/@Flatten[sys];,
v=vars;
]; 
nv=Length[v];
colors =Hue/@( Range[nv]/nv); 

p = MapThread[runPlot[sys, #1,{tstart, tend}, DisplayFunction-> Identity,PlotLabel-> #1,Global`holdLegend-> True,PlotStyle-> #2, opt]&,  {v, colors}];
nc=plotColumns/.{opt}/.Options[gridPlot]; 
ga=Partition[p,nc];
rem = Mod[nv, nc];
If[rem>0, 
ga = Append[ga, Take[p,-rem]]; 
];
With[{optsShow=MyFilterOptions[Plot,opt]},
Return[Show[GraphicsArray[ga], DisplayFunction-> $DisplayFunction, optsShow]]];
];


arrayGridPlot[n_, ncells_,tmax_, {vars__}, opt___?OptionQ]:= Module[
{singlePlot, plots, columns,df},

df = DisplayFunction/.{opt}/.{DisplayFunction-> $DisplayFunction}; 

singlePlot[variableName_]:= runPlot[n, #/@(Range[ncells]),{0,tmax},opt, PlotRange-> All,  Global`holdLegend-> True, PlotLabel-> #, DisplayFunction-> Identity]&/@{variableName};
plots = singlePlot/@{vars};

columns = plotColumns/.{opt}/.{plotColumns-> 3};

plots = Flatten[plots];
plots=Partition[plots, columns, columns, {1,1}, {}]; 
Return[Show[GraphicsArray[plots], DisplayFunction-> df,opt]];

]



debugRun=False;

simulate[system_,tend_,  opt___?OptionQ]:= Module[{},
simulate[system, timeSpan-> tend, opt]
];  


simulate[sys_, opt___?OptionQ]:= Module[

{ic, r, n, eqs, odes, vars, nopt, pvar, time=Global`t, icsGiven, icsMissing,ruleToICequation, gpvar, deindex, deindexedvars},

If[interpreted[sys], system=sys, system=interpret[sys]];

deindex[a_[b___]]:= deindex[a];
deindex[a_]:= a; 

ic = initialConditions/.{opt}/.Options[run];
r= rates/.{opt}/.Options[run];
vars = system[[2]]; 

tend = timeSpan/.{opt}/.{timeSpan-> 100};


(* convert any ics that are given as rules into NDSolve-compatible form *)

ruleToICequation[Rule[a_,b_]]:= Equal[a[0], b];
ruleToICequation[a_]:= a;
ic = ruleToICequation/@ic;

If[debugRun, Print["simulate:ic:",ic,"\nr:", r,"\nvars:",vars,"\ntend:",tend]];

(* determine missing initial conditions and set them to zero *)

icsGiven=Head/@First/@ic;
icsMissing=Complement[vars, icsGiven];
If[Length[icsMissing]>0,
Print["Warning: "//MathSBML`Private`boldRed,"Initial conditions are missing (and assumed to be zero) for the following variables: "//MathSBML`Private`boldBlack, icsMissing//MathSBML`Private`boldBlue];

icsMissing=Equal[#[0], 0]&/@icsMissing; 
ic=Join[ic, icsMissing];
];
If[debugRun, Print["simulate: ic:", ic]]; 

(* create the NDSolve-compatible system *) 

odes = system[[1]]; 
If[debugRun, Print["simulate: odes:", odes]]; 

eqs = Join[system[[1]], ic]/.r;

(* check for undefined variables/parameters/constants *) 

sym =MathSBML`Private`getSymbols[eqs];
deindexedvars=Union[deindex/@vars]; 
sym = Complement[sym, vars, deindexedvars,{time}]; 
If[Length[sym]>0, 
Print["Warning: "//MathSBML`Private`boldRed," The following symbols are undefined (and assumed to be equal to one (1)): "//MathSBML`Private`boldBlack, sym//MathSBML`Private`boldBlue]; 
sym = Rule[#,1]&/@sym;
eqs = eqs/.sym;
];

(* filter NDSolve options and solve the system *) 
(* 
With[
{nopt=MyFilterOptions[NDSolve,opt]},
n=NDSolve[eqs, vars, {time, tstart, tend}, nopt]; 
];
*)

Block[{model,constants, v, c,crule},
c= Global`compartment$1;
crule = c-> 1; 
constants = Append[r, crule];
v=MathSBML`Private`functionate/@vars;

model={};
AppendTo[model, Global`SBMLAlgebraicRules-> {}]; 
AppendTo[model, Global`SBMLAssignmentRules-> {}]; 
AppendTo[model, Global`SBMLCompartments-> {c}]; 
AppendTo[model, Global`SBMLConstants-> constants]; 
AppendTo[model, Global`SBMLConstraints->{}];
AppendTo[model, Global`SBMLContext->"None`"];
AppendTo[model, Global`SBMLEvents->{}];
AppendTo[model,Global`SBMLFunctions->{}]; 
AppendTo[model,Global`SBMLIC-> ic]; 
AppendTo[model, Global`SBMLInitialAssignments->{}];
AppendTo[model, Global`SBMLKineticLaws->{}]; 
AppendTo[model, Global`SBMLMetaIDAssociations->{}];
AppendTo[model, Global`SBMLModelid->"xlr8rModel"];
AppendTo[model,Global`SBMLModelName->"xCellerator Model"]; 
AppendTo[model, Global`SBMLModelVariables-> v]; 
AppendTo[model, Global`SBMLNameIDAssociations->{}];
AppendTo[model, Global`SBMLODES-> odes];
AppendTo[model, Global`SBMLParameters-> (First/@r)]; 
AppendTo[model, Global`SBMLSpecies-> v]; 
AppendTo[model, Global`SBMLSpeciesCompartmentAssociations-> (
Rule[#, c]&/@vars)]; 
AppendTo[model, Global`SBMLSpeciesTypeAssociations-> {}]; 
AppendTo[model, Global`SBMLSpeciesTypes-> {}]; 
AppendTo[model, Global`SBMLUnitAssociations->{}];
AppendTo[model, Global`SBMLUnitDefinitions->{}]; 

If[debugRun, Print["simulate: model: ", model]]; 
n=SBMLNDSolve[model, tend, opt];
];

Return[n];

If[plot/.{opt}/.Options[run],
(* if a plot is requested *) 

pvar = plotVariables/.{opt}/.Options[run];
If[!SameQ[pvar,None],
If[Length[pvar]>0,
runPlot[n, pvar,opt];,
runPlot[n]; 
]; 
 ]; 

(* if a gridPlot is requested *)

gpvar = gridPlotVariables/.{opt}/.Options[run];
If[!SameQ[gpvar,None], 
If[SameQ[gpvar,All],
gridPlot[n,All, {tstart, tend},opt];,
gridPlot[n,Flatten[gpvar],{tstart, tend},opt];
]

]; 

];

(* return a list of interpolating functions *)

Return[n];
];


steadyState[r_,t_:Global`t]:= Module[{eqs,vars},
If[interpreted[r], eqs=r,eqs=interpret[r]];
{eqs,vars}=eqs;
vars =#[t]&/@vars;

(* in 5.0++, equation will not necessarily be of the form x'=stuff but may be an equation will be an expression involving x': need to solve for x'[t] *)

eqs=Last/@Flatten[MapThread[Solve[#1,D[#2,{t,1}]]&, {eqs,vars}]];
eqs=Equal[#,0]&/@eqs;
Solve[eqs,vars]
];

steadyState[r_,t_, varlist_]:= Module[{teqs,vars,p},
If[interpreted[r], eqs=r,eqs=interpret[r]];
teqs=Transpose[eqs];
{eqs,vars}=eqs;

p=Flatten[Position[vars,#]&/@varlist];

{eqs,vars}=Transpose[teqs[[p]]];

eqs=Last/@Flatten[MapThread[Solve[#1,D[#2,{t,1}]]&, {eqs,vars}]];
eqs=Equal[#,0]&/@eqs;
Solve[eqs,vars]
]


PhasePlot[sim_, {x_,y_}, {tstart_, tend_},opt___?OptionQ]:= Module[{r, p},
r=Flatten[sim]; 
p = ParametricPlot[Evaluate[{x[t],y[t]}/.r],{t,tstart,tend},
AxesLabel-> {x,y},
opt];
Return[p];
];




PredictTransferFunction[stn_, {time_, tbegin_, tend_}, {inputVariable_, inmin_, inmax_, indelta_},
outputVariable_,opt___?OptionQ]:= 
Module[
{getvar, dbg=False, dpr, getopt, ic, value, currentICs, currentrates,num, output, nextoutput, outvars, integrate,results, f, ratemode, ICmode, col1label, eqs, vars, syms, r},

dbg = "Debug"/.{opt}/.{"Debug"-> False}; 

dpr[x___]:= If[dbg, Print["PredictTransferFunction: ", x]]; 
getopt[x_, defaultvalue_]:= x/.{opt}/.{x-> defaultvalue};
outvars=(#[time]&/@(Flatten[{outputVariable}])); 

(*  do an interpret to make sure system is well formed *)

{eqs, vars}=interpret[stn]; 
syms=Complement[Select[MathSBML`Private`getSymbols[eqs], Not[Context[#]=="System`"]&], vars]; 
syms = Complement[syms, {time}]; 

(* determine if the requested inputVariable is a variable or a parameter *)

If[MemberQ[syms, inputVariable],
ratemode=True; ICmode=False;,
If[MemberQ[vars, inputVariable], 
ratemode=False; ICmode=True;, 
Print["Error: PredictTransferFunction: symbol ", inputVariable, " not found!"]; 
Return[$Failed]; 
]; 
]; 

dpr["ratemode=", ratemode, " ICmode=", ICmode]; 

(* format the rate constants *)

r = getopt[rates, {}]; 
If[ratemode,
r=(r/.{Rule-> List}); 
r = Select[r, Not[SameQ[inputVariable, First[#]]]&]; 
r= (#/.{List-> Rule})&/@r; 
col1label=inputVariable;
dpr["r=", r]; 
]; 

(* format the initial conditions *)

ic = getopt[initialConditions,{}]; 
If[ICmode,
ic = ic/.{Rule-> List}; 
ic = Select[ic, Not[SameQ[inputVariable, First[#]]]&]; 
ic = (#/.{List-> Rule})&/@ic; 
col1label=inputVariable[tbegin];
dpr["ic=", ic]; 

]; 

integrate=getopt["Integrate", False]; 
f[x_]:= getopt["Function", (#&)][x]; 

dpr["r: ", r]; 
dpr["ic: ", ic]; 

output={Flatten[{col1label, #[tend]&/@Flatten[{outputVariable}]}]}; 

For[value = inmin, value<= inmax, value=value+indelta,

dpr["------ value: ", value]; 

If[ICmode,
currentICs=Append[ic, inputVariable-> value],
currentICs=ic
]; 

If[ratemode,
currentrates=Append[r, inputVariable-> value], 
currentrates=r
]; 

dpr["currentICs: ", currentICs]; 
dpr["currentrates: ", currentrates]; 


num=run[stn, 
timeSpan-> {tbegin, tend}, 
rates-> currentrates, 
initialConditions-> currentICs,
opt
]; 
dpr["num:", num]; 

If[integrate,
results=Map[NIntegrate[f[#/.num],{time,tbegin,tend}]&, outvars], 
results =f/@( (outvars/.Flatten[num])/.{time-> tend})
]; 

nextoutput=Flatten[{value, results}];
AppendTo[output, nextoutput];

dpr["end of step: r=", r, " currentrates=", currentrates]; 

];

Return[output]; 

]


xlr8rhelp[]:= Module[{names, usagestrings, print, ok}, 
names=MathSBML`Private`decontextify/@Names["xlr8r`*"];
usagestrings = ToExpression/@((ToString[#]<>"::usage")&/@names); 

ok = StringQ/@usagestrings; 
usagestrings = Pick[usagestrings, ok]; 
names = Pick[names, ok]; 

ok = (StringLength[#]>0)&/@usagestrings;
usagestrings = Pick[usagestrings, ok]; 
names = Pick[names, ok]; 

print[a_, b_]:= Module[{}, 
StylePrint[a, "Subsection"]; 
Print[b]; 
]; 
StylePrint["xlr8r Help", "Section"]; 
Print["This is the xlr8r Help file. It provides some reference information about each of the externally visible xlr8r functions. It is not a users guide and does not provide any introduction to using xlr8r. It also does not include plugin reference information. \nPlease note that xlr8r is experimental software and as such many of the functions may only contain partial implementations. And like a lot of software documentation in the cybersphere it does not always keep up with the latest implementation. Please check with the developer if you have any questions."];
Print["This file was generated by xlr8r version "<>$xlr8r$Version<>" on "<>DateString[{"Day", " ", "MonthNameShort", " ", "Year", " at ", "Hour", ":", "Minute", ":", "Second", " (", "TimeZone",")"}]<>" using Mathematica "<>$Version<>" (Version "<>ToString[ $VersionNumber]<>", Release "<>ToString[ $ReleaseNumber]<> ")"];  
MapThread[print, {names, usagestrings}]; 
];
MathSBML`AddHelp["xlr8r`"];
xlr8rHelp[]:= xlr8rhelp[]; 


VR=" (Version "<>ToString[$VersionNumber]<>", Release "<>ToString[$ReleaseNumber]<>")"; If[xlr8r`Private`msgflag, Print[Style["xlr8r "<>$xlr8r$Version<>" loaded "<>nower[]<>" using Mathematica "<>$Version<>VR<>" (MathSBML "<>MathSBML`$MathSBML$Version<>")\nGNU Lesser General Public License (LGPL) Terms Apply. ", Bold]]
]; 
Remove[xlr8r`Private`msgflag]; 
End[];
EndPackage[];
